[{"id":"8dd2c58b946638da599044d866c5a61b","title":"玩转Mock.js：构建模拟数据的利器","content":"玩转 Mock.js：构建模拟数据的利器Mock.js 基础介绍为什么需要 Mock.js\n\n对于前后端分离的项目，后端工程师的 API 数据迟迟没有上线；而前端工程师却没有 JSON 数据进行数据填充，自己写后端模拟又太繁重；这个时候，Mock.js 就能解决这个问题，让前端工程师更加独立做自己。\n前后端分离：让前端攻城师独立于后端进行开发\n开发无侵入：不需要修改既有代码，就可以拦截 Ajax 请求，返回模拟的响应数据\n数据类型丰富：支持生成随机的文本、数字、布尔值、日期、邮箱、链接、图片、颜色等\n增加单元测试的真实性：通过随机数据，模拟各种场显\n用法简单：符合直觉的接口\n方便扩展：支持支持扩展更多数据类型，支持自定义函数和正则\n\n\n原理：通过拦截 XMLHttpRequest 或 fetch 等网络请求，根据定义的规则返回模拟的数据。当开发者发起一个请求时，Mock.js 会检查匹配的规则，并返回相应的模拟数据。\n官方网站为：Mock.js (mockjs.com)\n\n安装与测试\n\nNode 下运行：创建 Mock 目录，npm instal mockjs；创建 JS 文件，键入官网示例代码运行即可输出对应的 JSON 格式的数据：\n\njs// 使用 Mock\nvar Mock = require(&quot;mockjs&quot;);\nvar data = Mock.mock(&#123;\n  // 属性 list 的值是一个数组，其中含有 1 到 10 个元素\n  &quot;list|1-10&quot;: [\n    &#123;\n      // 属性 id 是一个自增数，起始值为 1，每次增 1\n      &quot;id|+1&quot;: 1,\n    &#125;,\n  ],\n&#125;);\n// 输出结果 将JavaScript对象转换为格式化的JSON字符串，并在控制台输出，null表示不使用自定义替换函数，4表示缩进为4个空格\nconsole.log(JSON.stringify(data, null, 4));\n浏览器运行：直接在 HTML 文件中引入，编写代码在浏览器打开查看控制台输出：\n\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n  &lt;/head&gt;\n\n  &lt;body&gt;\n    &lt;script src=&quot;http://mockjs.com/dist/mock.js&quot;&gt;&lt;/script&gt;\n    &lt;script&gt;\n      const data = Mock.mock(&#123;\n        &quot;list|1-10&quot;: [\n          &#123;\n            &quot;id|+1&quot;: 1,\n          &#125;,\n        ],\n      &#125;);\n      console.log(data);\n      console.log(JSON.stringify(data, null, 4));\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\nMock.js 语法规范\nMock.js 的语法规范包括两个部分：**数据模板定义规范(DTD)和数据占位符定义规范(DPD)**；\n数据模板定义的规范包含 3 个部分：属性名、生成规则和属性值\n\njson&#39;属性名|生成规则&#39; : 属性值 //&#39;name|rule&#39; : value\n其中，字符串、数值有 7 种生成规则：\n\n\n\n\n生成规则\n说明\n示例\n\n\n\nmin-max\n生成 min~max 之间的字符串\n‘list|1-10’\n\n\ncount\n生成 count 个字符串\n‘list|5’\n\n\nmin-max.dmin-dmax\n生成 min~ max 之间的浮点数，小数点位数在 dmin ~dmax 之间\n‘id|1-10.1-3’:1\n\n\ncount.dcount\n生成 count 个字符串，小数点位数为 dcount\n‘id|8.2’:1\n\n\nmin-max.dcount\n&#x2F;&#x2F;同上\n\n\n\ncount.dmin-dmax\n&#x2F;&#x2F;同上\n\n\n\n+step\n每次进行累加一个值\n‘id|+1’:1\n\n\n\n除了以上几种规则格式，还有布尔值、对象和数组等规则\n\n\n\n\n生成规则\n说明\n示例\n\n\n\n布尔值\n生成布尔值，1&#x2F;2 概率 true\n‘flag|1’:true\n\n\n布尔值 min-max\n生成布尔值，概率为 min&#x2F;(min+max)\n‘flag|1-10’:true\n\n\n对象 count\n从对象中随机抽取 count 个属性\n‘obj|2’:obj\n\n\n对象 min-max\n从对象中随机抽取 min-max 属性\n‘obj|1-3’:obj\n\n\n数组 1\n获取 1 次数组\n‘arr|1’:arr\n\n\n数组 count\n重复 count 次组成新数组\n‘arr|2’:arr\n\n\n数组+1\n累加\n‘arr|+1’:arr\n\n\n数组 min-max\n重复 min-max 次组成新数组\n‘arr|1-2’:arr\n\n\n\n支持函数和正则表达式\n\n\n\n\n生成规则\n说明\n示例\n\n\n\n函数\n支持函数\n‘fn|1’:function\n\n\n正则\n支持正则\n‘reg|1’:&#x2F;[a-z]&#x2F;\n\n\n\n数据定义的占位符@，占领属性值的位置\n有两种方式可以输出这种随机占位符：\n\njsconsole.log(Mock.Random.cname());\n\nconsole.log(Mock.mock(&quot;@cname&quot;));\n所有占位符：\n\n\n\n\nType\nMethod\n\n\n\nBasic\nboolean,natural,integer,float,character,string,range,date,time,datetime,now\n\n\nImage\nimage,dataImage\n\n\nColor\ncolor\n\n\nText\nparagraph,sentence,word,title,cparagraph,csentence,cword,ctitle\n\n\nName\nfirst,last,name,cfirst,clast,cname\n\n\nWeb\nurl,domain,email,ip,tld\n\n\nAddress\narea,region\n\n\nHelper\ncapitalize,upper,lower,pick,shuffle\n\n\nMiscellaneous\nguid,id\n\n\njs//随机中文人名，不带c就是英文\nconsole.log(Mock.mock(&quot;@cname&quot;));\n//随机ID\nconsole.log(Mock.mock(&quot;@id&quot;));\n//随机中文标题，不带c就是英文\nconsole.log(Mock.mock(&quot;@ctitle&quot;));\n//随机ip地址\nconsole.log(Mock.mock(&quot;@ip&quot;));\n//随机图片地址\nconsole.log(Mock.mock(&quot;@image&quot;));\n//随机url地址\nconsole.log(Mock.mock(&quot;@url&quot;));\n//随机颜色，十六进制\nconsole.log(Mock.mock(&quot;@color&quot;));\n//随机数值\nconsole.log(Mock.mock(&quot;@integer&quot;));\n//随机日期\nconsole.log(Mock.mock(&quot;@datetime&quot;));\n//随机字符串\nconsole.log(Mock.mock(&quot;@string&quot;));\n如果没有想要的数据格式进行填充，可以使用扩展功能自己扩展：\n\njs//自行扩展占位符\nMock.Random.extend(&#123;\n  cstore() &#123;\n    return this.pick([&quot;宠物店&quot;, &quot;美容店&quot;, &quot;小吃店&quot;, &quot;数码店&quot;, &quot;快餐店&quot;]);\n  &#125;,\n&#125;);\n\nconsole.log(Mock.mock(&quot;@cstore&quot;));\nAxios 快速实践\naxios.js 是一个基于 promise 的 HTTP 库，支持浏览器·和 Node 环境；可以使用这个库来执行 Ajax 请求，获取 JSON 数据；可以利用 axios 发送 get、post 等一系列请求，然后得到数据\n安装：\nnode 下运行：npm insatll axios\n在浏览器使用：&lt; script src&#x3D;”https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt; &#x2F;script&gt;\n\n\n简单的在 Node 环境下实现远程获取 json 数据：\n\njsconst axios = require(&quot;axios&quot;);\n\naxios\n  .get(&quot;url&quot;)\n  .then((res) =&gt; &#123;\n    console.log(res.data);\n  &#125;)\n  .catch((err) =&gt; &#123;\n    console.log(&quot;错误&quot; + err);\n  &#125;);\n有时候需要在 url 地址配置参数进行数据筛选：\n\njsaxios(&#123;\n  method: &quot;get&quot;,\n  url: &quot;url&quot;,\n  params: &#123;\n    id: 1,\n    status: 5,\n  &#125;,\n&#125;).then((res) =&gt; &#123;\n  console.log(res.data);\n&#125;);\n如果项目中产生多个异步请求，会根据耗时长短来执行；如果需要请求按指定的顺序执行，使用 all()方法：\n\njsaxios\n  .all([\n    axios(&#123;\n      url: &quot;url&quot;,\n      data: &quot;1.异步&quot;,\n    &#125;),\n    axios(&#123;\n      url: &quot;url&quot;,\n      data: &quot;2.异步&quot;,\n    &#125;),\n    axios(&#123;\n      url: &quot;url&quot;,\n      data: &quot;3.异步&quot;,\n    &#125;),\n  ])\n  .then(\n    axios.spread((res1, res2, res3) =&gt; &#123;\n      console.log(res1.config.data);\n      console.log(res2.config.data);\n      console.log(res3.config.data);\n    &#125;)\n  );\n实例化操作与拦截操作：\n\njsconst myAxios = axios.create();\nmyAxios.defaults.baseURL = &quot;url&quot;;\n\n//请求拦截\nmyAxios.interceptors.request.use((config) =&gt; &#123;\n  //打印，修改\n  console.log(&quot;loading...&quot;);\n  //config.url = &#39;/data2.json&#39;;\n  //config.timeout = 50;\n  return config;\n&#125;);\n\n//响应拦截\nmyAxios.interceptors.response.use((response) =&gt; &#123;\n  //修改返回数据的格式\n  return response.data;\n&#125;);\n\nmyAxios\n  .request(&#123;\n    method: &quot;get&quot;,\n    url: &quot;/data.json&quot;,\n  &#125;)\n  .then((res) =&gt; &#123;\n    console.log(res);\n  &#125;);\nMock 拦截 axios 请求Mock.mock\n\n假设 axios 异步请求的数据尚未上线或不全，然后通过 mock 请求拦截，随机生成填充的数据进行前端设计\n\njs//ajax\naxios\n  .request(&#123;\n    method: &quot;get&quot;,\n    url: &quot;url&quot;,\n  &#125;)\n  .then((res) =&gt; &#123;\n    console.log(res.data);\n  &#125;);\n\n//mock拦截\nMock.mock(&quot;url&quot;, &#123;\n  &quot;list|5-10&quot;: [\n    &#123;\n      &quot;id|+1&quot;: 1,\n      username: &quot;@cname&quot;,\n      email: &quot;@email&quot;,\n      gender: &quot;@boolean&quot;,\n      price: &quot;@integer&quot;,\n    &#125;,\n  ],\n&#125;);Mock.setup\n\n使用 Mock 拦截请求时，可以通过Mock.setup()配置进行特定的行为：\n\njs//响应时间为400毫秒(默认值是10-100)\nMock.setup(&#123;\n  timeout: 400,\n&#125;);\n// 响应时间介于200-600毫秒之间\nMock.setup(&#123;\n  timeout: &quot;200-600&quot;,\n&#125;);\n注：目前，接口 Mock.setup( settings ) 仅用于配置 Ajax 请求，将来可能用于配置 Mock 的其他行为。\n\nMock.valid\n\n校验真实数据 data 是否与数据模板 template 匹配。\n\njsvar template = &#123;\n  name: &quot;value1&quot;,\n&#125;;\nvar data = &#123;\n  name: &quot;value2&quot;,\n&#125;;\n\nMock.valid(template, data)[\n  // =&gt;\n  &#123;\n    path: [&quot;data&quot;, &quot;name&quot;],\n    type: &quot;value&quot;,\n    actual: &quot;value2&quot;,\n    expected: &quot;value1&quot;,\n    action: &quot;equal to&quot;,\n    message: &quot;[VALUE] Expect ROOT.name&#39;value is equal to value1, but is value2&quot;,\n  &#125;\n];Mock.toJSONSchema\n\n把 Mock.js 风格的数据模板 template 转换成 JSON Schema。\n\njsconst Mock = require(&quot;mockjs&quot;);\n\n// 创建一个 Mock 对象\nconst mockData = Mock.mock(&#123;\n  &quot;list|1-10&quot;: [\n    &#123;\n      &quot;id|+1&quot;: 1,\n      name: &quot;@cname&quot;,\n      &quot;age|18-60&quot;: 1,\n    &#125;,\n  ],\n&#125;);\n\n// 将 Mock 对象转换为 JSON Schema\nconst jsonSchema = Mock.toJSONSchema(mockData);\n\nconsole.log(jsonSchema);\nMock 在 Vue 项目实践\n创建好 Vue 项目，npm install mockjs安装 mockjs 包\n\n\n新建.env.development，定义环境变量：\n\nmd# 控制是否需要使用 mock 模拟的数据\n\nMOCK = TRUE\n定义接口路由，在接口中并返回 mock 模拟的数据；在项目文件创建 mock 文件夹，定义 index.js 文件：\n\njsconst Mock = require(&quot;mockjs&quot;);\n\nmodule.exports = function (app) &#123;\n  if (process.env.MOCK == &quot;true&quot;) &#123;\n    // node中的express框架\n    // 参数1： 接口地址；参数2：服务器处理函数\n    app.use(&quot;/api/userinfo&quot;, (req, res) =&gt; &#123;\n      // 随机生成一个对象\n      var data = Mock.mock(&#123;\n        id: &quot;@id&quot;,\n        username: &quot;@cname&quot;,\n        date: &quot;@date(yyyy-MM-dd)&quot;,\n        description: &quot;@paragraph&quot;,\n        email: &quot;@email&quot;,\n        &quot;age|18-40&quot;: 0,\n      &#125;);\n      // 将模拟的数据转成json格式返回给浏览器\n      res.json(data);\n    &#125;);\n  &#125;\n&#125;;\n在 vue.config.js 中配置 devServer，在 before 属性中引入接口路由函数：\n\njsconst &#123; defineConfig &#125; = require(&quot;@vue/cli-service&quot;);\nmodule.exports = defineConfig(&#123;\n  transpileDependencies: true,\n  devServer: &#123;\n    // devServer在发送请求时，会先走到before指定的函数中进行处理，如果before中没有对应的接口路由，才会请求外网等\n    onBeforeSetupMiddleware: require(&quot;./mock/index.js&quot;),\n  &#125;,\n&#125;);3.使用 axios 调用该接口，获取数据:\nvue&lt;template&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;h1&gt;Test&lt;/h1&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport axios from &quot;axios&quot;;\n\nexport default &#123;\n  created() &#123;\n    axios.get(&quot;/api/userinfo&quot;).then((res) =&gt; &#123;\n      console.log(res);\n    &#125;);\n  &#125;,\n&#125;;\n&lt;/script&gt;\n\n&lt;style&gt;&lt;/style&gt;\n总结与思维拓展主流 Mock 方案对比\n\n代码侵入：\n\n直接在本地写死或者导入本地 json 数据文件\n优点：简单快捷\n缺点：冗余代码过多，需要一一剔除\n\n\n抓包工具：\n\n使用抓包工具对网络请求进行拦截，将其替换成我们需要的 Mock 数据\n优点：真实性强\n缺点：操作繁琐，成本较高\n\n\n本地服务：\n\n使用 express 或者 koa 等框架编写后端接口\n\n优点：真实，方便管理\n\n缺点：前端 &#x3D;&#x3D;&#x3D; 全栈 ？\n\n\n\n浏览器插件：\n\n运行与浏览器，避免了本地部署和使用第三发的服务\n优点：方便快捷\n缺点：–\n注：这里笔者进行了一下实践，个人认为也是一种比较轻量级的快速上手方案，详情参考：一款好用的 Chrome Mock 插件 - 掘金 (juejin.cn)\n\n\n平台类：\n\n使用软件或者网页来进行接口管理模拟数据\n优点：全面快捷\n缺点：依赖后端，需要(maybe)收费\n\n\n请求拦截：\n\n通过拦截 XMLHttpRequest 或 fetch 等网络请求，然后根据自定义规则返回 mock 数据\n优点：不在依赖后端，直接拦截请求，数据真实\n缺点：一定的学习成本~\n\n\n\n","slug":"前端--玩转Mock.js：构建模拟数据的利器","date":"2024-09-28T01:37:51.000Z","categories_index":"前端","tags_index":"Mock","author_index":"会思想的苇草i"},{"id":"9406d22de102d3de5b7b83df28453203","title":"前端开发新趋势：UnoCSS快速入门","content":"UnoCSS一、UnoCSS 简介\n\nUnoCSS 是一个即时、按需的原子级 CSS 引擎。它专注于提供轻量化、高性能的 CSS 解决方案。\n“Instant On-demand” 表示 UnoCSS 的加载和渲染速度非常快，可以立即进行使用。它不需要预先编译，使得样式可以在需要时动态地生成。\n“Atomic CSS Engine” 表示 UnoCSS 使用原子级 CSS 样式的概念。原子级 CSS 是一种通过将样式属性定义为独立的类来构建页面的方法。每个类都只包含一项或几项样式属性，可以在组件中灵活地组合和应用这些类，以实现细粒度的样式控制。\nUnoCSS 的目标是通过仅传递实际使用的样式属性，减小生成的 CSS 文件的体积。这样可以优化页面的加载速度，并减少不必要的网络传输和运行时的样式计算。\n总的来说，UnoCSS 是一个即时、按需的原子级 CSS 引擎，旨在提供快速、高性能的原子级 CSS 解决方案。\n\n\n二、UnoCSS 解决问题\nUI 库 Bootstrap 很早就在提供大量原子化 CSS 工具类。不过在应用开发中，由于原子化 CSS 自身的劣势——原子类的编写缺少提示、原子类的定义使 CSS 最终产物膨胀、原子类的大量堆叠降低 html 的可读性，语义化 CSS 逐渐成为了主流，原子 CSS 慢慢被边缘化，成为一种辅助的手段。\n\n现代的原子化 CSS 方案——Tailwind CSS、Windi CSS、UnoCSS，之所以将原子化 CSS 方案再度推向高潮，是因为其解决了上述的三大痛点：\n\n它们都推出了 VSCode 插件，为编写原子类提供了充分的提示与自动补全。\n它们都在构建阶段扫描代码，能够按照代码中的实际使用情况生成工具类，解决了原子类使 CSS 产物膨胀问题。\n针对原子类堆叠降低可读性的问题，提供了 @apply 语法支持在 CSS 中对多个原子类进行合并，与语义化 CSS 实现了很好的配合。\n\n\nUnoCSS 和 Tailwind CSS 有一些区别和特点：\n\n设计理念： UnoCSS 的设计理念是提供一个即时、按需的原子级 CSS 引擎。它专注于轻量化和高性能，并使用原子类的方式来构建页面样式。相比之下，Tailwind CSS 提供了更全面和丰富的工具集，以便于快速开发和定制化。它使用了一组预定义的类，通过组合这些类来构建页面样式。\n文件大小和加载性能： UnoCSS 生成的 CSS 文件相对较小，因为它仅包含实际使用的样式属性。这可以减少网络传输和运行时的样式计算，从而提高页面加载性能。而 Tailwind CSS 的 CSS 文件较大，因为它提供了大量的预定义类，以满足各种常见样式需求。\n学习曲线和使用方式： UnoCSS 使用原子类的方式来定义样式，需要熟悉其命名规则和使用方法，特别适合熟悉原子类概念的开发者。相比之下，Tailwind CSS 的类命名直观且易于理解，上手较快。它也提供了丰富的文档和示例，帮助开发者更快地上手。\n定制性和灵活性： Tailwind CSS 提供了大量的预定义类，使得样式定制和扩展非常方便。开发者可以通过配置文件自定义主题、添加新的类或修改现有类。UnoCSS 则更加注重即时、按需生成样式，定制性较弱。\n\n\n\n\n\nUnoCSS 并非要替代 Tailwind CSS 而是从另一个角度使原子化 CSS 在业务中融合的更完美\n\n按需生成\n\n\n传统的方式不仅会消耗不必要的资源（生成了但未使用），甚至有时更是无法满足你的需求，因为总会有部分需求无法包含在内。\n\n\n\n通过调换 “生成” 和 “扫描” 的顺序，”按需” 会为你节省浪费的计算开销和传输成本，同时可以灵活地实现预生成无法实现的动态需求。另外，这种方法可以同时在开发和生产中使用，提供了一致的开发体验，使得 HMR (Hot Module Replacement, 热更新) 更加高效。\nTailwind 的 API 和插件系统沿用了旧的思维方式进行设计，并不能适应新的按需方式。其核心工具是在生成器中锻造出来的，而且其定制化功能相当有限。(Tailwind 3.0 也是按需引入啦)\n\n性能\n\n\n从结果来看，UnoCSS 可以比 Tailwind 的 JIT 引擎快 200 倍！说实话，在按需生成的情况下，Windi 和 Tailwind JIT 都已经算是超快了，UnoCSS 的性能提升感知度可能没有那么高。然而，几乎为零的开销意味着你可以将 UnoCSS 整合到你现有的项目中，作为一个增量解决方案与其他框架一同协作，而不需要担心性能损耗。\n\nPure CSS icons\n\n纯 css 图标，使用 Iconify作为图标的数据源\n\n\nAttributify Mode\n\n特有的属性模式\n\n\nVariant Groups\n\n属性组的写法转换\n\n\nShortcuts\n\n快捷写法\n\n\nTagify\n\n标记\n\n\nWeb fonts\n\n网页字体\n\n\nCDN Runtime\n\nCDN 运行时\n\n\nInspector\n\n检查\n\n\n\n\n三、UnoCSS 实践\nIntegrations (unocss.dev)\n首先创建好项目，然后安装 unocss(顺便安装好 unocss 插件)：\n\n\n\n# 安装unocss和三个预设，第一个是工具类预设，第二个是属性化模式支持，第三个是icon支持\nnpm i -D unocss @unocss/preset-uno @unocss/preset-attributify @unocss/preset-icons\n# or\nyarn add -D unocss @unocss/preset-uno @unocss/preset-attributify @unocss/preset-icons\n# or\npnpm i -D unocss @unocss/preset-uno @unocss/preset-attributify @unocss/preset-icons\n\n\n安装完成\n\n\n\n修改 vite.config.js 文件：\n\nimport &#123; defineConfig &#125; from &quot;vite&quot;;\nimport vue from &quot;@vitejs/plugin-vue&quot;;\n// 引入Unocss\nimport Unocss from &quot;unocss/vite&quot;;\nimport &#123; presetUno, presetAttributify, presetIcons &#125; from &quot;unocss&quot;;\n// https://vitejs.dev/config/\nexport default defineConfig(&#123;\n  plugins: [\n    vue(),\n    Unocss(&#123;\n      // 使用Unocss\n      presets: [presetUno(), presetAttributify(), presetIcons()],\n    &#125;),\n  ],\n&#125;);\n\n\n修改 main.js 文件\n\nimport &#123; createApp &#125; from &quot;vue&quot;;\nimport &quot;./style.css&quot;;\nimport App from &quot;./App.vue&quot;;\nimport &quot;uno.css&quot;; // focus code\n\ncreateApp(App).mount(&quot;#app&quot;);\n\n\n在 app.vue 中编写代码\n\n&lt;script setup&gt;&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;button class=&quot;bg-blue w-80 h-10 ml-10 m-1&quot;&gt;button&lt;/button&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;&lt;/style&gt;\n\n\n\n可以通过以下方式自定义一个简单的 UnoCSS 静态规则\n\n// vite.config.js\nimport &#123; defineConfig &#125; from &quot;vite&quot;;\nimport vue from &quot;@vitejs/plugin-vue&quot;;\nimport Unocss from &quot;unocss/vite&quot;;\nimport &#123; presetUno, presetAttributify, presetIcons &#125; from &quot;unocss&quot;;\n\n// https://vitejs.dev/config/\nexport default defineConfig(&#123;\n  plugins: [\n    vue(),\n    Unocss(&#123;\n      presets: [presetUno(), presetAttributify(), presetIcons()],\n      rules: [\n        [&quot;m-1&quot;, &#123; margin: &quot;1px&quot; &#125;], // 这里可以自定义\n      ],\n    &#125;),\n  ],\n&#125;);\n\n\n\n可以通过配置使用 Webpack 打包 Unocss，这里就不详细展开啦\n\n使用风险：UnoCSS 仍处于实验阶段，但由于其精简的设计，生成的结果已经非常可靠了。需要注意的一点是，API 还没有最终定案，虽然我们会遵循 semver 的进行版本发布，但是还请为破坏性改动做好准备。\n\n\n\n四、好文推荐\n重新构想原子化 CSS (antfu.me)\n从 Tailwind CSS 到 UnoCSS —— 原子化真的是前端 CSS 的救星吗\n来试试 antfu 大佬的原子化 css 构想成果——UnoCSS\n\n","slug":"前端--UnoCSS快速入门","date":"2023-10-26T02:13:27.000Z","categories_index":"前端","tags_index":"CSS","author_index":"会思想的苇草i"},{"id":"85079fc8b482b07bf1c46c305ca3f3b0","title":"简洁高效的样式编写：揭秘Tailwind CSS","content":"Tailwind CSS一、Tailwind CSS简介What is Tailwind CSS\n\n\nTailwind CSS| TailwindCSS中文文档 | TailwindCSS中文网\n官方解释：只需书写 HTML 代码，无需书写 CSS，即可快速构建美观的网站。本质上是一个工具集，包含了大量类似 flex、 pt-4、 text-center 以及 rotate-90 等工具类，可以组合使用并直接在 HTML 代码上实现任何 UI 设计。\n个人理解：Tailwind CSS 就是一套实用型的 CSS 框架，它不像其他的 CSS 框架一样提供了一些预定义的类来实现常用样式，而是提供了一组可以组合的原子类，可以通过组合这些原子类来定义样式。这些原子类都是非常小的样式类，它们只定义了一个具体的样式细节，例如背景色、文本颜色、字体大小、宽度、高度等。通过将它们组合在一起，可以快速而灵活地创建出各种不同的样式。\n优点：\n灵活，高度定制化\n最终 CSS Bundle 极小，加快渲染速度\n极大减少命名，设计心智负担\n\n\n劣势：\n内容样式强耦合，后期维护方面或存在压力\n一定的学习成本\nClass 串稍长(@apply解决)\n\n\n应用场景：\n快速开发原型： Tailwind CSS 提供了大量的样式原子类，可以快速构建出漂亮且具有效果的原型。\n用于大型 Web 应用： Tailwind CSS 的设计理念可以使开发者更快地开发出易于维护的 CSS 代码。同时，它强调样式的规律性，可以防止样式的重复定义，提高代码的可读性和易维护性。\n与其他框架或库集成： Tailwind CSS 可以与其他框架或库集成，例如 React、Vue、Angular，以及其他的 CSS 框架，例如 Bootstrap。在不同的应用中，它可以作为一种简洁的样式定制解决方案。\n移动应用开发： Tailwind CSS 的响应式设计可以轻松的应用到移动应用中，开发人员可以根据不同屏幕尺寸来确定相应的样式，提高移动应用的适应性。\n\n\n\nWhy choose Tailwind CSS\n\n使用成本与许可：Tailwind CSS 是一个免费的开源项目，使用 MIT 许可证（MIT License）。这意味着可以免费使用、复制、修改、合并、出版发行、再授权、销售软件及其衍生品。所以从许可证方面来说，使用 Tailwind CSS 是没有直接的费用的，并且可以将其直接用于商业项目。\n\n\n\n文档资料与学习曲线：Tailwind CSS 提供了详细的文档和示例，使得学习过程更加简化。使用方式类似Bootstrap，且提供了vscode自动补全插件，方便进行快速开发。\n\n\n\n社区支持和更新频率： Tailwind CSS 社区非常庞大且活跃，拥有许多开发者、设计师和贡献者。可以在官方论坛、GitHub 仓库、Stack Overflow 和社交媒体等平台上找到大量的问题解答、教程、示例代码和实用资源。更新频率高，可以及时获取到 bug 修复、新功能和安全补丁，保持项目的稳定性和安全性。\n\n\n\n性能和可扩展性：\nTailwind CSS 在性能表现方面，采用了一种基于原子类的方法，只包含实际使用到的样式。这意味着不会加载不必要的代码，从而减小了文件大小，提高了加载速度。同时Tailwind CSS 提供了一套优化的构建工具和配置选项，无运行时依赖和快速响应式设计，使其具有良好的性能表现。\nTailwind CSS 使用原子类构建块的方法，通过组合不同的类来定义样式，而不是使用预定义的组件。这种方法使得定制和扩展变得非常简单，可以根据项目需求自由组合和重用样式类。具有高度可定制化的配置选项，提供了插件系统，允许轻松地扩展框架功能；也可以与现有的组件库集成。\n\n\n\n二、Tailwind CSS解决的问题1.类名命名\n一般标准做法是将CSS和HTML分开来实现关注点分离(separation of concerns)，作为程序员，工作中的一大难点就是起名。&gt;_&lt;||\n\n&lt;div class=&quot;chat-notification&quot;&gt;\n  &lt;div class=&quot;chat-notification-logo-wrapper&quot;&gt;\n    &lt;img class=&quot;chat-notification-logo&quot; src=&quot;/img/logo.svg&quot; alt=&quot;ChitChat Logo&quot;&gt;\n  &lt;/div&gt;\n  &lt;div class=&quot;chat-notification-content&quot;&gt;\n    &lt;h4 class=&quot;chat-notification-title&quot;&gt;ChitChat&lt;/h4&gt;\n    &lt;p class=&quot;chat-notification-message&quot;&gt;You have a new message!&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n\n&lt;style&gt;\n  .chat-notification &#123;\n    display: flex;\n    max-width: 24rem;\n    margin: 0 auto;\n    padding: 1.5rem;\n    border-radius: 0.5rem;\n    background-color: #fff;\n    box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);\n  &#125;\n  .chat-notification-logo-wrapper &#123;\n    flex-shrink: 0;\n  &#125;\n  .chat-notification-logo &#123;\n    height: 3rem;\n    width: 3rem;\n  &#125;\n  .chat-notification-content &#123;\n    margin-left: 1.5rem;\n    padding-top: 0.25rem;\n  &#125;\n  .chat-notification-title &#123;\n    color: #1a202c;\n    font-size: 1.25rem;\n    line-height: 1.25;\n  &#125;\n  .chat-notification-message &#123;\n    color: #718096;\n    font-size: 1rem;\n    line-height: 1.5;\n  &#125;\n&lt;/style&gt;\n\n\n这种做法会起很多无所谓的名字，几周之后回来修改代码时根本搞不清楚样式应用到了哪些元素上，而且很可能在其它地方也会使用同样的类名，当尝试修改时就导致UI无法正常工作。\n\n\n\n使用Tailwind CSS就不需要再起这些无所谓的类名了。\n\n&lt;div class=&quot;p-6 max-w-sm mx-auto bg-white rounded-xl shadow-lg flex items-center space-x-4&quot;&gt;\n  &lt;div class=&quot;shrink-0&quot;&gt;\n    &lt;img class=&quot;h-12 w-12&quot; src=&quot;/img/logo.svg&quot; alt=&quot;ChitChat Logo&quot;&gt;\n  &lt;/div&gt;\n  &lt;div&gt;\n    &lt;div class=&quot;text-xl font-medium text-black&quot;&gt;ChitChat&lt;/div&gt;\n    &lt;p class=&quot;text-slate-500&quot;&gt;You have a new message!&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n\n\n如果你觉得HTML中类名过多，可以在vscode中安装Inline fold插件，会自动折叠类名。\n\n\n2.语法冗长\n使用class定义类名，然后编写代码，如此反复可能会造成很大的代码量，使用Tailwind CSS能大大减少代码量，压缩代码体积。\n\n\n\n3.样式定制Tailwind CSS 和 Bootstrap 都是前端常用的 UI 框架，但它们的设计思路和使用方式存在一些区别：\n\n设计哲学： Tailwind CSS 的设计哲学是提供一系列基础工具类，通过组合这些工具类来快速构建页面和 UI。而 Bootstrap 更注重提供各种 UI 组件和样式风格，以便快速搭建现成的页面。\n样式组织方式： Tailwind CSS 使用原子级别的 CSS 类来构建页面，每个类只负责一个特定的样式，因此它的样式组织方式更加细粒度和灵活。而 Bootstrap 则更倾向于将多个样式组合成一个类，以便快速实现某个组件或效果。\n自定义程度： Tailwind CSS 更容易进行自定义和扩展，因为它的样式都是单独的类，并且可以通过配置文件进行自定义。而 Bootstrap 设计更为全面和集成，因此在进行自定义时较为困难。\n\n4.僵尸样式\n使用class编写类名再编写样式，会造成样式冗余，也会出现虽然定义了样式，但是没有被使用到，变成“僵尸样式”\nTailwind 会在针对生产环境进行构建时自动删除所有未使用到的 CSS 代码，也就是说 你所获得的最终的 CSS 代码包的尺寸是最小的。事实上，大部分 Tailwind 项目所生成的 CSS 代码包都小于 10kB 。\n\n5.暗黑模式\n使用暗黑模式前，你需要在tailwind.config.js中配置：\n\n/** @type &#123;import(&#39;tailwindcss&#39;).Config&#125; */\nmodule.exports = &#123;\n  darkMode: &#39;class&#39;,\n  // more options...\n&#125;\n\n\n然后，你只需要少量的代码，就可以使用暗黑模式了：\n\n&lt;div class=&quot;w-32 h-32 bg-blue-500 dark:bg-green-500&quot;&gt;&lt;/div&gt;\n\n三、Tailwind CSS语法规则基本规则\n\nTailwind CSS 是一种实用且强大的 CSS 框架，它提供了一些预设的样式类，可以让开发者快速地构建出美观的 UI 界面。下面是 Tailwind CSS 的基本使用方法和语法规则：\n\n\n样式类结构：Tailwind CSS 的样式类采用以 类别-属性-值 的结构命名，例如 .bg-blue-500 表示背景色为蓝色（blue），并且其颜色值为 500，类别为 bg（背景）。\n属性值的命名规则：在 Tailwind CSS 中，属性值分为数值、颜色和布尔值三种类型。数值采用数字表示，例如 w-20 表示宽度为 20 像素；颜色采用单词或十六进制颜色值表示，例如 bg-red-500 表示红色背景（颜色值为 #EF4444）；布尔值则采用 true 或 false 表示，例如 hidden 表示隐藏元素。\n基础样式类：在 Tailwind CSS 中，有一些基础样式类用于一些常用的样式调整，例如：\n.w-10 表示元素的宽度；\n.text-xl 表示字体大小\n.mx-auto 表示水平居中；\n.text-center 表示文本水平居中；\n.text-red-500 表示字体颜色\n\n\n响应式样式类：在 Tailwind CSS 中，有一些响应式样式类，用于在不同的屏幕尺寸下显示不同的样式。这些样式类命名规则为 &#123;屏幕尺寸&#125;:&#123;属性&#125;-&#123;属性值&#125;，例如 text-center sm:text-left 表示在小屏幕尺寸下文本左对齐，在大屏幕尺寸下文本居中。\n链接样式类：在 Tailwind CSS 中，有一些链接样式，用于美化页面中的链接效果，例如：\n.underline 表示下划线；\n.no-underline 表示去掉下划线；\n.hover:underline 表示鼠标悬停时出现下划线；\n.hover:text-red-500 表示鼠标悬停时文本变为红色；\n\n\n其他常用样式类：在 Tailwind CSS 中，还提供了许多其他常用样式类，例如：\n.rounded 表示圆角；\n.shadow 表示阴影；\n.bg-gradient-to-r 表示背景渐变。\n\n\n\n通过以上的基本使用方法和语法规则，可以让您更加熟悉和了解 Tailwind CSS 的使用，从而更加高效地使用这个强大的 CSS 框架。\n语法技巧\n\nTailwind CSS 是一个快速、高效且高度可定制的 CSS 框架，它使用一组预定义类来快速构建 UI。以下是一些实用技巧，帮助您更好地利用 Tailwind CSS：\n\n\n自定义颜色：在 tailwind.config.js 文件中，可以使用 theme 属性自定义颜色，这个属性包含一个颜色对象，您可以并据此为您的项目定义新的颜色。\n\n响应式设计：Tailwind 提供了一系列响应式类，让您可以根据不同的屏幕尺寸为不同的设备定制 UI，例如：sm，md，lg等。\n\n定制样式：Tailwind CSS 提供了许多原始的类，您可以轻松地将它们组合在一起创造出自定义样式的组合。\n\n组合实用类：通常情况下，您可以通过多个实用类的组合来实现所需样式。例如，要在元素上添加40个像素的上边距和底边距，您可以将 pt-10（上边距为10） 和 pb-10（底边距为10）两个实用类组合在一个元素上，即 class=&quot;pt-10 pb-10&quot; 。\n扩展现有实用类：您还可以通过添加前缀或后缀来扩展现有的实用类。例如，要创建一个自定义的 bg-opacity-90 类，即给背景添加90％的不透明度，只需将 bg-opacity-90 类添加到 bg-blue-500（蓝色背景）的后面，即 class=&quot;bg-blue-500 bg-opacity-90&quot;。\n使用 @apply 来扩展样式：该功能允许您将多个实用类组合成自定义样式，然后将其应用于一个元素。例如，您可以创建一个自定义的 font-bold-uppercase 类，然后使用 @apply 将 font-bold uppercase 两个类组合在一起：\n\nless复制代码.font-bold-uppercase &#123;\n  @apply font-bold uppercase;\n&#125;\n\n然后，可以应用该 font-bold-uppercase 类到一个元素中：class=&quot;font-bold-uppercase&quot;。\n\n文本样式：Tailwind CSS 提供了一些实用的类，可以快速设置文本的样式，例如： text-center（居中对齐文本）、text-2xl（增加文本大小）。\n\n构建网格系统：您可以利用 Tailwind CSS 来构建网格系统，这使得在项目中创建布局变得更加容易。利用网格系统类将组件和元素对池进行行和列的多样化排列，能让您快速定位到您需要的布局。\nini复制代码&lt;div class=&quot;grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4&quot;&gt; \n    &lt;div class=&quot;bg-gray-200 p-4&quot;&gt;Col 1&lt;/div&gt; \n    &lt;div class=&quot;bg-gray-200 p-4&quot;&gt;Col 2&lt;/div&gt; \n    &lt;div class=&quot;bg-gray-200 p-4&quot;&gt;Col 3&lt;/div&gt; \n&lt;/div&gt;\n\n\n定位元素：Tailwind 提供了各种定位元素的类，包括 z-index、position、top、right、bottom、left 等等，使您轻松定位元素的位置和层级。\n\n缩放图像：利用 Tailwind CSS，您可以轻松地在UI中缩放图像，只需使用 w-和 h- 后缀来指定图像的宽高。\n\n\n四、Tailwind CSS实践1. 安装依赖\n控制台输入以下命令：\n\n# 初始化package.json文件\nnpm init -y\n\n# 安装tailwind\nnpm install -D tailwindcss\n\n# 创建tailwind.config.js\nnpx tailwindcss init\n\n\n此时项目结构如下：\n\n\n\n修改content属性，使其能够定位到文件位置：\n\n// tailwind.config.js\n\nmodule.exports = &#123;\n  //路径注意调整\n  content: [&quot;./**/*.&#123;html,js&#125;&quot;],\n  theme: &#123;\n    extend: &#123;&#125;,\n  &#125;,\n  plugins: [],\n&#125;\n\n2.新建index.html和input.css文件\n在当前目录下新建index.html\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;!-- 注意这里引入的output.css文件，后面会用到 --&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;/dist/output.css&quot;&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;h1 class=&quot;flex text-3xl font-bold underline text-blue-600&quot;&gt;\n        Hello Tailwind CSS!\n    &lt;/h1&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n\n\n在当前目录下新建input.css\n\n/* 引入 tailwind 的基础样式 */\n@tailwind base;\n/* 引入 tailwind 的组件样式 */\n@tailwind components;\n/* 引入 tailwind 的工具样式 */\n@tailwind utilities;\n\n\n创建完文件后的项目结构：\n\n\n3.tailwind编译\n使用tailwindcss对当前项目进行编译然后输出css文件：\n\nnpx tailwindcss -i ./input.css -o ./dist/output.css\n\n\n执行完命令后的项目结构：\n\n\n\n在浏览器端预览index.html\n\n\n\n对于其它项目中的使用可以详见：TailwindCSS的使用，看这一篇就够了！\n\n","slug":"前端--Tailwind CSS浅析与实操","date":"2023-10-08T02:41:03.000Z","categories_index":"前端","tags_index":"CSS","author_index":"会思想的苇草i"},{"id":"78d471353b2103866278592ac6c06983","title":"前端开发实用技巧：mixin提高代码复用率","content":"mixin从理论到实践\n一、什么是mixin\nmixin混入 — Vue.js (vuejs.org)\n\n官方解释： 混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。\n\n个人理解： 如果在写vue组件时，发现有几个组件的逻辑类似，那么就可以使用vue的mixin（混入），把类似的逻辑抽离出来封装成js，然后在各个组件引入使用。mixin是一种可以在Vue组件中复用代码的方式。mixin可以包含任意的组件选项，例如data、methods、computed、watch等。当一个组件使用mixin时，它会将mixin中的选项与组件本身的选项合并。如果有选项名称冲突，一般情况下组件选项将覆盖mixin选项。\n\n优势：\n\n代码重用和维护性：通过使用混入，可以将常用的样式、功能或逻辑集中在一个地方定义，避免了代码的重复编写，提高了代码的重用性。当需要修改或更新某个样式或功能时，只需修改混入的定义，所有使用该混入的组件或模板都会自动应用更新，提高了代码的维护性。\n抽象和可配置性：混入可以将通用的代码逻辑抽象出来，并提供参数以使其具有灵活性。通过传递不同的参数给混入，可以根据具体的需求来定制代码逻辑和样式，实现更强的可配置性。\n组件模块化和复合性：混入能够将多个功能或样式组合在一起，形成更丰富的组件模块。通过将不同的混入组合使用，可以快速创建出具有复杂功能和样式的组件，提高了前端开发的效率和灵活性。\n\n\n劣势：\n\n命名冲突和可读性：过度使用混入可能导致命名冲突，特别是当多个混入定义了相同的样式或功能时。这可能会增加代码的复杂性和维护成本，并降低代码的可读性。\n依赖关系和耦合：使用混入可能导致组件之间产生依赖关系，并增加它们之间的耦合度。如果修改了一个混入的定义，可能会影响到多个组件或模板，需要特别注意修改带来的潜在风险。\n性能影响：当多个混入被应用到一个组件或模板中时，可能会导致多余的代码和样式加载。这可能会对页面的性能产生一定影响，特别是在加载大量混入的情况下。\n\n\n由于mixin会导致命名冲突和混乱的依赖关系、灵活性和可读性问题，以及会导致编译效率和性能问题，在 Vue 3 中引入了更加灵活和可组合的 Composition API。Composition API 允许以函数的形式编写逻辑，并将其作为可复用的组合函数在组件中使用。这种方式提供了更好的代码组织结构、更明确的依赖关系和更高的可读性。通过 Composition API，开发者可以更灵活地组合功能并避免命名冲突。\n\n但并不意味着 mixin 完全没有价值，混入仍然可以在某些情况下提供一些价值和灵活性。在 Vue 2 中，它仍然是一种常用的代码重用机制。特别是对于较小规模的项目或具有简单需求的组件，使用 mixin 可以提供一种简单且灵活的方式来组织和复用代码。\n\n在使用混入时，需要权衡利弊，合理使用，并确保良好的代码组织和命名规范，以最大化地发挥混入的优势并减少其潜在的缺点。\n\n\n\n二、使用mixin// 定义一个 Mixin 对象\nconst myMixin = &#123;\n  data() &#123;\n    return &#123;\n      message: &#39;Hello, Mixin!&#39;\n    &#125;\n  &#125;,\n  methods: &#123;\n    greet() &#123;\n      console.log(this.message);\n    &#125;\n  &#125;\n&#125;\n\n// 在组件中引入 Mixin\nVue.component(&#39;my-component&#39;, &#123;\n  mixins: [myMixin],\n  mounted() &#123;\n    this.greet(); // 输出：Hello, Mixin!\n  &#125;\n&#125;)\n\n\n在这个例子中，定义了一个名为 myMixin 的 Mixin 对象，它包含了一个名为 message 的数据属性和一个名为 greet 的方法。然后，我们在一个组件中通过 mixins 选项引入了这个 Mixin。最终，在组件的 mounted 生命周期钩子中调用了 greet 方法，控制台输出了 Hello, Mixin!\n\n\n三、mixin的合并策略data选项\n\n当一个组件和Mixin都拥有相同的data属性时，Vue会将它们合并成一个新的对象。如果是基本类型，组件的data属性将覆盖Mixin中的data属性，如果两个属性的值都是对象，则Vue会将它们深度合并，递归对比key，如果是同名key则会覆盖，如果不是同名的，则保留。\n\n生命周期钩子\n\n当一个组件和Mixin都定义了相同的生命周期钩子时，同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。\n\n方法与计算属性\n\n当一个组件和Mixin都包含相同名称的方法或计算属性时，组件的方法或计算属性会覆盖Mixin的方法或计算属性。\n\n除了上面这些选项，还有比如components（组件），和directives(指令)等也是一样的逻辑，同名的会覆盖，以组件的为优先。\n\n\n\n四、mixin辨析与 Vuex 的区别\n\nVuex：  用来做状态管理，vuex中定义的变量在每个组件中均可以使用和修改，在任一组件中修改此变量的值之后，其他组件中此变量的值也会随之修改。相当于所有组件共享。\n\nMixins：  可以定义共用的变量，在每个组件中使用，引用组件中之后，各个变量是相互独立的，值的修改在组件中不会相互影响。组件直接使用是相互隔离的，数据互不影响。\n\n\n与公共组件的区别\n\n组件： 在父组件中引入组件，相当于在父组件中给出一片独立的空间供子组件使用，然后根据 prop 来传值，但本质上两者是相对独立的。\n\nMixins： 在引入组件之后与组件中的对象和方法进行合并，相当于扩展了父组件的对象与方法，可以理解为形成了一个新的组件。\n\n\n\n五、个人实践\n前置情况：使用nust对项目进行重构，还是使用Vue2为主，且查询方案大量冗余，故使用mixin将相同代码进行抽离。\n\n\n\n目录结构定义mixins的文件夹，并创建queryPlan.js文件\n\n//导出\nexport const QueryPlan = &#123;\n    data() &#123;\n        return &#123;\n            list: &#123;\n                markets: [],\n                themes: [],\n                styles: [],\n                plays: [],\n            &#125;,\n            // ......\n        &#125;;\n    &#125;,\n    methods: &#123;\n        getMarkets() &#123;\n            // ...\n        &#125;,\n        getThemeList() &#123;\n            // ...\n        &#125;,\n        getPlays() &#123;\n            // ...\n        &#125;,\n        getStyles() &#123;\n            // ...\n        &#125;,\n        // ......\n    &#125;,\n    created() &#123;\n        // ......\n    &#125;,\n    mounted() &#123;\n        // ......\n    &#125;,\n&#125;;\n\n\n创建好之后在.vue文件中引入即可\n\n&lt;template&gt;\n    &lt;div id=&quot;main&quot;&gt;\n        &lt;!-- ... --&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n// 引入\nimport &#123; QueryPlan &#125; from &quot;~/mixins/queryPlan.js&quot;;\n\nexport default &#123;\n    name: &quot;index&quot;,\n    mixins: [QueryPlan],\n    data() &#123;\n    return &#123;\n        // ...\n    &#125;;\n    &#125;,\n    mounted() &#123;\n        // ...\n    &#125;,\n    methods: &#123;\n        // ...\n    &#125;,\n    watch: &#123;\n        // ...\n    &#125;,\n    computed: &#123;\n        // ...\n    &#125;,\n&#125;;\n&lt;/script&gt;\n&lt;style lang=&quot;scss&quot; scoped&gt;\n\n&lt;/style&gt;\n\n","slug":"前端--Mixin从理论到实践","date":"2023-09-11T11:21:16.000Z","categories_index":"前端","tags_index":"Vue","author_index":"会思想的苇草i"},{"id":"823667777e9312d7b7603b0c35d55e32","title":"掌握SEO核心技巧：深入了解搜索引擎优化","content":"\n深入理解搜索前端引擎优化(SEO)\n1、SEO基础入门SEO概述\nSearch Engine Optimization：中文翻译成搜索引擎优化。是指在了解搜索引擎自然排名机制的基础上，对网站进行内部及外部的调整优化，改进网站在搜索引擎中关键词的自然排名，获得更多流量，吸引更多目标客户，从而达到网络营销及品牌建设的目标。\n\n搜索引擎\n搜索引擎是指根据一定的策略、运用特定的计算机程序从互联网上搜集信息，在对信息进行组织和处理后，为用户提供检索服务，将用户检索相关的信息展示给用户的系统。\n常见的搜索引擎：谷歌，必应，百度，360搜索，搜狗搜索…\n搜索引擎收录是指搜索引擎将网页的内容添加到其数据库中，以便在用户进行搜索时能够返回相关的搜索结果。\n搜索引擎工作原理\n抓取\n搜录建库预处理\n分析搜索请求\n对结果排序\n\n\n搜索引擎工作原理 - 掘金 (juejin.cn)\n\n\n\n网页被搜索引擎蜘蛛爬行并保存索引，能被我们检索到时就算网页被收录了。\n使用site命令查询网站收录命令格式:site:+站点域名\n\n\n营销策略\nSEM竞价广告 VS SEO自然搜索结果\nSEM和SEO有什么区别呢？ (zhihu.com)\nSEM广告\n优点：见效快、范围广、操作简单\n缺点：价格高、波动大、恶意点击(扣费)\n\n\nSEO优化\n优点：价格低、排名稳定、不用担心恶意点击\n缺点：见效慢、数量受限、排名在竞价排名之后\n\n\n短期营销–竞价推广；长期发展–SEO优化\n\nSEO查询工具与站长平台SEO查询工具\n\n站长工具：SEO综合查询 - 站长工具 (chinaz.com)\n\n\n\n\n爱战工具：站长工具-百度权重排名查询-站长seo查询 - 爱站网 (aizhan.com)(类似站长工具)\n\n站长平台\n\n百度站长平台，好搜站长平台，搜狗搜索站长平台……\n\n收录与权重优化方式：\n\nurl提交：搜索引擎站长平台为站长提供单条url提交通道，搜索引擎会按照标准处理。\n抓取诊断：抓取诊断的主要作用就是主动邀请蜘蛛来抓取你的内容，抓取之后给予你抓取反馈。\n添加百度分享：网站上安装一个百度分享软件,可以分享到一些权重比较的高网站,像百度收藏、人人网、新浪网等等，也可以手工进行操作，转载到权重高人气旺一些的论坛，并备注一些转载地址，这样不但可以提高网站的权重，还可以缩短收录时间。\n制作添加网站地图：通过添加网站地图提高网站的收录量。\n增加外链新站上线，在非常活跃的网站里添加外链，能大大提高网站的收录速度。\n链接交换：交换几个友情链接，这里需要注意的是不是什么样的都交换，也不是只交换权重高的。交换几个稳定的，长期发展的网站。\n\n\n百度权重是爱站、站长工具等网站推出的针对网站关键词排名预计给网站带来流量，划分等级0-10的第三方网站欢迎度评估数据。百度官方明确表示不承认百度权重hh~\n\n新站提升网站权重:\n\n网站外链的推广度、数量和质量\n网站的内链够强大\n网站的原创质量\n网站的年龄时间\n网站的更新频率\n网站的服务器\n网站的流量:流量越高网站权重越高\n网站的关键词排名:关键词排名越靠前，网站的权重越高\n网站的收录数量:网站百度收录数量越多，网站百度权重越高\n网站或者网页的浏览量及深度:即用户体验越好，网站百度权重越高\n\n\n\n\n2、SEO站内优化关键词\n关键词：就是输入搜索框中的文字，也就是命令搜索引擎寻找的相关信息。\n\n核心关键词指用以描述网站的核心内容、主要服务等方面特征的词汇。(选择关键词的第一步是确定网站核心关键词！)网站的核心关键词代表一个网站的主题，可以是服务，也可以是产品，或者产品+服务。\n\n长尾关键词是指与目标关键词相关的任何有搜索量、有人关注的关键词。长尾关键词流量非常小，但因为长尾关键词词量非常多，所以长尾关键词的流量之和远远大于核心关键词的流量和，而且往往长尾关键词的转化率还要高于核心关键词，因此长尾关键词也是非常重要的。\n\n选择关键词的基本步骤：\n\n通过头脑风暴来确定关键词\n查看竞争对手网站的关键词\n查询关键词热度\n确定自己的核心关键词\n\n\n关键词工具：百度指数–百度指数 (baidu.com)，百度后台关键词推荐百度营销推广-推广怎么做 (baidu.com)，站点工具站长工具 - 站长之家 (chinaz.com)，爱战站长工具-百度权重排名查询-站长seo查询 - 爱站网 (aizhan.com)关键词推荐\n\n\n域名、主机、程序与SEO\n网站&#x3D;域名+服务器+页面文件\n主机服务商选择：避免使用免费主机，选择有信誉的主机提供商\n服务器速度会影响网站用户体验，严重影响网站收录(爬虫抓取时间)\n服务器不稳定，必然影响搜索引擎爬行和抓取\n一个良好SEO的网站程序，要满足以下几点:\nDIV+CSS布局\n自定义的网站头标签\n静态页面生成技术\n相关内容\n规范化的网站结构\n\n\n\n设计技巧及优化\n界面的修改\n修改界面不仅仅是为了SEO优化，修改网站的时候，尽量制作一个特有符合企业形象的界面，从而树立自己的品牌和形象，做到唯一性。如果我们的界面和别人大量重复，那么这样的网站想必在市场品牌这一块已经输了。另外，从SEO的角度来说，界面的变化，那么重复性就会大大的降低。\n\n\nURL的修改\nURL结构对于SEO很重要，因此在下载网站模板使用的时候务必进行修改，建议不要采用模板默认目录结构，可以把默认的栏目、子栏目的目录名称进行修改，这样就很大程度上保证网站url地址和其他网站的差异化。\n\n\nCSS文件的修改\n现在有很多网站模板都是采用DIV+CSS模式，代码精简所带来的直接好处是能使搜索引擎蜘蛛在最短的时间内爬完整个页面，由于能高效的爬行，就会受到蜘蛛喜欢，这样对收录数量有一定好处。\n\n\nJS文件的修改\n在Web项目的开发中, js, css文件会随着项目的开发变得越来越多,越来越大,这就给给性能方面带来一些问题,如页面引入的js, css越多的话,那么对就增加了http请求数,解决该问题的一个好的方法就是合并js,css文件。\n\n\n导航设计优化\n导航结构要清晰明了，突出重点，包含关键词。\n\n\n\n标签优化技巧(TDK)\n标题Title\n\nSEO作用:突出本页面目标关键词，在页面内部优化工作中非常重要。\ntitle标签注意事项\n字符限制建议控制在80字符内\n应添加本页面目标关键词\n\n\n\n\n描述Description\n\nSEO作用:对目标关键词的重要补充，对目标关键词相关搜索有排名辅助作用\ndescription属性的注意事项\n字符限制建议控制在200字符内\n\n\n\n\n关键词Keywords\n\nSEO作用:用来调整关键词密度\nKeywords属性的注意事项\n字符限制建议控制在100字符内\n\n\n\n\n\n页面关键词的布局和密度\n热力图：是反映网站访客对网页局部关注度高低的图\n颜色越暖关注度越高\n热力图显示“F”形\n\n\n\n\n\n“F”型孪生布局\n\n\n\n关键词密度(Keyword Density)与关键词频率（KeywordFrequency）所阐述的实质上是同一个概念，用来量度关键词在网页上出现的总次数与其他文字的比例，一般用百分比表示。关键词密度查询也是站内优化的一个辅助手段\n对于搜索引擎来说，一个页面上的关键字密度最好在**2%-8%**之间\n\n网站内部优化与代码优化内部优化\n\n内链:就是在同一网站域名下的内容页面之间的互相链接\n一般原则:\n用户在进行3次点击，可以到达网站的任何页面\n搜索引擎抓取3级，抓取到网站的所有页面\n\n\n留住用户的一定是内页，如果说整个网站是金字塔，那么网站的内页就是塔底，作为网站的排名基垫，网站的内页优化很重要。\n广义上说：网站除了首页以外的所有页面就是内页\n狭义上说：从网站内部分析网站可分成网站首页，栏目页，专题页，内页等\n\n\n\n\n\n内页优化的作用：\n从连接上可以实现整个网站的有效衔接，进而实现用户体验和搜索引擎优化;\n从文章质量上，可以有效的提高文章的用户体验度，进而提高用户粘度。\n\n\n内页关键词优化-“四处一词”\n标题title\n关键词keywords和描述description\n内容（头部底部、正文)\n锚文本（各种导航）\n\n\n\n代码优化\n\n&lt; h&gt;标签\n\n&lt; h1 &gt;和&lt; h2 &gt;标签能很好的突出显示页面重要标题（标题含关键词)，有助于关键词的排名提升。**&lt; h &gt;标签是网站中表示着重强调的最重要的标签之一**\n为了突出目标关键词，在使用h标签时应该注意\n&lt; h1 &gt;标签和&lt; h2 &gt;标签，不建议同时使用\n&lt; h1 &gt;标签和&lt; h2 &gt;标签在使用的时候建议包含关键词\n&lt; h1 &gt;标签和&lt; h2 &gt;标签在使用的时候建议只出现一次\n&lt; h3 &gt; 、&lt; h4 &gt; 、&lt; h5&gt;标签SEo作用较小，建议不要乱用\n&lt; h6 &gt;可以用在首页友情链接处，以降低友情链接对页面目标关键词的影响\n\n\n\n\n&lt; strong &gt;标签\n\n介绍:&lt; strong &gt;标签表示强调的作用，有加强语气的意思，在浏览器中表现为加粗显示\n作用:在页面内突出关键词，有助于关键词的排名提升\n注意事项：\n页面内不要有大量的加粗文字\n页面内非关键词文本少用此标签\n一般网站标题都需要用此标签\n常用来标注文章小标题\n\n\n\n\n&lt; img &gt;标签中的alt属性\n\n让百度更好的识别图片信息，从而使图片有收录和排名\n可以用来调整关键词的密度，用来保持关键词密度在2%-8%\n注意事项：\nalt描述要和图片内容相符\nalt描述控制在100字符内（极限）\n\n\n\n\n&lt; iframe &gt;标签\n\niframe元素会创建包含另外一个文档的内联框架（即行内框架)，尽量少使用frame和iframe框架结构，通过iframe显示的内容会被百度丢弃。会导致百度spider的抓取困难,建议不要使用(为了SEO)。\n\n\n\n301重定向，404优化301重定向\n\n页面永久性移走（301重定向）是一种非常重要的“自动转向”技术。网址重定向最为可行的一种办法。当用户或搜索引擎向网站服务器发出浏览请求时，服务器返回的HTTP数据流中头信息(header)中的状态码的一种，表示本网页永久性转移到另一个地址。\n\n网站301优化意义\n\n网站改版完成，先将新版上线，在线上保持一段时间新旧内容共存。\n新旧内容同时存在一段时间，且新版内容已开始收录后，对新旧内容设置301跳转，将旧版内容指向新版对应内容。\n301重定向有利于网站首选域的确定，对于同一资源页面多条路径的301重定向有助于URL权重的集中。\n\n\n按照上述操作方式在现有情况下能够尽可能的降低网站因改版带来的流量损失，提高用户体验度，同时有利于网站优化。\n\n可以通过IIS服务器实现301重定向、Apache服务器实现301重定向等。可以通过爱站网HTTPS检测工具 - 爱站网 (aizhan.com)的HTTP状态查询工具进行301重定向检测\n\n\n404优化\n\n404页面是客户端在浏览网页时，服务器无法正常提供信息，或是服务器无法回应，且不知道原因。404错误信息通常是在目标页面被更改或移除，或客户端输入页面地址错误后显示的页面。\n404页面是网站必备的一个页面，它承载着用户体验与SEO优化的重任。404页面通常为用户访问了网站上不存在或已删除的页面，服务器返回的404错误。如果站长没有设置404页面，会出现死链接，蜘蛛爬行这类网址时，不利于搜索引擎收录。\n404页面遵循的理念：\n提供简明的问题描述，消除访客的挫败感。\n提供合理的解决方案，辅助访客完成访问目标。\n提供个性化的友好界面，提升访问体验。\n\n\n\n网站地图和Robots文件网站地图\n\nHTML地图:具有可读性，而且通过分类的形式，展示大部分内容。\n优势:便于用户浏览。\n劣势:当分类过多，易造成遗漏文件不被抓取。\n\n\nXML地图:使用XML标签组成的网站地图，可以罗列几乎所有的地址\n优势:可区分网站的文件是否更新与内容的重要性。\n劣势:只适合搜索引擎蜘蛛抓取，不利于用户体验。\n\n\n\n\n平台工具使用手册_普通收录_搜索学堂_百度搜索资源平台 (baidu.com)\n\nRobots文件\n\nrobots协议（也称为爬虫协议、爬虫规则、机器人协议等）也就是robots.txt，网站通过robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不希望被抓取。\nRobots协议是网站国际互联网界通行的道德规范，其目的是保护网站数据和敏感信息、确保用户个人信息和隐私不被侵犯。\nspider访问一个网站时，首先会检查该网站中是否存在robots.txt这个文件，如果Spider找到这个文件，它就会根据这个文件的内容，来确定它访问权限的范围。\n例如：\nUser-agent: * 这里的 * 代表的所有的搜索引擎种类， * 是一个通配符\nDisallow: &#x2F;admin&#x2F;这里定义是禁止爬寻admin目录下面的目录\nDisallow:&#x2F;* ? *禁止访问网站中所有包含问号(?)的网址\nDisallow: &#x2F; .jpg$禁止抓取网页所有的.jpg格式的图片\nDisallow:&#x2F;ab&#x2F;adc.html禁止爬取ab文件夹下面的adc.html文件。\nAllow: &#x2F;cgi-bin&#x2F;这里定义是允许爬寻cgi-bin目录下面的目录\nAllow: .htm$仅允许访问以”.htm”为后缀的URL。\nAllow: .gif$允许抓取网页和gif格式图片\nSitemap:网站地图告诉爬虫这个页面是网站地图\n\n\n\n死链接\n死链接指原来正常，后来失效的链接。死链接发送请求时，服务器返回404错误页面。即页面已经无效化，无法给用户提供任何有价值信息的页面就是死链接。\n死链接会让浏览你的站点人对你的网站产生反感，直接降低用户体验，而搜索引擎的蜘蛛程序爬到这里的时候，发现前方的路不通，它有可能就会丢弃，不再向前爬，直接导致搜索引擎排名的下降或消失。死链接还可能导致网站的降权。\n处理方案：\n可以使用robots.txt对这些死链进行屏蔽，即是设置robots.txt文件，禁止蜘蛛抓取相关页面。\n查找网站内部所有死链接。提交搜索引擎死链，请求删除百度快照。\n\n\n\n网站优化策略单页面优化策略\n\n常见网站类型优化策略\n\n网站类型有企业站、博客站、电商站、论坛站….所有的网站都有一个最终的目的，那就是盈利，说的通俗点就是赚钱。那么针对这些不同的网站，采用的SEO策略也不同。\n\n企业站SEO优化：优化重心:内容\n\n网站的标题，是否与公司的产品接近\n网站是否有打不开的链接，即:死链接\n网站的关键字、描述是否够合理，这是最基础的\n网站内容要丰富多彩，要够充实\n新闻版块要有，及时并切有规律的更新网\n建立好网站地图&#x2F;404页面&#x2F;301重定向，有利于体验和权重集中!\n……\n\n\n博客类型SEO：优化重心:流量+变现\n\n博客类型属于信息分享类型网站那么这种类型的网站盈利点可以是广告盈利，既然要靠广告盈利，网站的流量就是关键，可以把几种方法一起使用，比如SEO+邮件+QQ+QQ群。\n\n\n电商类型的网站SEO：优化重心:流量+转化率\n\n这种类型的网站与博客类型的网站完全不同，因为它本身就是销售产品的，可直接盈利。那么这种类型的网站重点是流量以及转化率，转化率又和PV有关，PV越高，转化率也会随着变高。\n可以用SEO或者是社区推广的方法，让更多的人知道你的网站，从而进入到你的网站。转化率就得靠长尾词了，虽说长尾词搜索的人很少，但是因为搜索的这个词比较长，从而可以推断出搜索这个词的用户针对性比较强，扩展网站的长尾词以及合理的布局网站的长尾词可以提高网站的转化率。\n\n\n论坛网站做SEO优化，讲究3个核心:\n\n流量是论坛最为重要的一个判断标准\n不管是线下的传单还是线上的广告，每个论坛要做的就是将用户先引入你的网站，是每个论坛站长重点要考虑的问题。\n\n\n用户体验度\n用户可以在该论坛中找寻到自己喜爱的信息和内容，提高用户在该论坛内的停留时间和访问深度。\n\n\n用户粘性用户在网站内登陆，点击，发帖，浏览，回复，玩耍，写日志，加好友，做任务，玩游戏等等一系列的操作行为。而且，还要考究用户的忠诚度，有多少回访用户，有多少新增用户，有多少用户每天都会登陆，又有多少用户可以每天进行发帖，回复等等。\n\n\n\n改善网站内容提升用户体验\n内容为王，网站的生存之道在于网站的内容质量，提供优质的网络资源予用户浏览是一个网站的根基!\n网站内容具有**相关性(用户搜索的关键词与内容网页相匹配)、实用性(对用户越有用)，搜索引擎才会喜欢，浏览者才会喜欢(提升用户体验)**蜘蛛才会喜欢，排名才会上去。\n网站相关性的标准:\n标题里面出现的关键词，内容里面一定要出现。\n标题里面出现的关键词，内容里要围绕这个关键词展开。\n内容不能含有标题关键词以外的不相关的关键词。\n\n\nUEO(user experience Optimization)把它翻译成中文的意思是用户体验优化，也就是把你的网站针对于用户的体验来进行优化，面对用户层面的网站内容性优化，本着为访客服务的原则，改善网站功能、操作、视觉等网站要素，从而获得访客的青睐，通过UEO来提高流量转换率。\nUEO的追求目标是：用户，搜索引擎，企业都能实现自己的利益，从而实现三盈。SEO与UEO有效结合网站优化必不可少\nUEO四大要素：\n网站速度\n文章排版\n网站死链接\n内容更新与维护\n\n\n\n原创与伪原创方法和技巧\n原创的作品价值更高\n原创：指作者首创，并非抄袭模仿的，内容和形式都具有独特个性的物质或精神成果。\n在SEO中，原创不一定要自己写，只要你发表的内容是搜索引擎没有收录的，对于搜索引擎来说就是原创。搜索引擎通过算法判断，原创文章为高权重页面，网站内高权重页面增多了，网站权重也就提高了\n原创文章的基本标准:\n标题包含目标关键词\n内容中穿插目标关键词\n尽量使用概括性小标题\n\n\n原创文章写作要点:\n标题要标准、简洁—包含关键词\n文笔要多变—使用点缀关键词长尾关键词\n融入个性化风格—生动活泼，利于用户阅读\n少用空洞的词汇—有内涵，实用，有明确的观点\n尽量使用小标题—二、三级标题\n带有煽动性的情感—吸引用户，引导用户\n\n\n原创固然好，但难度也高，退而求其次，可采取伪原创的方式更新，以达到原创的效果\n伪原创：是根据现有的文章进行再加工，使其让搜索引擎认为是一篇原创文章。\n伪原创分级\n一级：也就是最初级的，仅仅是对标题修改，处理一些错别字（不建议使用）\n二级：在一级的基础上更进一步，不仅仅修改文章的标题，对段落或文字还进行重新排列，或是同义词的替换等（也不建议使用）\n三级：又进一步不仅对文章的标题进行修改，对段落或文字进行重排，还加入其他的信息，丰富了文章的内容。\n四级：就是在高级的基础上更进一步，加入了自己网站的相关文稿信息，配以图片等。\n\n\n做伪原创：\n修改标题\n拆分法:把原标题中词语拆分成单个词，保留关键词，再进行创作\n颠覆法:重新从关键词角度考虑命名，颠覆原有标题\n\n\n修改内容\n首段自创法:自己来写首段，就像引言的作用一样，在看完全文后，做个总结放在首段，最好带上自己网站的关键词\n段落调整法:调整文章段落顺序，可以倒叙或者穿插方式修改段落出现的顺序\n词语替换法:使用意思相近的词语代替原来内容中的词语\n文字排序法:通过打乱文字顺序让内容看起来不一样\n数字替换法:通过修改内容中的数字\n修改尾段法:修改尾段，可以用自己的话对整篇文章做个总结，以降低网页的相似度，最好带上自己网站的关键词\n\n\n\n\n\n采集工具使用\n火车头采集:http://www.locoy.com\n狂人采集器http://www.kuangren.cc/\n\n站内链接\n内链，顾名思义就是在同一网站域名下的内容页面之间的互相链接（自己网站的内容链接到自己网站的内部页面，也称之为站内链接）。合理的网站内链接构造，能提高搜索引擎的收录与网站权重。\n内链的作用：\n提升用户体验\n增加网站收录\n提升页面权重\n提高页面排名\n\n\n内链优化：\n给网站做Logo加上链接，检查网站的Logo是否带有指向首页的链接\n充分利用导航、底部区域、版权信息等位置增加内链\n链接到相似题目的文章可以帮助读者发现他们感兴趣的内容\n每个文章都用2~3个TAG，用tag来增加内链让页面互通,并且要把TAG设为静态的\n首页上加热门tag和热门搜索关键字，提高用户体验的同时构建了良好的内链\n\n\n内链注意事项：\n尊重用户的体验，注意链接的相关性，内部链接不要太过与泛滥\n内部链接一定要保证URL的唯一性\n内部链接要注意防止死链和断链\n每个页面的内部链接数量要有控制\n\n\n\n统计分析与白皮书分析\nIP：IP地址被用来给Internet上的电脑一个编号\nPV：浏览量，用户每打开一个页面就被记录一次，多次打开同一页面则累计\nUV：独立访客，一台电脑为一个，一天之内只算一次\n统计方式：CNZZ数据专家——全球最大的中文网站统计分析平台，51LA - 领先的数据统计服务商，百度统计——一站式智能数据分析与应用平台 (baidu.com)\n\n\n3、SEO站外优化外链优化基础外部链接\n\n外部链接又叫“反向链接”或“导入链接”,是指其他网站的链接指向你的网站。部链接包括：单向外链和双向外链（友情链接）\n\n外部链接的意义：\n\n增加网站的权重\n提高网站关键词排名\n提高网站流量\n\n\n查询外链\n\n搜索引擎查询\n\n谷歌查询：link:+网站域名地址\n百度查询：domain:+网站域名地址\n\n\n工具查询\n\n爱站网：http://link.aizhan.com/\n站长工具：http://outlink.chinaz.com/\n\n\n\n\n外部链接的注意事项：\n\n循序渐进，不要一下增加很多\n质量，不要单纯性追求数量\n内容相关性强\n\n\n\n单向外链\n\nA网页有链接指向B网页,而B网页没有链接指向A网页，这样的链接称为单向链接\n文本形式，超链形式\n\n双向链接\n\n双向链接，就是指你的网站链接对方的网站之后，对方也链接到你的网站，这就是双向链接\n\n交叉链接\n\n友情链接基础上的升级版，是三个站或者更多站交换\n\n友情链接、链轮、黑链友情链接\n\n友情链接是指互相在自己的网站放对方网站的链接。友情链接的形式：锚文本、图片\n友情链接的目的：\n提升网站权重得到搜索引擎的重视\n提高关键词排名\n提高品牌知名度\n\n\n友情链接的交换条件：行业相关，主题相似\n对方网站至少与我方网站权重相同（对方越高越好）\n友情链接的交换渠道\nQQ群洽谈交换\n行业网站洽谈交换\n\n\n\n链轮\n\nSEO链轮(SEO Link Wheels)是从国外引入国内的，一种比较新颖的SEO策略。是一种比较先进的网络营销方式。\n\nSEO链轮是指通过在互联网上建立大量的独立站点或是在各大门户网站上开设博客，这些独立站点或是博客群通过单向的、有策略、有计划紧密的链接，并都指向要优化的目标网站，以达到提升目标网站在搜索引擎结果中的排名。\n\n\n\n\n\n链轮的作用：\n\n提升网页PR值\n提升网页关键词排名\n提升网页搜索引擎权重\n提升网站知名度\n提升网站流量\n\n\n\n黑链\n\n黑链是SEO手法中相当普遍的一种手段，笼统地说，它就是指一些人用非正常的手段获取的其它网站的反向链接，最常见的黑链就是通过各种网站程序漏洞获取搜索引擎权重或者PR较高的网站的webshell，进而在被黑网站上链接自己的网站，其性质与明链一致，都是属于为高效率提升排名，而使用的作弊手法。\n\n在短时间内可以迅速提高排名，从金钱上来讲，有些站长是不合算了，黑链相对于买个别链接要合适的多，但在一定数量上可以说是价格不菲，所以黑链一般用于暴利的黑(灰)色产业，例如私服，医疗，冷门高利润行业等等。网站虽然提升的快，但对于一些勤快的站长来讲，会在第一时间删除这些黑链，随着搜索引擎的更新，排名也会不太稳定，解决只有不断的购进黑链，这种适合于投资型的站长。\n\nnofollow是一个HTML标签的属性值。这个标签的意义是告诉搜索引擎“不要追踪此网页上的链接”。如注册页，版权说明等等。\n\n把一些不需要获取排名或者非重要页面进行nofollow后，把本来分散在这些非重要页面上的权重值转移到其他重要的页面上，提高其他页面权重。\n\n\n&lt;A href=&quot;http://www.xxxxxxx.com/anli.html&quot; rel=nofollow&gt;成功案例&lt;/A&gt;\n\n外链增加方法与外链评估外链增加方法\n\n资源互换：\n\n个人关系\n同类网站\n链接交换网站\n\n\n友链注意事项：\n\n使用锚文本\n留意假PR值\n判断nofollow\n避免导出链接过多\n\n\nPR劫持是通过用欺骗手段获得比较高的PR值显示。方法是利用跳转。一般搜索引擎在处理301和302转向的时候，都是把目标URL当作实际应该收录的URL。\n\n外链增加–维护友链：\n\n是否有反链\n链接的网页快照\n链接的网站收录\n站长工具友情链接检测工具：http://link.chinaz.com/、http://inlink.linkhelper.cn、http://link.aizhan.com/\n\n\n外链增加–论坛外链\n\n帖子内容\n帖子回复\n签名档\n\n\n外链增加–博客外链\n\n友情链接模块\n博客文章\n博客评论\n\n\n外链增加–提交分类目录\n\n分类目录是指通过人工的方式收集网站资源，并把这些拥有一定价值的网站资源通过人工的方式对它们的主题进行整理组织，存放在相应的目录下面，从而形成的网站分类目录的体系。\n注意事项：\n不要提交未完成的站点\n避免网页有错误\n编写好的站点描述\n提交到不相关的目录\n避免镜像站重复提交\n\n\n\n\n外链增加–SNS社区增加外链\n\n日志中增加外链\n评论中增加外链\n\n\n外链增加–软文推广\n\n外链增加–问答平台\n\n百度知道\n好搜问答\n搜狗问问\n天涯问答\n知乎问答\n\n\n外链增加–产品闭环\n\n百度产品–百度知道、百度百科、百度贴吧、百度文库\n\n\n外链增加–链轮\n\nSEO链轮是指通过在互联网上建立大量的独立站点或是在各大门户网站上开设博客，这些独立站点或是博客群通过单向的、有策略、有计划紧密的链接，并都指向要优化的目标网站，以达到提升目标网站在搜索引擎结果中的排名。\n\n\n外链增加–购买外链\n\n网链\n爱链网爱链网-买卖友情链接，链接交易平台 (520link.com)\n阿里微微(已禁用)\n注意事项\n网站外链数量\n判断是否假PR\n网页的快照\n谨防JS链接\n网站收录数量\n网站性质\n\n\n\n\n\n评估外链\n\n高质量外链标准\n收录总数\n收录速度\n收录比例\n收录稳定性\n\n\n百度绿萝算法是百度于2013年2月19日上线的一种搜索引擎反作弊的算法。该算法主要打击超链中介、出卖链接、购买链接等超链作弊行为。该算法的推出有效制止恶意交换链接，发布外链的行为，有效净化互联网生态圈。\n百度绿萝算法的介绍及解读\n\nSEO白帽、灰帽、黑帽\n白帽就是使用公平的、符合主流搜索引擎方针规定的SEO优化方法。白帽SEO优化的生效时间较长，优点︰排名稳定，浮动不大，不用担心因为SEO操作而降权。\n\n黑帽SEO就是作弊的意思,操作手法不符合主流搜索引擎发行方针规定。轻则降权重则被K。\n\n所谓桥页也叫过渡页，是指一个页面打开之后会自动(或手动)转向到别的页面。桥页主要是针对搜索引擎做的，一些SEOer通过优化过的“桥页”堆砌大量的关键词链接到目标页，利用搜索引擎漏洞，达到快速排名的目的。h\n\n所谓SEO灰帽即是指介于白帽与黑帽之间的中间地带，相对于白帽而言，会采取一些取巧的方式来操作，这些行为因为不算违规,但同样也不遵守规则，是为灰色地带。\n\n网站降权是指搜索引擎给网站评定的级别下降了，也是搜索引擎对网站进行的一种处罚方式。\n\n被降权特征表现\n\n网站部分收录内容减少\n网站排名大幅下降\n搜索引擎快照更新速度降低\n网站首页被屏蔽\n网站全部页面删除\n\n\nSEO打油诗：\n\n准备篇:\n网络行业千千万，确定主题是关键。空间域名带备案，快速稳定是首选。\n\n\n建设篇:\n网站结构要整齐，树形网状是第一。内部链接做到底，平行垂直都考虑。\n\n\n内容篇:\n添加内容莫心急，长尾关键要布局。切忌初期就采集，原创才是硬道理。\n\n\n链接篇:\n内外结合要并行，链接策略切勿扔。内部做好锚文本，外部别忘谈友情。\n\n\n登陆篇:\n万事俱备欠东风，搜索引擎别忘登。分类目录也要整,导航站点稍留心。\n\n\n标题篇∶\n标题始终最重要，如何撰写有技巧。不长不短刚刚好，核心关键往左靠。\n\n\n关键词:\n不要去取堆积论，其实一个足够用。分布合理又均匀，首尾呼应捎带中。\n\n\n描述篇:\n围绕标题几句话，浓缩内容是精华。引导用户点击它，潜在流量成倍加。\n\n\n收录篇:\n对于收录要淡定，持续平稳去更新。蜘蛛看你是新人，只是考察你耐性。\n\n\n心态篇:\n排名起伏属正常，不必哭爹又喊娘。每天都有新气象，时间会让给辉煌。\n\n\n发展篇:\n网站走上正轨道，别神气也别骄傲。一步一步往前跑，流量会变成钞票。\n\n\n结束篇:\n做站前后三月余，边工作来边学习。虽然感觉有点累，看着流量心欢喜。\n\n\n附录篇:\n一个网站三分地，产不产粮看自己。只要用心去管理，神马都不是问题。\n\n\n\n\n网站SEO诊断报告。目的：找出网站seo做的不足地方，根据报告进行改善。\n\n确定网站基础信息\n\n目标网站网址\n域名年龄\n是否备案\n权重情况\n世界排名情况\n……\n\n\n核心关键词分析工作表\n\n指数：通过index.baidu.com 查看关键词百度指数\n排名：通过http://tool.chinaz.com/kws/ 查看关键词在第几位\n密度：通过http://tool.chinaz.com/Tools/Density.aspx 查看关键词密度\n\n\n\n诊断数据查看\n诊断标题、关键词、描述\n\n查看源代码–&gt;查看标题、关键词、描述\n\n\n网站URL目录与文章层级诊断\n\n网站目录层级与文章层级查看是否正常\n目录1-2层级 文章1-3层级\n\n\n301重定向诊断\n\n访问域名进行检测是否有做301重定向\n\n\n诊断图片Alt信息、iframe信息、Flash\n\n使用爱站工具包 网站体检工具检测\n\n\n网站SiteMap诊断\n\n使用域名+sitemap.xml  或者 sitemap.html 查看是否有网站地图。\n\n\n百度快照诊断\n\n使用百度快照或者chinaz工具查看百度快照\n\n\n内容收录诊断\n\n打开目标网站，找到最新的文章，复制文章地址，在百度搜索，查看是否有收录。\n\n\n\n正常情况：\n\n不正常情况：\n\n\n友情链接诊断\n\n使用http://link.chinaz.com/ 查看友情链接数量与是否有单向链接或nofollow\n\n\n网页响应时间\n\n使用爱站seo工具包网站体检，查看页面响应时间\n\n\n反向（外链）链接诊断\n\n使用link.aizhan.com 或者 http://outlink.chinaz.com/ 查看外链数量，越多越好，如果没有进行扣分，根据质量进行扣分。\n\n\n关键词排名诊断\n\n使用seo.chinaz.com查看关键词库 查看有排名的关键词数量。\n\n\nRobots文件诊断\n\n访问域名+robots.txt 查看是否有限制搜索引擎屏蔽全站\n\n\n锚文本诊断\n\n检测友情链接，所做的关键词是否是核心关键词\n\n\ncss和js文件诊断\n\n可以使用爱站seo工具包 网站体检查看，或者查看网站源代码计算。\n\n\n\n网站各地区访问速度\n使用http://tool.chinaz.com/speedtest.aspx 或者http://www.webkaka.com 查看地区访问速度。\n\n\n4、好文推荐\n前端进阶：SEO 全方位解决方案 - 掘金 (juejin.cn)\n《写给前端的SEO搜索引擎优化实践》 - 掘金 (juejin.cn)\n\n","slug":"前端--深入理解搜索前端引擎优化(SEO)","date":"2023-09-01T01:08:31.000Z","categories_index":"前端","tags_index":"SEO","author_index":"会思想的苇草i"},{"id":"89c991e26472da293343598b88f77ea9","title":"打造高效开发环境：Typescript进阶指南","content":"\n打造高效开发环境：TypeScript进阶指南一、快速入门0、TypeScript简介\nTypeScript是JavaScript的超集。\n它对JS进行了扩展，向JS中引入了类型的概念，并添加了许多新的特性。\nTS代码需要通过编译器编译为JS，然后再交由JS解析器执行。\nTS完全兼容JS，换言之，任何的JS代码都可以直接当成JS使用。\n相较于JS而言，TS拥有了静态类型，更加严格的语法，更强大的功能；TS可以在代码执行前就完成代码的检查，减小了运行时异常的出现的几率；TS代码可以编译为任意版本的JS代码，可有效解决不同JS运行环境的兼容问题；同样的功能，TS的代码量要大于JS，但由于TS的代码结构更加清晰，变量类型更加明确，在后期代码的维护中TS却远远胜于JS。\n\n1、TypeScript 开发环境搭建\n下载Node.js\n\n64位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi\n32位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi\n\n\n安装Node.js\n\n使用npm全局安装typescript\n\n进入命令行\n输入：npm i -g typescript\n\n\n创建一个ts文件\n\n使用tsc对ts文件进行编译\n\n进入命令行\n\n进入ts文件所在目录\n\n执行命令：tsc xxx.ts\n\n\n\n\n\n为了简化编译步骤，可以通过两个解决方案来完成:\n\n方式一:通过webpack，配置本地的TypeScript编译环境和开启一个本地服务，可以直接运行在浏览器上;https://mp.weixin.qq.com/s/wnL1l-ERjTDykWM76l4Ajw\n方式二:通过ts-node库，为TypeScript的运行提供执行环境;\n安装ts-node:npm install ts-node -g\nts-node需要以来tslib和@types&#x2F;node两个包:npm install tslib @types/node -g\n直接运行代码:ts-node xxx.ts\n\n\n\n\n最简单的 TypeScript 使用方法，就是使用官网的在线编译页面，叫做 TypeScript Playground。\n\n\n2、基本类型\n类型声明\n\n类型声明是TS非常重要的一个特点\n\n通过类型声明可以指定TS中变量（参数、形参）的类型\n\n指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错\n\n简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值\n\n在TypeScript定义变量(标识符）和ES6之后一致，可以使用var、let、const来定义，在tslint中并不推荐使用var来声明变量\n\n语法：\n\nlet 变量: 类型;\nlet a: number;\n\nlet 变量: 类型 = 值;\nlet a: number = 10;\n\nfunction fn(参数: 类型, 参数: 类型): 类型&#123;\n    ...\n&#125;\n function sum(a: number, b: number): number &#123;\n    return a + b;\n&#125;\n\n\n\n\n\n\n自动类型判断\n\nTS拥有自动的类型判断机制\n当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型\n所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明\n\n\n类型：\n\n\n\n类型\n例子\n描述\n\n\n\nnumber\n1, -33, 2.5\n任意数字\n\n\nstring\n‘hi’, “hi”, hi\n任意字符串\n\n\nboolean\ntrue、false\n布尔值true或false\n\n\n字面量\n其本身\n限制变量的值就是该字面量的值\n\n\nany\n*\n任意类型\n\n\nunknown\n*\n类型安全的any\n\n\nvoid\n空值（undefined）\n没有值（或undefined）\n\n\nnever\n没有值\n不能是任何值\n\n\nobject\n{name:’孙悟空’}\n任意的JS对象\n\n\narray\n[1,2,3]\n任意JS数组\n\n\ntuple\n[4,5]\n元素，TS新增类型，固定长度数组\n\n\nenum\nenum{A, B}\n枚举，TS中新增类型\n\n\n\nnumber\n\nlet decimal: number = 6;  //十进制\nlet hex: number = 0xf00d;  //十六进制\nlet binary: number = 0b1010;  //二进制\nlet octal: number = 0o744;  //八进制\nlet big: bigint = 100n;  //大整形\n\n\n\n\nboolean\n\nlet isDone: boolean = false;\n\n\n\n\nstring\n\nlet color: string = &quot;blue&quot;;\ncolor = &#39;red&#39;;\n\nlet fullName: string = `Bob Bobbington`;\nlet age: number = 37;\nlet sentence: string = `Hello, my name is $&#123;fullName&#125;.\n\nI&#39;ll be $&#123;age + 1&#125; years old next month.`;\n\n\n\n\n字面量\n\n也可以使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围(类似于常量，限定值或范围)\n\n第一次创建的对象字面量, 称之为fresh(新鲜的)\n\n对于新鲜的字面量, 会进行严格的类型检测. 必须完全满足类型的要求(不能有多余的属性)\n\nlet color: &#39;red&#39; | &#39;blue&#39; | &#39;black&#39;;\nlet num: 1 | 2 | 3 | 4 | 5;\n\n\n\n\nany\n\n相当于对该变量关闭了TS的类型检测\n\nTypeScript 提供了一个编译选项noImplicitAny，打开该选项，只要推断出any类型就会报错。\n tsc --noImplicitAny app.ts\n\n\n\n\nlet d: any = 4;\nd = &#39;hello&#39;;\nd = true;\n//隐式\nlet e;\n\n\n\n\nunknown\n\nunknown类型的变量，不能直接赋值给其他变量，不能直接调用\n\n\nlet notSure: unknown = 4;\nnotSure = &#39;hello&#39;;\n\n//类型检查\nlet s:string;\nif(typeof e === &quot;string&quot;)&#123;\n    s = e;\n&#125;\n\n//类型断言\n/*\n语法：\n变量 as 类型\n&lt;类型&gt;变量\n*/\ns = e as string;\n//s = &lt;string&gt;e;\n\n\n\n\nvoid\n\nlet unusable: void = undefined;\n\n//没写void，没写return，默认为void\n//可以将undefined赋值给void类型，函数可以返回undefined\nfunction fn(): void &#123;\n&#125;\n\n\n\n\nnever\n\n表示永远不会返回结果\n\n\nfunction error(message: string): never &#123;\n  throw new Error(message);\n&#125;\n\n\n\n\nobject（没啥用）\n\nlet obj: object = &#123;&#125;;\n\n// &#123;&#125; 用来指定对象中可以包含哪些属性\n// 语法：&#123;属性名:属性值,属性名:属性值&#125;\n// 在属性名后边加上?，表示属性是可选的\nlet b: &#123; name: string, age?: number &#125;;\nb = &#123; name: &#39;孙悟空&#39;, age: 18 &#125;;\n\n//定义对象结构\n// [propName: string]: any 表示任意类型的属性\nlet c: &#123; name: string, [propName: string]: any &#125;;\nc = &#123; name: &#39;猪八戒&#39;, age: 18, gender: &#39;男&#39; &#125;;\n\n//定义函数结构\n/*\n  设置函数结构的类型声明：\n  语法：(形参:类型, 形参:类型 ...) =&gt; 返回值\n*/\nlet d: (a: number, b: number) =&gt; number;\n// d = function (n1: string, n2: string): number&#123;\n//     return 10;\n// &#125;\n\n\n\n\narray\n\n//类型[]\nlet list: number[] = [1, 2, 3];\nlist.push(4)\n\n//Array&lt;类型&gt;\nlet list: Array&lt;number&gt; = [1, 2, 3];\n\n\n\n\ntuple\n\n//元组中每个元素都有自己特性的类型，根据索引值获取到的值可以确定对应的类型\nlet x: [string, number];\nx = [&quot;hello&quot;, 10]; \n\n\n\n\nenum\n\nenum Color &#123;\n  Red,\n  Green,\n  Blue,\n&#125;\nlet c: Color = Color.Green;\n\nenum Color &#123;\n  Red = 1,\n  Green,\n  Blue,\n&#125;\nlet c: Color = Color.Green;\n\nenum Color &#123;\n  Red = 1,\n  Green = 2,\n  Blue = 4,\n&#125;\nlet c: Color = Color.Green;\n\n// &amp;表示同时\nlet j: &#123; name: string &#125; &amp; &#123; age: number &#125;;\n// j = &#123;name: &#39;孙悟空&#39;, age: 18&#125;;\n\n// 类型的别名\ntype myType = 1 | 2 | 3 | 4 | 5;\nlet k: myType;\nlet l: myType;\nlet m: myType;\n\nk = 2;\n\n\n\n\n函数的参数类型\n\n指定函数的参数和返回值类型\n\nfunction sum(num1: number, num2: number): number &#123;\n  return num1 + num2\n&#125;\n\nconst res = sum(123, 321)\n\nexport &#123;&#125;\n\n\n函数类型表达式\n\ntype CalcType = (num1: number, num2: number) =&gt; number\n\n// 1.函数的定义\nfunction calc(calcFn: CalcType) &#123;\n  const num1 = 10\n  const num2 = 20\n  const res = calcFn(num1, num2)\n  console.log(res)\n&#125;\n\n\n// 2.函数的调用\nfunction sum(num1: number, num2: number) &#123;\n  return num1 + num2\n&#125;\n\nfunction foo(num1: number) &#123;\n  return num1\n&#125;\ncalc(sum)\ncalc(foo)\n\nfunction mul(num1: number, num2: number) &#123;\n  return num1 * num2\n&#125;\ncalc(mul)\n\n// 3.使用匿名函数\ncalc(function(num1, num2) &#123;\n  return num1 - num2\n&#125;)\n\nexport &#123;&#125;\n\n\n调用签名与构造签名\n\n// 1.函数类型表达式\ntype BarType = (num1: number) =&gt; number\n\n// 2.函数的调用签名(从对象的角度来看待这个函数, 也可以有其他属性)\ninterface IBar &#123;\n  name: string\n  age: number\n  // 函数可以调用: 函数调用签名\n  (num1: number): number\n&#125;\n\nconst bar: IBar = (num1: number): number =&gt; &#123;\n  return 123\n&#125;\n\nbar.name = &quot;aaa&quot;\nbar.age = 18\nbar(123)\n\nexport &#123;&#125;\n// 开发中如何选择:\n// 1.如果只是描述函数类型本身(函数可以被调用), 使用函数类型表达式(Function Type Expressions)\n// 2.如果在描述函数作为对象可以被调用, 同时也有其他属性时, 使用函数调用签名(Call Signatures)\n\nclass Person &#123;\n&#125;\n\ninterface ICTORPerson &#123;\n  new (): Person\n&#125;\n\nfunction factory(fn: ICTORPerson) &#123;\n  const f = new fn()\n  return f\n&#125;\n\nfactory(Person)\n\n\n参数的可选类型：**function  foo(x :  number, y? : number){ }**，此时y的类型为number|undefined\n默认参数：**function  foo(x :  number, y : number&#x3D;6){ }**，此时y的类型为number|undefined\n剩余参数：**function  foo(…nums：number[]){ }**，剩余参数语法允许我们将一个不定数量的参数放到一个数组中\n函数重载：举例，传入字符串或者数组，获取到它的长度\n\n// 1.普通的实现\nfunction getLength(arg) &#123;\n  return arg.length\n&#125;\n\n// 2.函数的重载\nfunction getLength(arg: string): number\nfunction getLength(arg: any[]): number\nfunction getLength(arg) &#123;\n  return arg.length\n&#125;\n\n// 3.联合类型实现(可以使用联合类型实现的情况, 尽量使用联合类型)\nfunction getLength(arg: string | any[]) &#123;\n  return arg.length\n&#125;\n\n// 4.对象类型实现\nfunction getLength(arg: &#123; length: number &#125;) &#123;\n  return arg.length\n&#125;\n\n\n函数中的this：前端面试之彻底搞懂this指向\n\n在没有指定this的情况，this默认情况下是any类型的，此时创建tsconfig.json文件，noImplicitThis设置为true，TypeScript 会根据上下文推导 this ，但是在不能正确推导时，就会报错，需要我们明确的指定 this \n函数的第一个参数我们可以根据该函数之后被调用的情况，用于声明this的类型(名词必须叫this)在后续调用函数传入参数时，从第二个参数开始传递的，this参数会在编译后被抹除\n\n// 1.对象中的函数中的this\nconst obj = &#123;\n  name: &quot;why&quot;,\n  studying: function(this: &#123;&#125;) &#123;\n    // 默认情况下, this是any类型\n    console.log(this, &quot;studying&quot;)\n  &#125;\n&#125;\n\n// obj.studying()\nobj.studying.call(&#123;&#125;)\n\n\n// 2.普通的函数\nfunction foo(this: &#123; name: string &#125;, info: &#123;name: string&#125;) &#123;\n  console.log(this, info)\n&#125;\n\nfoo.call(&#123; name: &quot;why&quot; &#125;, &#123; name: &quot;kobe&quot; &#125;)\n\nexport &#123;&#125;\n\n\nthis相关的内置工具\nThisParameterType:用于提取一个函数类型Type的this (opens new window)参数类型;如果这个函数类型没有this参数返回unknown\nOmitThisParameter:用于移除一个函数类型Type的this参数类型,并且返回当前的函数类型\nThisType:这个类型不返回一个转换过的类型，它被用作标记一个上下文的this 类型。\n\n\n\nfunction foo(this: &#123; name: string &#125;, info: &#123;name: string&#125;) &#123;\n  console.log(this, info)\n&#125;\n\ntype FooType = typeof foo\n\n// 1.ThisParameterType: 获取FooType类型中this的类型\ntype FooThisType = ThisParameterType&lt;FooType&gt;\n\n\n// 2.OmitOmitThisParameter: 删除this参数类型, 剩余的函数类型\ntype PureFooType = OmitThisParameter&lt;FooType&gt;\n\n\n// 3.ThisType: 用于绑定一个上下文的this\ninterface IState &#123;\n  name: string\n  age: number\n&#125;\n\ninterface IStore &#123;\n  state: IState\n  eating: () =&gt; void\n  running: () =&gt; void\n&#125;\n\nconst store: IStore &amp; ThisType&lt;IState&gt; = &#123;\n  state: &#123;\n    name: &quot;why&quot;,\n    age: 18\n  &#125;,\n  eating: function() &#123;\n    console.log(this.name)\n  &#125;,\n  running: function() &#123;\n    console.log(this.name)\n  &#125;\n&#125;\n\nstore.eating.call(store.state)\n\nexport &#123;&#125;\n\n\n\n\n匿名函数的参数会自动指定类型，会进行类型推断，这个过程称为上下文类型，因为函数执行的上下文可以帮助确定参数和返回值类型\n\n\nconst names: string[] = [&quot;abc&quot;, &quot;cba&quot;, &quot;nba&quot;]\n\n// 匿名函数最好不要添加类型注解\nnames.forEach(function(item, index, arr) &#123;\n  console.log(item, index, arr)\n&#125;)\n\nexport &#123;&#125;\n\n\n联合类型和交叉类型\n\n联合类型：联合类型是由两个或者多个其他类型组成的类型，表示可以是这些类型中的任何一个值；联合类型中的每一个类型被称之为联合成员（ union’s members）\n\nfunction printID(id: number | string) &#123;\n  console.log(&quot;您的ID:&quot;, id)\n\n  // 类型缩小\n  if (typeof id === &quot;string&quot;) &#123;\n    console.log(id.length)\n  &#125; else &#123;\n    console.log(id)\n  &#125;\n&#125;\n\nprintID(&quot;abc&quot;)\nprintID(123)\n\n\n类型别名：类型别名和接口非常类似\n\n// 类型别名: type\ntype MyNumber = number\nconst age: MyNumber = 18\n\n// 给ID的类型起一个别名\ntype IDType = number | string\n\nfunction printID(id: IDType) &#123;\n  console.log(id)\n&#125;\n\n\n// 打印坐标\ntype PointType = &#123; x: number, y: number, z?: number &#125;\nfunction printCoordinate(point: PointType) &#123;\n  console.log(point.x, point.y, point.z)\n&#125;\n\n\ninterface 和 type 都可以用来定义对象类型，如果是定义非对象类型 ，通常 推荐使用 type ，如果是定义对象类型，那么他们是有区别的：interface可以重复的对某个接口来定义属性和方法；而type 定义的是别名，别名是不能重复的\n\n// 1.区别一: type类型使用范围更广, 接口类型只能用来声明对象\ntype MyNumber = number\ntype IDType = number | string\n\n// 2.区别二: 在声明对象时, interface可以多次声明\n// 2.1. type不允许两个相同名称的别名同时存在\n// type PointType1 = &#123;\n//   x: number\n//   y: number\n// &#125;\n\n// type PointType1 = &#123;\n//   z?: number\n// &#125;\n\n// 2.2. interface可以多次声明同一个接口名称\ninterface PointType2 &#123;\n  x: number\n  y: number\n&#125;\n\ninterface PointType2 &#123;\n  z: number\n&#125;\n\nconst point: PointType2 = &#123;\n  x: 100,\n  y: 200,\n  z: 300\n&#125;\n\n// 3.interface支持继承的\ninterface IPerson &#123;\n  name: string\n  age: number\n&#125;\n\ninterface IKun extends IPerson &#123;\n  kouhao: string\n&#125;\n\nconst ikun1: IKun = &#123;\n  kouhao: &quot;你干嘛, 哎呦&quot;,\n  name: &quot;kobe&quot;,\n  age: 30\n&#125;\n\n// 4.interface可以被类实现(TS面向对象时候再讲)\n// class Person implements IPerson &#123;\n// &#125;\n\n// 总结: 如果是非对象类型的定义使用type, 如果是对象类型的声明那么使用interface\n\nexport &#123;&#125;\n\n\n交叉类型：交叉类似表示需要满足多个类型的条件，交叉类型使用&amp;符号\n\n// 交叉类型: 两种(多种)类型要同时满足\ntype NewType = number &amp; string // 没有意义\n\ninterface IKun &#123;\n  name: string\n  age: number\n&#125;\n\ninterface ICoder &#123;\n  name: string\n  coding: () =&gt; void\n&#125;\n\ntype InfoType = IKun &amp; ICoder\n\nconst info: InfoType = &#123;\n  name: &quot;why&quot;,\n  age: 18,\n  coding: function() &#123;\n    console.log(&quot;coding&quot;)\n  &#125;\n&#125;\n\n\n类型断言\n\n有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：\n\n第一种：as关键词\n\nlet someValue: unknown = &quot;this is a string&quot;;\nlet strLength: number = (someValue as string).length;\n\n\n\n\n\n第二种：尖括号语法\n\nlet someValue: unknown = &quot;this is a string&quot;;\nlet strLength: number = (&lt;string&gt;someValue).length;\n\n\n\n\n\n\n非空类型断言\n\n// 访问属性: 可选链: ?.\nconsole.log(info.friend?.name)\n// 非空类型断言(有点危险, 只有确保friend一定有值的情况, 才能使用)\ninfo.friend!.name = &quot;james&quot;\n\n\n\n\n字面量类型\n\n// 1.字面量类型的基本上\nconst name: &quot;why&quot; = &quot;why&quot;\nlet age: 18 = 18\n\n// 2.将多个字面量类型联合起来 |\ntype Direction = &quot;left&quot; | &quot;right&quot; | &quot;up&quot; | &quot;down&quot;\nconst d1: Direction = &quot;left&quot;\n\n// 栗子: 封装请求方法\ntype MethodType = &quot;get&quot; | &quot;post&quot;\nfunction request(url: string, method: MethodType) &#123;\n&#125;\n\nrequest(&quot;http://codercba.com/api/aaa&quot;, &quot;post&quot;)\n\nexport &#123;&#125;\n\n\n\n\n类型缩小：在给定的执行路径中，我们可以缩小比声明时更小的类型 ，这个过程称之为缩小(Narrowing），typeof padding &#x3D;&#x3D;&#x3D; “number 可以称之为 类型保护(type guards):typeof、平等缩小(比如  &#x3D; &#x3D; &#x3D;、! &#x3D; &#x3D;)、instanceof、in、等等…\n// 1.typeof: 使用的最多\nfunction printID(id: number | string) &#123;\n  if (typeof id === &quot;string&quot;) &#123;\n    console.log(id.length, id.split(&quot; &quot;))\n  &#125; else &#123;\n    console.log(id)\n  &#125;\n&#125;\n\n\n// 2.===/!==: 方向的类型判断\ntype Direction = &quot;left&quot; | &quot;right&quot; | &quot;up&quot; | &quot;down&quot;\nfunction switchDirection(direction: Direction) &#123;\n  if (direction === &quot;left&quot;) &#123;\n    console.log(&quot;左:&quot;, &quot;角色向左移动&quot;)\n  &#125; else if (direction === &quot;right&quot;) &#123;\n    console.log(&quot;右:&quot;, &quot;角色向右移动&quot;)\n  &#125; else if (direction === &quot;up&quot;) &#123;\n    console.log(&quot;上:&quot;, &quot;角色向上移动&quot;)\n  &#125; else if (direction === &quot;down&quot;) &#123;\n    console.log(&quot;下:&quot;, &quot;角色向下移动&quot;)\n  &#125;\n&#125;\n\n\n// 3. instanceof: 传入一个日期, 打印日期\nfunction printDate(date: string | Date) &#123;\n  if (date instanceof Date) &#123;\n    console.log(date.getTime())\n  &#125; else &#123;\n    console.log(date)\n  &#125;\n&#125;\n\n\n// 4.in: 判断是否有某一个属性\ninterface ISwim &#123;\n  swim: () =&gt; void\n&#125;\n\ninterface IRun &#123;\n  run: () =&gt; void\n&#125;\n\nfunction move(animal: ISwim | IRun) &#123;\n  if (&quot;swim&quot; in animal) &#123;\n    animal.swim()\n  &#125; else if (&quot;run&quot; in animal) &#123;\n    animal.run()\n  &#125;\n&#125;\n\nconst fish: ISwim = &#123;\n  swim: function() &#123;&#125;\n&#125;\n\nconst dog: IRun = &#123;\n  run: function() &#123;&#125;\n&#125;\n\nmove(fish)\nmove(dog)\n\n\n\n\n\n\n\n3、编译选项\n自动编译文件\n\n编译文件时，使用 -w  指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。\n\n示例：\n\ntsc xxx.ts -w\n\n\n\n\n\n\n自动编译整个项目\n\n如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。\n\n但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json(tsc --init)\n\ntsconfig.json是一个JSON文件，添加配置文件后，只需只需 tsc 命令即可完成对整个项目的编译tsc -w自动监视所有文件\n\n配置选项：\n\ninclude\n\n定义希望被编译文件所在的目录\n\n默认值：[“**&#x2F;*“]    (** 表示任意目录 *表示任意文件)\n\n示例：\n\n&quot;include&quot;:[&quot;src/**/*&quot;, &quot;tests/**/*&quot;]\n\n\n上述示例中，所有src目录和tests目录下的文件都会被编译\n\n\n\n\n\nexclude\n\n定义需要排除在外的目录\n\n默认值：[“node_modules”, “bower_components”, “jspm_packages”]\n\n示例：\n\n&quot;exclude&quot;: [&quot;./src/hello/**/*&quot;]\n\n\n上述示例中，src下hello目录下的文件都不会被编译\n\n\n\n\n\nextends\n\n定义被继承的配置文件\n\n示例：\n\n&quot;extends&quot;: &quot;./configs/base&quot;\n\n\n上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息\n\n\n\n\n\nfiles\n\n指定被编译文件的列表，只有需要编译的文件少时才会用到\n\n示例：\n\n&quot;files&quot;: [\n    &quot;core.ts&quot;,\n    &quot;sys.ts&quot;,\n    &quot;types.ts&quot;,\n    &quot;scanner.ts&quot;,\n    &quot;parser.ts&quot;,\n    &quot;utilities.ts&quot;,\n    &quot;binder.ts&quot;,\n    &quot;checker.ts&quot;,\n    &quot;tsc.ts&quot;\n  ]\n\n\n列表中的文件都会被TS编译器所编译\n\n\n\ncompilerOptions\n\n编译选项是配置文件中非常重要也比较复杂的配置选项\n\n在compilerOptions中包含多个子选项，用来完成对编译的配置\n\n项目选项\n\ntarget\n\n设置ts代码编译的目标版本\n\n可选值：\n\nES3（默认）、ES5、ES6&#x2F;ES2015、ES7&#x2F;ES2016、ES2017、ES2018、ES2019、ES2020、ESNext(ES最新版本)\n\n\n示例：\n\n&quot;compilerOptions&quot;: &#123;\n    &quot;target&quot;: &quot;ES6&quot;\n&#125;\n\n\n如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码\n\n\n\n\n\nlib\n\n指定代码运行时所包含的库（宿主环境）\n\n可选值：\n\nES5、ES6&#x2F;ES2015、ES7&#x2F;ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ……\n\n\n示例：\n\n&quot;compilerOptions&quot;: &#123;\n    &quot;target&quot;: &quot;ES6&quot;,\n    &quot;lib&quot;: [&quot;ES6&quot;, &quot;DOM&quot;],\n    &quot;outDir&quot;: &quot;dist&quot;,\n    &quot;outFile&quot;: &quot;dist/aa.js&quot;\n&#125;\n\n\n\n\n\n\nmodule\n\n设置编译后代码使用的模块化系统\n\n可选值：\n\nCommonJS、UMD、AMD、System、ES2020、ESNext、None\n\n\n示例：\n\n&quot;compilerOptions&quot;: &#123;\n    &quot;module&quot;: &quot;CommonJS&quot;\n&#125;\n\n\n\n\n\n\noutDir\n\n编译后文件的所在目录\n\n默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置\n\n示例：\n\n&quot;compilerOptions&quot;: &#123;\n    &quot;outDir&quot;: &quot;dist&quot;\n&#125;\n\n\n设置后编译后的js文件将会生成到dist目录\n\n\n\n\n\noutFile\n\n将所有的文件编译为一个js文件\n\n默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中\n\n示例：\n\n&quot;compilerOptions&quot;: &#123;\n    &quot;outFile&quot;: &quot;dist/app.js&quot;\n&#125;\n\n\n\n\n\n\nrootDir\n\n指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录\n\n示例：\n\n&quot;compilerOptions&quot;: &#123;\n    &quot;rootDir&quot;: &quot;./src&quot;\n&#125;\n\n\n\n\n\n\nallowJs\n\n是否对js文件编译\n\n\ncheckJs\n\n是否对js文件进行检查\n\n示例：\n\n&quot;compilerOptions&quot;: &#123;\n    &quot;allowJs&quot;: true,\n    &quot;checkJs&quot;: true\n&#125;\n\n\n\n\n\n\nremoveComments\n\n是否删除注释\n默认值：false\n\n\nnoEmit\n\n不对代码进行编译\n默认值：false\n\n\nsourceMap\n\n是否生成sourceMap\n默认值：false\n\n\n\n\n严格检查\n\nstrict\n启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查\n\n\nalwaysStrict\n总是以严格模式对代码进行编译\n\n\nnoImplicitAny\n禁止隐式的any类型\n\n\nnoImplicitThis\n禁止类型不明确的this\n\n\nstrictBindCallApply\n严格检查bind、call和apply的参数列表\n\n\nstrictFunctionTypes\n严格检查函数的类型\n\n\nstrictNullChecks\n严格的空值检查\n\n\nstrictPropertyInitialization\n严格检查属性是否初始化\n\n\n\n\n额外检查\n\nnoFallthroughCasesInSwitch\n检查switch语句包含正确的break\n\n\nnoImplicitReturns\n检查函数没有隐式的返回值\n\n\nnoUnusedLocals\n检查未使用的局部变量\n\n\nnoUnusedParameters\n检查未使用的参数\n\n\n\n\n高级\n\nallowUnreachableCode\n检查不可达代码\n可选值：\ntrue，忽略不可达代码\nfalse，不可达代码将引起错误\n\n\n\n\nnoEmitOnError\n有错误的情况下不进行编译\n默认值：false\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4、webpack\n通常情况下，实际开发中我们都需要使用构建工具对代码进行打包，TS同样也可以结合构建工具一起使用，下边以webpack为例介绍一下如何结合构建工具使用TS。\n\n步骤：\n\n初始化项目\n\n进入项目根目录，执行命令 npm init -y\n主要作用：创建package.json文件\n\n\n\n\n下载构建工具\n\nnpm i -D webpack webpack-cli webpack-dev-server typescript ts-loader clean-webpack-plugin\n共安装了7个包\nwebpack\n构建工具webpack\n\n\nwebpack-cli\nwebpack的命令行工具\n\n\nwebpack-dev-server\nwebpack的开发服务器\n\n\ntypescript\nts编译器\n\n\nts-loader\nts加载器，用于在webpack中编译ts文件\n\n\nhtml-webpack-plugin\nwebpack中html插件，用来自动创建html文件\n\n\nclean-webpack-plugin\nwebpack中的清除插件，每次构建都会先清除目录\n\n\n\n\n\n\n\n\n根目录下创建webpack的配置文件webpack.config.js\n\nconst path = require(&quot;path&quot;);\nconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);\nconst &#123; CleanWebpackPlugin &#125; = require(&quot;clean-webpack-plugin&quot;);\n\nmodule.exports = &#123;\n    optimization:&#123;\n        minimize: false // 关闭代码压缩，可选\n    &#125;,\n\n    entry: &quot;./src/index.ts&quot;,\n    \n    devtool: &quot;inline-source-map&quot;,\n    \n    devServer: &#123;\n        contentBase: &#39;./dist&#39;\n    &#125;,\n\n    output: &#123;\n        path: path.resolve(__dirname, &quot;dist&quot;),\n        filename: &quot;bundle.js&quot;,\n        environment: &#123;\n            arrowFunction: false // 关闭webpack的箭头函数，可选\n        &#125;\n    &#125;,\n\n    resolve: &#123;\n        extensions: [&quot;.ts&quot;, &quot;.js&quot;]\n    &#125;,\n    \n    module: &#123;\n        rules: [\n            &#123;\n                test: /\\.ts$/,\n                use: &#123;\n                   loader: &quot;ts-loader&quot;     \n                &#125;,\n                exclude: /node_modules/\n            &#125;\n        ]\n    &#125;,\n\n    plugins: [\n        new CleanWebpackPlugin(),\n        new HtmlWebpackPlugin(&#123;\n            title:&#39;TS测试&#39;\n        &#125;),\n    ]\n\n&#125;\n\n\n\n\n根目录下创建tsconfig.json，配置可以根据自己需要\n\n&#123;\n    &quot;compilerOptions&quot;: &#123;\n        &quot;target&quot;: &quot;ES2015&quot;,\n        &quot;module&quot;: &quot;ES2015&quot;,\n        &quot;strict&quot;: true\n    &#125;\n&#125;\n\n\n\n\n修改package.json添加如下配置\n\n&#123;\n  ...略...\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,\n    &quot;build&quot;: &quot;webpack&quot;,\n    &quot;start&quot;: &quot;webpack serve --open chrome.exe&quot;\n  &#125;,\n  ...略...\n&#125;\n\n\n\n\n在src下创建ts文件，并在并命令行执行npm run build对代码进行编译，或者执行npm start来启动开发服务器\n\n\n\n\n5、Babel\n经过一系列的配置，使得TS和webpack已经结合到了一起，除了webpack，开发中还经常需要结合babel来对代码进行转换以使其可以兼容到更多的浏览器，在上述步骤的基础上，通过以下步骤再将babel引入到项目中。\n\n安装依赖包：\n\nnpm i -D @babel/core @babel/preset-env babel-loader core-js\n共安装了4个包，分别是：\n@babel&#x2F;core\nbabel的核心工具\n\n\n@babel&#x2F;preset-env\nbabel的预定义环境\n\n\n@babel-loader\nbabel在webpack中的加载器\n\n\ncore-js\ncore-js用来使老版本的浏览器支持新版ES语法\n\n\n\n\n\n\n修改webpack.config.js配置文件\n\n...略...\nmodule: &#123;\n    rules: [\n        &#123;\n            test: /\\.ts$/,\n            use: [\n                &#123;\n                    loader: &quot;babel-loader&quot;,\n                    options:&#123;\n                        presets: [\n                            [\n                                &quot;@babel/preset-env&quot;,\n                                &#123;\n                                    &quot;targets&quot;:&#123;\n                                        &quot;chrome&quot;: &quot;58&quot;,\n                                        &quot;ie&quot;: &quot;11&quot;\n                                    &#125;,\n                                    &quot;corejs&quot;:&quot;3&quot;,\n                                    &quot;useBuiltIns&quot;: &quot;usage&quot;\n                                &#125;\n                            ]\n                        ]\n                    &#125;\n                &#125;,\n                &#123;\n                    loader: &quot;ts-loader&quot;,\n\n                &#125;\n            ],\n            exclude: /node_modules/\n        &#125;\n    ]\n&#125;\n...略...\n\n\n如此一来，使用ts编译后的文件将会再次被babel处理，使得代码可以在大部分浏览器中直接使用，可以在配置选项的targets中指定要兼容的浏览器版本。\n\n\n\n\n\n\n\n二、面向对象0、面向对象简介面向对象是程序中一个非常重要的思想，它被很多同学理解成了一个比较难，比较深奥的问题，其实不然。面向对象很简单，简而言之就是程序之中所有的操作都需要通过对象来完成。\n\n举例来说：\n操作浏览器要使用window对象\n操作网页要使用document对象\n操作控制台要使用console对象\n\n\n\n一切操作都要通过对象，也就是所谓的面向对象，那么对象到底是什么呢？这就要先说到程序是什么，计算机程序的本质就是对现实事物的抽象，抽象的反义词是具体，比如：照片是对一个具体的人的抽象，汽车模型是对具体汽车的抽象等等。程序也是对事物的抽象，在程序中我们可以表示一个人、一条狗、一把枪、一颗子弹等等所有的事物。一个事物到了程序中就变成了一个对象。\n在程序中所有的对象都被分成了两个部分数据和功能，以人为例，人的姓名、性别、年龄、身高、体重等属于数据，人可以说话、走路、吃饭、睡觉这些属于人的功能。数据在对象中被成为属性，而功能就被称为方法。所以简而言之，在程序中一切皆是对象。\n1、类（class）要想面向对象，操作对象，首先便要拥有对象，那么下一个问题就是如何创建对象。要创建对象，必须要先定义类，所谓的类可以理解为对象的模型，程序中可以根据类创建指定类型的对象，举例来说：可以通过Person类来创建人的对象，通过Dog类创建狗的对象，通过Car类来创建汽车的对象，不同的类可以用来创建不同的对象。\n\n定义类：\n\nclass 类名 &#123;\n    属性名: 类型;\n    \n    constructor(参数: 类型)&#123;\n        this.属性名 = 参数;\n    &#125;\n    \n    方法名()&#123;\n        ....\n    &#125;\n\n&#125;\n\n\n\n\n示例：构造函数不需要返回任何值，默认返回当前创建出来的实例\n\nclass Person&#123;\n    name: string;\n    age: number;\n\n    constructor(name: string, age: number)&#123;\n        this.name = name;\n        this.age = age;\n    &#125;\n\n    sayHello()&#123;\n        console.log(`大家好，我是$&#123;this.name&#125;`);\n    &#125;\n&#125;\n\n\n\n\n使用类：\n\nconst p = new Person(&#39;孙悟空&#39;, 18);\np.sayHello();\n\n\n\n\n\n\n直接定义的属性是实例属性，需要通过对象的实例去访问；使用static开头的属性是静态属性（类属性），可以直接通过类去访问static readonly age: number = 18;；readonly开头的属性表示一个只读的属性无法修改readonly name: string = &#39;孙悟空&#39;;\nTypeScript对于类型检测的时候使用的鸭子类型\n鸭子类型: 如果一只鸟, 走起来像鸭子, 游起来像鸭子, 看起来像鸭子, 那么你可以认为它就是一只鸭子。即鸭子类型, 只关心属性和行为, 不关心你具体是不是对应的类型\n有的时候，你不能提前知道一个类型里的所有属性的名字，但是你知道这些值的特征;这种情况，你就可以用一个索引签名(index signature)来描述可能的值的类型;一个索引签名的属性类型必须是string或者是number\n\ninterface MyObject &#123;\n  [key: string]: number;\n&#125;\n\nconst obj: MyObject = &#123;\n  a: 1,\n  b: 2,\n  c: 3,\n&#125;;\n\nconsole.log(obj[&#39;a&#39;]); // 输出: 1\nconsole.log(obj[&#39;b&#39;]); // 输出: 2\nconsole.log(obj[&#39;c&#39;]); // 输出: 3\n\n2、面向对象的特点\n封装\n\n对象实质上就是属性和方法的容器，它的主要作用就是存储属性和方法，这就是所谓的封装\n\n默认情况下，对象的属性是可以任意的修改的，为了确保数据的安全性，在TS中可以对属性的权限进行设置\n\n只读属性（readonly）：\n\n如果在声明属性时添加一个readonly，则属性便成了只读属性无法修改\n\n\nTS中属性具有三种修饰符：\n\npublic（默认值），可以在类、子类和对象中修改\nprotected ，可以在类、子类中修改\nprivate ，可以在类中修改\n\n\n示例：\n\npublic – public是默认的修饰符，也是可以直接访问的\n\nclass Person&#123;\n    public name: string; // 写或什么都不写都是public\n    public age: number;\n\n    constructor(name: string, age: number)&#123;\n        this.name = name; // 可以在类中修改\n        this.age = age;\n    &#125;\n\n    sayHello()&#123;\n        console.log(`大家好，我是$&#123;this.name&#125;`);\n    &#125;\n&#125;\n\nclass Employee extends Person&#123;\n    constructor(name: string, age: number)&#123;\n        super(name, age);\n        this.name = name; //子类中可以修改\n    &#125;\n&#125;\n\nconst p = new Person(&#39;孙悟空&#39;, 18);\np.name = &#39;猪八戒&#39;;// 可以通过对象修改\n\n\n\n\nprotected\n\nclass Person&#123;\n    protected name: string;\n    protected age: number;\n\n    constructor(name: string, age: number)&#123;\n        this.name = name; // 可以修改\n        this.age = age;\n    &#125;\n\n    sayHello()&#123;\n        console.log(`大家好，我是$&#123;this.name&#125;`);\n    &#125;\n&#125;\n\nclass Employee extends Person&#123;\n\n    constructor(name: string, age: number)&#123;\n        super(name, age);\n        this.name = name; //子类中可以修改\n    &#125;\n&#125;\n\nconst p = new Person(&#39;孙悟空&#39;, 18);\np.name = &#39;猪八戒&#39;;// 不能修改\n\n\n\n\nprivate\n\nclass Person&#123;\n    private name: string;\n    private age: number;\n\n    constructor(name: string, age: number)&#123;\n        this.name = name; // 可以修改\n        this.age = age;\n    &#125;\n\n    sayHello()&#123;\n        console.log(`大家好，我是$&#123;this.name&#125;`);\n    &#125;\n&#125;\n\nclass Employee extends Person&#123;\n\n    constructor(name: string, age: number)&#123;\n        super(name, age);\n        this.name = name; //子类中不能修改\n    &#125;\n&#125;\n\nconst p = new Person(&#39;孙悟空&#39;, 18);\np.name = &#39;猪八戒&#39;;// 不能修改\n\n\n\n\n\n\nreadonly – 不希望外界可以任意的修改，只希望确定值后直接使用，那么可以使用readonly\n\nclass Person &#123;\n  readonly name: string\n  age: number\n\n  constructor(name: string, age: number) &#123;\n    this.name = name\n    this.age = age\n  &#125;\n&#125;\n\n// 类和实例之间的关系(重要)\nconst p = new Person(&quot;why&quot;, 18)\nconsole.log(p.name, p.age)\n\n// p.name = &quot;kobe&quot; 只读属性不能进行写入操作\np.age = 20\n\nexport &#123;&#125;\n\n\n\n\n\n\n属性存取器\n\n对于一些不希望被任意修改的属性，可以将其设置为private\n\n直接将其设置为private将导致无法再通过对象修改其中的属性\n\n我们可以在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的存取器\n\n读取属性的方法叫做setter方法，设置属性的方法叫做getter方法\n\n示例：\n\nclass Person&#123;\n    private _name: string;\n\n    constructor(name: string)&#123;\n        this._name = name;\n    &#125;\n\n    get name()&#123;\n        return this._name;\n    &#125;\n\n    set name(name: string)&#123;\n        this._name = name;\n    &#125;\n\n&#125;\n\nconst p1 = new Person(&#39;孙悟空&#39;);\nconsole.log(p1.name); // 通过getter读取name属性\np1.name = &#39;猪八戒&#39;; // 通过setter修改name属性\n\n\n\n\n\n\n静态属性\n\n静态属性（方法），也称为类属性。使用静态属性无需创建实例，通过类即可直接使用\n\n静态属性（方法）使用static开头\n\n示例：\n\nclass Tools&#123;\n    static PI = 3.1415926;\n    \n    static sum(num1: number, num2: number)&#123;\n        return num1 + num2\n    &#125;\n&#125;\n\nconsole.log(Tools.PI);\nconsole.log(Tools.sum(123, 456));\n\n\n\n\n\n\nthis\n\n在类中，使用this表示当前对象\n\n\n参数属性\n\n通过在构造函数参数前添加一个可见性修饰符public private protected或者readonly来创建参数属性，最后这些类属性字段也会得到这些修饰符\n\n\n\n\n\n继承\n\n继承是面向对象中的又一个特性\n\n通过继承可以将其他类中的属性和方法引入到当前类中\n\n示例：\n\nclass Animal&#123;\n    name: string;\n    age: number;\n\n    constructor(name: string, age: number)&#123;\n        this.name = name;\n        this.age = age;\n    &#125;\n&#125;\n\nclass Dog extends Animal&#123;\n\n    bark()&#123;\n        console.log(`$&#123;this.name&#125;在汪汪叫！`);\n    &#125;\n&#125;\n\nconst dog = new Dog(&#39;旺财&#39;, 4);\ndog.bark();\n\n\n\n\n\n\n通过继承可以在不修改类的情况下完成对类的扩展\n\n重写\n\n发生继承时，如果子类中的方法会替换掉父类中的同名方法，这就称为方法的重写\n\n示例：\n\nclass Animal&#123;\n    name: string;\n    age: number;\n\n    constructor(name: string, age: number)&#123;\n        this.name = name;\n        this.age = age;\n    &#125;\n\n    run()&#123;\n        console.log(`父类中的run方法！`);\n    &#125;\n&#125;\n\nclass Dog extends Animal&#123;\n\n    bark()&#123;\n        console.log(`$&#123;this.name&#125;在汪汪叫！`);\n    &#125;\n\n    run()&#123;\n        console.log(`子类中的run方法，会重写父类中的run方法！`);\n    &#125;\n&#125;\n\nconst dog = new Dog(&#39;旺财&#39;, 4);\ndog.bark();\n\n\n在子类中可以使用super来完成对父类的引用(构造函数)\n\n\n\n\n\n抽象类（abstract class）\n\n抽象类是专门用来被其他类所继承的类，它只能被其他类所继承不能用来创建实例\n\nabstract class Animal&#123;\n    abstract run(): void;\n    bark()&#123;\n        console.log(&#39;动物在叫~&#39;);\n    &#125;\n&#125;\n\nclass Dog extends Animals&#123;\n    run()&#123;\n        console.log(&#39;狗在跑~&#39;);\n    &#125;\n&#125;\n\n\n使用abstract开头的方法叫做抽象方法，抽象方法没有方法体只能定义在抽象类中，继承抽象类时抽象方法必须要实现\n\n\n\n\n\n\n3、接口（Interface）接口的作用类似于抽象类，不同点在于接口中的所有方法和属性都是没有实值的，换句话说接口中的所有方法都是抽象方法。接口主要负责定义一个类的结构，接口可以去限制一个对象的接口，对象只有包含接口中定义的所有属性和方法时才能匹配接口。同时，可以让一个类去实现接口，实现接口时类中要保护接口中的所有属性。\n\n示例（检查对象类型）：\n\ninterface Person&#123;\n    name: string;\n    sayHello():void;\n&#125;\n\nfunction fn(per: Person)&#123;\n    per.sayHello();\n&#125;\n\nfn(&#123;name:&#39;孙悟空&#39;, sayHello() &#123;console.log(`Hello, 我是 $&#123;this.name&#125;`)&#125;&#125;);\n\n\n\n\n示例（实现）\n\ninterface Person&#123;\n    name: string;\n    sayHello():void;\n&#125;\n\nclass Student implements Person&#123;\n    constructor(public name: string) &#123;\n    &#125;\n\n    sayHello() &#123;\n        console.log(&#39;大家好，我是&#39;+this.name);\n    &#125;\n&#125;\n\n\n\n\n接口支持多继承，类不支持多继承，interface IKun extends IPerson &#123;&#125;\n\n\n4、泛型（Generic）软件工程的主要目的是构建不仅仅明确和一致的API，还要让代码具有很强的可重用性。定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定），此时泛型便能够发挥作用。\n\n举个例子：\n\nfunction test(arg: any): any&#123;\n    return arg;\n&#125;\n\n\n上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的，由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的，首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型\n\n使用泛型：\n\nfunction test&lt;T&gt;(arg: T): T&#123;\n    return arg;\n&#125;\n\n\n// 1.定义函数: 将传入的内容返回\n// number/string/&#123;name: string&#125;\nfunction bar&lt;Type&gt;(arg: Type): Type &#123;\n  return arg\n&#125;\n\n// 1.1. 完整的写法\nconst res1 = bar&lt;number&gt;(123)\nconst res2 = bar&lt;string&gt;(&quot;abc&quot;)\nconst res3 = bar&lt;&#123;name: string&#125;&gt;(&#123; name: &quot;why&quot; &#125;)\n\n// 1.2. 省略的写法\nconst res4 = bar(&quot;aaaaaaaaa&quot;)\nconst res5 = bar(11111111)\n\n\n这里的&lt;T&gt;就是泛型，T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型。所以泛型其实很好理解，就表示某个类型。\n\n那么如何使用上边的函数呢？\n\n方式一（直接使用）：\n\ntest(10)\n\n\n使用时可以直接传递参数使用，类型会由TS自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式\n\n\n\n方式二（指定类型）：\n\ntest&lt;number&gt;(10)\n\n\n也可以在函数后手动指定泛型\n\n\n\n\n\n可以同时指定多个泛型，泛型间使用逗号隔开：\n\nfunction test&lt;T, K&gt;(a: T, b: K): K&#123;\n    return b;\n&#125;\n\ntest&lt;number, string&gt;(10, &quot;hello&quot;);\n\n\n使用泛型时，完全可以将泛型当成是一个普通的类去使用\n\n\n\n类中同样可以使用泛型：\n\nclass MyClass&lt;T&gt;&#123;\n    prop: T;\n\n    constructor(prop: T)&#123;\n        this.prop = prop;\n    &#125;\n&#125;\n\n\n\n\n除此之外，也可以对泛型的范围进行约束\n\ninterface MyInter&#123;\n    length: number;\n&#125;\n\nfunction test&lt;T extends MyInter&gt;(arg: T): number&#123;\n    return arg.length;\n&#125;\n\n\n使用T extends MyInter表示泛型T必须是MyInter的子类，不一定非要使用接口类和抽象类同样适用。\n\n\n\n映射类型，就是使用了PropertyKeys 联合类型的泛型;其中 PropertyKeys 多是通过keyof 创建，然后循环遍历键名创建一个类型\n\n// TypeScript提供了映射类型: 函数\n// 映射类型不能使用interface定义\n// Type = IPerson\n// keyof = &quot;name&quot; | &quot;age&quot;\ntype MapPerson&lt;Type&gt; = &#123;\n  // 索引类型以此进行使用\n  [aaa in keyof Type]: Type[aaa]\n&#125;\n\n// type MapPerson&lt;Type&gt; = &#123;\n//   readonly [Property in keyof Type]?: Type[Property]\n// &#125;\n\ninterface IPerson &#123;\n  name: string\n  age: number\n&#125;\n\n// 拷贝一份IPerson\ntype NewPerson = MapPerson&lt;IPerson&gt;\n\nexport &#123;&#125;\n\n\n在使用映射类型时，有两个额外的修饰符可能会用到:\n\n一个是readonly，用于设置属性只读\n\n一个是?，用于设置属性可选\n\n可以通过前缀–或者＋删除（移除）或者添加这些修饰符，如果没有写前缀，相当于使用了＋前缀\n\n\n\n\n\n\n\n\n\n三、类型体操0、类型体操简介\nTypeScript 的目的是为 JavaScript 添加一套类型校验系统 ，因为 JavaScript 本身的灵活性，也让 TypeScript 类型系统不得不增加更附加的功能 以适配 JavaScript 的灵活性\nTypeScript 是一种可以 支持类型编程的类型系统\n你在开发一些框架、库，或者通用性的工具，为了考虑各种适配的情况，就需要使用类型编程\nTypeScript本身为我们提供了类型工具，帮助我们辅助进行类型转换\n\n1、条件类型\n很多时候，日常开发中我们需要基于输入的值来决定输出的值，同样我们也需要基于输入的值的类型来决定输出的值的类型。\n条件类型(Conditional types）就是用来帮助我们描述输入类型和输出类型之间的关系。\nSomeType extends OtherType ? TrueType : FalseType\n\nfunction sum &lt;T extends number | string&gt;(arg1: T, arg2: T): T extends number ? number : string \nfunction sum (arg1: any, arg2: any) &#123;\n  return arg1 + arg2\n&#125;\n\nconst result = sum(1, 2)\nconst result2 = sum(&#39;1&#39;, &#39;2&#39;)\n\n\n条件类型提供了infer 关键词，可以从正在比较的类型中推断类型，然后在true分支里引用该推断结果\n\ntype CalcFnType = (num1: number, num2: number) =&gt; number\ntype YKReturnType &lt;T extends (...args: any[]) =&gt; any&gt; = T extends (...args: any[]) =&gt; infer R ? R : never\ntype CalcFnReturnType = YKReturnType&lt;CalcFnType&gt;\n\ntype ParamType &lt;T extends (...args: any[]) =&gt; any&gt; = T extends (...args: infer P) =&gt; any ? P : never\ntype CalcFnParamType = ParamType&lt;CalcFnType&gt;\n\n\n分发条件类型：当在泛型中使用条件类型的时候，如果传入一个联合类型，就会变成分发的\n\ntype toArray&lt;Type&gt; = Type extends any ? Type[] : never\n\ntype newType = toArray&lt;number | string&gt; // number[] | string[]\n\n2、类型体操Record&lt; Type &gt;\n\n以 typeof 格式快速创建一个类型，此类型包含一组指定的属性且都是必填。具体的复杂业务场景中，一般会接口 Pick 、Partial 等组合使用，从而过滤和重组出新的类型定义。\n\ntype Coord = Record&lt;&#39;x&#39; | &#39;y&#39;, number&gt;;\n\n// 等同于\ntype Coord = &#123;\n    x: number;\n    y: number;\n&#125;\n\nPartial&lt; Type &gt;\n\n构造一个Type下面的所有属性都设置为可选的类型\n\ntype Coord = Partial&lt;Record&lt;&#39;x&#39; | &#39;y&#39;, number&gt;&gt;;\n\n// 等同于\ntype Coord = &#123;\n    x?: number;\n    y?: number;\n&#125;\n\nReadonly&lt; Type &gt;\n\n构造一个Type下面的所有属性全都设置为只读的类型，意味着这个类型的所有的属性全都不可以重新赋值\n\ntype Coord = Readonly&lt;Record&lt;&#39;x&#39; | &#39;y&#39;, number&gt;&gt;;\n\n// 等同于\ntype Coord = &#123;\n    readonly x: number;\n    readonly y: number;\n&#125;\n\n// 如果进行了修改，则会报错：\nconst c: Coord = &#123; x: 1, y: 1 &#125;;\nc.x = 2; // Error: Cannot assign to &#39;x&#39; because it is a read-only property.\n\nPick\n\n构造—个类型，它是从Type类型里面挑选了—些属性Keys\n\ntype Coord = Record&lt;&#39;x&#39; | &#39;y&#39;, number&gt;;\ntype CoordX = Pick&lt;Coord, &#39;x&#39;&gt;;\n\n// 等用于\ntype CoordX = &#123;\n    x: number;\n&#125;\n\nRequired&lt; Type &gt;\n\n构造一个Type下面的所有属性全都设置为必填的类型，这个工具类型跟 Partial相反\n\ntype Coord = Required&lt;&#123; x: number, y?:number &#125;&gt;;\n\n// 等同于\ntype Coord = &#123;\n    x: number;\n    y: number;\n&#125;\n\nExclude&lt;UnionType, ExcludedMembers&gt;\n\n构造一个类型，它是从UnionType联合类型里面排除了所有可以赋给ExcludedMembers的类型\n\ntype T0 = Exclude&lt;&#39;a&#39; | &#39;b&#39; | &#39;c&#39;, &#39;b&#39;&gt; // &#39;a&#39; | &#39;c&#39;\ntype T1 = Exclude&lt;string | number | boolean, boolean&gt; // string | number\n\nExtract&lt;Type, Union&gt;\n\n构造一个类型，它是从Type类型里面提取了所有可以赋给Union的类型\n\ntype T0 = Extract&lt;&#39;a&#39; | &#39;b&#39; | &#39;c&#39;, &#39;a&#39;&gt; // &#39;a&#39;\ntype T1 = Extract&lt;string | number | boolean, boolean&gt; // boolean\n\nOmit&lt; Type Keys &gt;\n\n构造一个类型，它是从Type类型里面过滤了一些属性Keys\n\ninterface I1 &#123;\n    a: number;\n    b: string;\n    c: boolean;\n&#125;\n\ntype AC = Omit&lt;I1, &#39;b&#39;&gt;;     // &#123; a:number; c:boolean &#125; \ntype C = Omit&lt;I1, &#39;a&#39; |&#39;b&#39;&gt;  // &#123; c: boolean &#125;\n\nNonNullable&lt; Type &gt;\n\n构造一个类型，这个类型从Type中排除了所有的null、undefined的类型\n\ntype T1 = NonNullable&lt;string | null | undefined&gt;; // string\n\nParameters&lt;T extends (…args: any) &#x3D;&gt;any&gt;\n\n获取函数的全部参数类型，以 元组类型 返回\n\ntype F1 = (a: string, b: number) =&gt; void;\n\ntype F1ParamTypes = Parameters(F1);  // [string, number]\n\nConstructorParameters&lt;T extends new (…args: any) &#x3D;&gt;any&gt;\n\n获取的是 构造函数 的全部参数。关于构造函数声明，以及如何使用此 高级类型 的方式：\n\ninterface IEntity &#123;\n    count?: () =&gt; number\n&#125;\n\ninterface IEntityConstructor &#123;\n    new (a: boolean, b: string): IEntity;\n&#125;\n\nclass Entity implements IEntity &#123;\n    constructor(a: boolean, b: string) &#123; &#125;\n&#125;\n\ntype EntityConstructorParamType = ConstructorParameters&lt;IEntityConstructor&gt;; // [boolean, string]\n\nReturnType&lt;T extends (…args: any)&#x3D;&gt;any&gt;\n\n构造一个含有Type函数的返回值的类型\n\ntype F1 = () =&gt; Date;\n\ntype F1ReturnType = ReturnType&lt;F1&gt;; // Date\n\nlnstanceType&lt;T extends (…args: any)&#x3D;&gt;any&gt;\n\n构造一个由所有Type的构造函数的实例类型组成的类型\n\ntype EntityType = InstanceType&lt;IEntityConstructor&gt;; // IEntity\n\nThisParameterType&lt; T &gt;\n\n获取函数中 this 的数据类型，如果没有则返回 unknown 类型：\n\ninterface Foo &#123;\n    x: number\n&#125;;\n\nfunction fn(this: Foo) &#123;&#125;\n\ntype Test = ThisParameterType&lt;typeof fn&gt;; // Foo\n\nOmitThisParameter&lt; T &gt;\n\n移除函数中的 this 数据类型：\n\ninterface Foo &#123;\n    x: number\n&#125;;\n\ntype Fn = (this: Foo) =&gt; void\n\ntype NonReturnFn = OmitThisParameter&lt;Fn&gt;; // () =&gt; void\n\n\ntype-challenges&#x2F;type-challenges: Collection of TypeScript type challenges with online judge (github.com)\n\n\n四、知识扩展\nJavaScript有一个很长的处理模块化代码的历史，TypeScript 从2012年开始跟进，现在已经实现支持了很多格式。但是随着时间流逝，社区和JavaScript规范已经使用为名为ES Module的格式，这也就是我们所知的import&#x2F;export 语法。\n在TypeScript中最主要使用的模块化方案就是ES Module\n\n非模块\n\nJavaScript 规范声明任何没有export的JavaScript文件都应该被认为是一个脚本，而非一个模块。\n在一个脚本文件中，变量和类型会被声明在共享的全局作用域，将多个输入文件合并成一个输出文件，或者在HTML使用多个&lt; script &gt;标签加载这些文件。\n如果有一个文件，现在没有任何import 或者export，但是希望它被作为模块处理，添加这行代码：export {}**，这会把文件改成一个没有导出任何内容的模块，这个语法可以生效，无论你的模块目标是什么。\n\n内置类型导入\nimport &#123; type IFoo,type IDType &#125; from &quot;./foo&quot;\nconst id : IDType = 100\nconst foo: IFoo = &#123;\n    name:&quot;why&quot;,\n    age:18\n&#125;\n\n命名空间namespace\n\nTypeScript有它自己的模块格式，名为namespaces，它在ES模块标准之前出现。\n命名空间在TypeScript早期时，称之为内部模块，目的是将一个模块内部再进行作用域的划分，防止一些命名冲突的问题;虽然命名空间没有被废弃，但是由于ES模块已经拥有了命名空间的大部分特性，因此更推荐使用ES模块，这样才能与JavaScript保持一致\n\n类型查找\n\n.d.ts 文件，它是用来做类型的声明(declare)，称之为类型声明(Type Declaration)或者类型定义(TypeDefinition)文件。它仅仅用来做类型检测，告知typescript我们有哪些类型\ntypescript会在内置类型声明、外部定义类型声明、自己定义类型声明来查找\n\n内置类型声明\n\n内置类型声明是typescript自带的、帮助我们内置了JavaScript运行时的一些标准化API的声明文件：\n\n包括比如Function、String、Math、Date等内置类型\n也包括运行环境中的DOM APl，比如Window、Document等\n\n\nTypeScript使用模式命名这些声明文件lib.[something].d.ts\n\n可以通过target和lib来决定哪些内置类型声明是可以使用的\n\nTypeScript: TSConfig Reference - Docs on every TSConfig option (typescriptlang.org)\n\n\n外部定义类型声明\n\n方式一:在自己库中进行类型声明（编写.d.ts文件)，比如axios\n方式二:通过社区的一个公有库DefinitelyTyped存放类型声明文件\n需要自己来定义声明文件情况\n情况一:我们使用的第三方库是一个纯的JavaScript库，没有对应的声明文件;比如lodash\n情况二:我们给自己的代码中声明一些类型，方便在其他地方直接进行使用\n\n\n\ndeclare声明\n\n我们也可以声明模块，比如lodash模块默认不能使用的情况，可以自己来声明模块:\n\ndeclare module &quot;lodash&quot;  &#123;\n    export function join(args: any[]): any ;\n&#125;\n\n\n声明模块的语法: declare module ‘模块名’{}\n\n在声明模块的内部，我们可以通过export 导出对应库的类、函数等\n\n在某些情况下，我们也可以声明文件:\n\n比如在开发vue的过程中，默认是不识别我们的.vue文件的，那么我们就需要对其进行文件的声明\n比如在开发中我们使用了jpg这类图片文件，默认typescript也是不支持的，也需要对其进行声明\n\n\n\ndeclare  module &#39;*.vue&#39; &#123;\n    import&#123;DefineComponent &#125; from &#39;vue&#39;\n    const component: Definecomponent\n    \n    export default component\n&#125;\ndeclare module &#39;*.jpg&#39; &#123;\n    const src: string\n    export default src\n&#125;\n\n\ndeclare命名空间\n\ntsconfig.json\n\ntsconfig.json文件有两个作用:\n\n作用一(主要的作用)︰让TypeScript Compiler在编译的时候，知道如何去编译TypeScript代码和进行类型检测;\n比如是否允许不明确的this选项，是否允许隐式的any类型\n将TypeScript代码编译成什么版本的JavaScript代码\n\n\n作用二:让编辑器（比如VSCode）可以按照正确的方式识别TypeScript代码;√对于哪些语法进行提示、类型错误检测等等\n\n\ntsconfig.json在编译时的使用\n\n在调用tsc命令并且没有其它输入文件参数时，编译器将由当前目录开始向父级目录寻找包含tsconfig文件的目录\n调用tsc 命令并且没有其他输入文件参数，可以使用–project(或者只是-p)的命令行选项来指定包含了tsconfig.json的目录\n当命令行中指定了输入文件参数, tsconfig.json文件会被忽略\n\n\nwebpack中使用ts-loader进行打包时，也会自动读取tsconfig文件，根据配置编译TypeScript代码。\n\nTypeScript: TSConfig Reference - Docs on every TSConfig option (typescriptlang.org)\n\n\n","slug":"前端--Typescript快速入门","date":"2023-08-16T03:14:23.000Z","categories_index":"前端","tags_index":"TypeScript","author_index":"会思想的苇草i"},{"id":"23d588264c6e2698d0390789d641229e","title":"Nuxt.js快速上手","content":"\nNuxt.js快速上手\n1、为什么用nuxtvue-cli本身问题\nSEO：即搜索引擎优化是通过优化网站的内容、结构和其他相关因素，以提高网站在搜索引擎中的排名，增加有机（非付费）搜索流量的过程。SEO旨在使网站更容易被搜索引擎索引和理解，并提供与搜索用户意图相匹配的高质量内容。\n条件：\n要求是多页面（非SPA）\n包含title、description、keyword等页面描述信息\n网站内容怎么来(页面渲染前拿到数据，还是渲染后拿到数据)\n\n\n使用Vue CLI构建的Vue项目在打包后会生成一个index.html文件，这是一个单页面应用（Single Page Application，SPA）的入口文件；且不是每个页面都包含各自title、description、keyword等页面描述信息；在页面渲染后才能拿到数据，爬虫无法抓取。故vue-cli存在较差的SEO。\n\n预渲染\n渲染就是把数据放到页面上，预渲染就是在页面加载完成之前把数据放到页面\n\n流程：\n\n读取配置，获取需要预渲染的页面\n发布机模拟浏览器环境打开页面\n页面脚本触发渲染机制\n渲染出当前的页面内容\n获取当前所有的DOM结构\n生成HTML文件\n\n\n使用插件：prerender-spa-plugin\n\nvue项目中安装prerender-spa-plugin，npm install prerender-spa-plugin -S\nvue.config.js进行配置\n\n\n修改title描述关键词：vue-meta-info\n\nvue项目中安装vue-meta-info，npm install vue-meta-info -S\n页面组件进行配置：\n\nmetaInfo:&#123;\n    title:&#39;&#39;,\n    meta:[&#123;\n        name:&#39;&#39;,\n        content:&#39;&#39;\n    &#125;]\n&#125;\n\n\n优点：\n\n打包生成多页面\n可以解决每个页面单独title描述关键词\n接口数据在html生成之前就放到页面上，爬虫可以抓取到内容\n\n\n缺点：\n\n预渲染无法配置动态路由\ntitle描述关键词不能来自接口的数据\n在html页面加载之前数据过来渲染后才有html的dom结构，可能存在页面空白的情况\n\n\n应用场景：\n\n一个项目某几个页面需要做SEO\n\n\n\n服务端渲染(通过SSR)\n关于 Nuxt.js - NuxtJS | Nuxt.js 中文网\n\n服务端渲染 (SSR) | Vue.js (vuejs.org)\n\n命令 - NuxtJS | Nuxt.js 中文网\n\n流程：\n\n\n\n\n应用场景：一个项目中所有页面都需要做SEO\n\n项目解决seo的方案选择\n前后端不分离\n\n页面加载压力在后端(服务端)，安全，可以通过SSR来生成具有完整HTML内容的页面，有利于SEO\n\n\n前后端分离\n\n页面加载压力在前端(客户端)，可以构建现代化的SPA单页面，提供流畅的用户体验\n\nSPA单页面应用\n\n预渲染–一个项目某几个页面需要做SEO\n服务端渲染–一个项目中所有页面都需要做SEO\n\n\n\n\n选择哪种方案主要取决于具体项目的需求和优先级。对于需要SEO的页面，预渲染或服务端渲染是比较常用的解决方案。而对于不需要SEO或SEO要求较低的页面，可以完全依赖前端的单页面应用架构。\n\n\n\n2、Nuxt安装和使用Nuxt安装和使用nuxt安装和目录结构\n前置知识(安装node和vue脚手架)：Vue-CLI安装方法_全局安装vue-cli_Legreay的博客-CSDN博客\n\n报错处理： ‘create-nuxt-app‘ 不是内部或外部命令，也不是可运行的程序或批处理文件。海盗船长说他要扬帆起航的博客-CSDN博客\n\n安装：\n\nnpx create-nuxt-app &lt;项目名&gt;，勾选配置随后生成项目\n\n\n\n\n\ncd &lt;project-name&gt;，进入项目文件夹\n\nnpm run dev，启动项目，应用运行在 http://localhost:3000 上运行\n\n\n\nNuxt.js 会监听 pages 目录中的文件更改，因此在添加新页面时无需重新启动应用程序。\n\n目录：\n\n资源目录 assets 用于组织未编译的静态资源如 LESS、SASS 或 JavaScript。对于不需要通过 Webpack 处理的静态资源文件，可以放置在static 目录中。\n组件目录 components 用于组织应用的 Vue.js 组件。\n布局目录 layouts 用于组织应用的布局组件。\n中间件目录middleware 目录用于存放应用的中间件。\n页面目录 pages 用于组织应用的路由及视图。Nuxt.js 框架读取该目录下所有的 .vue 文件并自动生成对应的路由配置。\n插件目录 plugins 用于组织那些需要在 根vue.js应用 实例化之前需要运行的 Javascript 插件。\n静态文件目录 static 用于存放应用的静态文件，此类文件不会被 Nuxt.js 调用 Webpack 进行构建编译处理。服务器启动的时候，该目录下的文件会映射至应用的根路径 / 下。\nstore 目录用于组织应用的 Vuex 状态树 文件。 Nuxt.js 框架集成了 Vuex 状态树 的相关功能配置，在 store 目录下创建一个 index.js 文件可激活这些配置。\nnuxt.config.js 文件用于组织 Nuxt.js 应用的个性化配置，以便覆盖默认配置。\npackage.json 文件用于描述应用的依赖关系和对外暴露的脚本接口。\n别名：**~ 或 @对应srcDir，~~或@@对应rootDir**，默认情况下srcDir 和 rootDir 相同。\n\n\n\nnuxt生命周期\nNuxt 2 - Nuxt Lifecycle\n\n\n服务端生命周期：\n\nnuxtServerInit(store,context) {} – 在服务端渲染期间调用，可以用于初始化 Vuex 状态\n参数1：vuex上下文\n参数2：nuxt上下文\n\n\n\n//\tstore/index.js\nexport const state = &#123;\n    token: &#39;&#39;\n&#125;\n\nexport const mutations = &#123;\n    setToken(state,token) &#123;\n        state.token = token;\n    &#125;    \n&#125;\n\nexport const actions = &#123;\n    nuxtServerInit(store,context) &#123;\n        store.commit(&#39;setToken&#39;,&#39;123456&#39;)\n        console.log(store,&#39;nuxtServerInit&#39;);\n    &#125;\n&#125;\n\n\nRoute Middleware – 类似于vue中的导航守卫，可以在每次路由切换之前执行一些共享的逻辑，比如身份验证、路由拦截或其他自定义操作等\n\n//全局 nuxt.config.js进行配置，创建文件夹并创建文件\n//\tnuxt.config.js\nrouter:&#123;\n    middleware:&#39;auth&#39;\n&#125;\n//\tmiddleware/auth.js\nexport default function () &#123;\n    console.log(&#39;auth middleware&#39;);\n&#125;\n\n//页面 页面中进行配置，创建文件夹并创建文件\n//\tpage/index.vue\n&lt;script&gt;\nexport default &#123;\n  middleware: &#39;auth&#39;,\n  //第二种写法 middleware()&#123;&#125;\n&#125;\n&lt;/script&gt;\n//\tmiddleware/auth.js\nexport default function () &#123;\n    console.log(&#39;auth middleware&#39;);\n&#125;\n\n\nvalidate({params,query}){} – 校验url参数\n\n//\tpages/index.vue\nvalidate(&#123;params,query&#125;)&#123;\n    console.log(&#39;validate&#39;);\n    return /^\\d+$/.test(query.id);\n&#125;\n\n\nasyncData({params,query}){} – pages中的页面请求数据**(也只有pages目录中的页面组件才可以去用，asyncData中没有this)**，在组件渲染之前调用，用于在服务端或客户端获取异步数据，并将数据合并到组件的数据中\n\n//\tpages/index.vue\nasyncData(&#123;params,query&#125;)&#123;\n    console.log(&#39;asyncData&#39;);\n&#125;,\n\n\nfetch({app,store,params}){} – 在组件渲染之前调用，用于在服务端或客户端获取异步数据。与 asyncData 不同的是，fetch 方法不会将数据合并到组件的数据中，而是通过返回一个 Promise 对象来处理异步数据。fetch有this。\n\n//\tpages/index.vue\nfetch(&#123;app,store,params&#125;)&#123;\n    console.log(&#39;fetch&#39;);\n&#125;,\n\n服务端和客户端共有的生命周期\n\nbeforeCreate()&#123;\n    console.log(&#39;beforeCreate&#39;);\n&#125;,\ncreated()&#123;\n    console.log(&#39;created&#39;);\n&#125;,\n\n客户端生命周期\n\n和vue中生命周期的一模一样\n\nnuxt路由自动生成\n\n路由 - NuxtJS | Nuxt.js 中文网\n\nNuxt.js 依据 pages 目录结构自动生成 vue-router 模块的路由配置。\n\n页面之间使用路由，使用&lt; nuxt-link &gt;标签。\n\n\n//\tpages/index.vue\n&lt;nuxt-link :to=&quot;&#123;name:&#39;list&#39;,query:&#123;id:1&#125;,params:&#123;id:2&#125;&#125;&quot;&gt;列表页&lt;/nuxt-link&gt;\n\n使用router.js\n\n下载：@nuxtjs&#x2F;router，npm i @nuxtjs/router -S\n\n下载完成后在nuxt.config.js的modules模块进行配置\nmodules:[\n    &#39;@nuxtjs/router&#39;\n],\n\n\n把router文件放入nuxt项目根目录，必须是router.js\n\n修改router.js的内容\n\nnuxtjs&#x2F;router返回的内容和vue有所不同\nimport Vue from &#39;vue&#39;\nimport Router from &#39;vue-router&#39;\n\nimport MyPage from &#39;~/components/my-page&#39;\n\nVue.use(Router)\n\nexport function createRouter() &#123;\n  return new Router(&#123;\n    mode: &#39;history&#39;,\n    routes: [\n      &#123;\n        path: &#39;/&#39;,\n        component: MyPage\n      &#125;\n    ]\n  &#125;)\n&#125;\n\n\n\nnuxt导航守卫router.js\n\nvue-cli中怎么用，nuxt中就怎么用，几乎一模一样\n\nnuxtjs\n\n中间件：middleware\n\n全局\n局部\n\n\n插件：plugins\n\n全局\n\n\n\n\nnuxt.config.js进行配置\n\n  plugins:[\n      &#39;~/plugins/router.js&#39;\n  ],\n\n\n新建plugins&#x2F;router.js\n\nexport default (&#123;app&#125;=&gt;&#123;\n    app.router.beforeEach((to,from.next)=&gt;&#123;\n        console.log(to);\n        next();\n    &#125;)\n&#125;\n\nnuxt Vuex状态树\n对于大型复杂项目而言，使用状态树(store)来管理状态(state)十分有必要，所以Nuxt.js内核实现了Vuex\n使用：Nuxt.js 会尝试找到 src 目录（默认是应用根目录）下的 store 目录，如果该目录存在，它将做以下的事情：\n引用 vuex 模块\n将 vuex 模块 加到 vendors 构建配置中去\n设置 Vue 根实例的 store 配置项\n\n\n具体使用同Vuex，可参考Vuex 状态树 - NuxtJS | Nuxt.js 中文网\n顺便附上Vuex官网教程，开始 | Vuex (vuejs.org)\n\n\n3、Nuxt配置项\nNuxt.js 默认的配置涵盖了大部分使用情形，可通过 nuxt.config.js 来覆盖默认的配置。\n以下配置修改默认中nuxt.config.js改动\n\nnuxt配置之head\n全局\n\nexport default &#123;\n  head: &#123;\n    title: &#39;demo&#39;,\n    meta: [\n         &#123;hid:&#39;description&#39;,name:&#39;description&#39;,content:&#39;xxx&#39;&#125;,\n        &#123;hid:&#39;keywords&#39;,name:&#39;keywords&#39;,content:&#39;xxx&#39;&#125;\n    ],\n  &#125;,\n&#125;\n\n\n局部\n\nhead()&#123;\n    retrun &#123;\n        title: &#39;demo&#39;,\n        \tmeta: [\n             &#123;hid:&#39;description&#39;,name:&#39;description&#39;,content:&#39;xxx&#39;&#125;,\n            &#123;hid:&#39;keywords&#39;,name:&#39;keywords&#39;,content:&#39;xxx&#39;&#125;\n        ],\n    &#125;\n&#125;\n\nnuxt配置之css\n下载保存reset.css\n\ncss: [\n    &#39;~/static/reset.css&#39;\n    &#39;@/assets/css/main.scss&#39;\n],\n\n\n注意：关于sass这里引用官网原文\n\n\n\nnuxt配置之plugins\nnuxt项目不像vue项目，没有main.js文件，所以直接在nuxt.config.js中引入文件。plugins 属性配置的所有插件会在 Nuxt.js 应用初始化之前被加载导入。\n\nplugins: [\n    &#39;~/plugins/aaa.js&#39;,\n    &#39;~/plugins/element.js&#39;\n],\n\nnuxt配置之modules和数据交互\nmodules 是 Nuxt.js 扩展，可以扩展它的核心功能并添加无限的集成\nnpm install @nuxtjs/axios -S和npm install axios -S区别在于前者可以直接使用而不需要引入，@nuxt&#x2F;***是Nuxt.js团队提供的官方模块\n\nnuxt配置代理\n安装 npm install @nuxtjs/axios @nuxtjs/proxy -S\nnuxt.config.js进行配置\n\n//\tnuxt.config.js\nmodules: [\n    &#39;@nuxtjs/axios&#39;,\n    &#39;@nuxtjs/proxy&#39;\n],\naxios:&#123;\n    proxy:true,\n    retry:&#123;retries:3&#125;,\n    baseUrl:process.env._ENV == &#39;prod&#39;?&#39;dev&#39;\n&#125; \nproxy:&#123;\n    &#39;/api&#39;:&#123;\n        target:&#39;http://localhost:4000&#39;,\n        pathRewrite:&#123;\n            &#39;^/api&#39;:&#39;&#39;,\n        &#125;\n    &#125;\n&#125;\n\nnuxt配置之loading\n在页面切换的时候，Nuxt.js 使用内置的加载组件显示加载进度条。可以定制它的样式，禁用或者创建自己的加载组件。\n\n//\tnuxt.config.js\nloading: false\n\n//\tnuxt.config.js\nmodules: [\n    &#39;@nuxtjs/axios&#39;,\n    &#39;@nuxtjs/proxy&#39;\n],\naxios:&#123;\n    proxy:true,\n    retry:&#123;retries:3&#125;,\n    baseUrl:process.env._ENV == &#39;prod&#39;?&#39;dev&#39;\n&#125; \nproxy:&#123;\n    &#39;/api&#39;:&#123;\n        target:&#39;http://localhost:4000&#39;,\n        pathRewrite:&#123;\n            &#39;^/api&#39;:&#39;&#39;,\n        &#125;\n    &#125;\n&#125;\n\nnuxt配置之loading\n在页面切换的时候，Nuxt.js 使用内置的加载组件显示加载进度条。可以定制它的样式，禁用或者创建自己的加载组件。\n\n//\tnuxt.config.js\nloading: false\n\n","slug":"前端--Nuxt.js快速上手","date":"2023-08-14T06:09:57.000Z","categories_index":"前端","tags_index":"Nuxt.js","author_index":"会思想的苇草i"},{"id":"018c91442287589961fe36016761790e","title":"计算机信息安全概论概述","content":"\n信息安全概论Chapter-1: 信息安全概论信息 (Information)\n\n一种资源和交流的对象，具有 普遍性、共享性、增值性、可处理性 和 多效用性，对人类社会发展具有特别重要的意义。\n\n信息系统 (Information System)\n\n由计算机及其相关和配套的设备、设施（含网络）构成的，按照一定的应用目标和规则对信息进行采集、加工、存储、传输、检索等处理的人机系统。\n\n信息安全事件 (Information Security Incident)\n\n由于 自然 或者 人为 以及 软硬件本身缺陷或故障 的原因，对信息系统 造成危害，或对社会造成负面影响的事件。\n\n信息安全保障 (Ensuring Information Security)\n\n保护信息系统和信息网络中的信息资源免受各种类型的威胁、干扰和破坏。\n措施:查找、防范、阻断引起危害和影响的潜在威胁。\n\n信息安全\n\n信息系统的硬件、软件及系统中的数据受到保护，不受偶然的因素或者恶意的行为而遭到破坏、更改、泄露，系统连续可靠正常地运行，信息服务不中断。\n\n信息安全事件分类\n\n有害程序事件（Malware）：是指 蓄意制造、传播有害程序，或因受到有害程序影响而导致的信息安全事件(计算机病毒、蠕虫、木马)\n\n网络攻击事件：通过网络或其他技术手段，利用信息系统的种种缺陷，或使用暴力手段对信息系统 实施攻击，造成信息系统异常或对信息系统当前运行造成潜在危害的信息安全事件(漏洞攻击、网络钓鱼)\n\n信息破坏事件：通过网络或其他技术手段，造成信息系统中的信息被篡改、假冒、泄露、窃取等而导致的信息安全事件(信息窃取、信息丢失)\n\n信息内容安全事件：利用信息网络发布、传播，危害国家安全、社会稳定和公共利益的内容的安全事件(违反宪法，网络舆情 –中介性 社会事件[直接性、突发性、偏差性])\n\n设备设施故障：由于信息系统自身故障或外围保障设施故障而导致的信息安全事件，以及 人为 的使用 非技术手段，有意或无意的造成信息系统破坏 而导致的信息安全事件(软硬件故障、外围保障设施故障)\n\n灾害性事件：由于 不可抗力 对信息系统造成 物理破坏 而导致的信息安全事件(水灾、地震)\n\n其他事件：前述6个基本分类之外的信息安全事件\n\n\n\nChapter-2: 信息安全保障体系信息安全范畴\n\n信息自身\n信息载体\n信息环境\n\n信息安全属性\n\n保密性（机密性）[信息保密]\n完整性 [数据完整]\n可用性 [有权访问和使用]\n鉴别性（可认证性）[身份的真实性]\n不可否认性（不可抵赖性）[防止用户否认]\n可靠性 [稳定、正确的信息服务]\n可追究性 [实体对其行为负责]\n可控性 [防止非法利用]\n保障 [实施过程保证]\n\n信息安全保障体系结构\n\n信息安全保障体系包括人、政策（包括法律、法规、制度、管理)和技术三大要素\n主要内涵是 实现 保密性、鉴别性、完整性、可用性等 各种安全属性。\n目标：保证信息和信息系统的安全性。\n\n信息安全防御模型\n传统的信息安全模型(被动防御)&#x2F;主动信息安全防御模型\n\n**风险评估 (Evaluation)**：需要对信息系统具有全面的了解\n**制定策略 (Policy)**：安全策略是安全模型的核心\n**实施保护 (Protection)**：采用一切可能的方法、技术和手段防止信息及信息系统遭受安全威胁，减少和降低遭受入侵和攻击的可能\n**监测 (Detection)**：在系统实施保护之后根据安全策略对信息系统实施监控和检测\n**响应 (Reaction)**：把系统调整到安全状态\n**恢复 (Restoration)**：恢复可以分为 系统恢复(修补系统缺陷) 和 信息恢复(数据恢复) 。\n\n信息安全技术原则\n安全是相对的，同时也是动态的，没有绝对的安全！\n\n最小化原则：受保护的敏感信息 只能在一定范围内被共享\n\n分权制衡原则：在信息系统中，对所有权限应该进行适当地划分\n\n安全隔离原则：将信息的主体与客体分离，按照一定的安全策略，在可控和安全的前提下实施主体对客体的访问\n\n\n\nChapter-3: 密码技术概述古典密码与现代密码\n\n古典密码侧重于加密算法的精心设计与保密性，而现代密码侧重于对密钥的保密，公开加密所用的算法。\n\n置换密码 or 替代密码；置换密码顾名思义，就是单纯的置换明文为密文；凯撒密码即为典型的替代法加密，可以被轻易破解\n\n\n现代密码再以密钥细分就会分为对称加密和非对称加密。\n\n对称加密，就是加密时和解密时的密钥是一样的；而非对称加密则是加密密钥和解密密钥不同。\n\n1949年香农发表论文《保密系统的通信理论》标志着现代密码学的诞生\n\n\n\n\n数据保密通信模型\n\n明文 (Plain text)：需要安全保护的原始信息&#x2F;数据，常记为 m 。所有明文构成 明文空间，常记为 M。\n密文 (Cipher text)：原始数据经加密变换得到的数据，常记为 c。所有密文构成 密文空间，常记为 C。\n加密&#x2F;解密\n密钥 (Key)：用于加解密的秘密信息。所有密钥构成 密钥空间，常记为 K。\n公众信道：数据公开传递的信道，也称公共信道。\n秘密信道：代指安全信道，用于传递密钥。\n密码体制 (Cipher System)：加密可以看做是 将密钥与明文混合变换 的过程解密是 从密文中剥离密钥 的过程，因此也称脱密过程。\nKerchhoffs假设：一个密码体制，对于所有密钥，加密和解密算法迅速有效。密码体制的 安全性 不应该依赖于算法的保密，而仅依赖密钥的保密。\n\n对称密码体制与公钥密码体制\n\n对称密码体制：加密与解密使用相同密钥(单钥)\n分组密码：明文划分成若干等长的块–分组，再分别对每个分组进行加密(设计思想：扩散和混淆)\n序列密码：把明文以位或字节为单位进行加密\n\n\n公钥密码体制：加密与解密使用不同密钥(双钥)\n借助某个特殊的数学问题，如数论中的**大数分解(RSA体制)、离散对数(EIGmal密码体制)**等数学难解问题,构造单向函数，\n\n\n\n数字签名\n\n数字签名必须使用某些对于签名者来讲具有唯一性 的信息，以 防止其伪造和否认。\n\n数字签名的 生成与验证 都必须是 相对容易 的，且在出现纠纷时可通过可信的第三方TTP仲裁 。\n\n公钥密码技术为数字签名提供了理论依据:公钥密码体制中的私钥是私有的、保密的，其他人无法获得，可作为持有者的唯一性信息\n\n数字签名机制使用公钥密码技术，使消息接收者相信收到的消息来自声称的 消息发送者（消息主体的识别与鉴别——鉴别性保护），并信任该消息（消息被正确地传递，没有被篡改——完整性保护)，同时消息签名者不能否认签发了该消息（不可否认性保护)。\n\n密码学哈希(Hash)函数：密码学哈希函数将任意长度输入转换为特定长度输出，典型的算法如MD5、SHA、SHA-256等。\n\n数字签名可以实现 3 个安全属性的保护\n\n鉴别性:实体和消息的真实性认证\n完整性\n不可否认性\n\n\n认证也称鉴别(Authentication)，是证明某种真实性、合法性、有效性或正确性的过程。\n\n实体身份的真实性\n消息的真实性\n\n\n\n计算复杂理论\n\n安全的三个层次：\n\n理论安全性：无限计算资源也无法破译\n可证明安全性：破译密码代价必读求解某个已知的数学模型\n计算安全性：使用最好算法和现有资源也不可能在合理时间完成破译一个密码系统\n\n\n密码分析所需的计算量是密码体制安全性的衡量指标\n\n用确定算法可以在多项式时间内求解的问题称为P问题\n\n多项式时间内可用非确定性算法求解的问题称为NP问题\n\n\n密码分析\n\n惟密码攻击：破译者已知的东西只有加密算法和待破译的密文\n已知明文攻击：破译者已知的东西包括加密算法和多个明-密文对\n选择明文攻击：破译者除了知道加密算法外，还可以选定明文消息，并可以知道该明文对应的加密密文\n选择密文攻击：知道选择的密文和对应的明文\n选择文本攻击：选择呢明文攻击和选择密文攻击的结合\n\n\nChapter-4: 对称密码技术古典密码\n\n古典代换密码(将明文字母 替换 成其他字母、数字或符号的方法，典型：凯撒密码) \n凯撒密码：共有25个密钥\n加密算法：c&#x3D;E(p)&#x3D;(p+k)mod(26)\n解密算法：p&#x3D;D(c)&#x3D;(c−k)mod(26)\n\n\n代换密码：不是简单有序地字母移位，任意地打乱字母的顺序，密钥数目：26！\n仿射密码：在移位密码、代换密码和仿射密码体制中明文中所有字母的加密都使用同一个映射，这种密码体制被称为单表代换密码\n维吉尼亚密码(Vigenere)：在明文消息中采用不同的代换表\n一次一密(Vernam密码)：随机密钥，理论上不可破，实际上不可行\n希尔(Hill)密码：单表代换密码体制中，明文中单字母出现的频率分布与密文中相同。在维吉尼亚密码和希尔密码体制中，将明文进行分组，对每组成组替换，使得同一个明文字母可对应不同的密文，改变了单表代换密码中密文的唯一性。这种密码体制称为多表代换密码。\n转轮密码：现代密码之前最广泛使用的复杂密码\n\n\n古典置换密码(保持明文的所有字符不变，只是利用置换打乱了明文字符的位置和次序。也就是改变了明文的结构，不改变明文内容。典型：栅栏密码、行移位密码等)\n\n数据加密标准DES\n\nDES是一种分组密码算法，加密和解密使用相同的密钥。\nDES的分组长度为64比特位。\n使用64比特密钥(其中包括8比特奇偶校验位)，密钥通过扩展后产生16个子密钥。经过16轮对明文分组的代换和置换\nS盒是DES的核心，也是DES算法最敏感的部分，所有替换都是固定的，甚显神秘。\n\n高级加密标准AES\n\nAES由多轮操作组成，轮数由分组和密钥长度决定。\nAES加解密基本流程：首先执行一次初始密钥混合:明文字节矩阵与初始主密钥矩阵直接相加（异或）。然后按规定次数执行轮变换。\nAES轮变换步骤：\n字节替换：状态矩阵中每个字节通过查S盒进行替换,实现密码算法的非线性运算，目的是为了得到一个非线性的代换密码\n行位移：1、2、3行以字节为单位分别按1、2、3字节的偏移量做循环左移位，\n列混合：将状态矩阵每一列看作GF(2 ^ 8)上的多项式与一个固定多项式a(x)模x ^ 4+1相乘，两者目的是获得明文消息分组在不同位置上的字节混合\n轮密钥加：一个简单地按位异或操作，给出了消息发布所需的秘密随机性\n\n\n密钥扩展：\n全部轮密钥的比特总数等于分组长度乘轮数加1。例如128比特分组长度和10轮迭代，共需1408比特的密钥。\n将初始密钥扩展成一个扩展密钥。\n轮密钥按下述方式从扩展密钥中选取:第一个轮密钥由开始Nb个字组成，第二个轮密钥由接下来的Nb个字组成如此继续下去。\n\n\nAES解密操作\n逆字节替换:翻转S盒\n逆行移位:右循环字节行移位\n逆列混合:a^-1(=(0b)x^3+(0d)x^2+(09) xt(0e)\n轮密钥加:异或运算\n\n\nIDEA算法：创新–混合模运算的使用\nBlowfish算法：分组加密算法，速度比DES快。依赖密钥的S盒和复杂的密钥调度。\nRC5&#x2F;RC6算法：创新–数据相关的循环移位思想\n流密码算法RC4：由主密钥（通信双方共享的一定长度密钥)按一定密钥调度算法产生任意长度伪随机密钥字节流(以字节为单位），与明文流按字节异或生成密文流，解密时密文流与相同的密钥流按字节异或恢复出明文字节流。\n\n分组密码算法工作模式\n\n电子密码本（ECB：Electronic Code Book）模式\n优–加密、解密可以并行处理\n\n\n密文分组链接（CBC：Cipher Block Chaining）模式\n使分组之间有关联性，增加破解的难度\n\n\n密文反馈（CFB：Cipher-FeedBack）模式\n输出反馈（OFB：Output-FeedBack）模式\n计数（CTR：Counter mode）模式\n\n\nChapter-5: 公钥密码技术RSA公钥密码算法\n\nRSA是一个经典公钥密码系统，RSA既可以用于加密也可以用于 签名 ，应用广泛，RSA算法包括公钥和私钥两个密钥，公钥可以让任何人知道并用于加密消息，使用公钥加密的消息只能使用对应的私钥解密\nRSA公钥密码系统包括 密钥产生 、 加密 和 解密 3个内容\nRSA的安全性依赖与两个数学问题：RSA问题 和 大整数分解问题\nRSA体制安全性分析：穷举分析、因数分解分析、参数选取不当造成的攻击、选择密文攻击、共模攻击、小e攻击\n\nDiffie-Hellman密钥协商机制 \n\nD-H密钥协商机制，可以实现在不安全信道上为两个实体建立一个共享秘密，协商的秘密可以作为后续对称密码体制的密钥使用\n\nElGamal公钥密码体制\n\nElGamal公钥密码算法是一种类似于D-H密钥协商机制的公钥密码，由EIGamal在1985年提出，在PGP等密码系统得到实际应用。ElGamal公钥算法定义在任意循环群G上，其安全性依赖于计算循环群G上离散对数问题的困难性。\n\n椭圆曲线密码体制\n\nChapter-6: 密钥管理密钥管理概述\n\n对称密码体制：以密钥分发中心 KDC (Key Distribution Center) 作为 可信第三方 TTP(Trusted Third Party)\n公钥密码体制：授权中心 CA (Certification Authority)\n密钥管理就是对密钥 从产生到销毁的全过程进行安全控制，涵盖了密钥的设置、产生、分发、存储、装入、使用、备份、恢复、提取、更新、吊销、销毁以及保护等一系列的内容和过程，其 核心是确保密钥的安全性不受威胁。\n密钥管理的一些基本要求如下：\n密钥产生：密钥生成算法及其实现是保证密钥质量的根本，密钥产生应具有较好的随机性\n密钥长度：决定了 密钥空间大小，也决定了 密码强度\n密钥存储：软保护(口令加密文件)；硬保护(智能卡、USB Key等存储设备)\n密钥更新：密钥应有 有效期\n密钥撤销：密钥丢失或遭受攻击时要 及时更新 密钥\n会话密钥(Session Key) ：一次性使用的即时密钥\n\n\n对称密钥管理与分发：在有 N 个用户的对称密码系统中，如果要求两两共享密钥，则需要的密钥总数为 N(N-1)&#x2F;2。\n密钥的层次化使用\n密钥分类与层次化管理：提高安全性\n密钥分类举例：主密钥MK(在密钥层次结构的 最高层；一般用人工方式建立)，密钥确认密钥KCK(产生消息认证码)，密钥加密密钥KEK()加密其他密钥，临时密钥TK(加密用户的通信数据)\n\n\n\n公钥基础设施 PKI\n\nPKI 是指使用 公钥密码技术 实施和提供安全服务的、具有普适性的安全基础设施，是信息安全领域核心技术之一\n\nPKI 通过 权威第三方机构 —— 授权中心CA 以签发 数字证书 的形式 发布 有效实体的 公钥。\n\n数字证书(Certificate) 是一种特殊的电子文档（也称电子凭证)，包括 公钥持有者(称为主体) 的信息及其公钥、有效期、使用方法等信息。数字证书将证书持有者的身份及其公钥绑定在一起。\n\n数字证书的完整性保护\n\n持有者身份与其公钥的绑定关系不能篡改\n\n解决办法：由CA对数字证书进行 数字签名\n\n\n\nPKI 是一种 由权威机构签发数字证书 和 管理数字证书通信实体使用数字证书 的方法、过程和系统。\n\nPKI 安全服务的 实现与应用分离 是作为 基础设施 的重要特征\n\nPKI 的功能包括 数字证书管理 和 基于数字证书的服务\n\n证书管理：证书申请、证书生成、证书发布、证书撤销、证书更新、证书备份与恢复\n\nPKI 服务：确立证书持有者可依赖的数字身份，通过数字身份与密码机制相结合，提供认证、授权和数字签名等服务。保密服务、完整性服务、认证服务、不可否认服务、时间戳\n\nPKI 的交叉认证：不同 PKI 系统的互联互通和业务整合。在PKI之间建立信任关系，实现一个PKI的用户可以验证另一个PKI的用户证书\n\n不同PKI的CA之间相互签发交叉认证证书：证书的签发者是一个CA，证书的主体是另一个CA，在不同安全域之间建立信任关系。PKI 体系结构\n\n一个完整的PKI系统由 认证中心CA 、密钥管理中心 KMC、注册机构RA、目录服务、证书应用服务 以及 安全认证应用软件 等部分组成。\n\n大规模的PKI可以有 多个CA，并按层次结构组织成树型，形成基于顶级CA(根CA)的信任链。\n\n\n数字证书\n\n数字证书是实体公钥的载体，用以实现公钥与实体身份的绑定。\n数字证书结构：版本号，序列号，签名算法标识，颁发者名称，有效期，主体名称，主体公钥，颁发者&#x2F;主体唯一，扩展项\n数字证书结构：签名算法标识符，颁发者签名\n私钥的存储与使用\n\n基于PKI的典型应用\n\n基于PKI的网上银行\n基于PKI的电子商务应用\n\n\nChapter-7: 安全协议安全协议概述\n\n协议是指在对等实体 (两方或多方)之间为完成某项任务所执行的一系列确定的步骤，是协议实体必须共同遵循的一套规则。协议步骤（或规则）是 明确定义 的。协议必须是 完整 的\n为了 实现特定安全目标，使用 密码技术 在网络和分布式系统中提供各种安全服务的协议，称为安全协议或密码协议\n两类最基本的安全协议： 实体认证协议 和 密钥协商协议\n网络协议栈各层上的安全协议：\n\n\n\n\n层级\n协议\n\n\n\n应用层\nHTTPS、SSH、PGP、Kerberos、SET、MIME\n\n\n传输层\nTCP、UDP、SSL、TLS、SOCK5\n\n\n网络层\nIPSec\n\n\n数据链路层\nPPP-PAP&#x2F;CHAP、WEP\n\n\n物理层\n物理层安全\n\n\n\n数据链路层安全协议：\n\nPPP-PAP：口令认证协议\n\nPAP认证口令以明文文本形式在链路上传输,不能防止窃听重放等攻击，是一种弱认证方法。\n\n质询握手认证协议，PPP-CHAP\n\nWEP：有线网等同保密\n\n\n\n应用层安全协议：\n\nMIME&#x2F;S-MIME：多用途网际邮件扩充协议\nPGP：用于电子邮件、存储数据加密和数字签名的开源应用程序\nSET：电子支付安全模型\n\n\n\n虚拟专用网协议\n\nVPN是建立在公共网络(如Internet)上的专用网络，通过在两个系统之间建立安全的信道（也称隧道）来实现重要数据的安全传输。\nVPN采用安全隧道技术将传送的原始数据经过加密和协议封装后，嵌套到网络传输单元中传输,实现对传输信息的保护。\nPPTP：点对点隧道协议，PPTP是在PPP协议的基础上开发的一种增强型安全协议，它使用一个TCP上的控制隧道和一个封装PPP数据包的通用路由封装GRE隧道\nL2TP：第二层隧道协议，只要求隧道媒介提供面向数据包的点对点的连接\nIPSec：IP层安全协议，工作在IP层，提供对IP父子进行加密和认证的功能\nIPSec定义了两类保护IP报文的协议：认证报头，有效载荷封装\nIPSec定义了两种工作模式：传输模式，隧道模式\n安全网关-安全网关：隧道模式\n主机-主机：隧道模式\n主机-安全网关：隧道模式\n\n\n\n\n\n传输层安全协议\n\nTLS协议是一个用于 Internet 上实现保密通信的安全协议\nTLS 的设计目标如下：\n密码安全性：TLS用于在通讯实体间建立安全连接\n互操作性：独立开发者可以使用TLS开发应用程序，而无需交换程序的代码\n扩展性：提供一种框架，便于加入新的公钥、对称密码\n相对效率性：密码操作是高 CPU 敏感的，尤其是公钥密码操作，TLS提供了 会话缓存机制 以减少建立的连接数，此外尽量减少网络活动\n\n\nTLS 体系结构：TLS 位于 TCP 层与应用层之间，对应用层透明，在可靠传输协议TCP之上建立一个可靠的端到端安全服务，为两个通信实体之间提供保密性和完整性保护\nTLS 协议分为两层\n底层：记录协议层\n上层：握手协议层\n\n\nTLS 记录协议层：\nTLS 记录协议建立在可靠的 TCP 协议上，为高层协议提供数据封装，实现压缩&#x2F;解压、加密&#x2F;解密、计算&#x2F;验证MAC等操作。\nTLS 记录协议要使用TLS握手协议协商的密码算法和密钥对上层数据加密，实现保密性。同时使用 HMAC 实现传输消息的完整性\n\n\nTLS 握手协议层：\n包含3个子协议：TLS 握手协议、TLS 密码规格变更协议、TLS 报警协议\nTLS 握手协议层负责在客户与服务器间进行身份认证、协商加密算法和密钥\nTLS 协议使用 对称密码 体制加密传输数据，使用 公钥密码 体制进行身份认证 和 交换加密密钥\n\n\nTLS 中有两个重要概念如下：\nTLS 连接（connection)：一个连接是一个提供一种合适类型服务的传输过程，TLS连接是端到端的关系，连接是暂时的，每一个连接和一个会话关联\nTLS 会话 (session）：1 个 TLS 会话 是在客户与服务器之间的一个关联会话由握手协议创建，定义一组可供多个连接共享的密码安全参数。会话用以避免为每一个连接提供新的安全参数所需的协商代价\n\n\n会话的状态\n当前读状态\n当前写状态\n预备读状态\n预备写状态\n\n\n\n\nChapter-8: 无线局域网安全WLAN及其安全需求\n\nWLAN 的基本特点：采用射频无线电信号传输，通信链路具有开放性；容易遭受窃听和攻击，网络安全问题突出。\n\nWLAN 的工作模式\n\n自组织模式(Ad Hoc)：无线网络终端(STA) 点对点通信，自组织构建无线通信网络\n基础设施模式：无线网络终端通过访问点AP(Access Point)相互通信，并实现与有线网络连接通信\n\n\nWLAN 的安全问题\n\n接入控制：只有合法实体才能访问WLAN及相关资源\n链路保密通信：无线链路通信应该确保数据的保密性、完整性及数据源的可认证性\n\n\nWLAN的安全机制\n\n实体认证、链路加密、完整性保护、数据源认证……\n\n\nWLAN安全保护方法分类\n\n采用非密码技术的接入控制机制\n采用基于密码技术的安全机制\n\n\n非密码技术的接入控制机制举例\n\n服务集识别码 SSIb (Service Set Identifier)认证\n地址过滤机制\n定向天线或控制传输功率\n\n\n\n有线等同保密协议 WEP\n\n有线等同保密协议 WEP: Wired Equivalent Privacy\n企图提供与有线网等同的数据保密性\n采用流密码算法 RC4，基于共享密钥实现实体认证和数据保密通信\n\n\nWEP 定义了两种认证机制\n开放系统认证(Open System Authentication)：实际上为空认证\n共享密钥认证(Shared Key Authentication)：实现基于共享密钥的质询——响应握手协议。\n\n\nWEP的安全性\nRC4 密码作为一种流密码，其安全程度 取决于 密钥流的随机程度流密码密钥流的随机程度并不高，在安全上存在一定风险\n弱IV与密钥的特定字节有着潜在的联系，每个弱IⅣ都会泄露密钥特定字节的信息。\n802.11的帧格式也容易泄露部分密钥特定字节的信息。\n\n\n\n健壮网络安全RSN\nWLAN鉴别与保密基础结构WAPI\n\nGB15629.11中定义了WLAN鉴别与保密基础结构WAPI，包括两个部分：\nWLAN 鉴别基础结构 WAI (WLAN Authenticatiot Infrastructure)\nWLAN 保密基础结构 WPI (WLAN Privacy Infrastructure)\n\n\nWAPI使用椭圆曲线ECC公钥密码算法，以及国家密码办指定的商用对称密码算法，分别实现对WLAN实体的鉴别和传输数据加密保护。\nWAI采用公钥密码体制，重新定义了数字证书结构实现实体身份与公钥的绑定，实现实体间认证和密钥协商，且证书格式与X.509不兼容。\n\n\nChapter-9: 网络安全技术网络安全技术概述\n\n构建网络安全防御体系，除了必要的人、制度、机制、管理等方面保障，还要依赖于各种网络安全技术。\n扫描技术:发现内部网络安全薄弱环节，进行完善保护\n防火墙技术:在内部与外部网络衔接处，阻止外部对内部网络的访问，限制内部对外部网络的访问等\n入侵检测系统:发现非正常的外部对内部网络的入侵行为，报警并阻止入侵行为和影响的进一步扩大\n隔离网闸技术:在物理隔离的两个网络之间进行安全数据交换\n\n\n\n网络扫描技术\n\n目的是发现网络中的设备及系统是否存在安全漏洞\n主机扫描：目的是确定在目标网络上的主机是否可达\n端口扫描：目的是发现目标主机的开放端口，包括网络协议和各种应用监听的端口\n\n\n\n网络防火墙技术\n\n网络防火墙是建立在内部网络(Intranet)与外部网络(Extranet)之间的安全网关(Gateway)。\n内部网络与外部网络之间所有的网络数据流都必须经过防火墙\n只有符合安全策略的数据流才能通过防火墙\n防火墙自身应具有非常强的抗攻击免疫力\n防火墙的功能\n防火墙是网络安全的屏障\n防火墙可以强化网络安全策略\n对网络接入和访问进行监控审计\n防止内部信息的外泄\n集成其它网络应用功能，如VPN、NAT等\n\n\n防火墙的工作原理\n包过滤技术：包过滤防火墙通常要对经过的数据包检查指定字段\n包过滤规则的匹配结果分为三种情况：\n如果一个分组与一个拒绝转发的规则相匹配，则该分组将被禁止通过\n如果一个分组与一个允许转发的规则相匹配，则该分组将被允许通过\n如果一个分组没有与任何的规则相匹配，则该分组将被禁止通过。这里遵循了 “一切未被允许的皆禁止” 的原则\n\n\n应用代理技术\n具有应用协议分析(Application Profocol AnaysIs)能力的防火墙\n采取代理机制工作，内外部网络之间的通信都要先经过代理服务器审核，不能直接连接会话，这样就可以避免攻击者使用“数据驱动”网络攻击\n代理机制使防火墙的性能受到一定的限制\n\n\n状态监视技术\n在动态包过滤技术基础上发展而来的防火墙技术能对网络通信各个层次实施监测，并根据各种过滤规则进行决策\n状态监视技术在支持对每个数据包的头部、协议、地址、端口类型等信息进行分析的基础上，进一步发展了 “会话过滤” (Session Filtering）功能在每个连接建立时，防火墙会为该连接构造一个会话状态，包含了该连接数据包的所有信息之后基于连接状态信息对每个数据包的内容进行分析和监视\n状态监视技术结合了包过滤技术和应用代理技术，实现上更复杂，也会占用更多资源\n\n\n\n\n\n入侵检测技术\n\n入侵检测：通过收集和分析计算机网络或系统中 若干关键点 的信息，检查网络或系统中是否存在违反安全策略的行为和被攻击的迹象实现这一功能的软件与硬件组合即构成 入侵检测系统 IDS (Intrusion Detection System)\n入侵检测系统分类如下：\n主机型 IDS ：安装在服务器或PC机上的软件，监测到达主机的网络信息流\n网络型 IDS：一般配置在网络入口处（路由器)或网络核心交换处（核心交换路由器）通过旁路技术监测网络上的信息流\n\n\n入侵检测系统的主要功能如下：\n监测、记录并分析用户和系统的活动\n核查系统配置和漏洞\n评估系统关键资源和数据文件的完整性\n识别已知的攻击行为\n统计分析异常行为\n管理操作系统日志，识别违反安全策略的用户活动\n\n\nIDS 需要分析的数据称为事件(Event)，它可以是网络中的数据包，也可以是从系统日志等其它途径得到的信息\nIDS一般包括以下组件\n事件产生器(Event generators)\n事件分析器(Event analyzers)\n响应单元(Response units)\n事件数据库(Event databases)\n\n\n网络 IDS ：是网络上的一个监听设备，通过监听网络上传递的报文，按照协议对报文进行分析，并报告网络中可能存在的入侵或非法使用者信息，还能对入侵行为自动地反击\n网络IDS的工作原理：按事件分析方法分类\n基于知识的数据模式判断方法：分析、建立网络中非法使用者(入侵者)的工作方法——数据模型在实时检测网络流量时，将网络中读取的数据与数据模型比对，匹配成功则报告事件。\n基于行为的行为模式判断方法\n统计行为判断：根据上面模式匹配的事件，在进行事后统计分析时，根据已知非法行为的规则判断出非法行为\n异常行为判断：根据平时统计的各种信息，得出正常网络行为准则，当遇到违背这种准则的事件发生时，报告非法行为事件\n\n\n主机 IDS 的基本原理：以主机系统日志、应用程序日志等作为数据源，也可以包括其他资源（如网络、文件、进程)，从所在的主机上收集信息并进行分析，通过查询、监听当前系统的各种资源的使用、运行状态，发现系统资源被非法使用或修改的事件，并进行上报和处理。\n\n\n\n蜜罐技术\n\n蜜罐(Honeypot)技术顾名思义，可以看成是一种诱导技术，目的是发现恶意攻击和入侵。通过设置一个 “希望被探测攻击甚至攻陷” 的系统，模拟正常的计算机系统或网络环境，引诱攻击者入侵蜜罐系统，从而发现甚至定位入侵者，发现攻击模式、手段和方法,进而发现配置系统的缺陷和漏洞，以便完善安全配置管理消除安全隐患。\n\n蜜罐可以分为高交互蜜罐和低交互蜜罐，根据系统载体不同可以分类为物理蜜罐和虚拟蜜罐\n\n高交互蜜罐 (High-interaction honeypots)\n\n一个高交互蜜罐是一个常规的计算机系统，如使用一台标准计算机、路由器等\n高交互蜜罐实际上是一个配置了真实操作系统和服务的系统为攻击者提供一个可以交互的真实系统\n这一系统在网络中没有常规任务，也没有固定的活动用户\n系统上只运行正常守护进程或服务，不应该有任何不正常的进程，也不产生任何网络流量\n高交互蜜罐可以完全被攻陷，它们运行真实操作系统，可能带有所有已知和未知的安全漏洞，攻击者与真实的系统和真实的服务交互，使得我们能够捕获大量的威胁信息。\n\n\n低交互蜜罐(Low-interaction honeypots)\n\n低交互蜜罐则是使用特定软件工具模拟操作系统、网络堆栈或某些特殊应用程序的一部分功能，例如具有网络堆栈、提供TCP连接、提供HTTP模拟服务等\n低交互蜜罐允许攻击者与目标系统有限交互，允许管理员了解关于攻击的主要的定量信息\n优点是简单、易安装和易维护，只需要安装和配置一个工具软件即可，典型的低交互蜜罐工具软件，有Tiny HoneypotHoneyd、Nepentbes等，以及用于Web欺骗的Google入侵蜜罐GHH(Google Hack Honeypot) 、PHP.HoP等\n由于低交互蜜罐只为攻击者提供一个模拟交互系统，这系统不会完全被攻陷，因此，低交互蜜罐构造了一个可控环境，风险有限。\n因为蜜罐没有生产价值，任何连接蜜罐的尝试都被认为是可疑的\n\n\n\n\n物理蜜罐和虚拟蜜罐\n\n物理蜜罐意味着蜜罐运行在一个物理计算机上\n虚拟蜜罐是在一台物理计算机上部署多个虚拟机作为蜜罐\n\n\n\n\nChapter-10: 信息隐藏与数字水印技术信息隐藏技术\n\n密码技术：本质上是一种数据变换，将数据从一种编码变换成另一种编码，而且变换过程受密钥控制。\n\n信息隐藏技术：利用特定载体中具有随机特性的冗余部分,将有特别意义的或重要的信息嵌入其中掩饰其存在,嵌入的秘密信息称为隐藏信息，嵌入秘密信息后的载体称隐藏载体。\n\n信息隐藏的基本特征\n\n隐蔽性：也称透明性或不可见性，在特定载体中嵌入秘密信息后在不引起所嵌入信息质量下降的前提下，不显著改变隐藏载体的外部特征\n不可检测性：嵌入秘密信息后载体与原始载体具有一致的特性\n鲁棒性：不因隐藏载体(如图像)的某种改动而导致隐藏信息丢失\n自恢复性：经过了一些操作和变换后，可能会使隐藏载体受到较大的破坏，如果只留下部分的数据，在不需要宿主信号的情况，却仍能恢复隐藏信息的特征就是所谓的自恢复性\n安全性：隐藏算法有较强的抗攻击能力，即隐藏算法必须能够承受一定程度的人为攻击，保证隐藏信息不会被破坏\n\n\n\n数字水印技术\n\n数字产品具有易修改、易复制、易窃取的特点，数字知识产权保护成为基于网络数字产品应用迫切需要解决的实际问题。\n\n数字水印(Digital Watermark) 是指嵌入在数字产品中不可见、不易移除的数字信号，可以是图像、符号、数字等一切可以作为标识和标记的信息。其目的是进行版权保护、所有权证明、指纹(追踪发布多份拷贝）和完整性保护等版权保护数字水印包含数字产品的出处和版权所有者标识，能够提供版权证明。\n\n数字水印基本特点\n\n鲁棒性：嵌入数字水印的媒体在受到无意损害或蓄意攻击后，仍然能够提取出数字水印信息\n不可见性(透明性)：数字水印不影响宿主媒体的主观质量，例如，嵌入水印的图像不应有视觉质量下降，与原始图像对比，很难发现二者区别\n安全性：数字水印应能抵御各种攻击，必须能够惟一地标识原始图像的相关信息，任何第三方都不能伪造他人的水印信息\n\n\n数字水印分类按照数字水印提取过程是否需要原始宿主的参与，可将其分为：\n\n秘密水印：检测水印时需要输入原始数据或原始水印\n半秘密水印(半盲化水印)：不使用原始数据而使用水印拷贝检测水印\n公开水印(盲化水印)：检测水印时不需要原始数据也不需要原始水印\n\n\n按照水印的用途不同，可以分为文本水印、图像水印、音频水印、视频水印\n\n按照数字水印自身类型，可分为有意义数字水印、无意义水印\n\n有意义数字水印：如数字水印本身为有特定意义的图像\n无意义数字水印：如数字水印本身为序列。在版权保护领域，有意义数字水印更具有版权证明能力。\n\n\n数字水印算法分类\n\n空域算法：适用于图像、视频、文本、三维模型等载体将水印信息直接嵌入到图像的像素、视频的帧、文本的字符特征及字符间隙、三维模型的空间尺寸中\n时域算法：主要适用于音频数字水印，将水印信息嵌入到音频时域采样中，如果将时间序列看成一个普通的维度，时域算法可以等价于一维空域算法\n变换域算法：适用于音频、图像、视频等数字载体；将水印信息嵌入载体的变换域系数中\n压缩域算法：主要针对音频、图像、视频等数字载体，利用JPEG、MPEG等图像、视频压缩技术的结构和特点，将水印嵌入到压缩过程中的各种变量值域中。\n\n\n评价数字水印的优劣：鲁棒性，不可见性\n\n\n测验测试1\n\n安全保障阶段中将信息安全体系归结为四个主要环节，下列保护、检测、响应、恢复是正确的。\n拒绝服务攻击（DOS）能够破坏信息系统的 可用性\n在下列要素中，不属于网络安全的范畴的有 可移植性\n根据Kerchhoffs假设，一个现代密码系统的安全性应该仅依赖于密钥的保密。\n密码技术的基本功能是保护信息的 机密性\n一个完整的密码体制，不包括以下 数字签名要素\n如果访问者有意避开系统的访问控制机制，则该访问者对网络设备及资源进行非正常使用属于 非授权访问\n以下属于信息安全风险评估中需要识别的对象是 威胁识别、资产识别、脆弱性识别\n信息安全涉及的范围包括 信息自身、信息载体、信息环境\n置换密码是把明文中的各字符的位置次序重新排列得到密文的一种密码体制。对\n\n测试2\n\n数据签名的 签名不可伪造 功能是指签名可以证明是签字者而不是其他人在文件上签字\nHash函数是可接受 变长 数据输入，并生成 定长 数据输出的函数\n在加密服务中，消息认证码 是用于保障数据的真实性和完整性的，目前主要有两种生成MAC的方式\n非对称密码体制，不但具有保密功能，并且具有鉴别功能\n数据签名机制不能实现的安全属性包括 可用性、保密性\n密码学Hash函数应具有的功能特性包括 抗碰撞性、单向性\n身份认证信息系统的用户在进入系统或访问不同保护级别的系统资源时，系统确认该用户的身份是否 真实、合法和唯一的过程\n从计算复杂性上讲，安全性有三个层次：理论安全性、可证明安全性和计算安全性，其中 可证明安全性 和 计算安全性 称为实际安全性。\n数字签名是指用户用自己的 私钥对原始数据进行 加密所得到的特殊字符串，专门用于保证信息来源的 真实性 、数据传输的 完整性 和不可否认性。\n\n测试3\n\nAES结构由一下4个不同的模块组成，其中 字节代换 是非线性模块\n\nDES的轮函数F不包含哪一项内容 循环移位\n\n下面说法正确的是 雪崩效应是指明文或密钥的微小变化引起密文的巨大变化\n\nAES算法采用的是SP网络结构\n\n机械密码的典型代表Enigma 密码机使用的是什么密码系统：多表代换密码系统\n\n下面描述不正确的是 置换密码能改变密文消息中英文字母的统计特性\n\nDES算法S盒如下：如果该S盒的输入为110011，则其二进制输出为：0100\n\n下图属于分组密码中哪种工作模式CBC\n\n下面说法错误的是 AES是面向比特的运算\n\n维吉尼亚密码的密钥有26^n^个\n\n\n测试4\n\n美国的数字签名标准DSS采用的算法是:类似于ElGamal算法的数字签名算法DSA\n假如一个RSA算法的用户公钥为e，私钥为d，运算模数为n，那么e与d应满足的关系是e ×d &#x3D; 1modφ ( n)\n第一个真正的公钥密码算法是RSA算法\nElGamal算法的数学基础是离散对数求解的困难性\nDiffie-Hellman密钥协商协议容易遭受中间人攻击\n用RSA算法进行数字签名，为了减少运算量，通常先用Hash函数压缩成“摘要”\nRSA算法的数学基础为 大整数分解的困难\n下面对椭圆曲线算法的描述正确的是\n椭圆曲线算法的优势是在相同的安全强度要求下密钥更短、存储空间更小、运算速度更快\nRSA、ElGamal、D-H等公钥算法可以在椭圆曲线上重新定义\n椭圆曲线算法通过构造—个抽象代数系统来进行算法的运算\n\n\nφ(35) &#x3D;24\n12^18^&#x3D;(1) mod 19\n\n测试5\n\n有一种技术能够让公共网络上的用户可以安全地访问仅对机构内部网络开放的信息资源，这种技术是VPN\n用于保护WEB网页信息安全通信的协议是HTTPS\n入侵检测系统按数据来源可以分为基于主机和基于网络两种。\nIPSec在任何通信开始之前，要在两个VPN节点或网关之间协商建立安全关联(SA)\n以下DES不属于无线加密标准。\nIEEE802.11标准定义了无线局域网技术规范。\n对照TCP&#x2F;IP网络体系结构，填写下列安全协议所在的层次：IPSec协议位于应用层，WEP协议位于数据链路层，HTTPS协议位于网络层，SSL协议位于传输层。\nTLS协议本身分为记录协议层和握手协议层，其中负责进行安全参数协商是握手协议层。\nPKI的中文翻译是公钥基础设施。PKI的中心部件称为授权中心或认证中心，其英文缩写是CA，它以签发数字证书的形式提供密钥服务。\n下列陈述正确的是\n相对而言对称密码系统的密钥管理比公钥密码系统更困难\nD-H协议可以用于协商对称密码系统的共享密钥\n可以用公钥密码技术保护对称密码系统的共享密钥\n为了向大规模用户提供密钥管理服务，建立了KDC、PKI等密钥服务系统\n\n\n\n","slug":"计算机信息安全概论","date":"2023-07-24T01:40:45.000Z","categories_index":"计算机科学与技术","tags_index":"信息安全概论","author_index":"会思想的苇草i"},{"id":"c87b8553228183b157da295156afb592","title":"计算机体系结构概述","content":"\n计算机体系结构Chapter-1：计算机系统结构的基本概念认识计算机系统结构\n\n1945年诞生与美国宾夕法尼亚大学的ENIAC，用于计算火炮的弹道\n\n1946年，生于匈牙利的美国数学家冯·诺依曼提出了”存储程序计算机”\n\n定义：\n\n计算机体系结构是程序员所看到的计算机的属性，即概念性结构与功能特性。\n\n定义二:计算机系统结构包括计算机系统设计的三个方面:计算机指令系统;计算机组成;计算机硬件。\n\n\n\n\n\n\n计算机系统结构的分类\n\n并行性能是计算机系统结构的分类标准\n\n弗林(Flynn)分类法\n指令流(Instruction Stream) :指令的传送序列。\n数据流(Data Stream):数据传送、加工的序列。\n多倍性(Multiplicity):在系统性能瓶颈部件上处于同一执行阶段的指令或数据的最大可能个数。\n单指令流单数据流(SISD)|单指令流多数据流(SIMD)|多指令流单数据流(MISD)|多指令流多数据流(MIMD)\n\n\n冯氏分类法\n最大并行度是指计算机单位时间内能够处理的最大的二进制位数。最大并行度是指计算机单位时间内能够处理的最大的二进制位数\n字串位串，WSBS | 字串位并，WSBP | 字并位串，WPBS | 字并位并，WPBP\n\n\n汉德勒(Hander)分类法\n从硬件设备结构的并行级和流水线的程度分类:程序控制部件的个数;算术逻辑运算部件(处理部件的个数);基本逻辑线路的套数。\n\n\n\n\n计算机系统结构  –  主要研究软硬件功能的分配和对软件、硬件界面的确定，是计算机系统的概念性结构和功能特性。\n\n计算机组成  –  计算机系统结构的逻辑实现。\n\n计算机的实现  –  指其计算机组成的物理实现。\n\n\n计算机系统结构的发展\n\n巨型机、大型机、中型机、小型机、微型机\n冯-诺依曼结构：存储程序计算机；计算机由四个部分组成（运算器、存储器、控制器、输入&#x2F;输出设备）\n冯·诺依曼结构两个最重要特征:\n指令驱动计算机内部的信息流动\n计算机应用主要面向数值计算\n\n\n非冯·诺依曼体系结构：数据流计算机，归约计算机，基于面向对象程序设计语言的计算机，人工智能计算机\n指令的操作：取指令→指令译码→取操作数→运算→结果写回(重新开始)\n对系统结构进行的4种改进方式\n输入&#x2F;输出方式的改进\n程序控制 &#x2F; DMA &#x2F; IO处理机\n\n\n采用并行处理技术\n存储器组织结构的发展\n指令系统的发展\n复杂指令集计算机&#x2F;精减指令集计算机\n\n\n\n\n\n量化设计的基本原则\n\n大概率事件优先原则：对于大概率事件或者说最常见的事件，赋予它优先的处理权和资源使用权，以获得全局的最优结果。\n\nAmdahl定律：系统中对某一部件采用更快执行方式所能获得的系统性能改进程度，取决于这种执行方式被使用的频率，或所占总执行时间的比例。\n\n加速比：假设我们对机器（部件）进行某种改进，那么机器系统部件的加速比就是：\n\n\n\n\n\n\n\n程序的局部性原理：程序的局部性原理是指程序总是趋向于使用最近使用过的数据和指令。程序访问地址的分布不是随机的，而是相对地簇聚\n时间局部性:近期被访问的代码，很可能不久又将再次被访问。\n空间局部性:是指地址上相邻近的代码可能会被连续的访问。\n\n\n\n计算机系统结构中并行性的发展\n\n并行性概念:计算机系统在同一时刻或者同一时间间隔内进行多种运算或操作。\n同时性:两个或两个以上的事件在同一时刻发生。\n并发性:两个或两个以上的事件在同一时间间隔内发生。\n\n\n从处理数据角度，并行  性等级从低到高为：字串位串|字串位并|字并位串|字并位并\n从执行程序角度，并行性等级从低到高为：指令内部并行|指令级并行|线程级并行|任务级或过程级并行|作业或程序级并行\n提高并行性的技术途径：时间重叠（时间）– 基础设是部件功能专用化、资源重复（空间）、资源共享（轮流使用）\n并行机发展的四个阶段：\n并行机的萌芽阶段(1964-1975)\n向量机的发展和鼎盛阶段(1976-1990)\nMPP出现和蓬勃发展阶段(1990-1995)\n各种体系结构并存阶段(1995-2000)\n机群蓬勃发展阶段(2000 - ?)\n\n\n\n\nChapter-2：指令系统指令系统分类\n\n指令系统:一台计算机中所有机器指令的集合，称为这台机器的指令系统。\n\n指令系统分类：\n\n复杂指令集计算机（CISC)\n精简指令集计算机（RISC)\n\n\n将指令系统的结构分为三种类型：\n\n堆栈型结构\n累加器型结构\n通用寄存器型结构\n\n\n\n寻址方式\n\n寻址方式是指令系统中产生所要访问的数据地址的方法。\nMOV AX BX — 操作码 目的操作数 源操作数\n按访问方式分类：\n按地址访问\n按内容访问\n\n\n寄存器寻址：ADD R1，R2\n立即值寻址：ADD R3，#6\n寄存器间接寻址：ADD R4，(R2)\n索引寻址：ADD R4，(R2+R4)\n直接寻址：ADD R4，(1010)\n存储器间接寻址：ADD R2，@(R4)\n自增寻址：ADD R1，(R2)+\n自减寻址：ADD R1，-(R2)\n缩放寻址：ADD R1，80(R2)[R3]\n\n指令系统的设计和优化\n\n设计时考虑因素：速度、成本、灵活性\n设计原则：完整性、规整性(对称性、均匀性)、正交性(不同含义字段在编码时互不相关、相互独立)、高效率、兼容性(向后兼容)\n控制指令：控制指令用来改变控制流\n操作码的优化\n等长扩展码\n定长扩展码\n\n\n\n指令系统的发展和改进\n\nCISC\n\n许多指令很少用、控制器硬件复杂、复杂指令速度慢、规整性不好\n改进：\n面向目标程序增强指令功能\n目标程序→统计分析\n高频度指令→硬件加快\n高频度高指令串→新指令替代\n增强运算型指令功能\n增强数据传送指令功能\n增强程序控制指令功能\n\n\n面向高级语言的优化实现改进指令系统\n频度高、执行时间长的语句\n增强系统结构的规整性\n\n\n面向操作系统的优化实现改进指令系统\n处理机工作状态和访问方式的切换\n进程的管理和切换\n存储管理和信息保护\n进程的同步与互斥，信号灯的管理等\n\n\n\n\n\n\nRISC\n\nRISC遵循的原则:\n指令条数少、功能简单\n采用简单统一的指令格式\n指令执行在单机器周期内完成\n采用Load-Store结构\n采用硬连线逻辑实现\n强调优化编译器作用\n利用流水技术提高性能\n\n\n\n\n\n操作数的类型和大小\n\n数据类型：由软件进行处理和实现的各种数据类型 — 图、表、树、字符串…\n数据表示：计算机硬件能够直接识别、指令系统可以直接调用的数据类型 – 定点数、逻辑数、浮点数\n操作数类型表示方法\n由操作码指定\n带标识符的数据表示\n\n\n操作数大小：\n字节(8位)\n半字(16位)\n单字(32位)\n双字(64位)\n\n\n\nMIPS指令系统结构\n\n国产CPU处理器\n飞腾 – 兼容ARM指令集\n龙芯 – Alpha指令\n申微 – 采用RIS架构，兼容MIPS指令\n\n\nMIPS的数据寻址方式\n立即数寻址\n偏移量寻址\n\n\nMIPS的指令格式\nI类指令\nR类指令\nJ类指令\n\n\n\n\nChapter-3：流水线技术流水线的基本概念\n\n把一个重复的过程分解为若干子过程(相当于上面的工序)，每个子过程由专门的功能部件来实现;把各个处理过程在时间上错开，依次通过各功能段，每个子过程与其他子过程并行进行。\n\n流水线中的每个子过程及其功能部件被称为“级”(或“段”);段数:流水线的深度。\n\n指令流水线：把流水线技术应用于指令的解释执行过程\n\n流水线的描述方法：时空图\n\n从时间和空间两个方面描述流水线的工作过程。\n横坐标表示时间，纵坐标表示各流水段。\n\n\n特点：\n\n流水过程由多个相关的子过程组成，每个子过程由专用的功能段实现。\n各功能段的时间应基本相等，否则时间最长的段将成为流水线的瓶颈;这个时间通常为1个时钟周期（1拍)。\n流水线需要经过一定的时间（“通过时间”)才能稳定下来，并持续地输出结果。\n流水线技术适用于于大量重复的时序过程。\n\n\n\n流水线的分类\n按流水线所完成的功能分类：\n\n单功能流水线:只能完成一种固定功能的流水线，如浮点加法流水线。\n多功能流水线:各段可以进行不同的连接，从而使流水线在不同的时间或同一段时间完成不同的功能。\n\n按同一时间内流水段的连接方式划分\n\n静态流水线:在同一时间内，流水线的各段只能按同一种功能的连接方式工作。\n动态流水线:在同一时间内，当某些段正在实现某种运算时，另一些段却在实现另一种运算。(控制逻辑很复杂)\n\n按流水的级别划分\n\n部件级流水线，又叫运算操作流水线，是把处理机的算术逻辑部件分段，使得各种数据类型的操作能够进行流水，如浮点加法流水线。\n处理机级流水线，又叫指令流水线,是把解释指令的过程按照流水方式处理，如指令分析执行流水线。\n处理机间流水线，又叫宏流水线，是由两个以上的处理机串行地对同一数据流进行处理，每个处理机完成一项任务。\n\n按照数据表示来进行分类\n\n把指令执行部件中采用了流水线的处理机称为流水线处理机。\n标量流水处理机\n向量流水处理机\n\n\n\n线性流水线与非线性流水线\n\n**线性流水线:**流水线的各段串行连接，没有反馈回路。数据通过流水线中的各段时，每一个段最多只流过一次。\n**非线性流水线:**流水线中除了有串行的连接外，还有反馈回路。\n\n根据任务流入和流出的顺序是否相同来进行分类\n\n顺序流水线:流水线输出端任务流出的顺序与输入端任务流入的顺序完全相同。乱序流水线:流水线输出端任务流出的顺序与输入端任务流入的顺序可以不同，允许后进入流水线的任务先完成（从输出端流出)。\n\nMIPS的一种简单实现\n\n非流水方式\n\n\n\n改进方法：采用多周期实现方案\n\n基本MIPS流水线\n\n改进思路：\n将前述数据通路流水化，使得数据通路中的每一个周期就成为流水线的一段。\n每个时钟周期启动一条指令，得到了一条简单的MIPS流水线。\n\n\n问题解决：\n应保证流水线各段不会在同一时钟周期内使用相同的寄存器通路资源。\n不能要求一个ALU既做有效地址计算，又做减法操作。解决方案:在IF段添加一个ALU部件，专门用于做有效地址计算。\nIF与MEM两个阶段都要访问存储器，怎样避免访存冲突?解决方案:可以采用分离的指令存储器(IM)和数据存储器(DM);或者基于同一个存储器，采用分离的指令Cache和数据Cache。\nID段和WB段都要访问同一寄存器文件，有可能存在读写冲突。解决方案是:前半拍写，后半拍读。\n\n\n下条指令PC值的计算问题。解决方案：改变数据通路。\n合理划分流水段，每段内的操作都必须在一个时钟周期内完成。\n要防止指令状态数据被其他指令修改。\n\n\n\n流水线的性能分析\n\n主要性能指标：吞吐率、加速比、效率\n吞吐率:在单位时间内流水线所完成的任务数量或输出结果的数量。\n\n\n\n各段时间均相等的流水线\n\n\n\n\n\n各段时间不完成相等的流水线\n举例:一条5段的流水线，S1，S2，S3，S5各段的时间:t、S4的时间:3t\n流水线中这种时间最长的段称为流水线的瓶颈段。\n\n\n\n\n\n\n\n加速比:完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比。\n\n\n\n\n流水线的效率:流水线中的设备实际使用时间与整个运行时间的比值，即流水线设备的利用率。\n\n\n\n\n\n性能指标之间的关系\n\n\n流水线相关\n\n\n\n\n流水线需要有一定的通过时间与排空时间;运算之间存在关联，后面有些运算要用到前面运算的结果。“流水线相关”\n消除相关的基本方法一一暂停。\n约定:\n暂停流水线中某条指令及其后面所有指令的执行;\n该指令之前的所有指令继续执行;\n不会取新的指令。\n\n\n三种不同类型的相关\n结构相关：当指令在重叠执行过程中,硬件资源满足不了指令重叠执行的要求，发生资源冲突。\n插入暂停周期\n缺点:流水线性能降低。\n\n\n采用资源重复的方法\n将指令存储器和数据存储器分离;\n将Cache分割成指令Cache和数据Cache。\n\n\n\n\n数据相关：因指令之间存在数据依赖，一条指令需要用到前面指令的结果，而无法与产生结果的指令重叠执行。\n向流水线中插入暂停周期\n通过定向技术减少数据相关带来的暂停\n\n\n控制相关：当流水线遇到分支指令和其它会改变PC值的指令时就发生控制相关。\n冻结或排空流水线\n预测分支失败\n预测分支成功\n延迟分支\n\n\n\n\n\n\nChapter-4：存储层次存储器的层次\n\n存储器主要指标\n容量 – 容量大\n速度 – 速度快\n价格 – 价格低\n\n\n策略–采用多种存储器技术，构成多级存储**(“寄存器-Cache-主存-辅存”)**层次\n存储层次的四个问题：映像规则、查找算法、替换算法、写策略\n\nCache的基本知识\n\n信息交互单位 ： 块\n映像规则——确定主存块和Cache块位置对应关系\n直接映像 – 主存中的每一块只能被放置到Cache中唯一的一个位置\n全相联映像\n组相联映像 – 主存中的每一块，可以被放置到Cache中唯一的一个组中的任何一个位置Cache等分为若干组，每组有若干块\n\n\n替换算法\n直接映像——Cache中只有一个块位置可被选择\n组相联、全相联映像——Cache中有多个选择\n随机法：实现简单、失效率偏高\n最近最少使用法（LRU)：失效率低\n**先进先出法(FIFO)**：实现简单、无法反映局部性原理\n**最不常使用法(LFU)**：失效率低、代价高\n\n\n\n降低Cache失效率的方法\n\n失效产生的原因\n强制性失效 – cache中未找到\n容量失效 – cache中找到容量满\n冲突失效 – cache中找到冲突\n\n\n解决方案\n增加Cache块大小\n提高相联度\nVuctim Cache\n硬件预取技术\n由编译器控制的预取\n编译器优化\n\n\n\n减少Cache失效率开销\n\n写缓冲及写合并\n写直达Cache:因为所有的写请求都必须发送到下级存储层次中，经常使用一个写缓冲器来降低失效开销。\n写回法Cache:也可采用写缓冲器(相对简单)，以减少块的替换时间。\n\n\n让读失效优先于写\n推迟读失效处理\n让读优先于写\n\n\n请求字处理\n尽早重启动\n请求字优先\n\n\n多级Cache\n增加一级Cache\n\n\n非阻塞Cache\n\n减少命中时间\n\n命中时间是指访问Cache命中时所采用的时间。\n采用容量小、结构简单的Cache\n虚拟Cache\n写操作流水化\n多体Cache\n路预测\nTrace Cache\n\n主存\n\n核心存储器件\n提高主存性能的优化策略\n增加存储器宽度\n多体交叉技术\n独立存储器\n\n\n\n虚拟存储器\n\n虚拟性\n共享性\n自动性\n虚拟存储器的管理方式：\n页式&#x2F;段式\n映像规则，查找算法，替换算法，写策略\n\n\n\n\nChapter-5：输入输出系统输入输出系统概述\n\n输入输出系统（简称I&#x2F;O系统）:通常把处理机与主存储器之外的部分。\n输入输出系统包括:输入输出设备、输入输出接口和输入输出软件等。\n主要作用:控制主机与外设之间的信息传送，包括设备的寻址、选择、数据通路的建立和数据传送等。\n特点：异步性、设备无关性、实时性\n基本输入输出方式：程序查询方式、中断输入输出方式、直接存储器访问方式(DMA)、通道方式、输入输出处理机方式\n\n总线系统\n\n总线:连接计算机中CPU、内存储器、外存储器和输入输出设备的接口的公共信息通路。\n总线系统:总线与其相配合的附属控制电路统称。\n总线在计算机结构中所处的位置：片内总线、片总线、内总线、外总线\n传递的信息类型：数据总线(双向)、地址总线(单向)、控制总线(单向)\n信息传送的方向：单向传输、双向传输(半双向、全双向)\n总线的分类：单总线结构、双总线结构、三总线结构\n总线控制方式：集中式和分布式\n总线的指标：*总线的传输率&#x3D;总线宽度 * 总线频率 每周期数据量\n\n中断系统\n\n中断源:引起中断的各种事件。\n中断源可以来自系统外部，也可以来自机器内部,甚至处理机本身。中断可以是硬件引起的,也可以是软件引起的。\n中断源的种类:故障中断、访管中断、I&#x2F;0中断（外设引起)、程序性中断、外中断\n中断优先级：紧迫性、重要性、设备的工作速度、数据恢复的难易程度\n影响中断系统性能的两个因素：中断响应时间、灵活性\n\n\n\n通道处理机\n\n通道的工作过程\n管态指令:操作系统的指令，例如控制外部设备操作用的输入输出指令。\n目态指令（访管指令）:用户态应用程序的指令。\n广义指令:访管指令和参数，它的操作码实质上是对应于此广义指令的管理程序入口。\n通道程序编制期、选择设备期、数据传送期、数据传送结束期\n\n\n字节多路通道\n以字节交叉方式轮流为多个外设服务，用于连接多个慢速的和中速的设备，如键盘、打印机等。\n\n\n选择通道\n又称高速通道，可以连接多个设备，在某一段时间内通道只能选择一个设备进行工作，传输完成后才为其他外围设备传输数据。用于连接高速外围设备，如磁盘等信息以成组方式高速传输。\n\n\n数组多路通道\n以数组（数据块）为单位，多个高速设备交叉复用通道。选择一个外设，送完一块数据后,再选择下一个外设进行数据传送\n\n\n通道的流量分析\n\n\n\n\n\n\n\n\n\nChapter-6：多处理机多处理机概述\n\n并行计算机体系结构分类\n\nFlynn分类法\n多指令流多数据流MIMD成为通用多处理机体系结构的主流选择\n\n\n通信模型和存储器的结构模型\n\n通信模型\n\n对于共享地址空间的机器：利用Load和Store指令中的地址隐含地进行数据通信。\n多个地址空间的机器：数据通信要通过处理器间显式地传递消息完成。\n消息传递机器：消息传递机器根据简单的网络协议，通过传递消息来请求某些服务或传输数据，从而完成通信。\n三个关键性能指标：通信带宽、通信延迟、通信延迟的隐藏\n\n\n存储器的结构模型：物理上分离的多个存储器可作为一个逻辑上共享的存储空间进行编址。整个地址空间由多个独立的地址空间构成，它们在逻辑上也是相独立的，远程的处理器不能对其直接寻址。\n\n\n\n并行处理面临的挑战\n\n程序中有限的并行性\n相对较高的通信开销\n\n\n\n对称式共享存储器体系结构\n\n多处理机Cache的一致性\n多级Cache可以降低处理器对存储器带宽的要求。\n对称式共享存储器体系结构支持对共享数据和私有数据的Cache缓存。\nCache的引进对I&#x2F;O操作产生了一致性问题\n存储器一致性定义:如果对某个数据项的任何读操作均可得到其最新写入的值，则认为这个存储系统是一致的。\n实现一致性的基本方案：\n共享数据迁移\n共享数据复制\n\n\nCache一致性协议：目录、监听\n维持一致性要求：写作废协议，写更新协议\n\n\n实现Cache一致性的基本方案\n监听协议及其实现\n\n分布式共享存储器体系结构\n\n基于目录的Cache一致性\n\n在支持Cache一致性的可缩放的共享存储器体系结构中，关键是寻找替代监听协议的一致性协议。\n\n\n目录协议及其实现\n\n目录协议:用一种专用的存储器所记录的数据结构,它记录着可以进入Cache的每个数据块的访问状态、该块在各个处理器的共享状态以及是否修改过等信息。\n\n目录协议两种主要的操作：处理读失效，处理对共享、干净块的写\n\n目录协议的状态：共享、未缓冲、专有\n\n发往一个目录的消息会产生两种不同类型的动作：更新目录状态，发送消息满足请求服务\n\n目录项可能接收到三种不同的请求：读失效、写失效、数据写回\n\n对基于目录的Cache一致性的多种改进：有限映射目录、链式结构目录\n\n\n\n\n互连网络\n\n互联网络是将对称式系统或分布式系统中的节点连接起来所构成的网络，这些节点可能是处理器、存储模块或者其他设备，它们通过互联网络进行信息交换。\n性能较高的互联网络的特点：数据传送速率高;延迟低;通信频带宽。\n互联网络性能参数：节点度，网络直径、等分宽度\n路由：在网络通信中对路径的选择与指定\n静态连接网络：静态网络使用直接链路，它一旦构成后就固定不变。这种网络比较适合于构造通信模式可预测或可用静态连接实现的计算机系统。\n动态连接网络：不用固定连接，而是沿着连接通路使用开关或仲裁器以提供动态连接特性。\n\n同步\n\n同步机制通常是在硬件提供的同步指令的基础上，通过用户级软件例程来建立的。\n\n实现同步操作的原语：原子交换、测试并置定、读取并加1、使用指令对\n\n用一致性实现锁：\n\n旋转锁:处理器环绕一个锁不停地旋转而请求获得该锁。\n如果机器支持Cache一致性，就将锁缓冲进入Cache,并通过一致性机制使锁值保持一致。\n\n\n同步性能问题：\n\n简单旋转锁不能很好地适应可缩扩性。大规模多处理机中，若所有的处理器都同时争用同一个锁，则会导致大量的争用和通信开销。\n\n\n栅栏同步：\n\n栅栏强制所有到达该栅栏的进程进行等待，直到全部的进程到达栅栏，然后释放全部的进程，从而形成同步。\n栅栏通常是在循环中使用，从栅栏释放的进程运行一段后又会再次返回栅栏，这样有可能出现某个进程永远离不开栅栏的状况。\n\n\n大规模机器的同步：\n\n人们所希望的同步机制是在无竞争的条件下延迟较小，在竞争激烈时串行性小。\n\n\n硬件原语支持\n\n排队锁:排队记录等待的进程，当锁释放时送出一个已确定的等待进程。\n硬件同步原语:引进一种原语来减少栅栏记数时所需的时间，从而减小串行形成的瓶颈。\n\n\n\n同时多线程\n\n多线程技术 与 同时多线程技术是不同的技术\n\n多线程技术：使多个线程以重叠的方式共享单个处理器的功能单元，从而提高处理器的性能。\n\n细粒度多线程:在每条指令间都能进行线程的切换，从而导致多个线程的交替执行。\n粗粒度多线程:线程之间的切换只在发生代价较高、时间较长的阻塞出现时。\n\n\n同时多线程技术(SMT):是一种在多流出、动态调度处理器上开发线程级并行和指令级并行的改进的多线程技术。\n\n\n\nChapter-7：非冯-洛依曼型计算机人工智能计算机\n\n人工智能计算有如下特征:\n人工智能计算的主要对象是符号而不是数值。常用的基本符号操作包括比较、选择、排序、匹配、逻辑集合运算、分类以及模式检索和识别等。\n非确定计算:由于人工智能进行的主要是非数值运算，很多算法存在不确定性，因而在求解过程中常采用对所有的可能性进行穷尽枚举，或者对求解空间进行有控制的搜索。\n动态进行:由于缺少完整的知识和对求解过程的预见性，因此在求解过程中往往需要建立新的数据结构和函数,对于存储器及其它资源可能随时回收或重新分配，其任务可能动态建立，通信拓扑可能动态变化。\n并行和分布处理:由于在人工智能算法中，任务往往是相互独立的，因此存在并行性和分布处理的潜力，而且任务之间往往缺乏数值性的约束或关联。\n知识管理占主导地位。在非数值的符号处理中，有用的知识越多，无用的搜索就越少，因此知识管理起着很重要的作用，包括知识的表达、加工、管理和学习等。在智能化的求解过程中，有些知识来源未知，或者无法预见，因此存在知识的不完善性，这就要求人工智能系统一般设计成开放性的系统，允许其不断地求精和获取新的知识。\n\n\n人工智能计算机一般可分为四类:\n基于语言的人工智能计算机\n基于知识的人工智能计算机\n连接式(Connectionist)人工智能计算机\n带智能接口的人工智能计算机\n\n\n\n数据流计算机\n\n冯-洛依曼体系结构的不足：\n\n控制驱动型\n指令执行的并行性不高\n\n\n数据流计算机的基本原理\n\n采用数据驱动方式工作\n没有程序计数器\n没有常规的变量概念\n指令是在数据可用性的控制下并行执行的\n\n\n数据驱动的特性：异步性、并行性、函数性、局部性\n\n最基本的数据流语言是数据流计算机的机器语言，即数据流程序图。\n\n高级数据流程序设计语言主要有三类：\n\n单赋值语言\n函数类语言\n命令类语言\n\n\n数据流计算机的优点：\n\n高度并行运算\n流水线异步操作\n与VLSI技术相适应\n有利于提高程序设计效率\n\n\n数据流计算机的缺点：\n\n操作开销过大\n不能有效利用传统计算机的研究成果\n数据流语言尚不完善\n\n\n\n\n平时测验例题：\n一\n\n利用时间重叠原理实现并行处理的是 流水处理机\n多处理机首先的并行主要是 任务级并行\n从计算机系统结构来看，机器语言程序员看到的机器属性是 编程要用到的硬件组织\n直接执行微指令的是 硬件\n软件兼容的根本特征是 向后兼容\n同构型多处理机所采用的提高并行性的技术途径分别是 资源重复\n异构型多处理机所采用的提高并行性的技术途径分别是 时间重叠\n从执行程序的角度看，并行性等级从低到高可分为指令内部并行、指令级 并行、线程级并行、任务级或过程级并行和作业或程序级并行\n在一个计算机系统中，低层机器的属性对高层机器的程序员往往是 透明 的\n根据Amdahl定律，只要对某一部件进行充分改进，提高其加速比，系统加速比就可以无限制提高。 ×\n\n二\n\n不需要编址的数据存储空间是 堆栈\nCPU中用来存储操作数的存储单元主要有 堆栈、寄存器和累加器\n以下有关指令系统的说法错误的是 指令系统和机器语言是无关的\n在CPU执行指令的过程中，指令的地址由 程序计数器PC 给出\n对指令系统的基本要求是 完整性、正交性、兼容性\n\n三\n\n动态流水线只能是单功能流水线 说法是不正确的\n\n与线性流水线最大吞吐率有关的是 最慢的那一段的执行时间\n\n在MIPS的指令流水线中，可能发生的冲突有 先流入的指令的写操作与后流入的指令的读操作之间的写后读冲突\n\n关于“延迟分支”方法的3三种调度策略中，从前调度策略最好\n\n延迟分支方法有3种调度策略：从前调度、从目标处调度和从失败处调度\n\n由分支指令引起的延迟称为 分支延迟\n\n流水线在连续流动达到稳定状态后所得到的吞吐率，称为 最大吞吐率\n\n定向技术可以消除大部分数据相关，结合流水线调度技术就能够消除全部数据相关了 ×\n\n为了避免结构相关，应该将流水线中的所有功能单元完全流水化或设置足够多的硬件资源 ×\n\n理想情况下，流水线的最大加速比等于流水线的段数，所以，应该尽可能采用段数多的流水线方案 ×\n\n\n四\n\n与全相联映像相比，组相联映像的优点是 目录表小\n按Cache地址映像的块冲突概率从高到低的顺序是：直接映像、组相联映像、全相联映像\n组相联映像、LRU替换算法的Cache存储器，不影响Cache命中率的是 增大主存容量\n程序员编写程序时，使用的访存地址是：逻辑地址\n虚拟存储器主要是为了解决 扩大存储系统的容量\n虚拟存储器的替换算法采用 LRU\nCache容量越大，使失效率达到最低的块大小 越大\n存储器层次结构设计技术的最基本依据是程序的 局部性 原理\n在“Cache—主存”层次中，CPU的访存地址被分割为 块地址 和块内偏移两部分\n当组相联的路数n变为1时，组相联就变成了直接映像，当组数G变为1 时，组相联就变成了全相联映像 √\n\n五\n\n磁盘存储器适合于连接到 选择通道或数组多路通道\n\n在配置有通道的计算机系统中，用户程序需要输入输出时，引起的中断是 访管中断\n\n当计算机系统通过执行通道程序完成输入输出工作时，执行通道程序的是 通道\n\n输入输出数据不经过CPU内部寄存器的输入输出方式是 直接存储器访问方式\n\n目前，全球权威的评测服务器性能的现行标准是 TPC-C\n\n下面不属于总线特点的是 并行性\n\n单碟容量的提高不仅可以提高硬盘的总容量，而且还能提高硬盘的性能。 √\n\n在计算机系统中，导致错误的原因是各种故障，因此，只要有故障就一定会导致错误。×\n\n在RAID0~RAID6的各级磁盘阵列中，都是通过添加冗余信息来增加系统整体可靠性的，但是具体方法不太一样。×\n\n采用RAID技术之后，不仅系统可靠性得到提升，单盘可靠性也得以改善。×\n\n\n六\n\n能实现指令级、程序级、任务级并行的计算机系统是 MIMD\n\n性能较高的互联网络的特点不包括 出错率低\n\n对于多处理机系统，维护各处理器缓存内容版本同步的协议称为 Cache一致性协议\n\n数据流计算机的特点不包括 没有操作码\n\n现有的MIMD机器可分为 集中式共享存储器结构 和 分布式共享存储器结构 两类。每一类代表了一种存储器的结构和互连策略。\n\n实现Cache一致性协议有 写作废协议 和 写更新协议 两类\n\n多处理机结构由若干台独立的计算机组成，每台计算机能够独立执行自己的程序。 √\n\n支持共享存储器的可缩放机器，既可以支持也可以不支持Cache一致性。 √\n\n粗粒度多线程技术能够在每条指令间都能进行线程的切换，从而导致多个线程的交替执行。×\n\n在多处理机中实现同步的硬件原语功能，能够自动读出并修改存储单元，普通用户也可以随便使用。×\n\n假设浮点数操作FP操作的比例为25%，FP操作的平均CPI&#x3D;4.0，其他指令的平均CPI为1.33，则系统CPI为1.9975\n\n假设某程序中，求浮点数平方根FPSQR操作占整个程序执行时间的20%，若使FPSQR的操作速度提高10倍，则系统的加速比为 1.22（保留两位小数）\n\n解释和仿真原则 不是计算机设计中经常用到的定量设计原理\n\n下列不是冯.诺伊曼计算机的主要特点的是 机器以控制器为中心\n\n面向目标程序优化的思想是 通过使用频度分析和改进指令系统 和 增设强功能复合指令代替原来的软件实现\n\n平均码长最短的编码是 哈夫曼编码\n\n操作码优化的主要目的是 缩短指令字长、减少程序总位数、增加指令字表示的信息\n\n信息按整数边界存储的主要优点是 访存速度快\n\nCPU中用来存储操作数的存储单元主要有堆栈、累加器和寄存器\n\n不需要编址的数据存储空间是 堆栈\n\n采用流水线之后，单从一条指令来看，其执行时间有什么变化 – 一定变长（因为有一定的流水线开销）\n\n哪一项是最常见的MIPS数据相关类型 – 写后读\n\n理想情况下，流水线的最大加速比等于流水线的段数，所以，应该尽可能采用段数多的流水线方案。错\n\n结构相关一定能消除但不一定要消除，数据相关一定能消除并且一定要消除。错\n\n消除流水线瓶颈的方法有细分瓶颈段和重复设置瓶颈段两种。\n\n流水线中的每个子过程及其功能部件称为流水线的段，流水线的段数称为流水线的 深度\n\n非线性流水线的特征是 一次运算中要多次使用流水线中的某些功能段\n\n按照流水的级别来分，流水线可分为部件级流水线、处理机级流水线和 处理机间流水线\n\n磁盘存储器适合于连接到选择通道或数组多路通道\n\n在配置有通道的计算机系统中，用户程序需要输入输出时，引起的中断是访管中断\n\n当计算机系统通过执行通道程序完成输入输出工作时，执行通道程序的是通道\n\n输入输出数据不经过CPU内部寄存器的输入输出方式是直接存储器访问方式\n\n目前，全球权威的评测服务器性能的现行标准是TPC-C\n\n下面不属于总线特点的是并行性\n\n现有的MIMD机器可分为集中式共享存储器结构和分布式共享存储器结构两类。每一类代表了一种存储器的结构和互连策略\n\n实现Cache一致性协议有写作废协议和写更新协议两类\n\n能实现指令级、程序级、任务级并行的计算机系统是MIMD\n\n性能较高的互联网络的特点不包括出错率低\n\n对于多处理机系统，维护各处理器缓存内容版本同步的协议称为Cache一致性协议\n\n数据流计算机的特点不包括没有操作码\n\nCache存储系统中，主存有0~7共8块，Cache为4块， 若采用直接相联映像方式，则主存中第6块将映像到Cache中的哪一块。第二块\n\nCache存储系统中，主存有0~7共8块，Cache为4块,若采用每组2块的组相联映像方式，则主存中第6块将映像到Cache中的哪一块。第二块或第三块\n\nCache存储系统中，主存有0~7共8块，Cache为4块，采用全相联映像方式，则主存中第6块将映像到Cache中的哪一块。4块中的任意一块\n\n按Cache地址映像的块冲突率从高到低的顺序是直接映像、组相联映像、全相联映像\n\n支持共享存储器的可缩放机器，既可以支持也可以不支持Cache一致性。√\n\n粗粒度多线程技术能够在每条指令间都能进行线程的切换，从而导致多个线程的交替执行。×\n\n在多处理机中实现同步的硬件原语功能，能够自动读出并修改存储单元，普通用户也可以随便使用。×\n\n多处理机结构由若干台独立的计算机组成，每台计算机能够独立执行自己的程序。 √\n\n单碟容量的提高不仅可以提高硬盘的总容量，而且还能提高硬盘的性能。 √\n\n在计算机系统中，导致错误的原因是各种故障，因此，只要有故障就一定会导致错误。×\n\n在RAID0~RAID6的各级磁盘阵列中，都是通过添加冗余信息来增加系统整体可靠性的，但是具体方法不太一样。×\n\n采用RAID技术之后，不仅系统可靠性得到提升，单盘可靠性也得以改善。×\n\n单功能流水线一定是静态流水线 √\n\n动态流水线一定是多功能流水线 √\n\n多功能流水线一定是动态流水线 ×\n\n\n","slug":"计算机体系结构知识点大全","date":"2023-07-02T01:47:11.000Z","categories_index":"计算机科学与技术","tags_index":"计算机体系结构","author_index":"会思想的苇草i"},{"id":"e6457ff6789a076addbc03fc1dc3721a","title":"微信小程序运行原理揭秘：高效的更新机制","content":"\n1、微信小程序运行机制\n微信小程序运行机制\n\n\n\n官方文档描述的很详细，所以这里只介绍主要的相关概念。\n\n1.1 前台和后台\n小程序启动后，界面被展示给用户，此时小程序处于前台状态。\n\n当用户点击右上角按钮关闭小程序，或者按了设备 Home 键离开微信时，小程序并没有完全终止运行，而是进入了后台状态，小程序还可以运行一小段时间。\n\n当用户再次进入微信或再次打开小程序，小程序又会从后台进入前台。但如果用户很久没有再进入小程序，或者系统资源紧张，小程序可能被销毁，即完全终止运行。\n\n\n1.2 小程序启动：冷启动和热启动\n小程序启动可以分为两种情况，一种是冷启动，一种是热启动。\n\n\n冷启动：如果用户首次打开，或小程序销毁后被用户再次打开，此时小程序需要重新加载启动，即冷启动。\n热启动：如果用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时小程序并未被销毁，只是从后台状态进入前台状态，这个过程就是热启动。\n\n1.3 小程序销毁\n通常，只有当小程序进入后台一定时间，或者系统资源占用过高，才会被销毁。具体而言包括以下几种情形：\n\n\n当小程序进入后台，可以维持一小段时间的运行状态，如果这段时间内都未进入前台，小程序会被销毁。\n当小程序占用系统资源过高，可能会被系统销毁或被微信客户端主动回收。\n\n\n2、微信小程序更新机制\n微信小程序更新机制\n\n开发者在管理后台发布新版本的小程序之后，微信客户端会有若干个时机去检查本地缓存的小程序有没有新版本，并进行小程序的代码包更新。但如果用户本地有小程序的历史版本，此时打开的可能还是旧版本。\n\n\n2.1 启动时同步更新\n在以下情况下，小程序启动时会同步更新代码包。同步更新会阻塞小程序的启动流程，影响小程序的启动耗时。\n\n如果更新失败或超时，为了保障小程序的可用性，还是会使用本地版本打开。\n\n\n定期检查发现版本更新\n微信运行时，会定期检查最近使用的小程序是否有更新。如果有更新，下次小程序启动时会同步进行更新，更新到最新版本后再打开小程序，尽可能保证用户能够尽快使用小程序的最新版本。\n\n用户长时间未使用小程序\n用户长时间未使用小程序时，为保障小程序版本的实时性，会强制同步检查版本更新，更新到最新版本后再打开小程序。\n\n若用户处于弱网环境、下载最新版本失败等情况下，仍会启动本地的较低版本。\n\n\n2.2 启动时异步更新\n即使启动前未发现更新，小程序每次冷启动时，都会异步检查是否有更新版本。如果发现有新版本，将会异步下载新版本的代码包。但当次启动仍会使用客户端本地的旧版本代码，即新版本的小程序需要等下一次冷启动才会使用。\n\n开发者手动触发更新\n在启动时异步更新的情况下，如果开发者希望立刻进行版本更新，可以使用 wx.getUpdateManager API 进行处理。在有新版本时提示用户重启小程序更新新版本。\n官方版本：\n\nconst updateManager = wx.getUpdateManager()\n\nupdateManager.onCheckForUpdate(function (res) &#123;\n  // 请求完新版本信息的回调\n  console.log(res.hasUpdate)\n&#125;)\n\nupdateManager.onUpdateReady(function () &#123;\n  wx.showModal(&#123;\n    title: &#39;更新提示&#39;,\n    content: &#39;新版本已经准备好，是否重启应用？&#39;,\n    success(res) &#123;\n      if (res.confirm) &#123;\n        // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启\n        updateManager.applyUpdate()\n      &#125;\n    &#125;\n  &#125;)\n&#125;)\n\nupdateManager.onUpdateFailed(function () &#123;\n  // 新版本下载失败\n&#125;)\n\n\n实际使用版本：\n\n//app.js\nApp(&#123;\n    onLaunch() &#123;\n        this.update()\n    &#125;,\n \n    // 版本更新\n    update() &#123;\n        const updateManager = wx.getUpdateManager()\n \n        updateManager.onCheckForUpdate(function (res) &#123;\n            // 请求完新版本信息的回调\n            if(res.hasUpdate) &#123;\n \n                // 新版本下载成功\n                updateManager.onUpdateReady(function () &#123;\n                    wx.showModal(&#123;\n                        title: &#39;更新提示&#39;,\n                        content: &#39;新版本已经准备好，请您重启应用，以确保正常使用。&#39;,\n                        success: function (res) &#123;\n                            if (res.confirm) &#123;\n                                // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启\n                                updateManager.applyUpdate()\n                            &#125;\n                        &#125;\n                    &#125;)\n                &#125;)\n \n                // 新版本下载失败\n                updateManager.onUpdateFailed(function () &#123;\n                    wx.showModal(&#123;\n                        title: &#39;更新提示&#39;,\n                        content: &#39;检测到了新版本，但是下载失败了~&#39;\n                    &#125;)\n                &#125;)\n \n            &#125;\n        &#125;)\n    &#125;\n&#125;)\n\n2.3 小程序管理后台的相关设置\n小程序开发者可以通过在小程序管理后台进行设置，影响更新逻辑。\n\n优先使用本地版本设置\n若开发者判断某些较新的小程序版本无需强制用户同步更新到最新版本，可以在小程序管理后台「设置」-「功能设置」-「优先使用本地版本设置」中进行设置，设置后若同步更新时检查本地版本不低于该版本，则优先使用本地版本，同时将会异步下载最新版本的代码包。\n\n小程序最低可用版本设置\n若开发者判断某些较旧的小程序版本服务不再可用，可以在小程序管理后台 「设置」-「功能设置」-「小程序最低可用版本设置」中进行设置。设置后若同步更新时检查本地版本低于该版本，则无法打开，并继续尝试下载最新版本、若异步更新，则会在检查到更新后提示用户重启小程序更新新版本。\n\n操作步骤如下：\n\n\n\n\n\n\n最终小程序打开如下图所示\n\n注意\n开发者在后台发布新版本之后，无法立刻影响到所有现网用户，但最差情况下，也在发布之后 24 小时之内覆盖绝大多数用户。\n小程序管理后台的「优先使用本地版本设置」和「小程序最低可用版本设置」不会影响同步更新与异步更新的选择。\n\n","slug":"前端--微信小程序运行及更新机制","date":"2023-04-23T14:34:07.000Z","categories_index":"前端","tags_index":"微信小程序","author_index":"会思想的苇草i"},{"id":"e64fdb23f4387c8c4044a46c8a9a5d8b","title":"快速上手微信小程序：开发进阶","content":"1、小程序–开发进阶1.1 自定义组件组件的创建\n\n在项目的根目录中，鼠标右键。创建 components -&gt; test 文件夹\n在新建的 components -&gt; test 文件夹上，鼠标右键，点击“新建 Component”\n键入组件的名称之后回车，会自动生成组件对应的 4 个文件，后缀名分别为.js，.json，.wxml 和.wxss\n\n组件的引用\n\n局部引用:组件只能在当前被引用的页面内使用（在 pages 中配置）\n\n//json\n&#123;\n  &quot;usingComponents&quot;: &#123;\n    &quot;my-test1&quot;:&quot;/components/test/test&quot;\n  &#125;\n&#125;\n//wxml\n&lt;my-test1&gt;&lt;/my-test1&gt;\n\n\n全局引用:组件可以在每个小程序页面中使用（在 app.json 中配置）\n\n组件与页面的区别\n\n组件的.json 文件中需要声明”component”: true 属性\n组件的.js 文件中调用的是 Component()函数\n组件的事件处理函数需要定义到 methods 节点中\n\n组件样式\n\n组件样式隔离：组件不会影响到小程序页面和其它组件的样式\napp.wxss 的全局样式对组件无效，只有 class 选择器会有样式隔离效果\n可以通过styleIsolation修改组件的样式隔离选项\n\n//.js\noptions:&#123;\n    styleIsolation:&#39;isolated&#39;\n  &#125;,\n//或者\n//.json\n&#123;\n    &quot;styleIsolation&quot;:&quot;isolated&quot;\n&#125;\n\n\n\n\n可选值\n默认值\n描述\n\n\n\nisolated\n是\n表示启用样式隔离，在自定义组件内外，使用 class 指定的样式将不会相互影响\n\n\napply-shared\n否\n表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面\n\n\nshared\n否\n表示页面 wxss 样式将影响到自定义组件，自定义组件 wxss 中指定的样式也会影响页面和其他设置了 apply-shared 或 shared 的自定义组件\n\n\n数据、方法和属性\n\n在小程序组件中，用于组件模板渲染的私有数据，需要定义到 data 节点中\n在小程序组件中，事件处理函数和自定义方法需要定义到 methods 节点中\n在小程序组件中，properties 是组件的对外属性，用来接收外界传递到组件中的数据\ndata 更倾向于存储组件的私有数据\nproperties 更倾向于存储外界传递到组件中的数据\n\n\n\n数据监听器\n\n数据监听器用于监听和响应任何属性和数据字段的变化，从而执行特定的操作\n\nobservers:&#123;\n    &#39;n1,n2&#39;:function name(newN1,newN2) &#123;\n      this.setData(&#123;\n        sum:newN1+newN2\n      &#125;)\n    &#125;\n  &#125;\n\n\n数据监听器支持监听对象中单个或多个属性的变化**(‘对象.属性 A’)**\n如果某个对象中需要被监听的属性太多，可以使用通配符******来监听对象中所有属性的变化\n\n纯数据字段\n\n纯数据字段指的是那些不用于界面渲染的 data 字段,既不会展示在界面上。也不会传递给其他组件\n纯数据字段有助于提升页面更新的性能\n\noptions:&#123;\n    //指定纯数据字段格式\n    pureDataPattern:/^_/\n  &#125;,\n  data:&#123;\n    a:true,//普通数据字段\n    _b:true//纯数据字段\n  &#125;\n\n组件的生命周期\n\n\n\n生命周期函数\n参数\n描述说明\n\n\n\ncreated\n无\n在组件实例刚刚被创建时执行\n\n\nattached\n无\n在组件实例进入页面节点树时执行\n\n\nready\n无\n在组件在视图层布局完成后执行\n\n\nmoved\n无\n在组件实例被移动到节点树另一个位置时执行\n\n\ndetached\n无\n在组件实例被从页面节点树移除时执行\n\n\nerror\nObject Error\n每当组件方法抛出错误时执行\n\n\n\n组件实例刚被创建好的时候,created 生命周期函数会被触发\n\n此时还不能调用 setData\n通常在这个生命周期函数中，只应该用于给组件的 this 添加一些自定义的属性字段\n\n\n在组件完全初始化完毕、进入页面节点树后,attached 生命周期函数会被触发\n\n此时, this.data 已被初始化完毕\n这个生命周期很有用，绝大多数初始化的工作可以在这个时机进行（例如发请求获取初始数据\n\n\n在组件离开页面节点树后， detached 生命周期函数会被触发\n\n退出一个页面时，会触发页面内每个自定义组件的 detached 生命周期函数\n此时适合做一些清理性质的工作\n\n\n在小程序组件中，生命周期函数可以直接定义在 Component 构造器的第一级参数中，可以在 lifetimes 字段内进行声明**(这是推荐的方式，其优先级最高**)。\n\n\nComponent(&#123;\n  lifetimes: &#123;\n    //推荐用法\n    attached() &#123;&#125;,\n  &#125;,\n  //attached()&#123; &#125;, 旧式定义方式\n&#125;);\n\n组件所在页面的生命周期\n\n自定义组件的行为依赖于页面状态的变化，此时就需要用到组件所在页面的生命周期。\n\n\n\n\n生命周期函数\n参数\n描述\n\n\n\nshow\n无\n组件所在的页面被展示时执行\n\n\nhide\n无\n组件所在的页面被隐藏时执行\n\n\nresize\nObject Size\n组件所在的页面尺寸变化时执行\n\n\nComponent(&#123;\n  pageLifetimes: &#123;\n    show: function () &#123;&#125;, //页面被展示\n    hide: function () &#123;&#125;, //页面被隐藏\n    resize: function (size) &#123;&#125;, //页面尺寸变化\n  &#125;,\n&#125;);\n\n插槽\n\n提供一个&lt; slot&gt;节点(插槽)，用于承载组件使用这提供的 wxml 结构，默认只允许使用单个插槽\n\n\n\n多个插槽，以不同的 name 来区分不同的插槽\n\n//component.js\noptions:&#123;\n    multipleSlots:true\n  &#125;,\n\n//component.wxml\n&lt;view&gt;\n  &lt;slot name=&quot;before&quot;&gt;&lt;/slot&gt;\n  &lt;view&gt;这里是组件的内部结构&lt;/view&gt;\n  &lt;slot name=&quot;after&quot;&gt;&lt;/slot&gt;\n&lt;/view&gt;\n\n//pages.wxml\n&lt;my-test&gt;\n  &lt;view slot=&quot;before&quot;&gt;这里通过before插槽填充的内容&lt;/view&gt;\n  &lt;view slot=&quot;after&quot;&gt;这里通过after插槽填充的内容&lt;/view&gt;\n&lt;/my-test&gt;\n\n父子组件之间的通信\n\n属性绑定\n\n用于父组件向子组件的指定属性设置数据，仅能设置 JSON 兼容的数据\n\n//父组件data节点\ndata: &#123;\n    count:0\n  &#125;,\n// 父组件wxml\n&lt;my-test5 count=&quot;&#123;&#123;count&#125;&#125;&quot;&gt;&lt;/my-test5&gt;\n&lt;view&gt;~~~~~~~~~&lt;/view&gt;\n&lt;view&gt; 父组件中，count值是：&#123;&#123;count&#125;&#125;&lt;/view&gt;\n//子组件properties节点\nproperties: &#123;\n    count:Number\n  &#125;,\n// 子组件wxml\n&lt;view&gt;子组件中，count值是：&#123;&#123;count&#125;&#125;&lt;/view&gt;\n\n\n事件绑定\n\n用于子组件向父组件传递数据，可以传递任意数据\n\n//父组件定义方法\nsyncCount(e)&#123;\n    this.setData(&#123;\n      count:e.detail.value\n    &#125;)\n  &#125;,\n//父组件wxml，使用 bind:自定义事件名称\n&lt;my-test5 count=&quot;&#123;&#123;count&#125;&#125;&quot; bind:sync=&quot;syncCount&quot;&gt;&lt;/my-test5&gt;\n//子组件wxml\n&lt;view&gt;子组件中，count值是：&#123;&#123;count&#125;&#125;&lt;/view&gt;\n&lt;button bindtap=&quot;addCount&quot;&gt;+1&lt;/button&gt;\n//子组件方法\nmethods: &#123;\n    addCount()&#123;\n      this.setData(&#123;\n        count:this.properties.count+1\n      &#125;)\n      this.triggerEvent(&#39;sync&#39;,&#123;value:this.properties.count&#125;)\n    &#125;\n  &#125;\n\n\n获取组件实例\n\n父组件还可以通过 this.selectComponent()获取子组件实例对象\n这样就可以直接访问子组件的任意数据和方法\n\n//父组件wxml结构\n&lt;my-test5 count=&quot;&#123;&#123;count&#125;&#125;&quot; bind:sync=&quot;syncCount&quot; class=&quot;customA&quot;&gt;&lt;/my-test5&gt;\n&lt;view&gt; 父组件中，count值是：&#123;&#123;count&#125;&#125;&lt;/view&gt;\n&lt;button bindtap=&quot;getChild&quot;&gt;获取子组件的实例对象&lt;/button&gt;\n//父组件js方法 id选择器或者class选择器\ngetChild()&#123;\n    const child = this.selectComponent(&#39;.customA&#39;)\n    child.setData(&#123;count:child.properties.count + 1&#125;)\n    child.addCount()\n  &#125;,\n\n\n\nbehaviors\n\n用于实现组件代码共享的特性\n\n\n\n调用 Behavior(Object object)方法即可创建一个共享的 behavior 实例对象，供所有的组件使用\n\n//创建文件夹，创建文件\nmodule.exports = Behavior(&#123;\n  data: &#123; username: &quot;zs&quot; &#125;,\n  properties: &#123;&#125;,\n  methods: &#123;&#125;,\n&#125;);\n//js文件中使用\nconst myBehavior = require(&quot;../../behaviors/my-behaviors&quot;);\n// components/test5/test5.js\nComponent(&#123;\n  behaviors: [myBehavior],\n&#125;);\n\n\n\n\n可用的节点\n类型\n是否必填\n描述\n\n\n\nproperties\nObject Map\n否\n同组件的属性\n\n\ndata\nObject\n否\n同组件的数据\n\n\nmethods\nObject\n否\n同自定义组件的方法\n\n\nbehaviors\nString Array\n否\n引入其它的 behavior\n\n\ncreated\nFunction\n否\n生命周期函数\n\n\nattached\nFunction\n否\n生命周期函数\n\n\nready\nFunction\n否\n生命周期函数\n\n\nmoved\nFunction\n否\n生命周期函数\n\n\ndetached\nFunction\n否\n生命周期函数\n\n\n\n覆盖和组合规则：https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html\n\n1.2 使用 npm 包npm 包的限制\n\n不支持依赖于 Node.js 内置库的包\n不支持依赖于浏览器内置对象的包\n不支持依赖于 C+＋插件的包\n\nVant Weapp\n\n官方文档地址：https://youzan.github.io/vant-weapp\n\n\n\n安装 Vant 组件库(详细参考https://youzan.github.io/vant-weapp/#/quickstart#an-zhuang)\n\n通过 npm 安装(建议指定版本为@1.3.3)\n构建 npm 包\n修改 app.json\n\n\n使用 Vant 组件：\n\n\n//app.json\n&quot;usingComponents&quot;: &#123;\n    &quot;van-button&quot;: &quot;@vant/weapp/button/index&quot;\n  &#125;\n//pages的wxml结构\n&lt;van-button type=&quot;primary&quot;&gt;按钮&lt;/van-button&gt;\n\n\n定制全局主题样式\n\nCSS 变量的基本用法：https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_custom_properties\n颜色变量：https://github.com/youzan/vant-weapp/blob/dev/packages/common/style/var.less\n\npage &#123;\n  //定制警告按钮的背景颜色和边框颜色\n  --button-danger-background-color: #c00000;\n  --button-danger-border-color: #d60000;\n&#125;\n\n\n\nAPI Promise 化\n\n默认情况下，小程序官方提供的异步 API 都是基于回调函数实现的，存在回调地狱，代码的可读性、维护性差\nAPl Promise 化，指的是通过额外的配置，将官方提供的、基于回调函数的异步 API，升级改造为基于 Promise 的异步 API，从而提高代码的可读性、维护性，避免回调地狱的问题\n\n//装包，需重新构建\nnpm i --save miniprogram-api-promise@1.0.4\n//app.js\nimport &#123;promisifyAll&#125; from &#39;miniprogram-api-promise&#39;\nconst wxp = wx.p = &#123;&#125;\npromisifyAll(wx,wxp)\n\n1.3 全局数据共享\n全局数据共享(又叫做:状态管理)是为了解决组件之间数据共享的问题\n\n在小程序中，可使用 mobx-miniprogram 配合 mobx-miniprogram-bindings 实现全局数据共享。\n\nmobx-miniprogram 用来创建 Store 实例对象\nmobx-miniprogram-bindings 用来把 Store 中的共享数据或方法，绑定到组件或页面中使用\n\n\n\n//装包，重新构建\nnpm i --save mobx-miniprogram@4.13.2 mobx-miniprogram-bindings@1.2.1\n\n//创建MobX的Store实例 创建store文件夹、store.js文件\nimport &#123;observable,action&#125; from &#39;mobx-miniprogram&#39;\n\nexport const store = observable(&#123;\n  //数据字段\n  numA:1,\n  numB:2,\n  //计算属性\n  get sum()&#123;\n    return this.numA + this.numB\n  &#125;,\n  //actions方法，用来修改store中的数据\n  updateNum1:action(function(step)&#123;\n    this.numA += step\n  &#125;),\n  updateNum2:action(function(step)&#123;\n    this.numB += step\n  &#125;),\n&#125;)\n\n\n//将Store中的成员绑定到页面中 页面的.js文件\nimport &#123;createStoreBindings&#125; from &#39;mobx-miniprogram-bindings&#39;\nimport&#123;store&#125; from &#39;../../store/store&#39;\n\nPage(&#123;\n  onLoad:function()&#123; //监听页面加载\n    this.storeBindings = createStoreBindings(this,&#123;\n      store,    //指定要绑定的Store\n      fields:[&#39;numA&#39;,&#39;numB&#39;,&#39;sum&#39;],//指定要绑定的字段数据\n      actions:[&#39;updateNum1&#39;]//指定要绑定的方法\n    &#125;)\n  &#125;,\n  onUnload:function()&#123;//监听页面卸载\n    this.storeBindings.destroyStoreBindings()\n  &#125;\n&#125;)\n\n\n//页面wxml\n&lt;view&gt; &#123;&#123;numA&#125;&#125; + &#123;&#123;numB&#125;&#125; = &#123;&#123;sum&#125;&#125; &lt;/view&gt;\n&lt;van-button type=&quot;primary&quot; bindtap=&quot;btnHandler1&quot; data-step=&quot;&#123;&#123;1&#125;&#125;&quot;&gt; numA+1 &lt;/van-button&gt;\n&lt;van-button type=&quot;danger&quot; bindtap=&quot;btnHandler1&quot; data-step=&quot;&#123;&#123;-1&#125;&#125;&quot;&gt; numA-1 &lt;/van-button&gt;\n\n\n//组件js\nimport &#123; storeBindingsBehavior &#125; from &#39;mobx-miniprogram-bindings&#39;\nimport &#123;store&#125; from &#39;../..store/store&#39;\n\nComponent(&#123;\n  behaviors:[storeBindingsBehavior],\n  storeBindings:&#123;\n    store,\n    fields:&#123;\n      numA:&#39;numA&#39;,\n      numB:&#39;numB&#39;,\n      sum:&#39;sum&#39;\n    &#125;,\n    actions:&#123;\n      updateNum2:&#39;updateNum2&#39;\n    &#125;\n  &#125;,\n&#125;)\n\n\n//组件wxml\n&lt;my-numbers&gt;&lt;/my-numbers&gt;\n\n\n//组件js\nmethods: &#123;\n    btnHandler2(e)&#123;\n      this.updateNum2(e.target.dataset.step)\n    &#125;\n  &#125;\n\n1.4 分包概念\n\n分包指的是把一个完整的小程序项目，按照需求划分为不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载\n\n优点：\n\n可以优化小程序首次启动的下载时间\n在多团队共同开发时可以更好的解耦协作\n\n\n分包项目由 1 个主包 + 多个分包组成\n\n主包:一般只包含项目的启动页面或 TabBar 页面、以及所有分包都需要用到的一些公共资源**(启动是默认下载并启动)**\n分包:只包含和当前分包有关的页面和私有资源**(进入时下载)**\n总包不超过16M，单包不超过2M\n\n\n\n使用\n\n小程序会按**subpackages** 的配置进行分包,subpackages 之外的目录将被打包到主包中\n主包也可以有自己的 pages(即最外层的 pages 字段)\ntabBar 页面必须在主包内\n分包之间不能互相嵌套\n\n\n\n主包无法引用分包内的私有资源\n分包之间不能相互引用私有资源\n分包可以引用主包内的公共资源\n\n独立分包\n\n独立分包本质也是分包，可以独立于主包和其他分包而单独运行&quot;independent&quot;: true\n\n开发者可以按需，将某些具有一定功能独立性的页面配置到独立分包中\n\n小程序从普通分包页面启动时，首先需要下载主包\n独立分包不依赖主包即可运行，提升分包页面的启动速度\n\n\n独立分包和普通分包以及主包之间，是相互隔绝的，不能相互引用彼此的资源！！\n\n\n分包预下载\n\n在进入小程序的某个页面时，由框架自动预下载可能需要的分包，从而提升进入后续分包页面时的启动速度\n同一个分包中的页面享有共同的预下裁大小限额2M\n\n//app.json\n&quot;preloadRule&quot;: &#123;\n    &quot;pages/contact/contact&quot;:&#123;\n      //指定的网络模式下进行预下载\n      &quot;network&quot;: &quot;all&quot;,\n      //进入页面后预下载哪些分包\n      &quot;packages&quot;:[&quot;pkgA&quot;]\n    &#125;\n  &#125;,\n\n","slug":"前端--微信小程序（进阶）","date":"2023-03-25T01:15:36.000Z","categories_index":"前端","tags_index":"微信小程序","author_index":"会思想的苇草i"},{"id":"3c5b8d1cedaa864e9f8845e75af9e565","title":"快速上手微信小程序：视图与逻辑","content":"1、小程序–视图与逻辑1.1 页面导航\n页面导航指页面之间的相互跳转\n\n小程序实现页面导航的两种方式：\n\n声明式导航\n\n在页面上声明一个&lt; navigator&gt;导航组件；通过点击&lt; navigator&gt;组件实现页面跳转\n导航到tabBar页面\n\n//页面地址必须以/开头\n//必须指定跳转方式，为switchTab\n&lt;navigator url=&quot;/pages/message/message&quot; open-type=&quot;switchTab&quot;&gt;导航消息页面&lt;/navigator&gt;\n\n\n导航到非tabBar页面\n\n//页面地址必须以/开头\n//指定跳转方式，为navigate，可省略\n&lt;navigator url=&quot;/pages/info/info&quot; open-type=&quot;navigate&quot;&gt;导航到info页面&lt;/navigator&gt;\n\n\n后退导航\n\n//open-type的值必须是navigateBack，表示要进行后退导航\n//delta的值必须是数字，表示要后退的层级,可省略，默认值为1\n&lt;navigator open-type=&quot;navigateBack&quot; delta=&quot;1&quot;&gt;后退&lt;/navigator&gt;\n\n\n编程式导航\n\n调用小程序的导航API，实现页面的跳转\n\n\n\n\n属性\n类型\n是否必选\n说明\n\n\n\nurl\nstring\n是\n需要跳转的页面的路径，路径后不能带参数\n\n\nsuccess\nfunction\n否\n接口调用成功的回调函数\n\n\nfail\nfunction\n否\n接口调用失败的回调函数\n\n\ncomplete\nfunction\n否\n接口调用结束的回调函数（调用成功、失败都会执行）\n\n\n\n导航到tabBar页面\n\n//wxml\n&lt;button bindtap=&quot;gotoMessage&quot;&gt;跳转到消息页面&lt;/button&gt;\n\n//js\ngotoMessage()&#123;\n    wx.switchTab(&#123;\n        url:&#39;/pages/message/message&#39;\n    &#125;)\n&#125;\n\n\n导航到非tabBar页面\n\n//wxml\n&lt;button bindtap=&quot;gotoInfo&quot;&gt;跳转到信息页面&lt;/button&gt;\n\n//js\ngotoInfo()&#123;\n  wx.navigateTo(&#123;\n    url: &#39;/pages/info/info&#39;\n  &#125;)\n&#125;,\n\n\n后退导航\n\n\n\n\n属性\n类型\n默认值\n是否必选\n说明\n\n\n\ndelta\nnumber\n1\n否\n返回的页面数，如果 delta 大于现有页面数，则返回到首页\n\n\nsuccess\nfunction\n\n否\n接口调用成功的回调函数\n\n\nfail\nfunction\n\n否\n接口调用失败的回调函数\n\n\ncomplete\nfunction\n\n否\n接口调用结束的回调函数（调用成功、失败都会执行）\n\n\n//wxml\n&lt;button bindtap=&quot;gotoBack&quot;&gt;后退&lt;/button&gt;\n\n//js\ngotoBack()&#123;\n    wx.navigateBack(&#123;\n  &#125;)\n&#125;\n\n\n\n\n导航传参\n\n声明式导航传参\n\n路径后面携带参数：\n参数与路径之间使用？\n分隔参数键与参数值用**&#x3D;**相连\n不同参数用**&amp;**分隔\n\n\n\n&lt;navigator url=&quot;/pages/info/info?name=zs&amp;age=20&quot;&gt;跳转到info页面&lt;/navigator&gt;\n\n\n编程式导航传参\n//wxml\n&lt;button bindtap=gotoInfo2&quot;&gt;跳转到info页面&lt;/button&gt;\n\n//js\ngotoInfo2()&#123;\n    wx.navigateTo(&#123;\n    ur1: &quot; /pages/infolinfo?name=ls&amp;gender=男&quot;\n  &#125;)\n&#125;\n\n\n在onLoad中接收导航参数\n\n\nonLoad:function(options)&#123;\n    //options即导航传递过来的参数对象\n    console.log(options)\n&#125;\n\n\n\n1.2 页面事件下拉刷新事件\n\n通过手指在屏幕上的下拉滑动操作，从而重新加载页面数据的行为\n\n启用下拉刷新的方式：\n\n全局开启下拉刷新(app.json的windows结点设置)\n局部开启下拉刷新(页面的.json中配置)\n实际开发中为需要的页面单独开启下拉刷新的效果\n\n\n监听页面的下拉刷新事件\n\n在页面的.js文件中，通过 **onPullDownRefresh()**函数即可监听当前页面的下拉刷新事件\n\nonPullDownRefresh() &#123;\n    console.log(&#39;触发下拉刷新事件&#39;)\n    wx.stopPullDownRefresh()\n  &#125;,\n\n\n停止下拉刷新的效果\n\n调用**wx.stopPullDownRefresh()**可以停止当前页面的下拉刷新\n\n\n\n上拉触底事件\n\n通过手指在屏幕上的上拉滑动操作,从而加载更多数据的行为\n监听页面的上拉触底事件\n在页面的.js文件中，通过onReachBottom()函数即可监听当前页面的上拉触底事件(节流  – 在data 中定义isloading节流阀；在方法中修改isloading节流阀的值；在onReachBottom 中判断节流阀的值，从而对数据请求进行节流控制)\n\n\n配置上拉触底距离\n触发上拉触底事件时，滚动条距离页面底部的距离，在全局或页面的.json配置文件中，通过onReachBottomDistance属性来配置上拉触底的距离\n\n\n\n1.3 生命周期\n在小程序中，生命周期分为两类,分别是:\n\n应用生命周期(范围较大)特指小程序从启动-&gt;运行-&gt;销毁的过程\n页面生命周期(范围较小)特指小程序中，每个页面的加载-&gt;渲染-&gt;销毁的过程\n\n\n生命周期函数:是由小程序框架提供的内置函数，会伴随着生命周期，自动按次序执行，允许程序员在特定时间点执行某些特定的操作\n\n生命周期强调的是时间段，生命周期函数强调的是时间点\n\n应用生命周期函数\n\n\n//app.js 文件\nApp(&#123;\n    //小程序初始化完成时，执行此函数，全局只触发一次。可以做一些初始化的工作\n    onLaunch: function(options) &#123; &#125;,\n    //小程序启动，或从后台进入前台显示时触发。\n    onShow : function(options) &#123; &#125;,\n    //小程序从前台进入后台时触发。\n    onHide : function() &#123; &#125;\n&#125;)\n\n\n页面生命周期函数\n\n//页面的.js 文件\nPage(&#123;\n    onLoad : function(options) &#123; &#125;,//监听页面加载，一个页面只调1次\n    onshow : function() &#123; &#125;,//监听页面显示\n    onReady : function() &#123; &#125;，//监听页面初次渲染完成，一个页面只调用1次\n    onHide: function() &#123; &#125;,//监听页面隐藏\n    onUnload: function()&#123; &#125; //监听页面卸载，一个页面只调用1次\n&#125;)\n\n1.4 WXS脚本概述\n\nWXS (WeiXin Script)是小程序独有的一套脚本语言，结合WXML，可以构建出页面的结构\n\nWXML中无法调用在页面的.js中定义的函数，但是，WXML中可以调用WXS中定义的函数\n\nWXS与JavaScript的关系\n\nwxs有自己的数据类型\n\nnumber数值类型、string字符串类型、boolean布尔类型、object对象类型、function函数类型、array数组类型、date日期类型、regexp 正则\n\n\nwxs不支持类似于ES6及以上的语法形式\n\n不支持: let. const、解构赋值、展开运算符、箭头函数、对象属性简写、etc…\n支持: var定义变量、普通function函数等类似于ES5的语法\n\n\nwxs遵循CommonJS规范\n\nmodule对象、require()函数、module.exports对象\n\n\n\n\n\n基础语法\n\n内嵌wxs脚本\n外联wxs脚本\n\nwxs的特点\n\n大量借鉴JavaScript的语法(但是是两种不同的语言)\n不能作为组件的事件回调(配合Mustache语法使用)\n隔离性(不能调用js定义的函数及小程序提供的API)\n性能好(iOS上比js快2-20倍）\n\n","slug":"前端--微信小程序（视图与逻辑）","date":"2023-03-11T01:45:00.000Z","categories_index":"前端","tags_index":"微信小程序","author_index":"会思想的苇草i"},{"id":"fcb4d1e2238062848ffc04d17153bd49","title":"快速搭建微信小程序：模板和配置详细介绍","content":"1、小程序 – 模板与配置1.1 WXML模板语法数据绑定\n\n在data中定义数据\n\nPage(&#123;\n    data:&#123;\n        //字符串类型数据\n        info:&#39;init data&#39;,\n        //数组类型数据\n        msgList:[&#123;msg:&#39;hello&#39;&#125;,&#123;nsf:&#39;world&#39;&#125;]\n    &#125;\n&#125;)\n\n\n在WXML中使用数据\n\n&lt;view&gt;&#123;&#123; 要绑定的数据名称 &#125;&#125;&lt;/view&gt;\n//Mustache语法(双大括号)\n//应用场景：绑定内容,绑定属性,运算（三元运算、算术运算等)\n\n事件绑定\n\n事件是渲染层到逻辑层的通讯方式\n\n\n\n小程序中常用事件\n\n\n\n\n类型\n绑定方式\n事件描述\n\n\n\ntap\nbindtap 或 bind:tap\n手指触摸后马上离开，类似于 HTML 中的 click 事件\n\n\ninput\nbindinput 或 bind:input\n文本框的输入事件\n\n\nchange\nbindchange 或 bind:change\n状态改变时触发\n\n\n\n事件对象的属性列表\n当事件回调触发的时候，会收到一个事件对象event，它的详细属性如下表所示:\n\n\n\n\n\n\n属性\n类型\n说明\n\n\n\ntype\nString\n事件类型\n\n\ntimeStamp\nInteger\n页面打开到触发事件所经过的毫秒数\n\n\ntarget\nObject\n触发事件的(源头)组件的一些属性值集合\n\n\ncurrentTarget\nObject\n当前(正在触发事件)组件的一些属性值集合\n\n\ndetail\nObject\n额外的信息\n\n\ntouches\nArray\n触摸事件，当前停留在屏幕中的触摸点信息的数组\n\n\nchangedTouches\nArray\n触摸事件，当前变化的触摸点信息的数组\n\n\n\n事件绑定语法格式：\n\n//wxml\n&lt;button type=&quot;primary&quot; bindtap=&quot;btnTapHandler&quot;&gt;按钮&lt;/button&gt;\n\n//js\nPage(&#123;\n  btnTapHandler(e)&#123;\n    console.log(e)\n  &#125;,  \n&#125;)\n\n\n在事件处理函数中为data中的数据赋值\n\nPage(&#123;\n  data:&#123;\n    count:0\n  &#125;,\n  changeCount()&#123;\n    this.setData(&#123;\n      count:this.data.count + 1//修改\n    &#125;)\n  &#125;\n&#125;)\n\n\n事件传参\n\n//wxml\n&lt;button bindtap = &quot;btnHandler&quot; data-info=&quot;&#123;&#123;2&#125;&#125;&quot;&gt;事件传参&lt;/button&gt;\n//通过data-*自定义属性传参\n\n//js\nbtnHandler(event)&#123;\n    console.log(event.target.dataset.info)\n&#125;\n//通过event.target.dataset.参数名获取到具体参数的值\n\n\nbindinput语法格式\n通过input事件来响应文本框的输入事件\n\n\n\n//wxml\n&lt;input bindinput=&quot;inputHandler&quot;&gt;&lt;/input&gt;\n\n//js\nPage(&#123;\n  inputHandler(e)&#123;\n    console.log(e.detail.value)\n  &#125;\n&#125;)\n\n数据同步\n\n步骤\n\n\n定义数据(data数据)\n渲染结构(wxml)\n美化样式(wxss)\n绑定input事件处理函数(js函数)\n\n条件渲染\n&lt;view wx:if=&quot;&#123;&#123;type === 1&#125;&#125;&quot;&gt;男&lt;/view&gt;\n&lt;view wx:elif=&quot;&#123;&#123;type === 2&#125;&#125;&quot;&gt;女&lt;/view&gt;\n&lt;view wx:else&gt;保密&lt;/view&gt;\n\n//要一次性控制多个组件的展示与隐藏，可以使用一个&lt;block&gt; &lt;/block&gt;标签将多个组件包装起来，&lt;block&gt;并不是一个组件，它只是一个包裹性质的容器，不会在页面中做任何渲染。\n&lt;block wx: if=&quot;&#123;&#123;true&#125;&#125;&quot;&gt;\n    &lt;view&gt; view1 &lt;/view&gt;\n    &lt;view&gt; view2 &lt;/view&gt;\n&lt;/block&gt;\n\n//hidden也能控制元素的显示与隐藏\n&lt;view hidden=&quot;&#123;&#123;condition&#125;&#125;&quot;&gt;条件为true隐藏，条件为 false显示&lt;/view&gt;\n\n\nwx:if 与 hidden 的对比\n运行方式不同\nwx:if 以动态创建和移除元素的方式，控制元素的展示与隐藏\nhidden 以切换样式的方式(display: none&#x2F;block;)，控制元素的显示与隐藏\n\n\n使用建议\n频繁切换时,建议使用hidden\n控制条件复杂时，建议使用wx:if 搭配wx:elif、wx:else进行展示与隐藏的切换\n\n\n\n\n\n列表渲染\n&lt;view wx:for=&quot;&#123;&#123;arr&#125;&#125;&quot;&gt;\n  索引是：&#123;&#123;index&#125;&#125;, item项：&#123;&#123;item&#125;&#125;\n&lt;/view&gt;\n//默认情况下，当前循环项的索引用index表示;当前循环项用item表示\n//也可以手动指定索引和当前项的变量名 wx:for-index=&quot;&quot; wx:for-item=&quot;&quot;\n\n//小程序在实现列表渲染时，也建议为渲染出来的列表项指定唯一的key值，从而提高渲染的效率\n//wxml\n&lt;view wx:for=&quot;&#123;&#123;userList&#125;&#125;&quot; wx:key=&quot;id&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/view&gt;\n//js\nPage(&#123;\n  data:&#123;\n    userList:[\n      &#123;id:1,name:&#39;小红&#39;&#125;,\n      &#123;id:2,name:&#39;小黄&#39;&#125;,\n      &#123;id:3,name:&#39;小白&#39;&#125;\n    ]\n  &#125;,\n&#125;)\n\n1.2 WXSS模板样式\nrpx\n\nrpx (responsive pixel）是微信小程序独有的，用来解决屏适配的尺寸单位\n\nrpx的实现原理：鉴于不同设备屏幕的大小不同，为了实现屏幕的自动适配，rpx把所有设备的屏幕，在宽度上等分为750份(即:当前屏幕的总宽度为750rpx) \n\n在较小的设备上,1rpx所代表的宽度较小\n\n在较大的设备上， 1rpx所代表的宽度较大\n\n\n\n小程序在不同设备上运行的时候，会自动把rpx的样式单位换算成对应的像素单位来渲染，从而实现屏幕适配\n\n\n\n\n\n设备\nrpx换算px (屏幕宽度750)\npx换算rpx (750&#x2F;屏幕宽度)\n\n\n\niPhone5\n1rpx &#x3D; 0.42px\n1px  &#x3D; 2.34rpx\n\n\niPhone6\n1rpx &#x3D; 0.5px\n1px &#x3D; 2rpx\n\n\niPhone6  Plus\n1rpx &#x3D; 0.552px\n1px  &#x3D; 1.81rpx\n\n\n\n开发中建议采用iPhone 6作为视觉设计稿\n\n样式导入\n\n使用WXSS提供的import语法。可以导入外联的样式表\n\n@import &quot;demo.wxss&quot;\n\n全局样式\n\n定义在app.wxss中的样式为全局样式，作用于每一个页面\n\n局部样式\n\n在页面的.wxss文件中定义的样式为局部样式，只作用于当前页面\n\n注意:\n\n当局部样式和全局样式冲突时，根据就近原则，局部样式会覆盖全局样式\n当局部样式的权重大于或等于全局样式的权重时，才会覆盖全局的样式\n\n\n\n1.3 全局配置\n小程序根目录下的 app.json文件是小程序的全局配置文件。常用的配置项如下:\npages：记录当前小程序所有页面的存放路径\nwindow：全局设置小程序窗口的外观\ntabBar：设置小程序底部的tabBar效果\nstyle：是否启用新版的组件样式\n\n\n\nwindow\n\n\n常用配置项\n\n\n\n\n属性名\n类型\n默认值\n说明\n\n\n\nnavigationBarTitleText\nString\n字符串\n导航栏标题文字内容\n\n\nnavigationBarBackgroundColor\nHexColor\n#000000\n导航栏背景颜色，仅支持16进制颜色\n\n\nnavigationBarTextStyle\nString\nwhite\n导航栏标题颜色，仅支持 black &#x2F; white\n\n\nbackgroundColor\nHexColor\n#ffffff\n窗口的背景色 ，仅支持16进制颜色\n\n\nbackgroundTextStyle\nString\ndark\n下拉 loading 的样式，仅支持 dark &#x2F; light\n\n\nenablePullDownRefresh\nBoolean\nfalse\n是否全局开启下拉刷新\n\n\nonReachBottomDistance\nNumber\n50\n页面上拉触底事件触发时距页面底部距离，单位为px\n\n\ntabBar\n\ntabBar是移动端应用常见的页面效果,用于实现多页面的快速切换，分为底部和顶部两类\n只能配置最少2个，最多5个tab页签；渲染顶部tabBar时并不显示icon\n\n\n\ntabBar配置项：\n\n\n\n\n属性\n类型\n必填\n默认值\n描述\n\n\n\nposition\nString\n否\nbottom\ntabBar 的位置，仅支持 bottom&#x2F;top\n\n\nborderStyle\nString\n否\nblack\ntabBar 上边框的颜色，仅支持 black&#x2F;white\n\n\ncolor\nHexColor\n否\n\ntab 上文字的默认（未选中）颜色\n\n\nselectedColor\nHexColor\n否\n\ntab 上的文字选中时的颜色\n\n\nbackgroundColor\nHexColor\n否\n\ntabBar 的背景色\n\n\nlist\nArray\n是\n\ntab 页签的列表，  最少 2  个、最多  5 个 tab\n\n\n\n每个tab项的配置选项\n\n\n\n\n属性\n类型\n必填\n描述\n\n\n\npagePath\nString\n是\n页面路径，页面必须在 pages  中预先定义\n\n\ntext\nString\n是\ntab 上显示的文字\n\n\niconPath\nString\n否\n未选中时的图标路径；当 postion 为 top 时，不显示 icon\n\n\nselectedIconPath\nString\n否\n选中时的图标路径；当 postion 为 top 时，不显示 icon\n\n\n1.4 页面配置\n小程序中，每个页面都有自己的.json配置文件，用来对当前页面的窗口外观、页面效果等进行配置\n当页面配置与全局配置冲突时，根据就近原则，最终的效果以页面配置为准\n常用配置项：(同全局配置项)\n\n\n\n\n属性\n类型\n默认值\n描述\n\n\n\nnavigationBarBackgroundColor\nHexColor\n#000000\n当前页面导航栏背景颜色，如 #000000\n\n\nnavigationBarTextStyle\nString\nwhite\n当前页面导航栏标题颜色，仅支持 black &#x2F; white\n\n\nnavigationBarTitleText\nString\n\n当前页面导航栏标题文字内容\n\n\nbackgroundColor\nHexColor\n#ffffff\n当前页面窗口的背景色\n\n\nbackgroundTextStyle\nString\ndark\n当前页面下拉 loading 的样式，仅支持 dark &#x2F; light\n\n\nenablePullDownRefresh\nBoolean\nfalse\n是否为当前页面开启下拉刷新的效果\n\n\nonReachBottomDistance\nNumber\n50\n页面上拉触底事件触发时距页面底部距离，单位为 px\n\n\n1.5 网络数据请求\n出于安全性方面的考虑，小程序官方对数据接口的请求做出了如下两个限制:\n只能请求HTTPS类型的接口\n必须将接口的域名添加到信任列表中\n\n\n\n\n\n配置域名步骤：登录微信小程序管理后台 -&gt; 开发 -&gt; 开发设置 -&gt; 服务器域名 -&gt; 修改request合法域名\n\n注意：\n\n域名只支持https协议\n域名不能使用IP地址或localhost\n域名必须经过ICP备案\n服务器域名一个月内最多可申请5次修改\n\n\n发起GET请求\n\n\nwx.request(&#123;\n      url: &#39;https://www.escook.cn/api/get&#39;, //请求的接口地址，必须是基于https协议\n      method:&#39;GET&#39;,  //请求的方式\n      data:&#123;         //发送到服务器的数据\n        name:&#39;xyk&#39;,\n        age:21\n      &#125;,\n      success:(res=&gt;&#123;  //请求成功之后的回调函数  \n        console.log(res)\n      &#125;)\n    &#125;)\n\n\n发起POST请求\n\nwx.request(&#123;\n      url: &#39;https://www.escook.cn/api/post&#39;, //请求的接口地址，必须是基于https协议\n      method:&#39;POST&#39;,  //请求的方式\n      data:&#123;         //发送到服务器的数据\n        name:&#39;xyk&#39;,\n        age:21\n      &#125;,\n      success:(res)=&gt;&#123;  //请求成功之后的回调函数  \n        console.log(res)\n      &#125;\n    &#125;)\n\n\n页面加载时请求数据\n\n//生命周期函数\nonLoad(options) &#123;\n  this.getInfo()\n  this.postInfo()\n&#125;,\n\n\n跳过合法域名检验\n我们可以在微信开发者工具中，临时开启「开发环境不校验请求域名、TLS版本及 HTTPS证书」选项，跳过request 合法域名的校验\n仅限在开发与调试阶段使用\n\n\n\n\n\n关于跨域和Ajax\n跨域问题只存在于基于浏览器的Web开发中。由于小程序的宿主环境不是浏览器，而是微信客户端，所以小程序中不存在跨域的问题\nAjax技术的核心是依赖于浏览器中的XMLHttpRequest这个对象，由于小程序的宿主环境是微信客户端，所以小程序中不能叫做“发起Ajax请求”，而是叫做“发起网络数据请求”\n\n\n\n","slug":"前端--小程序（模板与配置）","date":"2023-03-07T08:05:06.000Z","categories_index":"前端","tags_index":"微信小程序","author_index":"会思想的苇草i"},{"id":"4919a85d97ec4c073e64d0ad59bc5172","title":"快速上手微信小程序：简介与开发技巧","content":"1、微信小程序–起步1.1 小程序简介小程序与普通网页开发的区别\n\n运行环境不同\n网页运行在浏览器中，小程序运行在微信环境中\n\n\nAPI不同\n小程序无法调用DOM和BOM的API，但是小程序中可以调用微信环境提供的各种APl\n\n\n开发模式不同\n网页的开发模式:浏览器＋代码编辑器\n小程序有自己的一套标准开发模式:\n申请小程序开发账号\n安装小程序开发者工具\n创建和配置小程序项目\n\n\n\n\n\n体验小程序\n\n注册小程序开发账号\n\n打开网站： https://mp.weixin.qq.com/ ，点击 立即注册\n选择注册账号的类型为 小程序\n填写账号信息\n提示邮箱激活\n点击链接激活账号\n选择主体类型 个人，并完成主体信息登记\n获取小程序的AppID，点击 开发管理 - 开发设置 - 获取开发者ID\n\n安装开发者工具\n\n微信开发者工具是官方推荐使用的小程序开发工具，它提供的主要功能如下:\n快速创建小程序项目\n代码的查看和编辑\n对小程序功能进行调试\n小程序的预览和发布\n\n\n步骤：\n\n\n打开网站 微信官方文档–下载 下载即可\n下载好后安装\n手机微信扫码登录\n设置外观和代理(不使用代理)\n\n创建小程序项目\n\n点击“加号”按钮\n填写项目信息\n\n\n\n项目创建完成\n在模拟器上查看项目效果\n\n\n1.2 小程序构成基本组成结构\n\n\npages用来存放所有小程序的页面\n\n.js文件(页面的脚本文件，存放页面的数据、事件处理函数等)\n.json文件(当前页面的配置文件，配置窗口的外观、表现等)，会覆盖其他配置项\n.wxml文件(页面的模板结构文件)\n.wxss文件(当前页面的样式表文件)\n\n\nutils用来存放工具性质的模块（例如:格式化时间的自定义模块)\n\napp.js小程序项目的入口文件\n\napp.json小程序项目的全局配置文件，包括了小程序的所有页面路径、窗口外观、界面表现、底部 tab等\n\npages:用来记录当前小程序所有页面的路径\nwindow:全局定义小程序所有页面的背景色、文字颜色等\nstyle:全局定义小程序组件所使用的样式版本\nsitemapLocation:用来指明sitemap.json的位置\n\n\napp.wxss小程序项目的全局样式文件\n\nprojectconfig.json项目的配置文件\n\nsetting中保存了编译相关的配置\nprojectname中保存的是项目名称\nappid中保存的是小程序的账号ID\n\n\nsitemap.json用来配置小程序及其页面是否允许被微信索引(类似网页的SEO)\n\n只需要在 app.json -&gt; pages 中新增页面的存放路径，小程序开发者工具即可帮我们自动创建对应的页面文件\n\n只需要调整app.json -&gt; pages数组中页面路径的前后顺序，即可修改项目的首页。小程序会把排在第一位的页面，当作项目首页进行渲染\n\n\nWXML模板\n\nWXML (Weixin Markup Language)是小程序框架设计的一套标签语言，用来构建小程序页面的结构，其作用类似于网页开发中的 HTML\nWXSS和HTML的区别：\n标签名称不同\nHTML (div,span, img, a)\nWXML (view, text, image, navigator)\n\n\n属性节点不同\n&lt; a href&#x3D;”#”&gt;超链接&lt; &#x2F;a&gt;\n&lt; navigator url&#x3D;”&#x2F;pages&#x2F;home&#x2F;home” &gt; &lt; &#x2F;navigator&gt;\n\n\n提供了类似于Vue中的模板语法\n数据绑定\n列表渲染\n条件渲染\n\n\n\nWXSS样式\n\nWXSS (WeiXin Style Sheets)是一套样式语言，用于描述WXML的组件样式，类似于网页开发中的CSS\nWXSS和CSS的区别：\n新增了rpx尺寸单位\nCSS中需要手动进行像素单位换算，例如rem\nWXSS 在底层支持新的尺寸单位rpx，在不同大小的屏幕上小程序会自动进行换算\n\n\n提供了全局的样式和局部样式\n项目根目录中的app.wxss会作用于所有小程序页面\n局部页面的.wxss样式仅对当前页面生效\n\n\nWSSS仅支持部分CSS选择器\n.class 和#id\nelement\n并集选择器、后代选择器\nafter和:before 等伪类选择器\n\n\n\nJS逻辑交互\n\n通过.js文件来处理用户的操作\n\n小程序中的JS文件分为三大类，分别是:\n\n\n\napp.js\n是整个小程序项目的入口文件，通过调用App()函数来启动整个小程序\n\n\n页面的.js文件\n是页面的入口文件,通过调用Page()函数来创建并运行页面\n\n\n普通的.js 文件\n是普通的功能模块文件,用来封装公共的函教或属性供页面使用\n\n\n\n1.3 小程序的宿主环境宿主环境简介\n\n宿主环境(host environment)指的是程序运行所必须的依赖环境，如Android和iOS是两个不同的宿主环境\n手机微信是小程序的宿主环境\n小程序宿主环境包含的内容：\n通信模型\n运行机制\n组件\nAPI\n\n\n\n通信模型\n\n小程序中通信的主体是渲染层和逻辑层，其中:\nWXML模板和WXSS 样式工作在渲染层\nJS脚本工作在逻辑层\n渲染层和逻辑层之间的通信 – 由微信客户端进行转发\n逻辑层和第三方服务器之间的通信 – 由微信客户端进行转发\n\n\n\n\n运行机制\n\n小程序启动过程：\n\n\n把小程序的代码包下裁到本地\n解析 app.json全局配置文件\n执行 app.js小程序入口文件，调用App()创建小程序实例\n渲染小程序首页\n小程序启动完成\n\n\n页面渲染的过程：\n\n\n加载解析页面的.json配置文件\n加载页面的.wxml模板和.wxss样式\n执行页面的.js文件，调用Page()创建页面实例\n页面渲染完成\n\n组件\n\n组件分类：\n\n\n视图容器\n\nview\n普通视图区域\n类似于HTML中的div，是一个块级元素\n常用来实现页面的布局效果\n\n\nscroll-view\n可滚动的视图区域\n常用来实现滚动列表效果\n\n\nswiper和 swiper-item\n轮播囤容器组件和轮播图item组件\n\n\n\n\n\n\n属性\n类型\n默认值\n说明\n\n\n\nindicator-dots\nboolean\nfalse\n是否显示面板指示点\n\n\nindicator-color\ncolor\nrgba(0,  0, 0, .3)\n指示点颜色\n\n\nindicator-active-color\ncolor\n#000000\n当前选中的指示点颜色\n\n\nautoplay\nboolean\nfalse\n是否自动切换\n\n\ninterval\nnumber\n5000\n自动切换时间间隔\n\n\ncircular\nboolean\nfalse\n是否采用衔接滑动\n\n\n\n基础内容\n\ntext\n文本组件\n类似于HTML中的span标签，是一个行内元素\n\n\nrich-text\n富文本组件\n支持把HTML字符串渲染为WXML结构\n\n\nbutton\n按钮组件\n功能比 HTML中的button按钮丰富\n通过open-type属性可以调用微信提供的各种功能（客服、转发、获取用户授权、获取用户信息等)\n\n\nimage\n图片组件\nimage 组件默认宽度约300px、高度约240px\n\n\n\n\n\n\nmode 值\n说明\n\n\n\nscaleToFill\n（默认值）缩放模式，不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素\n\n\naspectFit\n缩放模式，保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。\n\n\naspectFill\n缩放模式，保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。\n\n\nwidthFix\n缩放模式，宽度不变，高度自动变化，保持原图宽高比不变\n\n\nheightFix\n缩放模式，高度不变，宽度自动变化，保持原图宽高比不变\n\n\n\nnavigator\n页面导航组件\n类似于HTML中的a链接\n\n\n\n\n表单组件\n\n导航组件\n\n媒体组件\n\nmap 地图组件\n\ncanvas画布组件\n\n开放能力\n\n无障碍访问\n\n\nAPI\n\n事件监听API\n特点:以on开头，用来监听某些事件的触发\n举例:wx.onWindowResize(function callback)监听窗口尺寸变化的事件\n\n\n同步API\n特点1:以 Sync结尾的API都是同步API\n特点2:同步API的执行结果，可以通过函数返回值直接获取，如果执行出错会抛出异常\n举例: wx.setStorageSync(“key’ , ‘value’)向本地存储中写入内容\n\n\n异步API\n特点:类似于jQuery中的$.ajax(options)函数，需要通过success、fail、complete接收调用的结果\n举例: wx.request()发起网络数据请求，通过success回调函数接收数据\n\n\n\n1.4 协同工作和发布协同工作\n\n出于管理需要，我们需要对不同岗位、不同角色的员工的权限进行边界的划分，使他们能够高效的进行协同工作\n\n\n\n\n小程序成员管理体现在管理员对小程序项目成员及体验成员的管理:\n\n项目成员:\n表示参与小程序开发、运营的成员可登录小程序管理后台\n管理员可以添加、删除项目成员，并设置项目成员的角色\n\n\n体验成员:\n表示参与小程序内测体验的成员\n可使用体验版小程序，但不属于项目成员管理员及项目成员均可添加、删除体验成员\n\n\n\n\n不同项目成员对应的权限：\n\n\n\n\n\n权限\n运营者\n开发者\n数据分析者\n\n\n\n开发者权限\n\n√\n\n\n\n体验者权限\n√\n√\n√\n\n\n登录\n√\n√\n√\n\n\n数据分析\n\n\n√\n\n\n微信支付\n√\n\n\n\n\n推广\n√\n\n\n\n\n开发管理\n√\n\n\n\n\n开发设置\n\n√\n\n\n\n暂停服务\n√\n\n\n\n\n解除关联公众号\n√\n\n\n\n\n腾讯云管理\n\n√\n\n\n\n小程序插件\n√\n\n\n\n\n游戏运营管理\n√\n\n\n\n\n\n可以在 微信公众平台-小程序，成员管理中添加项目成员和体验成员\n\n小程序版本\n\n\n\n版本阶段\n说明\n\n\n\n开发版本\n使用开发者工具，可将代码上传到开发版本中。  开发版本只保留每人最新的一份上传的代码。     点击提交审核，可将代码提交审核。开发版本可删除，不影响线上版本和审核中版本的代码。\n\n\n体验版本\n可以选择某个开发版本作为体验版，并且选取一份体验版。\n\n\n审核版本\n只能有一份代码处于审核中。有审核结果后可以发布到线上，也可直接重新提交审核，覆盖原审核版本。\n\n\n线上版本\n线上所有用户使用的代码版本，该版本代码在新版本代码发布后被覆盖更新。\n\n\n发布上线\n\n步骤：\n\n\n上传代码：点击开发者工具的 上传 按钮，填写版本号及备注(查看版本：登录小程序管理后台 – 管理 – 版本管理 )\n\n \n\n提交审核：小程序管理后台版本管理处点击 提交审核 即可\n\n发布：审核通过后会收到通知，在审核列表处点击 发布 即可\n\n\n\n获取小程序码 ：登录小程序管理后台 -&gt; 设置 -&gt; 基本设置 -&gt; 基本信息 -&gt; 小程序码及线下物料下载\n\n运营数据\n\n在“小程序后台”查看\n\n登录小程序管理后台\n点击侧边栏的“统计”\n点击相应的tab可以看到相关的数据\n\n\n使用“小程序数据助手”查看\n\n打开微信  \n搜索“小程序数据助手”\n查看已发布的小程序相关的数据\n\n\n\n","slug":"前端--微信小程序（起步）","date":"2023-02-25T01:22:07.000Z","categories_index":"前端","tags_index":"微信小程序","author_index":"会思想的苇草i"},{"id":"054121162cf16271d339158fbc3ed82e","title":"前端初学者必读：TypeScript入门指南","content":"第一章 快速入门0、TypeScript简介\nTypeScript是JavaScript的超集。\n它对JS进行了扩展，向JS中引入了类型的概念，并添加了许多新的特性。\nTS代码需要通过编译器编译为JS，然后再交由JS解析器执行。\nTS完全兼容JS，换言之，任何的JS代码都可以直接当成JS使用。\n相较于JS而言，TS拥有了静态类型，更加严格的语法，更强大的功能；TS可以在代码执行前就完成代码的检查，减小了运行时异常的出现的几率；TS代码可以编译为任意版本的JS代码，可有效解决不同JS运行环境的兼容问题；同样的功能，TS的代码量要大于JS，但由于TS的代码结构更加清晰，变量类型更加明确，在后期代码的维护中TS却远远胜于JS。\n\n1、TypeScript 开发环境搭建\n下载Node.js\n\n64位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi\n32位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi\n\n\n安装Node.js\n\n使用npm全局安装typescript\n\n进入命令行\n输入：npm i -g typescript\n\n\n创建一个ts文件\n\n使用tsc对ts文件进行编译\n\n进入命令行\n\n进入ts文件所在目录\n\n执行命令：tsc xxx.ts\n\n\n\n\n2、基本类型\n类型声明\n\n类型声明是TS非常重要的一个特点\n\n通过类型声明可以指定TS中变量（参数、形参）的类型\n\n指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错\n\n简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值\n\n语法：\n\nlet 变量: 类型;\nlet a: number;\n\nlet 变量: 类型 = 值;\nlet a: number = 10;\n\nfunction fn(参数: 类型, 参数: 类型): 类型&#123;\n    ...\n&#125;\n function sum(a: number, b: number): number &#123;\n    return a + b;\n&#125;\n\n\n\n\n\n\n自动类型判断\n\nTS拥有自动的类型判断机制\n当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型\n所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明\n\n\n类型：\n\n\n\n类型\n例子\n描述\n\n\n\nnumber\n1, -33, 2.5\n任意数字\n\n\nstring\n‘hi’, “hi”, hi\n任意字符串\n\n\nboolean\ntrue、false\n布尔值true或false\n\n\n字面量\n其本身\n限制变量的值就是该字面量的值\n\n\nany\n*\n任意类型\n\n\nunknown\n*\n类型安全的any\n\n\nvoid\n空值（undefined）\n没有值（或undefined）\n\n\nnever\n没有值\n不能是任何值\n\n\nobject\n{name:’孙悟空’}\n任意的JS对象\n\n\narray\n[1,2,3]\n任意JS数组\n\n\ntuple\n[4,5]\n元素，TS新增类型，固定长度数组\n\n\nenum\nenum{A, B}\n枚举，TS中新增类型\n\n\n\nnumber\n\nlet decimal: number = 6;\nlet hex: number = 0xf00d;\nlet binary: number = 0b1010;\nlet octal: number = 0o744;\nlet big: bigint = 100n;\n\n\n\n\nboolean\n\nlet isDone: boolean = false;\n\n\n\n\nstring\n\nlet color: string = &quot;blue&quot;;\ncolor = &#39;red&#39;;\n\nlet fullName: string = `Bob Bobbington`;\nlet age: number = 37;\nlet sentence: string = `Hello, my name is $&#123;fullName&#125;.\n\nI&#39;ll be $&#123;age + 1&#125; years old next month.`;\n\n\n\n\n字面量\n\n也可以使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围(类似于常量，限定值或范围)\n\nlet color: &#39;red&#39; | &#39;blue&#39; | &#39;black&#39;;\nlet num: 1 | 2 | 3 | 4 | 5;\n\n\n\n\nany\n\n相当于对该变量关闭了TS的类型检测\n\n\nlet d: any = 4;\nd = &#39;hello&#39;;\nd = true;\n//隐式\nlet e;\n\n\n\n\nunknown\n\nunknown类型的变量，不能直接赋值给其他变量\n\n\nlet notSure: unknown = 4;\nnotSure = &#39;hello&#39;;\n\n//类型检查\nlet s:string;\nif(typeof e === &quot;string&quot;)&#123;\n    s = e;\n&#125;\n\n//类型断言\n/*\n语法：\n变量 as 类型\n&lt;类型&gt;变量\n*/\ns = e as string;\n//s = &lt;string&gt;e;\n\n\n\n\nvoid\n\nlet unusable: void = undefined;\n\n//没写void，没写return，默认为void\nfunction fn(): void &#123;\n&#125;\n\n\n\n\nnever\n\n表示永远不会返回结果\n\n\nfunction error(message: string): never &#123;\n  throw new Error(message);\n&#125;\n\n\n\n\nobject（没啥用）\n\nlet obj: object = &#123;&#125;;\n\n// &#123;&#125; 用来指定对象中可以包含哪些属性\n// 语法：&#123;属性名:属性值,属性名:属性值&#125;\n// 在属性名后边加上?，表示属性是可选的\nlet b: &#123; name: string, age?: number &#125;;\nb = &#123; name: &#39;孙悟空&#39;, age: 18 &#125;;\n\n//定义对象结构\n// [propName: string]: any 表示任意类型的属性\nlet c: &#123; name: string, [propName: string]: any &#125;;\nc = &#123; name: &#39;猪八戒&#39;, age: 18, gender: &#39;男&#39; &#125;;\n\n//定义函数结构\n/*\n  设置函数结构的类型声明：\n  语法：(形参:类型, 形参:类型 ...) =&gt; 返回值\n*/\nlet d: (a: number, b: number) =&gt; number;\n// d = function (n1: string, n2: string): number&#123;\n//     return 10;\n// &#125;\n\n\n\n\narray\n\n//类型[]\nlet list: number[] = [1, 2, 3];\n\n//Array&lt;类型&gt;\nlet list: Array&lt;number&gt; = [1, 2, 3];\n\n\n\n\ntuple\n\nlet x: [string, number];\nx = [&quot;hello&quot;, 10]; \n\n\n\n\nenum\n\nenum Color &#123;\n  Red,\n  Green,\n  Blue,\n&#125;\nlet c: Color = Color.Green;\n\nenum Color &#123;\n  Red = 1,\n  Green,\n  Blue,\n&#125;\nlet c: Color = Color.Green;\n\nenum Color &#123;\n  Red = 1,\n  Green = 2,\n  Blue = 4,\n&#125;\nlet c: Color = Color.Green;\n\n// &amp;表示同时\nlet j: &#123; name: string &#125; &amp; &#123; age: number &#125;;\n// j = &#123;name: &#39;孙悟空&#39;, age: 18&#125;;\n\n// 类型的别名\ntype myType = 1 | 2 | 3 | 4 | 5;\nlet k: myType;\nlet l: myType;\nlet m: myType;\n\nk = 2;\n\n\n\n\n类型断言\n\n有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：\n\n第一种\n\nlet someValue: unknown = &quot;this is a string&quot;;\nlet strLength: number = (someValue as string).length;\n\n\n\n\n第二种\n\nlet someValue: unknown = &quot;this is a string&quot;;\nlet strLength: number = (&lt;string&gt;someValue).length;\n\n\n\n\n\n\n\n\n\n3、编译选项\n自动编译文件\n\n编译文件时，使用 -w  指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。\n\n示例：\n\ntsc xxx.ts -w\n\n\n\n\n\n\n自动编译整个项目\n\n如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。\n\n但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json(tsc --init)\n\ntsconfig.json是一个JSON文件，添加配置文件后，只需只需 tsc 命令即可完成对整个项目的编译tsc -w自动监视所有文件\n\n配置选项：\n\ninclude\n\n定义希望被编译文件所在的目录\n\n默认值：[“**&#x2F;*“]    (** 表示任意目录 *表示任意文件)\n\n示例：\n\n&quot;include&quot;:[&quot;src/**/*&quot;, &quot;tests/**/*&quot;]\n\n\n上述示例中，所有src目录和tests目录下的文件都会被编译\n\n\n\n\n\nexclude\n\n定义需要排除在外的目录\n\n默认值：[“node_modules”, “bower_components”, “jspm_packages”]\n\n示例：\n\n&quot;exclude&quot;: [&quot;./src/hello/**/*&quot;]\n\n\n上述示例中，src下hello目录下的文件都不会被编译\n\n\n\n\n\nextends\n\n定义被继承的配置文件\n\n示例：\n\n&quot;extends&quot;: &quot;./configs/base&quot;\n\n\n上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息\n\n\n\n\n\nfiles\n\n指定被编译文件的列表，只有需要编译的文件少时才会用到\n\n示例：\n\n&quot;files&quot;: [\n    &quot;core.ts&quot;,\n    &quot;sys.ts&quot;,\n    &quot;types.ts&quot;,\n    &quot;scanner.ts&quot;,\n    &quot;parser.ts&quot;,\n    &quot;utilities.ts&quot;,\n    &quot;binder.ts&quot;,\n    &quot;checker.ts&quot;,\n    &quot;tsc.ts&quot;\n  ]\n\n\n列表中的文件都会被TS编译器所编译\n\n\n\ncompilerOptions\n\n编译选项是配置文件中非常重要也比较复杂的配置选项\n\n在compilerOptions中包含多个子选项，用来完成对编译的配置\n\n项目选项\n\ntarget\n\n设置ts代码编译的目标版本\n\n可选值：\n\nES3（默认）、ES5、ES6&#x2F;ES2015、ES7&#x2F;ES2016、ES2017、ES2018、ES2019、ES2020、ESNext(ES最新版本)\n\n\n示例：\n\n&quot;compilerOptions&quot;: &#123;\n    &quot;target&quot;: &quot;ES6&quot;\n&#125;\n\n\n如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码\n\n\n\n\n\nlib\n\n指定代码运行时所包含的库（宿主环境）\n\n可选值：\n\nES5、ES6&#x2F;ES2015、ES7&#x2F;ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ……\n\n\n示例：\n\n&quot;compilerOptions&quot;: &#123;\n    &quot;target&quot;: &quot;ES6&quot;,\n    &quot;lib&quot;: [&quot;ES6&quot;, &quot;DOM&quot;],\n    &quot;outDir&quot;: &quot;dist&quot;,\n    &quot;outFile&quot;: &quot;dist/aa.js&quot;\n&#125;\n\n\n\n\n\n\nmodule\n\n设置编译后代码使用的模块化系统\n\n可选值：\n\nCommonJS、UMD、AMD、System、ES2020、ESNext、None\n\n\n示例：\n\n&quot;compilerOptions&quot;: &#123;\n    &quot;module&quot;: &quot;CommonJS&quot;\n&#125;\n\n\n\n\n\n\noutDir\n\n编译后文件的所在目录\n\n默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置\n\n示例：\n\n&quot;compilerOptions&quot;: &#123;\n    &quot;outDir&quot;: &quot;dist&quot;\n&#125;\n\n\n设置后编译后的js文件将会生成到dist目录\n\n\n\n\n\noutFile\n\n将所有的文件编译为一个js文件\n\n默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中\n\n示例：\n\n&quot;compilerOptions&quot;: &#123;\n    &quot;outFile&quot;: &quot;dist/app.js&quot;\n&#125;\n\n\n\n\n\n\nrootDir\n\n指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录\n\n示例：\n\n&quot;compilerOptions&quot;: &#123;\n    &quot;rootDir&quot;: &quot;./src&quot;\n&#125;\n\n\n\n\n\n\nallowJs\n\n是否对js文件编译\n\n\ncheckJs\n\n是否对js文件进行检查\n\n示例：\n\n&quot;compilerOptions&quot;: &#123;\n    &quot;allowJs&quot;: true,\n    &quot;checkJs&quot;: true\n&#125;\n\n\n\n\n\n\nremoveComments\n\n是否删除注释\n默认值：false\n\n\nnoEmit\n\n不对代码进行编译\n默认值：false\n\n\nsourceMap\n\n是否生成sourceMap\n默认值：false\n\n\n\n\n严格检查\n\nstrict\n启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查\n\n\nalwaysStrict\n总是以严格模式对代码进行编译\n\n\nnoImplicitAny\n禁止隐式的any类型\n\n\nnoImplicitThis\n禁止类型不明确的this\n\n\nstrictBindCallApply\n严格检查bind、call和apply的参数列表\n\n\nstrictFunctionTypes\n严格检查函数的类型\n\n\nstrictNullChecks\n严格的空值检查\n\n\nstrictPropertyInitialization\n严格检查属性是否初始化\n\n\n\n\n额外检查\n\nnoFallthroughCasesInSwitch\n检查switch语句包含正确的break\n\n\nnoImplicitReturns\n检查函数没有隐式的返回值\n\n\nnoUnusedLocals\n检查未使用的局部变量\n\n\nnoUnusedParameters\n检查未使用的参数\n\n\n\n\n高级\n\nallowUnreachableCode\n检查不可达代码\n可选值：\ntrue，忽略不可达代码\nfalse，不可达代码将引起错误\n\n\n\n\nnoEmitOnError\n有错误的情况下不进行编译\n默认值：false\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4、webpack\n通常情况下，实际开发中我们都需要使用构建工具对代码进行打包，TS同样也可以结合构建工具一起使用，下边以webpack为例介绍一下如何结合构建工具使用TS。\n\n步骤：\n\n初始化项目\n\n进入项目根目录，执行命令 npm init -y\n主要作用：创建package.json文件\n\n\n\n\n下载构建工具\n\nnpm i -D webpack webpack-cli webpack-dev-server typescript ts-loader clean-webpack-plugin\n共安装了7个包\nwebpack\n构建工具webpack\n\n\nwebpack-cli\nwebpack的命令行工具\n\n\nwebpack-dev-server\nwebpack的开发服务器\n\n\ntypescript\nts编译器\n\n\nts-loader\nts加载器，用于在webpack中编译ts文件\n\n\nhtml-webpack-plugin\nwebpack中html插件，用来自动创建html文件\n\n\nclean-webpack-plugin\nwebpack中的清除插件，每次构建都会先清除目录\n\n\n\n\n\n\n\n\n根目录下创建webpack的配置文件webpack.config.js\n\nconst path = require(&quot;path&quot;);\nconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);\nconst &#123; CleanWebpackPlugin &#125; = require(&quot;clean-webpack-plugin&quot;);\n\nmodule.exports = &#123;\n    optimization:&#123;\n        minimize: false // 关闭代码压缩，可选\n    &#125;,\n\n    entry: &quot;./src/index.ts&quot;,\n    \n    devtool: &quot;inline-source-map&quot;,\n    \n    devServer: &#123;\n        contentBase: &#39;./dist&#39;\n    &#125;,\n\n    output: &#123;\n        path: path.resolve(__dirname, &quot;dist&quot;),\n        filename: &quot;bundle.js&quot;,\n        environment: &#123;\n            arrowFunction: false // 关闭webpack的箭头函数，可选\n        &#125;\n    &#125;,\n\n    resolve: &#123;\n        extensions: [&quot;.ts&quot;, &quot;.js&quot;]\n    &#125;,\n    \n    module: &#123;\n        rules: [\n            &#123;\n                test: /\\.ts$/,\n                use: &#123;\n                   loader: &quot;ts-loader&quot;     \n                &#125;,\n                exclude: /node_modules/\n            &#125;\n        ]\n    &#125;,\n\n    plugins: [\n        new CleanWebpackPlugin(),\n        new HtmlWebpackPlugin(&#123;\n            title:&#39;TS测试&#39;\n        &#125;),\n    ]\n\n&#125;\n\n\n\n\n根目录下创建tsconfig.json，配置可以根据自己需要\n\n&#123;\n    &quot;compilerOptions&quot;: &#123;\n        &quot;target&quot;: &quot;ES2015&quot;,\n        &quot;module&quot;: &quot;ES2015&quot;,\n        &quot;strict&quot;: true\n    &#125;\n&#125;\n\n\n\n\n修改package.json添加如下配置\n\n&#123;\n  ...略...\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,\n    &quot;build&quot;: &quot;webpack&quot;,\n    &quot;start&quot;: &quot;webpack serve --open chrome.exe&quot;\n  &#125;,\n  ...略...\n&#125;\n\n\n\n\n在src下创建ts文件，并在并命令行执行npm run build对代码进行编译，或者执行npm start来启动开发服务器\n\n\n\n\n5、Babel\n经过一系列的配置，使得TS和webpack已经结合到了一起，除了webpack，开发中还经常需要结合babel来对代码进行转换以使其可以兼容到更多的浏览器，在上述步骤的基础上，通过以下步骤再将babel引入到项目中。\n\n安装依赖包：\n\nnpm i -D @babel/core @babel/preset-env babel-loader core-js\n共安装了4个包，分别是：\n@babel&#x2F;core\nbabel的核心工具\n\n\n@babel&#x2F;preset-env\nbabel的预定义环境\n\n\n@babel-loader\nbabel在webpack中的加载器\n\n\ncore-js\ncore-js用来使老版本的浏览器支持新版ES语法\n\n\n\n\n\n\n修改webpack.config.js配置文件\n\n...略...\nmodule: &#123;\n    rules: [\n        &#123;\n            test: /\\.ts$/,\n            use: [\n                &#123;\n                    loader: &quot;babel-loader&quot;,\n                    options:&#123;\n                        presets: [\n                            [\n                                &quot;@babel/preset-env&quot;,\n                                &#123;\n                                    &quot;targets&quot;:&#123;\n                                        &quot;chrome&quot;: &quot;58&quot;,\n                                        &quot;ie&quot;: &quot;11&quot;\n                                    &#125;,\n                                    &quot;corejs&quot;:&quot;3&quot;,\n                                    &quot;useBuiltIns&quot;: &quot;usage&quot;\n                                &#125;\n                            ]\n                        ]\n                    &#125;\n                &#125;,\n                &#123;\n                    loader: &quot;ts-loader&quot;,\n\n                &#125;\n            ],\n            exclude: /node_modules/\n        &#125;\n    ]\n&#125;\n...略...\n\n\n如此一来，使用ts编译后的文件将会再次被babel处理，使得代码可以在大部分浏览器中直接使用，可以在配置选项的targets中指定要兼容的浏览器版本。\n\n\n\n\n\n\n第二章：面向对象0、面向对象简介面向对象是程序中一个非常重要的思想，它被很多同学理解成了一个比较难，比较深奥的问题，其实不然。面向对象很简单，简而言之就是程序之中所有的操作都需要通过对象来完成。\n\n举例来说：\n操作浏览器要使用window对象\n操作网页要使用document对象\n操作控制台要使用console对象\n\n\n\n一切操作都要通过对象，也就是所谓的面向对象，那么对象到底是什么呢？这就要先说到程序是什么，计算机程序的本质就是对现实事物的抽象，抽象的反义词是具体，比如：照片是对一个具体的人的抽象，汽车模型是对具体汽车的抽象等等。程序也是对事物的抽象，在程序中我们可以表示一个人、一条狗、一把枪、一颗子弹等等所有的事物。一个事物到了程序中就变成了一个对象。\n在程序中所有的对象都被分成了两个部分数据和功能，以人为例，人的姓名、性别、年龄、身高、体重等属于数据，人可以说话、走路、吃饭、睡觉这些属于人的功能。数据在对象中被成为属性，而功能就被称为方法。所以简而言之，在程序中一切皆是对象。\n1、类（class）要想面向对象，操作对象，首先便要拥有对象，那么下一个问题就是如何创建对象。要创建对象，必须要先定义类，所谓的类可以理解为对象的模型，程序中可以根据类创建指定类型的对象，举例来说：可以通过Person类来创建人的对象，通过Dog类创建狗的对象，通过Car类来创建汽车的对象，不同的类可以用来创建不同的对象。\n\n定义类：\n\nclass 类名 &#123;\n    属性名: 类型;\n    \n    constructor(参数: 类型)&#123;\n        this.属性名 = 参数;\n    &#125;\n    \n    方法名()&#123;\n        ....\n    &#125;\n\n&#125;\n\n\n\n\n示例：\n\nclass Person&#123;\n    name: string;\n    age: number;\n\n    constructor(name: string, age: number)&#123;\n        this.name = name;\n        this.age = age;\n    &#125;\n\n    sayHello()&#123;\n        console.log(`大家好，我是$&#123;this.name&#125;`);\n    &#125;\n&#125;\n\n\n\n\n使用类：\n\nconst p = new Person(&#39;孙悟空&#39;, 18);\np.sayHello();\n\n\n\n\n\n\n直接定义的属性是实例属性，需要通过对象的实例去访问；使用static开头的属性是静态属性（类属性），可以直接通过类去访问static readonly age: number = 18;；readonly开头的属性表示一个只读的属性无法修改readonly name: string = &#39;孙悟空&#39;;\n\n2、面向对象的特点\n封装\n\n对象实质上就是属性和方法的容器，它的主要作用就是存储属性和方法，这就是所谓的封装\n\n默认情况下，对象的属性是可以任意的修改的，为了确保数据的安全性，在TS中可以对属性的权限进行设置\n\n只读属性（readonly）：\n\n如果在声明属性时添加一个readonly，则属性便成了只读属性无法修改\n\n\nTS中属性具有三种修饰符：\n\npublic（默认值），可以在类、子类和对象中修改\nprotected ，可以在类、子类中修改\nprivate ，可以在类中修改\n\n\n示例：\n\npublic\n\nclass Person&#123;\n    public name: string; // 写或什么都不写都是public\n    public age: number;\n\n    constructor(name: string, age: number)&#123;\n        this.name = name; // 可以在类中修改\n        this.age = age;\n    &#125;\n\n    sayHello()&#123;\n        console.log(`大家好，我是$&#123;this.name&#125;`);\n    &#125;\n&#125;\n\nclass Employee extends Person&#123;\n    constructor(name: string, age: number)&#123;\n        super(name, age);\n        this.name = name; //子类中可以修改\n    &#125;\n&#125;\n\nconst p = new Person(&#39;孙悟空&#39;, 18);\np.name = &#39;猪八戒&#39;;// 可以通过对象修改\n\n\n\n\nprotected\n\nclass Person&#123;\n    protected name: string;\n    protected age: number;\n\n    constructor(name: string, age: number)&#123;\n        this.name = name; // 可以修改\n        this.age = age;\n    &#125;\n\n    sayHello()&#123;\n        console.log(`大家好，我是$&#123;this.name&#125;`);\n    &#125;\n&#125;\n\nclass Employee extends Person&#123;\n\n    constructor(name: string, age: number)&#123;\n        super(name, age);\n        this.name = name; //子类中可以修改\n    &#125;\n&#125;\n\nconst p = new Person(&#39;孙悟空&#39;, 18);\np.name = &#39;猪八戒&#39;;// 不能修改\n\n\n\n\nprivate\n\nclass Person&#123;\n    private name: string;\n    private age: number;\n\n    constructor(name: string, age: number)&#123;\n        this.name = name; // 可以修改\n        this.age = age;\n    &#125;\n\n    sayHello()&#123;\n        console.log(`大家好，我是$&#123;this.name&#125;`);\n    &#125;\n&#125;\n\nclass Employee extends Person&#123;\n\n    constructor(name: string, age: number)&#123;\n        super(name, age);\n        this.name = name; //子类中不能修改\n    &#125;\n&#125;\n\nconst p = new Person(&#39;孙悟空&#39;, 18);\np.name = &#39;猪八戒&#39;;// 不能修改\n\n\n\n\n\n\n属性存取器\n\n对于一些不希望被任意修改的属性，可以将其设置为private\n\n直接将其设置为private将导致无法再通过对象修改其中的属性\n\n我们可以在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的存取器\n\n读取属性的方法叫做setter方法，设置属性的方法叫做getter方法\n\n示例：\n\nclass Person&#123;\n    private _name: string;\n\n    constructor(name: string)&#123;\n        this._name = name;\n    &#125;\n\n    get name()&#123;\n        return this._name;\n    &#125;\n\n    set name(name: string)&#123;\n        this._name = name;\n    &#125;\n\n&#125;\n\nconst p1 = new Person(&#39;孙悟空&#39;);\nconsole.log(p1.name); // 通过getter读取name属性\np1.name = &#39;猪八戒&#39;; // 通过setter修改name属性\n\n\n\n\n\n\n静态属性\n\n静态属性（方法），也称为类属性。使用静态属性无需创建实例，通过类即可直接使用\n\n静态属性（方法）使用static开头\n\n示例：\n\nclass Tools&#123;\n    static PI = 3.1415926;\n    \n    static sum(num1: number, num2: number)&#123;\n        return num1 + num2\n    &#125;\n&#125;\n\nconsole.log(Tools.PI);\nconsole.log(Tools.sum(123, 456));\n\n\n\n\n\n\nthis\n\n在类中，使用this表示当前对象\n\n\n\n\n继承\n\n继承时面向对象中的又一个特性\n\n通过继承可以将其他类中的属性和方法引入到当前类中\n\n示例：\n\nclass Animal&#123;\n    name: string;\n    age: number;\n\n    constructor(name: string, age: number)&#123;\n        this.name = name;\n        this.age = age;\n    &#125;\n&#125;\n\nclass Dog extends Animal&#123;\n\n    bark()&#123;\n        console.log(`$&#123;this.name&#125;在汪汪叫！`);\n    &#125;\n&#125;\n\nconst dog = new Dog(&#39;旺财&#39;, 4);\ndog.bark();\n\n\n\n\n\n\n通过继承可以在不修改类的情况下完成对类的扩展\n\n重写\n\n发生继承时，如果子类中的方法会替换掉父类中的同名方法，这就称为方法的重写\n\n示例：\n\nclass Animal&#123;\n    name: string;\n    age: number;\n\n    constructor(name: string, age: number)&#123;\n        this.name = name;\n        this.age = age;\n    &#125;\n\n    run()&#123;\n        console.log(`父类中的run方法！`);\n    &#125;\n&#125;\n\nclass Dog extends Animal&#123;\n\n    bark()&#123;\n        console.log(`$&#123;this.name&#125;在汪汪叫！`);\n    &#125;\n\n    run()&#123;\n        console.log(`子类中的run方法，会重写父类中的run方法！`);\n    &#125;\n&#125;\n\nconst dog = new Dog(&#39;旺财&#39;, 4);\ndog.bark();\n\n\n在子类中可以使用super来完成对父类的引用(构造函数)\n\n\n\n\n\n抽象类（abstract class）\n\n抽象类是专门用来被其他类所继承的类，它只能被其他类所继承不能用来创建实例\n\nabstract class Animal&#123;\n    abstract run(): void;\n    bark()&#123;\n        console.log(&#39;动物在叫~&#39;);\n    &#125;\n&#125;\n\nclass Dog extends Animals&#123;\n    run()&#123;\n        console.log(&#39;狗在跑~&#39;);\n    &#125;\n&#125;\n\n\n使用abstract开头的方法叫做抽象方法，抽象方法没有方法体只能定义在抽象类中，继承抽象类时抽象方法必须要实现\n\n\n\n\n\n\n3、接口（Interface）接口的作用类似于抽象类，不同点在于接口中的所有方法和属性都是没有实值的，换句话说接口中的所有方法都是抽象方法。接口主要负责定义一个类的结构，接口可以去限制一个对象的接口，对象只有包含接口中定义的所有属性和方法时才能匹配接口。同时，可以让一个类去实现接口，实现接口时类中要保护接口中的所有属性。\n\n示例（检查对象类型）：\n\ninterface Person&#123;\n    name: string;\n    sayHello():void;\n&#125;\n\nfunction fn(per: Person)&#123;\n    per.sayHello();\n&#125;\n\nfn(&#123;name:&#39;孙悟空&#39;, sayHello() &#123;console.log(`Hello, 我是 $&#123;this.name&#125;`)&#125;&#125;);\n\n\n\n\n示例（实现）\n\ninterface Person&#123;\n    name: string;\n    sayHello():void;\n&#125;\n\nclass Student implements Person&#123;\n    constructor(public name: string) &#123;\n    &#125;\n\n    sayHello() &#123;\n        console.log(&#39;大家好，我是&#39;+this.name);\n    &#125;\n&#125;\n\n\n\n\n\n\n4、泛型（Generic）定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定），此时泛型便能够发挥作用。\n\n举个例子：\n\nfunction test(arg: any): any&#123;\n    return arg;\n&#125;\n\n\n上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的，由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的，首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型\n\n使用泛型：\n\nfunction test&lt;T&gt;(arg: T): T&#123;\n    return arg;\n&#125;\n\n\n这里的&lt;T&gt;就是泛型，T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型。所以泛型其实很好理解，就表示某个类型。\n\n那么如何使用上边的函数呢？\n\n方式一（直接使用）：\n\ntest(10)\n\n\n使用时可以直接传递参数使用，类型会由TS自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式\n\n\n\n方式二（指定类型）：\n\ntest&lt;number&gt;(10)\n\n\n也可以在函数后手动指定泛型\n\n\n\n\n\n可以同时指定多个泛型，泛型间使用逗号隔开：\n\nfunction test&lt;T, K&gt;(a: T, b: K): K&#123;\n    return b;\n&#125;\n\ntest&lt;number, string&gt;(10, &quot;hello&quot;);\n\n\n使用泛型时，完全可以将泛型当成是一个普通的类去使用\n\n\n\n类中同样可以使用泛型：\n\nclass MyClass&lt;T&gt;&#123;\n    prop: T;\n\n    constructor(prop: T)&#123;\n        this.prop = prop;\n    &#125;\n&#125;\n\n\n\n\n除此之外，也可以对泛型的范围进行约束\n\ninterface MyInter&#123;\n    length: number;\n&#125;\n\nfunction test&lt;T extends MyInter&gt;(arg: T): number&#123;\n    return arg.length;\n&#125;\n\n\n使用T extends MyInter表示泛型T必须是MyInter的子类，不一定非要使用接口类和抽象类同样适用。\n\n\n\n\n\n\n","slug":"前端--前端初学者必读：TypeScript入门指南","date":"2023-02-13T01:45:38.000Z","categories_index":"前端","tags_index":"TypeScript","author_index":"会思想的苇草i"},{"id":"ddc9a9789fb65bc02a967a2d0baf7db8","title":"数据库原理及应用概述","content":"数据库原理及应用1、数据库系统概述1.1 基本概念数据data\n\n数据库中存储的基本对象，描述事物的符号记录\n\n数据库DB\n\n长期存储在计算机内\n有组织的\n可共享的大量数据的集合\n\n\n数据管理：数据查询、(数据更新)数据插入、数据删除、数据修改\n\n数据库管理系统\n\n位于用户和计算机操作系统之间的一层数据管理软件\n主要功能：\n数据定义\n数据操作\n事务管理和运行管理\n数据存储和查询处理\n建立和维护功能\n\n\n\n数据库系统DBS\n\n采用数据库技术的计算机系统称为DBS\n组成：数据库DB、数据库管理系统DBMS、数据库管理员DBA、应用程序\n优点：\n数据整体结构化 – 数据库系统与文件系统的本质区别\n数据的共享性高、冗余度低、易扩充\n数据独立性高\n物理独立性：数据库数据的存储结构与存取方法与外部应用程序独立\n逻辑独立性：局部逻辑数据结构与全局逻辑数据结构之间的独立性\n\n\n数据统一由DBMS控制\n\n\n\n1.2 数据模型\n数据模型是一种形式机制，用于数据建模，描述数据、数据之间的联系、数据的语义、数据上的操作和数据的完整性约束条件\n\n概念模型(信息模型)：实体-联系(E-R)模型是一种广泛使用的概念模型\n\n数据模型的三要素\n\n数据结构：数据结构描述数据库中的对象和对象之间的联系，是对系统静态特性的描述\n数据操作：数据操作定义数据库中各种数据对象的实例上允许执行的操作和操作规则(查询和更新)，是对系统动态特性的描述\n数据完整性约束：数据的完整性约束条件是一组规则，用以限定符合数据模型的数据库状态和状态的变化，保证数据的正确、有效和相容\n\n\n目前最流行的数据模型是关系模型\n\n关系的每个属性必须取原子值\n\n\n1.3 数据库系统的结构\n模式：对全体数据逻辑结构和特征的描述，对型的描述，不涉及具体值\n实例：模式的一个具体值\n\n三级模式\n\n外模式：外模式也称子模式或用户模式。外模式介于模式与应用之间，是特定数据库用户的数据视图，是与某一具体应用相关的数据局部逻辑结构的描述，一个数据库有多个外模式\n模式：模式也称逻辑模式。模式是数据库中全体数据的总体逻辑结构描述，是所有用户的公共数据视图，一个数据库只有一个模式\n内模式：内模式也称存储模式或物理模式。内模式是数据物理结构和存储方式的描述，定义数据在数据库内部的表示方式，一个数据库只有一个内模式\n\n二级映像\n\n外模式–模式映像\n\n保证数据的逻辑独立性\n\n\n模式–内模式映像\n\n保证数据的物理独立性\n唯一的\n\n\n\n扩展\n\n数据库系统提供三种语言:DDL用于定义数据库模式，DML用于表达数据库的查询和更新，而 DCL用于定义用户对数据对象的访问权限。这三种语言不是独立的，而是集成在一起，形成完整的数据库语言。\n数据管理员负责管理数据库，实施数据的集中控制。\n\n2、实体 – 联系模型2.1  基本概念\n实体：客观存在并且可以相互区分的任何事物，可以是实际对象，也可以是抽象模型\n\n实体集：具有相同属性的实体的集合\n\n码：\n\n超码：能够唯一确定实体集中每个实体的属性集，(包含无关紧要属性的码)\n候选码：真子集都不是超码的极小超码**(”最小“超码)**\n主码：用来区分同一实体集中不同实体的候选码**(从候选码中选即可)**，(最多只能有一个的码)\n码：表示主码或候选码\n对于学生实体集中，{学号}和{学号，姓名}都是超码，{学号}是极小超码，因为它的真子集是空集，不是超码，如果不允许重名的话，{姓名}也是极小超码，{学号}，{姓名}都是候选码，可以选择{学号}作为主码\n\n\n\n\n属性：\n\n简单属性：不能划分成更小部分的属性\n复合属性：可以划分成更小部分的属性(具有层次关系)\n单值属性：是特定的实体在该属性上只能取单个值的属性\n多值属性：是特定的实体在该属性上只能取多个值的属性(具有对等关系)\n基本属性：不能通过其他属性的值来推导出来（即它的值必须存储在系统中）的属性\n派生属性：派生属性的值可以从其他相关属性或实体计算得到，因此派生属性又称计算属性\n\n\n\n\n\nE-R图：\n\n\n2.2 实体-联系图\n联系是多个实体之间的相互联系\n\n联系集是相同类型联系的集合\n\n联系的类型\n\n一对一联系\n一对多(多对一)联系\n多对多联系\n\n\n\n\n\n\n2.3 弱实体集\n如果一个实体集的任何属性集都不足以形成该实体集的码，则称该实体集为弱实体集\n存在码的实体集称为强实体集\n\n\n\n标识实体集： 弱实体集必须与另一个称作标识实体集或属主实体集的强实体集相关联才有意义\n标识性联系： 标识实体集与弱实体集相关联的联系称为标识性联系，表示法：双线菱形\n分辨符： 如果一个属性可以惟一确定存在依赖于同一个强实体的弱实体，则称该属性集为弱实体集的分辨符，表示法：虚下划线\n弱实体的码： 弱实体集的标识实体集的码和该弱实体集的分辨符共同形成弱实体集的码\n部分码： 弱实体集的分辨符又称弱实体集的部分码\n可以与多个标识实体集关联：有的弱实体集还可以与多个标识实体集关联，该弱实体集的码由诸标识实体集的码和弱实体集的分辨符的组合\n另一种处理弱实体集的方法：把它作为其标识实体集的一个多值复合属性，例如可以把家属作为职工的一个多值属性\n不好的设计: 方法将强实体集的码添加到弱实体集的属性集中，将弱实体集转化成强实体集\n\n3、关系数据模型3.1 关系数据库的结构\n关系模型只包含单一的数据结构 – 关系\n\n域：一个具有相同数据类型的值的集合 – 顺序的取值范围\n\n基数：一个域允许的不同取值个数\n\n笛卡尔积：域上面的一种集合运算 – 得到每个域中元素的所有可能的组合 – 基数相乘\n\n关系：笛卡尔积的子集叫做其在域上的集合(可以用二维表和集合来表示关系)\n\n除了语义约束外，对关系的限制主要有两点：\n\n第一，在关系数据库中，只考虑有限关系\n第二，关系的每个属性都必须是原子的\n\n\n关系模式概念对应于程序设计语言中的类型概念，是对关系型的描述，可以表示为R(U, D, DOM, F) – 关系模式名(关系模式的诸属性，属性对应的域，U到D的映射，属性间的数据依赖集定义)\n\n二维表表示关系时列的次序不重要\n\n外码是另外一个表的主码\n\n\n3.2 从ER模型到关系模型\n属性处理\n\n派生属性的处理:转换时我们忽略派生属性\n复合属性的处理:忽略复合属性本身，而直接考虑它的成分属性\n多值属性的处理:为每个多值属性M创建一个关系Rm\n\n\n实体集处理\n\n强实体集处理：实体集名可以作为关系名,实体集的全部属性构成关系的属性\n弱实体集处理：弱实体集名可以作为关系名,弱实体集存在依赖的标识实体集的主码和弱实体集的全部属性构成关系的属性\n\n\n联系集处理\n\n方法一：联系转换成关系模式\n\n联系是一对一的，则每个实体集的码都是关系的码\n联系是一对多(多对一)的，则“多端”实体集的码组合成关系的码\n联系是多对多的，则参与联系的所有实体集的码组合成关系的码\n\n\n方法二：合并\n\n联系是一对一的，则可以和任意一端实体集转换得到的关系模式合并\n联系是一对多的，则和多端实体集转换得到的关系模式合并\n联系是多对多的，则该联系集转换成独立的关系模式\n\n\n\n3.3 关系操作、完整性约束、关系代数\n关系语言的分类 ：关系代数、关系演算、SQL语言\n\n完整性分类：\n\n实体完整性：关系R的所有元组在主码上的值必须惟一，并且在主码的任何属性上都不能取空值\n参照完整性：如果属性集FK是关系R的外码(一个关系中的一个属性是另外一个关系中的主码则这个属性为外码)，它参照关系S的主码Ks ,则R的任何元组在FK上的值等于S的某个元组在主码Ks上的值，或者为空值，对外码取值限制\n用户自定义完整性：反映特定的数据库所涉及的数据必须满足的语义约束条件。由于不存在一般性规则，这些约束条件必须由用户根据实际问题的语义指定，对候选码取值限制\n\n\n基本运算：选择(一元运算符)、投影(一元运算符)、并、差、笛卡尔积\n\n附加运算：交、除、连接、自然连接（必须有同名属性才能进行）\n\n\n4、关系数据库的设计理论\n不好的关系模式：冗余、插入异常、更新异常、删除异常\n\n4.1 函数依赖\n数据依赖是语义概念,是关于关系诸属性值之间内在相关性的陈述,它规定了关系模式的合法关系实例所必须满足的条件\n\n\n\n平凡的函数依赖(X包含Y)、非平凡的函数依赖\n\n4.2 关系模式\n1NF要求关系的所有属性值都是原子的，是对关系模式的基本要求，不满足1NF的数据模式不能称为关系模式，即所有关系模式都是1NF\n\n2NF对于任意的非平凡函数依赖X→A∈F^+^ :A是主属性，X不是R的任意码的真子集\n\n3NF对于任意的非平凡函数依赖X→A∈F^+^：A是主属性，X是R的码\n\nBCNF 限制R中成立的所有函数依赖要么是平凡的，要么是对码的依赖。对于任何关系模式R，以下两种两数依赖必定成立:平凡的函数依赖；任意属性对超码的依赖\n\n主属性：一个属性只要在任何一个候选码中出现过，这个属性就是主属性。\n\n非主属性：一个属性没有在任何候选码中出现过，这个属性就是非主属性。\n\n部分函数依赖：设有关系R(A,B,C)，若AB→C，A→C，则C部分函数依赖于AB。\n\n完全函数依赖：设有关系R(A,B,C)，若AB→C，A!→C，B!→C，则C完全函数依赖于AB。\n\n传递函数依赖：设有关系R(A,B,C)，若A→B，B→C，则C传递函数依赖于A。\n\n1NF：关系中的每个属性都不可再分。\n\n2NF：在1NF的基础之上，消除了非主属性对于候选码的部分函数依赖。\n\n3NF：在2NF的基础之上，消除了非主属性对于候选码的传递函数依赖。\n\nBCNF：在3NF的基础之上，消除主属性对于候选码的部分函数依赖与传递函数依赖。\n\n\n\n4.3 在设计中使用规范化理论\n规范化的总体目标是:消除某些冗余，避免存储异常，产生一种直观、易于扩充、可以很好描述现实世界，并且可以简单地验证某些语义约束的设计\nER模型与规范化\n完全规范化导致许多逻辑上相互分离的关系;涉及多个关系的查询需要求多个关系的自然连接，而自然连接是一种非常耗时的运算，从而会影响查询性能。解决方案:引入“冗余”的关系模式，即逆规范(denormalization) \n(操作时间冲突):逆规范化只对某些查询有利，而对另一些查询不利或对更新不利。解决方案:物化视图( materialized view ，对应SQL SERVER索引视图)\n\n5、数据库设计\n数据库设计步骤：需求分析 → 概念设计 → 逻辑结构设计 → 物理结构设计 → 数据库试运行和维护阶段\n\n5.1 数据库设计概述\n数据库设计就是根据用户应用需求和数据库的支撑环境（包括DBMS、操作系统和硬件)，设计出数据模式（包括外模式、模式和内模式)、建立数据库和典型的应用程序﹐使之能够有效地存储数据，满足各种用户的信息要求和处理要求。\n数据库设计的成果有：数据模式，以数据库为基础的典型应用程序\n数据库设计的目标是为用户和各种应用系统提供一个信息基础设施和高效的运行环境，即存取效率高、存储空间的利用率高，数据库系统运行管理效率高\n数据库设计的特点：反复性、试探性、多阶段性、多技术性\n设计之前的工作 – 可行性分析\n\n5.2 需求分析\n调查应用领域，对应用领域中各种应用的信息要求、处理要求、安全性和完整性要求进行详细分析，形成需求分析说明书\n数据字典是需求分析阶段所取得的主要成果之一 – 为设计人员提供了关于数据详细描述的信息\n数据项是数据的基本单元或最小单位\n数据结构是若干数据项组成的有意义的集合，它反映了数据之间组合关系\n数据流是数据在系统中的传输路径,它由一个处理传到另一个处理\n处理过程也称加工过程，这里指数据库应用程序模块\n\n5.3 概念结构设计\n逐步扩张(滚雪球)和混合策略(自顶向下和自底向上混合)\n数据抽象 – 将具有某些共同特性和行为的对象抽象为一个概念\n分E-R图集成：合并(消除冲突 [属性冲突、命名冲突、结构冲突])和优化(消除冗余)\n概念结构设计阶段的成果是全局ER图\n\n5.4 逻辑结构设计\n关系的分解：\n水平分解：把关系的元组分为若干子集，对每个子集定义一个子关系，以提高系统的效率\n垂直分解：把关系模式R的属性分解为若干子集合，形成多个子关系模式，从而将对应的关系也分解成多个子关系，优点是可以提高某些查询的效率\n\n\n逻辑结构设计阶段的成果是关系模式，对关系模式进行优化，外模式设计在此阶段设计\n\n5.5 物理结构设计\n数据库在物理设备上的存储结构和存取方法就称为数据库的物理结构\n\n数据库的物理结构设计∶就是为一个给定数据库的逻辑结构选取一个最适合应用环境的物理结构和存取方法的过程，目的是为了提高数据库的访问速度并有效地利用存储空间\n\n常用索引方法 – 聚簇：为了提高某个属性(或属性组)的查询速度，把这个或这些属性(称为取簇码）上具有相同值的元组集中存放在同一个物理块或若干个相邻的物理块或柱面内\n\n对已有关系建立聚簇，将导致关系中元组物理存储位置的变化，并使此关系上原有的索引无效，必须重建\n\n确定数据库的物理结构主要指：\n\n确定数据的存放位置和存储结构，包括确定关系、索引、聚簇、日志、备份等存储安排和存储结构\n确定系统配置\n\n\n确定数据的存放位置和存储结构要综合考虑\n\n存取时间\n\n存储空间利用率\n\n维护代价\n\n\n\n为了提高系统性能，应该根据应用情况将数据的易变部分与稳定部分，经常存取部分和存取频率较低部分分开存放\n\nDBMS产品一般都提供了一些系统配置变量、存储分配参数、供设计人员和DBA对数据库进行物理优化\n\n\n5.6 数据库的实施和维护\n建立数据库模式\n加载数据\n试运行将检验数据库系统的设计是否达到设计目标、能否满足实际需要\n确认系统能够满足实际需要之后﹐系统才能正式投入使用，进入漫长的运行维护阶段\n\n6、 关系数据库标准语言6.1 SQL概述\nSQL的数据定义语言(DDL)、SQL的数据操纵语言(DML)、SQL的数据控制语言(DCL)\nSQL的特点集多种数据库语言于一体、高度非过程化(大大减轻了用户负担&#x2F;有利于提高数据的独立性)、面向集合的操作方式、一种语法两种使用方式、功能强大，语言简洁\n\n6.2 SQL的数据类型\nCHAR(n):定长字符串，长度n由用户指定·省略n时，长度为1,CHAR的全称是CHARACTER\nVARCHAR(n):变长字符串，最大长度n由用户指定, VARCHAR的全称是CHARACTER VARYING\nBIT(n):定长二进位串，长度n由用户指定。省略n时，长度为1\nBIT VARYING(n):变长二进位串，最大长度n由用户指定\nINT:整数，其值域依赖于具体实现。INT的全称是INTEGER\nSMALLINT :小整数，其值域依赖于具体实现，但小于INT的值域\nDEC(p, d): p位有效数字的定点数，其中小数点右边占d位。DEC的全称是DECIMAL\nFLOAT(n):精度至少为n位数字的浮点数，其值域依赖于实现REAL:实数，精度依赖于实现\nDOUBLE PRECISION:双精度实数，精度依赖于实现，但精度比REAL高\nDATE:日期，包括年﹑月﹑日，格式为YYYY-MM-DD\nTIME:时间，包括时﹑分﹑秒,格式为HH:MM:SS ° TIME(n)可以表示比秒更小的单位，秒后取n位\nTIMESTAMP:时间戳，是DATE 和 TIME的结合\nINTERVAL:时间间隔·SQL允许对DATE 、TIME和INTERVAL类型的值进行计算\nSQL提供ETRACT(field FROM Var) , Var可以是DATE ·TIME 或TIMESTAMP数据类型的变量,ETRACT函数的功能是从 Var 中提取字段field\n\n6.3 模式、表、索引的定义和删除模式\n\n目录(catlog) – 模式(schema) – 对象\n\n符号说明：\n\n&lt; X &gt;表示X是需要进一步定义或说明语言成分\n[X]表示X可以缺省或出现一次\n{}表示X可以出现一次\nX |Y表示或者X出现，或者Y出现，但二者不能同时出现\n\n\n模式的定义：\n\nCREATE SCHEMA&lt;模式名&gt;[&lt;模式元素&gt;….]\nCREATE SCHEMA[&lt;模式名&gt;]AUTHORIZATION&lt;用户名&gt; – 授权\n\n\n模式删除：DROP SCHEMA&lt;模式名&gt; CASCADE|RESTRICT\n\nCASCADE，则删除&lt;模式名&gt;指定模式得同时并删除该模式中的所有数据库对象(基本表﹑视图﹑断言等)\nRESTRICT，则仅当&lt;模式名&gt;指定的模式不包含任何数据库对象时才删除指定的模式，否则拒绝删除\n\n\n\n表\n\n表的定义：CREATE TABLE&lt;表名&gt;\n\n列级约束的定义：**[CONSTRAINT&lt;约束名&gt;]&lt;列约束&gt;**\n\nNOT NULL\nPRIMARY KEY\nUNIQUE\nCHECK&lt;条件&gt;\n\n\n表级约束的定义：**[CONSTRAINT&lt;约束名&gt;]&lt;表约束&gt;**\n\nPRIMARY\nUNIQUE\nCHECK\nFOREIGN KEY\n\n\n修改基本表：ALTER TABLE&lt;表名&gt;\n\n[ADD[COLUMN]&lt;列名&gt;&lt;数据类型[列级约束定义]]\n[[ALTER[COLUMN]&lt;列名&gt;{SET DEFAULT&lt;缺省值&gt;| DROP DEFAULT}]\n[DROP [ COLUMN ]&lt;列名&gt;{CASCADE|RESTRICT}]\n[[ADD&lt;表约束定义&gt;]\n[DROP CONSTRAINT&lt;约束名&gt;{CASCADE|RESTRICTH]\n\n\n删除基本表：DROP TABLE&lt;表名&gt;{CASCADE|RESTRICT}\n\n\n索引\n\nCREATE [UNIQUE] [CLUSTER] INDEX&lt;索引名&gt;ON&lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;]{,&lt;列名&gt;[&lt;次序&gt;]})\n&lt;索引名&gt;为建立的索引命名\n&lt;表名&gt;是要建立索引的基本表的名字\n次序可以是 ASC (升序)和 DESC (降序)，缺省值为ASC\n\n\nUNIQUE表示该索引为惟一性索引UNIQUE缺省时，创建的索引为非唯一性索引；CLUSTER表示建立的索引是聚簇索引，缺省时为非聚簇索引；创建索引不仅创建索引结构，而且将索引的定义存储在数据字典中\n索引删除：DROP INDEX&lt;索引名&gt;\n\n6.4 数据操作\nSELECT\n\nSELECT[ALL | DISTINCT]&lt;选择序列&gt;\nFROM&lt;表引用&gt;,…,&lt;表引用&gt;\n[WHERE&lt;查询条件&gt;]\n[GROUP BY&lt;分组列&gt;{&lt;分组列&gt;}[HAVING&lt;分组选择条件&gt;]\n[ORDER BY&lt;排序列&gt;[ASC | DESC]{,&lt;排序列&gt;[ASC lDESC}\n\n\nSELECT后可以使用集合量词ALL或DISTINCT，缺省时为ALL;ALL不删除结果的重复行，而DISTINCT将删除结果中的重复行\n\nBETWEEN表达式：**&lt;值表达式&gt;[NOT] BETWEEN&lt;下界&gt;AND&lt;上界&gt;**\n\nIN表达式：\n\n&lt;值表达式&gt;[NOT]IN(&lt;值表达式列表&gt;)\n&lt;元组&gt; |[NOT] IN&lt;子查询&gt;\n\n\nLIKE表达式：**[NOT] LIKE&lt;匹配串&gt;[ESCAPE‘&lt;换码字符&gt;’]**\n\nNULL表达式：**&lt;值表达式&gt;&lt;子查询&gt;IS [ NOT ] NULL**\n\n排序：ORDER BY&lt;排序列&gt;[ASC | DESC] {,&lt;排序列&gt;[ASCDESC]}\n\n聚集函数\n\n分组语句group by：GROUP BY&lt;分组列&gt;{，&lt;分组列&gt;}[HAVING&lt;分组选择条件&gt;]\n\n对于带GROUP BY子句的SELECT语句,SELECT子句中的结果列必须是GROUPBY子句中的&lt;分组列&gt;或聚集函数；分组语句细化了聚集函数作用的作用对象\n\n连接查询、嵌套查询、子查询、集合查询\n\n\n数据更新\n\n插入：INSERRT INTO T[] VALUES()                  &#x2F;            INSERT INTO T[]\n删除：DELETE FROM T [ WHERE&lt;删除条件&gt;]\n修改：UPDATE T SET A1 &#x3D; e1, …,Ak &#x3D; ek[WHERE&lt;修改条件&gt;]\n\n例：\n1.在产品表(Products)中找出库存大于50的产品的所有信息，按产品编号升序排序。\nSELECT * FROM Products WHERE UnitsInStock&gt;=50 ORDER BY ProductID\n2.查询顾客表(Customers)中所有不重复的所在城市，并升序排序。\nSELECT DISTINCT City FROM Customers ORDER BY City\n3.在顾客表(Customers)中找出所在城市为London、Madrid、Torino和Paris的顾客编号及电话。\nSELECT CustomerID,Phone FROM Customers WHERE City IN (&#39;London&#39;,&#39;Madrid&#39;,&#39;Torino&#39;,&#39;Paris&#39;)\n4.在产品表(Products)中找出单位数量中有box的产品名和产品编号。\nSELECT ProductName,ProductID FROM Products WHERE QuantityPerUnit LIKE &#39;%box%&#39;\n5.在顾客表(Customers)中找出公司名的首字母为F，第5位为k的顾客编号和联系人名。\nSELECT CustomerID,ContactName FROM Customers WHERE CompanyName LIKE &#39;F___k%&#39;\n6.统计在’1997-10-1’ 到’1997-10-7’期间，订单中每个员工的订单数，并按订单数降序排序。\nSELECT EmployeeID&quot;员工编号&quot;,COUNT(ORDERID)&quot;订单数&quot; FROM Orders WHERE OrderDate BETWEEN &#39;1997-10-1&#39;ANd&#39;1997-10-7&#39; GROUP　BY EmployeeID ORDER BY COUNT(OrderID) DESC\n7.请查询平均价格在30元及以上的产品类型。\nSELECT CategoryID,AVG(UnitPrice)&#39;平均价格&#39; FROM Products GROUP　BY CategoryID Having AVG(UnitPrice)&gt;=30\n8.查询’1997-10-7’当天所售商品的库存情况，包括商品编号、名称、库存。\nSELECT Products.ProductID,ProductName,UnitsInStock FROM Products,Orders,[Order Details] WHERE Products.ProductID=[Order Details].ProductID AND [Order Details].OrderID=Orders.OrderID AND OrderDate=&#39;1997-10-7&#39;\n6.5 视图\n定义：CREATE VIEW&lt;视图名&gt;[(&lt;列名&gt;，…,&lt;列名&gt;)]AS&lt;查询表达式&gt;[WITH CHECK OPTION]\n\n删除：DROP VIEW&lt;视图名&gt;[ CASCADE |RESTRICT ]\n\n视图的优点：\n\n\n\n视图能够简化用户的操作\n\n视图使用户能以多种角度看待同一数据\n\n视图重构数据库提供了一定程度的逻辑独立性\n\n视图能够对机密数据提供安全保护\n\n视图能够更清晰的表达\n\n\n7、数据库的完整性7.1  完整性概述\n数据库的完整性是指数据库中数据是正确的(数据库的数据是符合语义约束的数据)、一致的(数据之间的逻辑关系是正确的)和相容的(同一个事实的两个数据应当是一致的)\n\n约束的分类：(就被约束的数据对象而言)\n\n类型&#x2F;域约束\n属性约束\n关系约束\n数据库约束\n\n\n约束的分类：(从约束的状态的角度)\n\n静态约束（数据库正确状态）\n动态约束（数据库状态转移）\n\n\nDBMS必须提供完整性控制的机制有：定义完整性约束条件的方法、完整性检查机制、违约处理\n\n可以实现级联操作的短语是：CASCADE\n\n\n7.2 实体完整性\n实体完整性要求:\n\n每个关系应该有一个主码，每个元组的主码值惟一确定该元组\n主码的任何属性都不能取空值\n\n\n违反的操作： 插入新元祖、修改元祖的主码、DBMS自动检查、SQL支持实体完整性\n\n\n7.3 参照完整性\n参照完整性要求:\n\n参照关系R的任何元组在其外码FKR上的值或者等于被参照关系S的某个元组在主码K上的值，或者为空值\n\n\n违法的操作：向参照关系R插入、修改参照关系R外码上的值、删除(修改)被参照关系S的元组\n\n向数据库表中插入数据违法参照完整性规则时，系统所做的操作是：拒绝\n\n\n7.4 用户自定义完整性\n用户自定义的完整性约束：用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求，用户定义的完整性可以是：\n\n属性级\n关系级\n数据库级\n\n\n域约束：每个属性都必须在一个值域上取值\n\n属性约束：属性的取值必须来自其定义的值域\n\n关系约束：说明关系的合法取值，常常涉及同一关系的多个属性和或多个元祖\n\n断言与数据库约束：断言是一种命名约束，表达了数据库状态必须满足的逻辑条件\n\n\n7.5 触发器\n触发器( trigger）是特殊类型的存储过程，当某个事件发生时它自动执行\n按触发事件分：DELETE触发器、INSERT触发器、UPDATE触发器\n定义触发器操作的SQL语句：CREATE TRIGGER\n\nCREATE TRIGGER `register` AFTER UPDATE ON `student` FOR EACH ROW BEGIN\n UPDATE driver_school SET total_number = (total_number + 1) WHERE driver_school.id = student.school_id;\nEND\n\n8、数据库编程与访问技术8.1 T-SQL\n变量：局部变量–变量名前加一个@，全局变量–变量名前加两个@@\n变量的声明与赋值：&lt;@var&gt;\n运算符：算术运算符、比较运算符、逻辑运算符、位运算符、字符串连接运算符–‘+’\n函数\n流程控制语句\n\n\n8.2 存储过程\n存储过程是为了完成特定功能汇集而成的命名了的一组SQL语句集合\n编译、优化后存储，可多次执行\n\n\n优点：将业务操作封装、实现一定程度的安全性保护、适合复杂的统计和查询操作\n\nCREATE PROCEDURE &lt;procedureName&gt; --&lt;procedureName&gt;存储过程名称\n    [(&lt;@parameterName&gt;&lt;datatype&gt;[=&lt;defaultValue&gt;][OUTPUT]--&lt;@parameterName&gt; 参数名\n       [,&lt;@parameterName&gt;&lt;datatype&gt;[=&lt;defaultValue&gt;][OUTPUT]])]--OUTPUT输出参数\nAs\n    &lt;SQL-Statements&gt;\n\n8.3  数据库访问技术\nODBC：一组对数据库访问的标准API\nDAO与RDO\nJDBC访问步骤：\n导入包\n加载JDBC驱动程序\n打开一个数据库连接\n执行一个查询\n从结果集中提取数据\n清理环境\n\n\n\n9、数据库的安全性9.1 概述\n数据库的安全性是指保护数据库，防止因用户非法使用数据库造成数据泄露、更改或破坏\n恶意访问的形式：未经授权读取、修改、删除数据\n安全性保护手段：用户标识与鉴别、强制存取控制、审计和加密、自主存取和控制、视图\n\n9.2 用户识别与标识\n用户标识与鉴别是系统提供的最外层安全保护措施\n\n其基本方法是:系统提供一定的方式让用户标识自己的名字或身份;系统内部记录着所有合法用户的标识;每次用户要求进入系统(与数据库连接)时，由系统核对用户提供的身份标识;通过鉴别的合法用户才能进入系统，建立数据库连接\n\n\n9.3 存取控制\n存取控制是数据库系统的主要安全措施：自主存取控制，强制存取控制\n\n9.4 自主存取控制\n存取控制的任务：\n授权（DCL中提供了相应的授权语句，允许用户自主地定义存取权限，并将用户的授权登记在数据字典中）\n合法权限检查（当用户发出存取数据库的操作请求后，DBMS将查找数据字典，根据用户权限进行合法权限的检查;如果用户的操作请求超出了自身的权限，系统将拒绝执行此操作2）\n\n\n权限的授予与回收：\nGRANT&lt;权限列表&gt;ON&lt;对象名&gt;TO&lt;用户&#x2F;角色列表&gt;[WITH GTANT OPTION]\nREVOKE&lt;权限列表&gt;ON&lt;对象名&gt;FROM&lt;用户&#x2F;角色列表&gt;{CASCADE|RESTRICT}\n\n\n\n9.5 强制存取控制\n自主存取控制不能阻止副本的非授权传播\n\n强制存取控制( Mandatory Access Control ，简称MAC）是系统为保证更高程度的安全性所采取的强制存取检查手段\n\n在MAC中,DBMS所管理的全部实体被分为主体和客体两大类：\n\n主体是系统中的活动实体，可以是DBMS管理的实际用户或代表用户的各个进程\n客体是系统中的被动实体，是受主体操纵的对象·如文件、基本表、索引、视图等\n\n\n敏感度标记：绝密、机密、秘密、公开\n\n主体的敏感度标记称为许可证级别（ Clearance Level)\n客体的敏感度标记称为密级（ Classification Level )\n\n\n仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体；仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体\n\n\n9.6 视图机制\n视图是定义外模式,为用户提供个性化数据库模型的一种手段\n利用视图实现安全保护的基本思想是:\n首先通过定义视图，屏蔽掉一部分需要对某些用户保密的数据\n然后，在视图上定义存取权限，将对视图的访问权授予这些用户，而不允许他们直接访问定义视图的关系(基本表)\n\n\n\n9.7 其它措施\n审计启用一个专门的审计日志（ Audit Log），自动记录所有用户对数据库的更新操作(插入、删除和修改)\n数据加密的基本思想:按照一定的加密算法，将原始数据(明文)变换成不可直接识别的格式(密文)，使得不知道解密方法的人即使获得数据，也不知道数据的真实内容，从而达到保护数据的目的\n\n10、事务于并发控制10.1 事务与并发控制事务\n\n事务是用户定义的一个数据库的操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单元\n事务是并发控制与调度的基本单位，也是数据库恢复的基本单位\n事务的特点：(ACID)原子性、一致性、隔离性、持久性\n事务状态\n活动状态：初始状态，事务执行时处于该状态\n部分提交状态：最后一条语句被执行后的状态\n失败状态：正常的执行不能持续后的状态\n中止状态：事务回滚并且数据库已被恢复到事务开始执行前的状态\n重启事务\n废除事务\n\n\n提交状态：成功完成后的状态\n\n\n\n\n\nSQL对事务的支持：COMMIT WORK–提交当前事务；ROLLBACK WORD–中止当前事务；SET TRANSACTION–设置事务的特性\n这里&lt;级别&gt;从低到高依次为\nREAD UNCOMMITED读未提交的修改，只能在只读状态下使用\nREAD COMMITED读提交的修改\nREPEATABLE READ可重复读\nSERIALIZABLE可串行化\n\n\n隔离级别越高(低)，可能出现的问题越少(多)，系统并发度越低（高)\n\n并发控制\n\n为了防止数据库的不一致性，对多个运行的事务需要并发控制\n保证事务的一致性、隔离性\n相对于串行执行，并发执行优点有：提高吞吐量和资源利用率、减少等待时间；缺点有：丢失修改、读脏数据、不可重复读\n\n10.2 封锁\n并发控制的主要技术有：封锁、时间戳、乐观控制法、多版本并发控制\n所谓封锁就是事务T在对某个数据对象操作之前，先向系统发出加锁请求，加锁后事务T就对该数据对象有了一定的控制权，在事务T释放它的锁之前，其它事务不能更新该数据对象\n基本锁类型：共享锁S(读锁，可读不可写)和排他锁X(写锁，可读可写)\n\n\n\n封锁协议：\n\n一级封锁协议 防止丢失修改\n二级封锁协议 防止读“脏”数据\n三级封锁协议 进一步保证可重复读\n\n\n活锁与死锁：活锁又称饥饿，是某个事务因等待锁而处于无限期等待状态(解决–先来先服务)；死锁是两个或两个以上的事务之间的循环等待现象(解决–一次封锁法、顺序封锁法)\n\n死锁的检测与解除：超时法和等待图法\n\n解除死锁：选择一个或多个处于死锁状态的事务，将其撤销并释放这些事务持有的所有的锁，从而打破了循环等待条件，解除死锁，使得其他事务能够继续运行。当然,被撤消的事务对数据库的更新必须恢复(回滚)，并且要在稍后需要重新运行\n\n\n10.3 并发调度的可串行化\n并发调度正确性准则：一组事务的一个并发调度S是正确的，当且仅当调度S的执行结果与某一个串行调度的执行结果相同。此时，我们称并发调度S是可串行化的\n\n10.4 两阶段协议\n两段锁协议：是最常用的一种封锁协议、理论上已经证明使用该协议可保证并发调度串行化\n为了避免级联回滚，产生了两种改进的两阶段封锁协议：严格两阶段封锁协议、强两阶段封锁协议\n\n10.5 多粒度封锁\n系统能够同时支持多种封锁粒度供不同的事务选择的封锁方法称之为多粒度封锁\n选择封锁粒度时应该同时考虑封锁开销和并发度两个因素：\n封锁的粒度越大，数据库所能封锁的数据单元就越少，并发度就越小，系统开销就越小\n封锁的粒度越小，并发度就高，系统开销就越大\n\n\n\n11、数据库的恢复技术1.1 概述\n数据库的恢复机制就是负责将数据库恢复到故障发生前的某一个一致状态，并将崩溃后的数据库不能使用的时间减少到最小\n故障的类型：\n事务故障：事务程序的逻辑错误，系统错误\n系统故障：\n介质故障：磁盘损坏导致的故障\n\n\n故障恢复技术的基本思想：在系统正常时建立冗余数据（通过登记日志、数据转储），保证有足够的信息可用于故障恢复；故障发生后采取措施将数据库内容恢复到某个一致性状态，保证事务原子性和持久性\n\n1.2 存储器结构\n存储器类型：\n\n易失性存储器：内存、高速缓存\n非易失性存储器：磁盘、磁带\n稳定存储器：理想的存储器\n\n\n采用冗余独立磁盘阵列可以保证单个磁盘的故障不会导致数据丢失\n\n数据访问通过input和output将块在主存和磁盘之间移动\n\n\n1.3 恢复技术基于日志的恢复技术\n\n日志是日志记录的序列，记录了数据库中所有的更新活动\n日志记录的格式：事务标识符、操作类型、操作对象、旧值、新值\n日志登记的原则：日志记录必须严格按并发事务执行的时间次序登记；必须先记日志，后写数据库\nredo(正序)和undo(逆序)操作\n延迟更新指的是将事务对数据库的更新推迟到事务提交之后\n即时更新技术允许事务在活跃状态时就将更新输出到数据库中\n系统故障发生，哪些事务需要重做，事务需要回滚\n什么时候重做——系统故障发生之前，事务A已经提交，事务A需要重做\n什么时候回滚——系统故障发生时，事务B已经开始，但未提交，而且没有回滚\n什么时候不做处理——系统发生故障前，已经回滚\n（PS:注意检查点隔断问题！！！)\n\n\n\n基于检查点的恢复技术\n\n提高系统故障恢复效率的基本方法是使用检查点技术\n\n在建立检查点时，不允许事务执行任何更新动作，如写缓冲块或写日志记录；建立检查点之后，所有在检查点前发生的更新都已经输出到数据库中，尚未完成的事务都登记在检查点记录中；这样，发生系统故障时，只需要从最近的检查点记录开始扫描日志\n\n对于事务故障用处不大，对于系统故障能提高效率\n\n\n缓冲技术\n\n日志缓冲：一个日志记录通常远小于稳定存储器的块。为了提高I&#x2F;O效率，日志记录在主存中被缓冲，而不是直接输出到稳定存储器；当缓冲区被日志记录装满，或者执行日志强制输出时，日志记录才被输出到稳定存储器；日志缓冲减少了将日志输出到稳定存储器的开销，但是也带来了风险:一旦发生系统发生故障，缓冲区中的日志记录将丢失\n数据库缓冲：数据库存储在非易失性存储器中，在需要时再将相应的数据块调入主存，存在闩锁\n\n转储\n\n转储是指将整个或部分数据库复制到磁带或另一个磁盘上，产生数据库后备副本的过程；后备副本可以脱机保存，供介质故障恢复时使用（因此，转储又称归档)；一旦数据库遭到破坏，就可以将后备副本重新装入，将数据库恢复到转储时的状态，分为静态转储&#x2F;动态转储或者海量转储&#x2F;增量转储\n\n其他恢复技术\n\n影子分页技术\n数据库镜像\n\n","slug":"计算机数据库原理及应用概述","date":"2023-02-10T04:36:13.000Z","categories_index":"计算机科学与技术","tags_index":"数据库原理及应用","author_index":"会思想的苇草i"},{"id":"42ad5343960ce09baf2db672de3117be","title":"计算机网络概述","content":"计算机网络1、概述1.1 计算机网络基本概念\n网络（计算机网络）：网络（Network）由若干结点（Node）和连接这些结点的链路（Link）组成。\n\n三大类网络\n\n电信网络:提供电话、电报及传真等服务;\n有线电视网络:向用户传送各种电视节目;\n计算机网络:使用户能在计算机之间传送数据文件;发展最快的并起到核心作用的是计算机网络。\n\nInternet 和 internet 的区别\n\ninternet(互连网)：通用名词，它泛指由多个计算机网络互连而成的网络。\n\nInternet(因特网、互联网)：专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定计算机网络，它采用 TCP&#x2F;IP 协议族作为通信的规则，且其前身是美国的 ARPANET。\n\n万维网：互联网上的应用\n\n互联网具有两个重要基本特点：连通性和共享\n\n\n因特网发展的三个阶段\n\n第一阶段：从单个网络向互联网发展的过程。1983 年 TCP&#x2F;IP 协议成为 ARPANET 上的标准协议。\n第二阶段：建成三级结构的互联网。主干网、地区网和校园网（或企业网）。\n第三阶段：形成多层次的ISP（Internet Service Provider 因特网服务提供者）结构的互联网\n\n互联网的组成\n\n边缘部分：用户直接使用\n核心部分：为边缘部分提供服务\n\n计算机网络拓扑：星型、环形、总线型、树形与网状\nInternet工作模式\n\n客户服务器方式（C&#x2F;S方式）：即Client&#x2F;Server方式。（客户是服务的请求方，服务器是服务的提供方）\n对等方式（P2P方式）：即Peer-to-Peer方式。（对等连接中的每一个主机既是客户又同时是服务器）\n\n1.2 互联网核心部分:数据交换\n在网络核心部分起特殊作用的是路由器(router)\n\n路由器是实现分组交换 (packet switching) 的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能\n\n\n数据交换的三种方式\n\n电路交换  – 用户始终占用端到端的通信资源\n报文交换**(存储转发)**\n分组交换：高效，灵活，迅速，可靠(存储转发)\n\n\n\n1.3 计算机网络的性能指标\n速率：比特( bit)是计算机中数据量的单位，也是信息论中使用的信息量的单位。指连接在计算机网络上的主机在数字信道上传送数据的速率。b&#x2F;s（bps） 如100M以太网，实际是指100Mb&#x2F;s。往往是指额定速率或标称速率。\n带宽：指信号具有的频带宽度(信号各种不同频率成分所占据的频率范围)。数字信道所能传送的最高速率。b&#x2F;s（bps）\n\n\n\n吞吐量：表示在单位时间内通过某个网络(或信道﹑接口)的数据量，也是一种速率。其绝对上限值等于带宽。\n\n时延：数据（一个报文或分组、甚至比特）从网络（或链路）的一段传送到另一端的时间，也称延迟。\n\n① 发送时延：主机或路由器发送数据帧所需的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。也成传输时延。发送时延 &#x3D; 数据帧长度（b） &#x2F; 信道带宽（b&#x2F;s）\n② 传播时延：电磁波在信道中传输一定距离所需划分的时间。传播时间 &#x3D; 信道长度（m） &#x2F; 传输速率（m&#x2F;s）\n③ 处理时延：主机或路由器处理收到的分组所花费的时间。\n④ 排队时延：分组在输入队列中等待处理的时间加上其在输出队列中等待转发的时间。\n综上：总时延 &#x3D; 发送时延 + 传播时延 + 处理时延 + 排队时延。\n时延带宽积：传播时延 * 带宽。表示链路的容量。   \n往返时间RTT：从发送方发送数据开始，到发送发收到接收方的确认为止，所花费的时间。\n\n\n\n\n\n\n\n利用率：某信道有百分之几是被利用的（有数据通过）。而信道或网络利用率过高会产生非常大的时延。当前时延&#x3D;空闲时时延&#x2F;（1-利用率）\n\n\n1.4 计算机网络体系结构\n网络协议，简称为协议，是为进行网络中的数据交换而建立的规则 、标准或约定。\n包括三要素：语法、语义、时序(同步)。\n\n\n\n网络接口层：并没有规定具体内容，这样做的目的是可以互连全世界各种不同的网络接口，例如：有线的以太网接口，无线局域网的WIFI接口等。\n网际层：它的核心协议是IP协议。\n运输层：TCP和UDP是这层的两个重要协议。\n应用层：这层包含了大量的应用层协议，如 HTTP , DNS 等。\n\n\n\n\n实体表示任何可发送或接收信息的硬件或软件进程。\n协议是控制两个对等实体(收发双方相同层次中的实体)进行通信的规则的集合。\n在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务，要实现本层协议，还需要使用下层所提供的服务。\n协议三要素：语法、语义、同步\n\n\n\n协议和服务的区别\n\n协议是“水平的”，即协议是控制对等实体之间通信的规则。\n服务是“垂直的”，即服务是由下层向上层通过层间接口提供的。\n实体看得见相邻下层所提供的服务，但并不知道实现该服务的具体协议。也就是说，下面的协议对上面的实体是**”透明”**的。\n同一系统相邻两层实体进行交互的地方，称为服务访问点SAP(Service Access Point)。\n\n2、物理层2.1 物理层基本概念\n2.2 数据通信系统模型\n协议：控制数据通信的一组规则\n\n信息、数据与信号\n\n信息：指人们对客观现实世界事物的存在方式或运动状态的某种认知\n数据：信息的表达形式\n信号：数据的电气的或电磁的表现\n“模拟的”：连续的\n“数字的”：离散的\n\n\n\n数据通信方式\n\n串行传输：数据是一个比特一个比特依次发送的，因此在发送端与接收端之间，只需要一条数据传输线路即可\n\n并行传输：一次发送n个比特，因此，在发送端和接收端之间需要有n条传输线路，并行传输的优点是比串行传输的速度n倍，但成本高\n\n数据在传输线路上的传输采用是串行传输，计算机内部的数据传输常用并行传输\n\n单向通信：又称为单工通信，即只能有一个方向的通信而没有反方向的交互（无线电、广播）\n\n双向交替通信：又称为半双工通信，即通信的双方可以发送信息，但不能双方同时发送（当然也就不能同时接收）\n\n双向同时通信：又称为全双工通信，即通信的双方可以同时发送和接收信息。（传输效率最高）\n\n\n信道传输类型\n\n基带信号：来自信源的信号，频率较低，近距离传输大多采用\n频带信号：将基带信号变换成模拟信号，远距离通信通常采用\n宽带传输：宽带传输一定是采用频带传输技术的，但频带传输不一定就是宽带传输\n\n2.3 数据编码技术\n编码：用数字信号承载数字或模拟数据\n\n调制：用模拟信号承载数字或模拟数据\n\n\n信道容量极限\n\n限制码元在信道上的传输速率的因素有：\n信道能够通过的频率范围\n信噪比\n\n\n数据在信道中的传输速率受编码、带宽、信噪比的限制\n\n\n\n\n2.4 信道复用技术\n复用 (multiplexing) 是通信技术中的基本概念，它允许用户使用一个共享信道进行通信，降低成本，提高利用率\n\n\n\n频分复用 FDM：将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。\n\n\n\n时分复用TDM： 时分复用则是将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。每一个用户所占用的时隙是周期性地出现（其周期就是TDM帧的长度）的。TDM 信号也称为等时 (isochronous) 信号。\n\n\n\n同步时分复用 STDM：\n\n\n\n波分复用(WDM)：\n\n\n\n码分复用 CDM ：常用的名词是码分多址 CDMA (Code Division Multiple Access)。各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。\n\n\n3、数据链路层3.1 概述\n数据链路层主要目的是为了在有差错的物理线路基础上，采取差错检测、差错控制、流量控制等方法，将有差错的物理线路改进成无差错的数据链路，向网络层提供高质量的数据传输服务。\n\n数据链路层信道类型：\n\n点对点信号 – 一对一\n广播信号 – 一对多\n\n\n\n\n\n数据链路层传送的是帧。封装成帧(framing) :在一段数据的前后分别添加首部和尾部，然后就构成了一个帧,确定帧的界限。\n透明传输是指数据链路层对上层交付的传输数据没有任何限制，好像数据链路层不存在一样。解决方法：面向字节的物理链路使用字节填充 (byte stuffing) 或字符填充 (character stuffing)，面向比特的物理链路使用比特填充的方法实现透明传输。为了提高帧的传输效率，应当使帧的数据部分的长度尽可能大些。考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即最大传送单元MTU 。\n差错检测实际的通信链路都不是理想的，比特在传输过程中可能会产生差错: 1可能会变成0,而0也可能变成1。这称为比特差错。差错检测编码：纠错码和检错码。\n\n\n\n\n\n检错码只能检测出帧在传输过程中出现了差错，但并不能定位错误，因此无法纠正错误。\n使用CRC差错检测技术只能做到无差错接受，非可靠传输，互联网数据链路层提供的是不可靠传输服务\n循环冗余校验CRC有很好的检错能力（漏检率非常低)，虽然计算比较复杂，但非常易于用硬件实现，因此被广泛应用于数据链路层。\n例：要发送的数据为1101011011，采用CRC的生成多项式是10011，求出的检验序列为1110\n\n3.2 PPP协议\n现在互联网使用得最多的数据链路层协议是点对点协议PPP (Point-to-Point Protoco1) 。\n\n\n\n帧格式：\n\n\n\n透明传输问题：当PPP用在异步传输时，就使用一种特殊的字符填充法；当PPP用在同步传输链路时，协议规定采用硬件来完成比特填充。\n差错检测：能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。\n\n3.3 CSMA&#x2F;CD\n局域网是计算机网络的一种形式；LAN是在一个较小的范围，实现数据通信和资源共享的目的；网络为一个单位所拥有，且地理范围和站点数目均有限\n\n局域网的主要优点：\n\n具有广播功能，从一个站点可很方便地访问全网。\n便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。\n提高了系统的可靠性、可用性和残存性。\n\n\n决定局域网特征的主要技术：\n\n设备互联的:拓扑结构\n用于传输数据的媒体:传输介质\n由于信道共享而采用的媒体接入控制方法:介质访问控制方法\n\n\n媒体共享技术：\n\n静态划分信道（代价太高、不适合局域网)\n\n频分复用\n时分复用\n波分复用\n码分复用\n\n\n动态媒体接入控制(多点接入)\n\n随机接入（易产生碰撞，需要解决碰撞的协议)\n受控接入（如多点线路探询(polling)，或轮询)\n\n\n\n\n随机接入：载波监听多点接入&#x2F;碰撞检测（CSMA&#x2F;CD协议）\n\n“多点接入MA”表示许多计算机以多点接入的方式连接在一根总线上。\n\n“载波监听CS”是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。\n\n“碰撞检测CD”就是计算机边发送数据边检测信道上的信号电压大小。当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。\n\n\n\n工作流程：\n\n争用期：\n\n\n\n\n最小帧长：\n\n\n\n最大帧长：\n\n\n\n截断二进制指数退避算法：\n\n\n\n信道利用率：\n\n\n\n帧接收流程：\n\n\n\n争用期:2r\n协议规定具体的争用时间为:51.2us\n信号在以太网上传播一公里大约需要5us，以太网的最大端到端时延必须小于争用期的一半（即:25.6pus)这相当于以太网的最大端到端长度为5km.\n对于10Mb&#x2F;s以太网，在争用期内可发送512bits，即64字节。\n强化碰撞:32或48比特的干扰信号\n帧间最小间隔:96bit\n\n\n\n现在互联网的数据链路层多采用PPP协议和CSMA&#x2F;CD协议，这两种协议都不采用序号和确认机制，因此，互联网数据链路层提供的是不可靠传输服务。\nOSI体系结构的数据链路层采用的是面向连接的HDLC协议，因此OSI数据链路层提供可靠的传输服务。\n当数据率一定时，以太网的连线的长度受到限制，否则 τ 的数值会太大。\n以太网的帧长不能太短，否则 T0 的值会太小，使 a 值太大。\n\n\n3.4 局域网的扩展\n虚拟局域网VLAN是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段具有某些共同的需求·每一个 VLAN的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个VLAN 。虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。（现代高性能路由器已逐渐取代VLAN）\n\n虚拟局域网(VLAN)技术具有以下主要优点:\n\n改善了性能\n简化了管理\n降低了成本\n改善了安全性\n\n\n网桥和二层交换机可以在数据链路层扩展以太网覆盖的地理范围。\n\n10个站连接到一个10Mbps的以太网交换机上，每个站点独享10Mbps，所有站点共享10Mbps 。\n\n\n4、网络层4.1 IP协议概述及IP地址\n网络层的主要任务是实现网络互连，进而实现数据包在各网络之间的传输\n网络层提供的虚电路服务(逻辑连接，非物理连接)\n网络层提供数据报服务，网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺。\n网际协议IP是TCP&#x2F;IP体系中两个最主要的协议之一；与IP协议配套使用的还有三个协议:\n地址解析协议ARP\n网际控制报文协议ICMP\n网际组管理协议IGMP\n\n\n\n虚拟互连网络\n\n将网络互相连接起来要使用一些中间设备。\n中间设备又称为中间系统或中继(relay)系统。\n有以下五种不同的中间设备:\n物理层中继系统:集线器(Hub) \n数据链路层中继系统:网桥或桥接器(bridge)\n网络层中继系统:路由器(router)\n网桥和路由器的混合物:桥路器(brouter)\n网络层以上的中继系统:网关(gateway)\n\n\n网络互连都是指用路由器进行网络互连和路由选择\n\n\n\n\n对比的方面\n虚电路服务\n数据报服务\n\n\n\n思路\n可靠通信应当由网络来保证\n可靠通信应当由用户主机来保证\n\n\n连接的建立\n必须有\n不需要\n\n\n终点地址\n仅在连接建立阶段使用，每个分组使用短的虚电路号\n每个分组都有终点的完整地址\n\n\n分组的转发\n属于同一条虚电路的分组均按照同一路由进行转发\n每个分组独立选择路由进行转发\n\n\n当结点出故障时\n所有通过出故障的结点的虚电路均不能工作\n出故障的结点可能会丢失分组，一些路由可能会发生变化\n\n\n分组的顺序\n总是按发送顺序到达终点\n到达终点时不一定按发送顺序\n\n\n端到端的差错处理和流量控制\n可以由网络负责，也可以由用户主机负责\n由用户主机负责\n\n\n\nIP地址现在由因特网名字与号码分配机构ICANN负责分配\nABCDE类地址\nA类IP地址范围是1.0.0.0到127.255.255.255  (小于128)\nB类IP地址范围128.0.0.0-191.255.255.255 （128~191）\nC类IP地址范围192.0.0.0-223.255.255.255 （192~223）\nD类：组播地址\nE类地址:保留今后使用\n\n\n本质上IP地址是标志一个主机和一条链路的接口，具有多网络(多IP地址)的主机称为多归属主机\n\n4.2 ARP协议、IP数据报\n通信时使用了两个地址：\nIP地址：网络层地址\nMAC地址：数据链路层地址\n\n\nARP 作用:从网络层使用的IP地址,解析出在数据链路层使用的硬件地址(只适用于IPV4)\nARP是解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题\n举例：主机A发送IP数据报给主机B，途径4个路由器，发送过程中总共使用5几次ARP\n\n4.3 划分子网与构建超网\n划分子网纯属一个单位内部事物；划分子网后IP地址就变成了三级结构；划分子网只是把IP地址的主机号host-id这部分进行再划分，而不改变IP地址原来的网络号net-id\n从一个IP数据报的首部并无法判断源主机或目的主机所连接的网络是否进行了子网划分，使用子网掩码(subnet mask)可以找出IP地址中的子网部分\n默认子网掩码：\nA类地址：255.0.0.0\nB类地址：255.255.0.0\nC类地址：255.255.255.0\n\n\n同样的IP与不同的子网掩码得出相同的网络地址；但不同的掩码的效果不同。\n\n\n\n某网络的IP地址为202.168.5.0&#x2F;24，采用可变长子网划分，子网掩码为255.255.255.192，则该网络的最大子网个数为4（2的平方），每个子网内的最大可分配主机地址个数为62（2的6次方-2）\n\n\n\n4.4 路由选择协议及RIP、OSFP及BGP\n路由算法\n\n静态路由选择策略 – 非自适应路由选择\n动态路由选择策略 – 自适应路由选择\n\n\n自治系统：处于管理机构控制下的路由器和网络群组；在一个自治系统中的所有路由器必须相互连接，运行相同的路由协议，同时分配同一个自治系统编号·自治系统之间的链接使用外部路由协议\n\n自治系统之间的路由选择:域间路由选择；自治系统内部的路由选择:域内路由选择\n\n互联网路由选择协议\n\n内部网关协议\nRIP(较小规模使用较多)：一种分布式基于距离向量的路由选择协议；RIP协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录\n特点：仅和相邻路由器交换信息；交换的信息是当前本路由器所知道的全部信息，即自己的路由表；按固定的时间间隔交换路由信息\nRIP2具有简单鉴别功能；RIP协议特点:好消息传播得快，坏消息传播得慢。RIP存在的一个问题:当网络出现故障时，要经过比较长的时间（例如数分钟)才能将此信息传送到所有的路由器。\nOSPF：“开放最短路径优先”，采用分布式链路状态协议\n洪泛法、划分区域减少了整个网路上的通信量\n五种分组类型：\n类型1，问候(He11o)分组–发现和维持可达性\n类型2，数据库描逑(Database Description)分组  –  摘要信息\n类型3，链路状态请求(Link State Request)分组  –  请求发送某些链路状态项目\n类型4，链路状态更新(Link State Update)分组  –  用洪泛法对全网更新链路状态。\n类型5，链路状态确认(Link State Acknow1edgment)分组\n\n\n一个路由器的链路状态只涉及到与其相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。\n\n\n外部网关协议\nBGP：每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“BGP发言人”。一般说来，两个BGP发言人都是通过一个共享网络连接。\n使用的四种报文：打开 – 更新 – 保活 – 通知\n\n\n\n\n\n\n\n路由器的构造：路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组。\n\n“转发”(forwarding)是指路由器根据转发表将收到的用户IP数据报从合适端口转发出去。\n\n“路由选择”(routing）是指按照分布式算法，根据从各相邻路由器得到的关于网络拓扑的变化情况，动态地改变所选择的路由。\n\n路由表是根据路由选择算法得出的转发表是从路由表得出的。\n\n\n\n\n5、运输层5.1 概述+UDP+TCP报文运输层协议\n\n引用运输层协议作用：为运行在不同主机上的应用进程提供直接的通信服务\n消除网络层的不可靠（无法控制通信子网），改善质量，增强网络层QOS ;\n提供端到端服务:提供可靠的、与实际使用网络无关的信息传输\n\n\n从通信和信息处理的角度看：运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层\n计算机网络的本质是实现进程通信；运输层的主要任务就是要实现分布式进程通信\n运输层的主要功能：\n提供应用进程之间端到端的逻辑通信\n运输层向高层用户屏蔽了下层通信网络核心的细节\n运输层提供流量控制(拥塞控制)能力\n运输层对收到的报文进行差错检测\n运输层实现复用和分用\n\n\n运输层的主要协议：\n面向连接的传输控制协议TCP\n无连接的用户数据报协议UDP（存在价值：无需建立连接、实现简单、头部开销少、没有拥塞控制）\n\n\n端口号只具有本地意义，它仅仅是本地计算机应用层中的各个进程和运输层交互时的层间接口\n一个套接字不能同时与远地的两个套接字相连\n\n用户数据报协议UDP\n\n无连接、不提供可靠交付–不使用拥塞控制和流量控制、简单、支持单&#x2F;多&#x2F;广播、差错检测、不需要套接字\n适用于IP电话、视频会议等实时应用\n\n运输控制协议TCP\n\n面向连接、可靠交付、复杂、点对点、全双工、面向字节流、需要套接字\n适用于要求可靠传输的应用，如文件传输\n\n5.2 可靠传输的基本原理 + TCP可靠传输的实现可靠传输的基本原理\n\n实现可靠传输：采用停等协议 – 发送方发送消息，等待接收方确认（优点简单，缺点信道利用率太低）\n差错处理、超时重传、发送丢失、确认丢失、确认迟到\n需要注意的几个问题：在发送完一个报文后，必须暂时保留已发送的报文的副本；报文和确认报文都必须进行编号；超时计时器的重传时间应当比数据在报文传输的平均往返时间更长一些。\n改进：流水线传输 – 连续发送多个分组、数据不间断地传输，即连续ARQ协议和滑动窗口协议\n累积确认：对最后一个报文发送确认，则表示所有保温都已正确收到 – 效率高、任意实现，即使确认丢失也不必重传\nGo-back-N：回退\n\nTCP可靠传输的实现\n\nTCP连接的每一端都必须设有两个窗口:一个发送窗口和一个接收窗口。TCP的可靠传输机制用字节的序号进行控制。TCP所有的确认都是基于序号而不是基于报文段。TCP两端的四个窗口经常处于动态变化之中。\n\n\n\n注意：TCP基于以字节为单位的滑动窗口来实现可靠传输、发送方的发送窗口并不总和接收方的接收窗口一样大、对于不按序到达的数据TCP未明确规定如何处理、TCP要求接收方必须有累积确认和捎带确认机制、TCP通信是全双工通信\n发送缓存与接收缓存的作用\n发送缓存用来暂时存放:\n发送应用程序传送给发送方TCP准备发送的数据\nTCP已发送出但尚未收到确认的数据\n\n\n接收缓存用来暂时存放:\n按序到达的、但尚未被接收应用程序读取的数据\n不按序到达的数据\n\n\n\n\n超时重传：重传机制是TCP中最重要和最复杂的问题之一。TCP每发送一次报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。\n加权平均往返时间：\n\n\n\n超时重传时间RTO：\n\n\n\nKarn算法：在计算平均往返时间RTT 时，只要报文段重传了,就不采用其往返时间样本。这样得出的加权平均往返时间RTTS和超时重传时间RTO就较准确。\n修正的Karn算法：新的RTO &#x3D; γ × 旧的RTO 。系数的典型值是2\n选择确认SACK：接收方收到了和前面的字节流不连续的两个字节块。如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据。\n\n5.3 流量控制与拥塞控制流量控制\n\n控制发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。\n\nTCP连接利用滑动窗口机制实现流量控制。\n\nTCP为每一个连接设有一个持续计时器\n\n只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器\n若持续计时器设置的时间到，就发送一个**零窗口探测报文段(**仅携带1字节的数据)，而对方就在确认这个探测报文段时给出了现在的窗口值\n若窗口(rwnd)仍然是零，则收到这个报文段的一方就重新设置持续计时器。\n\n\n使用不同的机制控制发送TCP报文段的时机\n\n第1种机制是TCP维持一个变量，它等于最大报文段长度MSS。只要缓存中存放的数据达到MSS字节，就组装成一个TCР报文段发送出去\n第⒉种机制是由发送方的应用进程指明要求发送报文段，即TCP支持的推送(push)操作\n第3种机制是发送方的一个计时器期限到了，就把当前缓存的数据装入报文段(但长度不能超过MSS)发送出去\n\n\nNagle算法：当数据以一字节的方式进入发送端，发送端第一次只发送一个字节，其他字节存入缓存。当收到第一个字节的确认后，再发送缓存的其他数据。只有当收到对前一个报文段的确认后才继续发送下面的报文段。当数据到达较快或者网络速度较慢时，用这种方法可以明显减少所用的网络带宽。\n\nNagle还规定:当缓存中的数据字节数达到发送窗口的1&#x2F;2或接近最大报文段长度MSS时，立即将它们作为1个报文段发送。\n\n糊涂窗口综合症：让接收方等待一段时间，使得接收缓存已有足够空间容纳一个最长的报文段，或等到接收缓存已有一半空闲的空间，再发确认。（发送方不要发送太小的报文，接收方在窗口值很小时不要确认）\n\n\nTCP拥塞控制\n\n拥塞控制就是防止过多的数据注入到网络中，使网络中的路由器或链路不致过载，拥塞控制是一个全局性的过程\n\n拥塞控制的两种模式\n\n开环控制:在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。避免发生\n闭环控制:基于反馈环路的概念，具体过程如下：监测网络系统以便检测到拥塞在何时、何处发生；将拥塞发生的信息传送到可采取行动的地方；调整网络系统的运行以解决出现的问题。尽力解除\n\n\n几种拥塞控制方法：慢开始、拥塞避免、快重传、快恢复\n\n拥塞窗口：大小取决于网络的拥塞程度并且动态变化，发送端根据拥塞窗口动态调整，swnd≤Min（cwnd，rwnd）\n\n控制拥塞窗口的基本原则：网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。\n\n拥塞的判断：\n\n重传定时器超时\n收到三个相同的ACK\n\n\nMSS(Maximum Segment Size)是TCP报文段中的数据字段的最大长度。数据字段加上 TCP首部才等于整个的 TCP报文段。所以, MSS是“TCP报文段长度减去TCP首部长度”。\n\n慢开始算法：在主机刚刚开始发送报文段时先设置拥塞窗口cwnd&#x3D;1 ,即设置为一个最大报文段SMSS的数值。每收到一个对新报文段的确认后，将拥塞窗口加1，即增加一个 SMSS的数值。用这样的方法逐步增大发送端的拥塞窗口（cwnd） ,可以使分组注入到网络的速率更加合理。(由小到大逐渐增大拥塞窗口数值)\n\n传输轮次：慢开始算法，没经过一个传输轮次，拥塞窗口就加倍；一个传输轮次所经历的时间就是往返时间RTT\n\n\n拥塞避免算法：让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，使拥塞窗口cwnd按线性规律缓慢增长(加法增大)。慢开始和拥塞避免一般同时使用。\n\n设置慢开始门限状态变量：慢开始门限状态变量ssthresh的用法如下：\n当cwnd &lt; ssthresh时，使用慢开始算法\n当cwnd &gt; ssthresh时，停止使用慢开始算法而改用拥塞避免算法\n当cwnd &#x3D; ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法。\n\n\n当网络出现拥塞时：无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（根据有没有按时收到确认），就要把慢开始门限变量ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2)(乘法减小)。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法·这样做目的是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。\n\n\n\n\n\n加法增大:执行拥塞避免算法时，在收到对所有报文段的确认后（即经过一个往返时间)），把拥塞窗口cwnd增加一个MSS ，使拥塞窗口缓慢增大，以防止网络过早出现拥塞。\n乘法减小:指不论在慢开始阶段还是拥塞避免阶段，只要出现一次超时(即出现网络拥塞)，就把慢开始门限值ssthresh设置为当前的拥塞窗口值乘以0.5 。当网络频繁出现拥塞时，ssthresh值就下降得很快,以大大减少注入到网络中的分组数。\n快重传算法：接收方每收到一个失序的报文段后就立即发出重复确认，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段。快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。\n快恢复算法：当发送端收到连续三个重复的确认时，就执行“乘法减小”算法，把慢开始门限ssthresh减半，但不执行慢开始算法。将拥塞窗口cwnd设置为慢开始门限ssthresh 减半后的数值，然后开始执行拥塞避免算法(加法增大)，使拥塞窗口缓慢地线性增大。(发送方认为网络很可能没有发生拥塞)。\n发送窗口上限值：发送方发送窗口的上限值应当取为接收方接收窗口rwnd和拥塞窗口cwnd这两个变量中较小的一个，即应按以下公式确定发送窗口的上限值Min[rwnd, cwnd]\n\n\n\n\n\n拥塞控制v.s流量控制：\n拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素\n流量控制往往指在给定的发送端和接收端之间的点对点通信量的控制，即抑制发送端发送数据的速率，以便使接收端来得及接收。\n\n\n\n\n\n5.4 TCP的运输连接管理\n运输层连接管理的三个阶段：连接建立(握手)、数据传送、连接释放(挥手)\nTCP的连接建立要解决以下三个问题:\n使TCP双方能够确知对方的存在;\n使TCP双方能够协商一些参数(如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等\n使TCP双方能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配\n\n\n\n\n\n\nTCP保活计时器：当保活计时器到时后，TCP服务器进程向TCP客户进程发送一个探测报文段\n\n6、应用层\n6.1 DNS\n因特网采用层次树状结构的命名方式\n\n…  . 三级域名 . 二级域名 . 顶级域名\n\n顶级域名TLD分为以下三类：国家顶级域名、通用顶级域名、反向域\n\n域名服务器的四种类型：\n\n根域名服务器 – 最高层次的域名服务器，不直接对域名进行解析，返回该域名所属顶级域名的顶级域名服务器的IP地址\n顶级域名服务器 – 管理在该顶级域名服务器注册得所有二级域名\n权限域名服务器 – 管理某个区的域名\n本地域名服务器 –  本地域名服务器起着代理的作用，会将该报文转发到上述的域名服务器的等级结构中\n\n\n域名的解析：\n\n主机向本地域名服务器的查询一般都是采用递归查询\n本地域名服务器向根域名服务器的查询通常是采用迭代查询\n\n\n高速缓存用来存放最近查询过的域名以及何处获得域名映射信息的记录。\n\n连接到互联网上的主机名必须是唯一的&#x2F;一个主机名可以对应多个IP\n\n\n6.2 FTP\n文件传送协议FTP(File Transfer Protocol)是因特网上使用得最广泛的文件传送协议。\n\n提供交互式的访问\n屏蔽了各计算机系统的细节，因而适合在异构网络中任意计算机之间传送文件\n\n\nFTP客户和服务器之间要建立以下两个并行的TCP控制\n\n控制连接\n数据连接\n默认情况下，FTP使用TCP 21端口进行控制连接，TCP 20端口进行数据连接。主动方式使用TCP 20端口,被动方式由服务器和客户端自行协商决定。\n\n\n\n6.3 WWW\n万维网(www :Wor1d wide Web)：是建立在因特网上的一种信息发布系统，是一个大规模的、联机式的信息储藏所。(访问方式称为超链接)\n万维网以客户服务器方式工作\n使用统一资源定位符URL来标志万维网上的各种文档，格式**&lt;协议名&gt;:&#x2F;&#x2F;&lt;主机&gt;:&lt;端口&gt;&#x2F;&lt;路径&gt;&#x2F;&lt;文件名&gt;**\n超文本传送协议HTTP来实现万维网上各种超链的链接；HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」\nHTTP&#x2F;1.0协议采用非持续连接；HTTP&#x2F;1.1协议使用持续连接 – 非流水线方式、流水线方式\nHTTP有两类报文 – 请求报文、响应报文\n1xx表示通知信息的，如请求收到了或正在进行处理；2xx表示成功，如接受或知道了；3xx表示重定向，表示要完成请求还必须采取进一步的行动；4xx表示客户的差错，如请求中有错误的语法或不能完成；5xx表示服务器的差错，如服务器失效无法完成请求。\n万维网使用Cookie产生唯一的识别码，Cookie是一种对无状态的HTTP进行状态化的技术。\n\n\n超文本标记语言HTML使万维网文档能在因特网上各种计算机上显示出来\n搜索引擎使用户能够很方便地找到所需的信息\n\n6.4 DHCP\n互联网广泛使用的动态主机配置协议 DHCP (Dynamic Host Configuration Protocol) 提供了即插即用连网 (plug-and-play networking) 的机制。\n\n\n\n\n传输层为DHCP和SMTP提供的服务分别是UDP、TCP\n\n6.5 e-mail\n电子邮件（E-mail)是因特网上最早流行的一种应用，并且仍然是当今因特网上最重要、最实用的应用之一\n电子邮件系统采用客户&#x2F;服务器方式\n电子邮件系统的三个主要组成构建：用户代理，邮件服务器以及电子邮件所需的协议\n常用的邮件发送协议是简单邮件传送协议SMTP(为解决SMTP传送非ASCII码文本提出了多用途因特网邮件扩展MIME)\n常用的邮件读取协议为邮局协议POP3；因特网邮件访问协议IMAP受或知道了；3xx表示重定向，表示要完成请求还必须采取进一步的行动；4xx表示客户的差错，如请求中有错误的语法或不能完成；5xx表示服务器的差错，如服务器失效无法完成请求。\n万维网使用Cookie产生唯一的识别码，Cookie是一种对无状态的HTTP进行状态化的技术。\n\n\n超文本标记语言HTML使万维网文档能在因特网上各种计算机上显示出来\n搜索引擎使用户能够很方便地找到所需的信息\n\n","slug":"计算机网络基础知识点","date":"2023-02-02T02:13:39.000Z","categories_index":"计算机科学与技术","tags_index":"计算机网络","author_index":"会思想的苇草i"},{"id":"ccba9309aa28da995832d41b5289f1c2","title":"Axios进阶指南：构建可靠的前端网络请求","content":"Axios1、Axios的理解和使用1.1 Axios概述\n前端最流行的ajax请求库\n\nreact&#x2F;vue官方都推荐使用axios 发ajax 请求 \n\n文档: https://github.com/axios/axios\n\naxios中文网：axios中文网|axios API 中文文档 | axios (axios-js.com)\n\n\n\n1.2 Axios特点\n基于xhr + promise的异步ajax请求库\n浏览器端&#x2F;node端都可以使用\n支持请求&#x2F;响应拦截器\n支持请求取消\n请求&#x2F;响应数据转换\n批量发送多个请求\n\n1.3 Axios常用语法\naxios(config):通用&#x2F;最本质的发任意类型请求的方式\naxios(url[, config]):可以只指定url发get 请求\naxios.request(config):等同于axios(config)\naxios.get(url[, config]):发get请求\naxios.delete(url[, config]):发delete请求\naxios.post(url[, data, config]):发post请求\naxios.put(url[, data, configl):发put 请求\naxios.defaults.xxx:请求的默认全局配置\naxios.interceptors.request.use():添加请求拦截器\naxios.interceptors.response.use():添加响应拦截器\naxios.create([config]):创建一个新的axios(它没有下面的功能)\naxios.Cancel():用于创建取消请求的错误对象\naxios.CancelToken():用于创建取消请求的token对象\naxios.isCancel():是否是一个取消请求的错误\naxios.all(promises):用于批量执行多个异步请求\naxios.spread():用来指定接收所有成功数据的回调函数的方法\n\n\n\naxios基本使用\n\n    //获取按钮\n    const btns = document.querySelectorAll(&#39;button&#39;);\n\n    //第一个\n    btns[0].onclick = function () &#123;\n        //发送 AJAX 请求\n        axios(&#123;\n            //请求类型\n            method: &#39;GET&#39;,\n            //URL\n            url: &#39;http://localhost:3000/posts/2&#39;,\n        &#125;).then(response =&gt; &#123;\n            console.log(response);\n        &#125;);\n    &#125;\n\n    //添加一篇新的文章\n    btns[1].onclick = function () &#123;\n        //发送 AJAX 请求\n        axios(&#123;\n            //请求类型\n            method: &#39;POST&#39;,\n            //URL\n            url: &#39;http://localhost:3000/posts&#39;,\n            //设置请求体\n            data: &#123;\n                title: &quot;今天天气不错, 还挺风和日丽的&quot;,\n                author: &quot;张三&quot;\n            &#125;\n        &#125;).then(response =&gt; &#123;\n            console.log(response);\n        &#125;);\n    &#125;\n\n    //更新数据\n    btns[2].onclick = function () &#123;\n        //发送 AJAX 请求\n        axios(&#123;\n            //请求类型\n            method: &#39;PUT&#39;,\n            //URL\n            url: &#39;http://localhost:3000/posts/3&#39;,\n            //设置请求体\n            data: &#123;\n                title: &quot;今天天气不错, 还挺风和日丽的&quot;,\n                author: &quot;李四&quot;\n            &#125;\n        &#125;).then(response =&gt; &#123;\n            console.log(response);\n        &#125;);\n    &#125;\n\n    //删除数据\n    btns[3].onclick = function () &#123;\n        //发送 AJAX 请求\n        axios(&#123;\n            //请求类型\n            method: &#39;delete&#39;,\n            //URL\n            url: &#39;http://localhost:3000/posts/3&#39;,\n        &#125;).then(response =&gt; &#123;\n            console.log(response);\n        &#125;);\n    &#125;\n\n\naxios其他使用\n\n//获取按钮\n    const btns = document.querySelectorAll(&#39;button&#39;);\n\n    //发送 GET 请求\n    btns[0].onclick = function () &#123;\n        // axios()\n        axios.request(&#123;\n            method: &#39;GET&#39;,\n            url: &#39;http://localhost:3000/comments&#39;\n        &#125;).then(response =&gt; &#123;\n            console.log(response);\n        &#125;)\n    &#125;\n\n    //发送 POST 请求\n    btns[1].onclick = function () &#123;\n        // axios()\n        axios.post(\n            &#39;http://localhost:3000/comments&#39;,\n            &#123;\n                &quot;body&quot;: &quot;喜大普奔&quot;,\n                &quot;postId&quot;: 2\n            &#125;).then(response =&gt; &#123;\n                console.log(response);\n            &#125;)\n    &#125;\n\n\naxios默认配置\n\n    //获取按钮\n    const btns = document.querySelectorAll(&#39;button&#39;);\n    //默认配置\n    axios.defaults.method = &#39;GET&#39;;//设置默认的请求类型为 GET\n    axios.defaults.baseURL = &#39;http://localhost:3000&#39;;//设置基础 URL\n    axios.defaults.params = &#123; id: 100 &#125;;\n    axios.defaults.timeout = 3000;//\n\n    btns[0].onclick = function () &#123;\n        axios(&#123;\n            url: &#39;/posts&#39;\n        &#125;).then(response =&gt; &#123;\n            console.log(response);\n        &#125;)\n    &#125;\n\n1.4 难点语法的理解和使用 axios.create(config)\n\n根据指定配置创建一个新的axios，也就是每个新axios都有自己的配置\n新axios 只是没有取消请求和批量发请求的方法，其它所有语法都是一致的\n为什么要设计这个语法?(1)需求:项目中有部分接口需要的配置与另一部分接口需要的配置不太一样，如何处理(2)解决:创建2个新axios，每个都有自己特有的配置，分别应用到不同要求的接口请求中\n\n拦截器函数&#x2F;ajax请求&#x2F;请求的回调函数的调用顺序\n\n说明:调用axios()并不是立即发送ajax请求，而是需要经历一个较长的流程\n流程:请求拦截器2&#x3D;&gt;请求拦截器1&#x3D;&gt;发ajax请求&#x3D;&gt;响应拦截器1&#x3D;&gt;响应拦截器2&#x3D;&gt;请求的回调  (unshift,push)\n注意:此流程是通过promise串连起来的，请求拦截器传递的是config，响应拦截器传递的是response\n\n\n代码：\n\n    // Promise\n    // 设置请求拦截器  config 配置对象\n    axios.interceptors.request.use(function (config) &#123;\n        console.log(&#39;请求拦截器 成功 - 1号&#39;);\n        //修改 config 中的参数\n        config.params = &#123; a: 100 &#125;;\n\n        return config;\n    &#125;, function (error) &#123;\n        console.log(&#39;请求拦截器 失败 - 1号&#39;);\n        return Promise.reject(error);\n    &#125;);\n\n    axios.interceptors.request.use(function (config) &#123;\n        console.log(&#39;请求拦截器 成功 - 2号&#39;);\n        //修改 config 中的参数\n        config.timeout = 2000;\n        return config;\n    &#125;, function (error) &#123;\n        console.log(&#39;请求拦截器 失败 - 2号&#39;);\n        return Promise.reject(error);\n    &#125;);\n\n    // 设置响应拦截器\n    axios.interceptors.response.use(function (response) &#123;\n        console.log(&#39;响应拦截器 成功 1号&#39;);\n        return response.data;\n        // return response;\n    &#125;, function (error) &#123;\n        console.log(&#39;响应拦截器 失败 1号&#39;)\n        return Promise.reject(error);\n    &#125;);\n\n    axios.interceptors.response.use(function (response) &#123;\n        console.log(&#39;响应拦截器 成功 2号&#39;)\n        return response;\n    &#125;, function (error) &#123;\n        console.log(&#39;响应拦截器 失败 2号&#39;)\n        return Promise.reject(error);\n    &#125;);\n\n    //发送请求\n    axios(&#123;\n        method: &#39;GET&#39;,\n        url: &#39;http://localhost:3000/posts&#39;\n    &#125;).then(response =&gt; &#123;\n        console.log(&#39;自定义回调处理成功的结果&#39;);\n        console.log(response);\n    &#125;);\n\n取消请求\n\n基本流程配置cancelToken对象缓存用于取消请求的cancel函数在后面特定时机调用cancel函数取消请求在错误回调中判断如果error是cancel，做相应处理\n实现功能点击按钮，取消某个正在请求中的请求\n\n\n代码：\n\n    //获取按钮\n    const btns = document.querySelectorAll(&#39;button&#39;);\n    //2.声明全局变量\n    let cancel = null;\n    //发送请求\n    btns[0].onclick = function () &#123;\n        //检测上一次的请求是否已经完成\n        if (cancel !== null) &#123;\n            //取消上一次的请求\n            cancel();\n        &#125;\n        axios(&#123;\n            method: &#39;GET&#39;,\n            url: &#39;http://localhost:3000/posts&#39;,\n            //1. 添加配置对象的属性\n            cancelToken: new axios.CancelToken(function (c) &#123;\n                //3. 将 c 的值赋值给 cancel\n                cancel = c;\n            &#125;)\n        &#125;).then(response =&gt; &#123;\n            console.log(response);\n            //将 cancel 的值初始化\n            cancel = null;\n        &#125;)\n    &#125;\n\n    //绑定第二个事件取消请求\n    btns[1].onclick = function () &#123;\n        cancel();\n    &#125;\n\n2、Axios源码分析2.1 源码目录结构\n2.2 源码分析axios 与Axios的关系\n\n从语法上来说: axios不是Axios 的实例  (对象，函数，实例对象的方法添加到函数身上)\n从功能上来说: axios是Axios的实例   (拥有实例对象上的方法)\naxios是Axios.prototype.request 函数bind()返回的函数\naxios作为对象有Axios原型对象上的所有方法，有Axios对象上所有属性\n\ninstance 与axios的区别\n\n相同:(1都是一个能发任意请求的函数: request(config)\n(2)都有发特定请求的各种方法:get()&#x2F;post()&#x2F;put()&#x2F;delete()\n(3)都有默认配置和拦截器的属性: defaults&#x2F;interceptors\n\n不同:\n(1)默认配置很可能不一样\n(2)instance没有axios后面添加的一些方法: create()&#x2F;CancelToken()&#x2F;all()\n\n\naxios运行的整体流程\n\n\n整体流程:request(config) &#x3D;&#x3D;&gt; dispatchRequest(config)  &#x3D;&#x3D;&gt; xhrAdapter(config)\n\nrequest(config):将请求拦截器&#x2F; dispatchRequest()&#x2F;响应拦截器通过promise链串连起来，返回promise\n\ndispatchRequest(config):转换请求数据&#x3D;&#x3D; &#x3D;&gt;调用xhrAdapter()发请求 &#x3D;&#x3D;&#x3D;&gt;请求返回后转换响应数据.返回 promise\n\nxhrAdapter(config):创建XHR对象，根据config进行相应设置，发送特定请求，并接收响应数据，返回promise\n\n\naxios的请求&#x2F;响应拦截器是什么\n\n\n请求拦截器:\n在真正发送请求前执行的回调函数\n可以对请求进行检查或配置进行特定处理\n成功的回调函数，传递的默认是config(也必须是)\n失败的回调函数，传递的默认是error\n\n\n响应拦截器\n在请求得到响应后执行的回调函数\n可以对响应数据进行特定处理\n成功的回调函数，传递的默认是response\n失败的回调函数，传递的默认是error\n\n\n\naxios的请求&#x2F;响应数据转换器是什么\n\n请求转换器:对请求头和请求体数据进行特定处理的函数if (utils.isObject(data)) {setContentTypelfUnset(headers, ‘application&#x2F;json;charset&#x3D;utf-8’);return JSON.stringify(data);}\n响应转换器:将响应体json字符串解析为js对象或数组的函数response.data &#x3D; JSON.parse(response.data)\n\nresponse的整体结构{data,\nstatus,\nstatusText,\nheaders,\nconfig,\nrequest}\nerror的整体结构{message,\nresponse,request,}\n如何取消未完成的请求\n\n当配置了cancelToken对象时，保存cancel函数\n(1创建一个用于将来中断请求的cancelPromise\n(2)并定义了一个用于取消请求的cancel函数\n(3)将cancel函数传递出来\n\n调用cancel()取消请求\n(1)执行cacel 函数，传入错误信息message\n(2)内部会让cancelPromise变为成功，且成功的值为一个Cancel对象\n(3)在cancelPromise 的成功回调中中断请求，并让发请求的 proimse失败，失败的reason为 Cancel对象\n\n\n","slug":"前端--详解axios（快速入门）","date":"2023-01-31T01:25:07.000Z","categories_index":"前端","tags_index":"Axios","author_index":"会思想的苇草i"},{"id":"0da050a8ade26330ecd92d326adb320f","title":"从回调地狱到Promise天堂：前端异步革命","content":"Promise1、Promise介绍与基本使用1.1 Promise概述理解\n\n抽象表达:\n1)Promise是一门新的技术(ES6规范)\n2)Promise是Js中进行异步编程的新解决方案\n\n备注:旧方案是单纯使用回调函数\n\n\n具体表达:\n  1)从语法上来说: Promise是一个构造函数\n  2)从功能上来说: promise对象用来封装一个异步操作(fs 文件操作、数据库操作、AJAX 、定时器 )并可以获取其成功&#x2F;失败的结果值\n\n\nPromise的状态改变\n\npending 变为resolved\npending变为reject\n\n\n说明:只有这2种，且一个promise对象只能改变一次；无论变为成功还是失败，都会有一个结果数据；成功的结果数据一般称为value，失败的结果数据一般称为reason\n\nPromise的基本流程\n\n1.2 Promise的作用\n指定回调函数的方式更加灵活\n旧的:必须在启动异步任务前指定\npromise:启动异步任务&#x3D;&gt;返回promie对象&#x3D;&gt;给promise对象绑定回调函数(甚至可以在异步任务结束后指定&#x2F;多个)\n\n\n支持链式调用，可以解决回调地狱问题\n什么是回调地狱 – 回调函数嵌套调用，外部回调函数异步执行的结果是嵌套的回调执行的条件\n回调地狱的缺点 – 不便于阅读，不便于异常处理\n解决方案 – promise链式调用\n终极解决方案 – async&#x2F;await\n\n\n\n1.3 Promise的使用\nPromise实践练习-fs模块\n\nconst fs = require(&#39;fs&#39;);\n\n//回调函数 形式\n// fs.readFile(&#39;./resource/content.txt&#39;, (err, data) =&gt; &#123;\n//     // 如果出错 则抛出错误\n//     if(err)  throw err;\n//     //输出文件内容\n//     console.log(data.toString());\n// &#125;);\n\n//Promise 形式\nlet p = new Promise((resolve , reject) =&gt; &#123;\n    fs.readFile(&#39;./resource/content.txt&#39;, (err, data) =&gt; &#123;\n        //如果出错\n        if(err) reject(err);\n        //如果成功\n        resolve(data);\n    &#125;);\n&#125;);\n\n//调用 then \np.then(value=&gt;&#123;\n    console.log(value.toString());\n&#125;, reason=&gt;&#123;\n    console.log(reason);\n&#125;);\n\n\nPromise封装练习-fs模块\n\n/**\n * 封装一个函数 mineReadFile 读取文件内容\n * 参数:  path  文件路径\n * 返回:  promise 对象\n */\nfunction mineReadFile(path)&#123;\n    return new Promise((resolve, reject) =&gt; &#123;\n        //读取文件\n        require(&#39;fs&#39;).readFile(path, (err, data) =&gt;&#123;\n            //判断\n            if(err) reject(err);\n            //成功\n            resolve(data);\n        &#125;);\n    &#125;);\n&#125;\n\nmineReadFile(&#39;./resource/content.txt&#39;)\n.then(value=&gt;&#123;\n    //输出文件内容\n    console.log(value.toString());\n&#125;, reason=&gt;&#123;\n    console.log(reason);\n&#125;);\n\n\nPromise实践练习-AJAX请求\n\n        const btn = document.querySelector(&#39;#btn&#39;);\n\n        btn.addEventListener(&#39;click&#39;, function()&#123;\n            //创建 Promise\n            const p = new Promise((resolve, reject) =&gt; &#123;\n                //1.创建对象\n                const xhr = new XMLHttpRequest();\n                //2. 初始化\n                xhr.open(&#39;GET&#39;, &#39;https://api.apiopen.top/getJoke&#39;);\n                //3. 发送\n                xhr.send();\n                //4. 处理响应结果\n                xhr.onreadystatechange = function()&#123;\n                    if(xhr.readyState === 4)&#123;\n                        //判断响应状态码 2xx   \n                        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;\n                            //控制台输出响应体\n                            resolve(xhr.response);\n                        &#125;else&#123;\n                            //控制台输出响应状态码\n                            reject(xhr.status);\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;);\n            //调用then方法\n            p.then(value=&gt;&#123;\n                console.log(value);\n            &#125;, reason=&gt;&#123;\n                console.warn(reason);\n            &#125;);\n        &#125;);\n\n\nPromise封装AJAX操作\n\n        /**\n         * 封装一个函数 sendAJAX 发送 GET AJAX 请求\n         * 参数   URL\n         * 返回结果 Promise 对象\n         */\n        function sendAJAX(url)&#123;\n            return new Promise((resolve, reject) =&gt; &#123;\n                const xhr = new XMLHttpRequest();\n                xhr.responseType = &#39;json&#39;;\n                xhr.open(&quot;GET&quot;, url);\n                xhr.send();\n                //处理结果\n                xhr.onreadystatechange = function()&#123;\n                    if(xhr.readyState === 4)&#123;\n                        //判断成功\n                        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;\n                            //成功的结果\n                            resolve(xhr.response);\n                        &#125;else&#123;\n                            reject(xhr.status);\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;);\n        &#125;\n    \n        sendAJAX(&#39;https://api.apiopen.top/getJok&#39;)\n        .then(value =&gt; &#123;\n            console.log(value);\n        &#125;, reason =&gt; &#123;\n            console.warn(reason);\n        &#125;);\n\n2、Promise API\nPromise构造函数: Promise (excutor){}\n(1)executor函数:执行器(resolve, reject)&#x3D;&gt;{}\n(2)resolve函数:内部定义成功时我们调用的函数value &#x3D;&gt;{}\n(3)reject 函数:内部定义失败时我们调用的函数reason &#x3D;&gt; {}\n\n说明: executor 会在 Promise 内部立即同步调用,异步操作在执行器中执行\n\n\nPromise.prototype.then方法:(onResolved, onRejected)&#x3D;&gt;{}\n (1)onResolved 函数:成功的回调函数(value)&#x3D;&gt;{}\n(2)onRejected 函数:失败的回调函数(reason)&#x3D;&gt;{}\n\n说明:指定用于得到成功value 的成功回调和用于得到失败reason的失败回调返回一个新的promise对象\n\n\nPromise.prototype.catch方法:(onRejected)&#x3D;&gt;{}\n\nonRejected 函数:失败的回调函数(reason)&#x3D;&gt; {}\n\n说明: then()的语法糖，相当于: then(undefined, onRejected)\n\n\n\nPromise.resolve方法:(value)&#x3D;&gt;{}\n\n\n\nvalue:成功的数据或promise对象\n\n说明:返回一个成功&#x2F;失败的promise对象\n\n\n\nPromise.reject方法: (reason)&#x3D;&gt;{}\n\n\nreason:失败的原因\n\n说明:返回一个失败的promise对象\n\n\n\nPromise.all方法:(promises)&#x3D;&gt;{}\n\n\npromises:包含n个promise的数组\n\n说明:返回一个新的promise，只有所有的promise都成功才成功，只要有一个失败了就直接失败\n\n\n\nPromise.race方法:(promises)&#x3D;&gt;0\n\npromises:包含n个promise的数组\n说明:返回一个新的promise，第一个完成的promise 的结果状态就是最终的结果状态\n\n\n\n3、Promise关键问题\n如何改变promise 的状态?\n(1)resolve(value):如果当前是pending就会变为resolved\n(2)reject(reason):如果当前是pending 就会变为rejected\n(3)抛出异常:如果当前是pending 就会变为rejected\n\n一个promise指定多个成功&#x2F;失败回调函数，都会调用吗?\n当promise改变为对应状态时都会调用\n\n改变promise状态和指定回调函数谁先谁后?\n(1)都有可能，正常情况下是先指定回调再改变状态(异步任务)，但也可以先改状态再指定回调(同步任务)\n(2)如何先改状态再指定回调?\n\n在执行器中直接调用resolve()&#x2F;reject()\n延迟更长时间才调用then()\n\n(3)什么时候才能得到数据?\n\n如果先指定的回调，那当状态发生改变时，回调函数就会调用，得到数据(异步任务)\n如果先改变的状态，那当指定回调时，回调函数就会调用，得到数据(同步任务)\n\n\npromise.then()返回的新promise的结果状态由什么决定?\n(1)简单表达:由 then()指定的回调函数执行的结果决定\n(2)详细表达:\n\n如果抛出异常，新promise变为rejected, reason为抛出的异常\n如果返回的是非promise的任意值，新promise变为resolved, value为返回的值\n如果返回的是另一个新promise，此promise的结果就会成为新promise的结果\n\n\npromise如何串连多个操作任务?\n(1)promise 的 then()返回一个新的promise，可以开成then()的链式调用\n(2)通过 then的链式调用串连多个同步&#x2F;异步任务\n\npromise异常传透?\n(1)当使用promise的then链式调用时，可以在最后指定失败的回调\n(2)前面任何操作出了异常，都会传到最后失败的回调中处理\n\n中断promise链?\n(1)当使用promise的then链式调用时，在中间中断，不再调用后面的回调函数\n(2)办法:在回调函数中返回一个pendding状态的 promise对象\n\n\n4、Promise自定义封装\n自定义Promise\n\n//声明构造函数\nfunction Promise(executor) &#123;\n    //添加属性\n    this.PromiseState = &#39;pending&#39;;\n    this.PromiseResult = null;\n    //声明属性\n    this.callbacks = [];\n    //保存实例对象的 this 的值\n    const self = this;// self _this that\n    //resolve 函数\n    function resolve(data) &#123;\n        //判断状态\n        if (self.PromiseState !== &#39;pending&#39;) return;\n        //1. 修改对象的状态 (promiseState)\n        self.PromiseState = &#39;fulfilled&#39;;// resolved\n        //2. 设置对象结果值 (promiseResult)\n        self.PromiseResult = data;\n        //调用成功的回调函数\n        setTimeout(() =&gt; &#123;\n            self.callbacks.forEach(item =&gt; &#123;\n                item.onResolved(data);\n            &#125;);\n        &#125;);\n    &#125;\n    //reject 函数\n    function reject(data) &#123;\n        //判断状态\n        if (self.PromiseState !== &#39;pending&#39;) return;\n        //1. 修改对象的状态 (promiseState)\n        self.PromiseState = &#39;rejected&#39;;// \n        //2. 设置对象结果值 (promiseResult)\n        self.PromiseResult = data;\n        //执行失败的回调\n        setTimeout(() =&gt; &#123;\n            self.callbacks.forEach(item =&gt; &#123;\n                item.onRejected(data);\n            &#125;);\n        &#125;)\n    &#125;\n    try &#123;\n        //同步调用『执行器函数』\n        executor(resolve, reject);\n    &#125; catch (e) &#123;\n        //修改 promise 对象状态为『失败』\n        reject(e);\n    &#125;\n&#125;\n\n//添加 then 方法\nPromise.prototype.then = function (onResolved, onRejected) &#123;\n    const self = this;\n    //判断回调函数参数\n    if (typeof onRejected !== &#39;function&#39;) &#123;\n        onRejected = reason =&gt; &#123;\n            throw reason;\n        &#125;\n    &#125;\n    if (typeof onResolved !== &#39;function&#39;) &#123;\n        onResolved = value =&gt; value;\n        //value =&gt; &#123; return value&#125;;\n    &#125;\n    return new Promise((resolve, reject) =&gt; &#123;\n        //封装函数\n        function callback(type) &#123;\n            try &#123;\n                //获取回调函数的执行结果\n                let result = type(self.PromiseResult);\n                //判断\n                if (result instanceof Promise) &#123;\n                    //如果是 Promise 类型的对象\n                    result.then(v =&gt; &#123;\n                        resolve(v);\n                    &#125;, r =&gt; &#123;\n                        reject(r);\n                    &#125;)\n                &#125; else &#123;\n                    //结果的对象状态为『成功』\n                    resolve(result);\n                &#125;\n            &#125; catch (e) &#123;\n                reject(e);\n            &#125;\n        &#125;\n        //调用回调函数  PromiseState\n        if (this.PromiseState === &#39;fulfilled&#39;) &#123;\n            setTimeout(() =&gt; &#123;\n                callback(onResolved);\n            &#125;)\n        &#125;\n        if (this.PromiseState === &#39;rejected&#39;) &#123;\n            setTimeout(() =&gt; &#123;\n                callback(onRejected);\n            &#125;)\n        &#125;\n        //判断 pending 状态\n        if (this.PromiseState === &#39;pending&#39;) &#123;\n            //保存回调函数\n            this.callbacks.push(&#123;\n                onResolved: function () &#123;\n                    callback(onResolved);\n                &#125;,\n                onRejected: function () &#123;\n                    callback(onRejected);\n                &#125;\n            &#125;);\n        &#125;\n    &#125;)\n&#125;\n\n//添加 catch 方法\nPromise.prototype.catch = function (onRejected) &#123;\n    return this.then(undefined, onRejected);\n&#125;\n\n//添加 resolve 方法\nPromise.resolve = function (value) &#123;\n    //返回promise对象\n    return new Promise((resolve, reject) =&gt; &#123;\n        if (value instanceof Promise) &#123;\n            value.then(v =&gt; &#123;\n                resolve(v);\n            &#125;, r =&gt; &#123;\n                reject(r);\n            &#125;)\n        &#125; else &#123;\n            //状态设置为成功\n            resolve(value);\n        &#125;\n    &#125;);\n&#125;\n\n//添加 reject 方法\nPromise.reject = function (reason) &#123;\n    return new Promise((resolve, reject) =&gt; &#123;\n        reject(reason);\n    &#125;);\n&#125;\n\n//添加 all 方法\nPromise.all = function (promises) &#123;\n    //返回结果为promise对象\n    return new Promise((resolve, reject) =&gt; &#123;\n        //声明变量\n        let count = 0;\n        let arr = [];\n        //遍历\n        for (let i = 0; i &lt; promises.length; i++) &#123;\n            //\n            promises[i].then(v =&gt; &#123;\n                //得知对象的状态是成功\n                //每个promise对象 都成功\n                count++;\n                //将当前promise对象成功的结果 存入到数组中\n                arr[i] = v;\n                //判断\n                if (count === promises.length) &#123;\n                    //修改状态\n                    resolve(arr);\n                &#125;\n            &#125;, r =&gt; &#123;\n                reject(r);\n            &#125;);\n        &#125;\n    &#125;);\n&#125;\n\n//添加 race 方法\nPromise.race = function (promises) &#123;\n    return new Promise((resolve, reject) =&gt; &#123;\n        for (let i = 0; i &lt; promises.length; i++) &#123;\n            promises[i].then(v =&gt; &#123;\n                //修改返回对象的状态为 『成功』\n                resolve(v);\n            &#125;, r =&gt; &#123;\n                //修改返回对象的状态为 『失败』\n                reject(r);\n            &#125;)\n        &#125;\n    &#125;);\n&#125;\n\n5、async与await5.1. mdn文档https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async functionhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await\n5.2.async函数\n函数的返回值为promise对象\n\npromise对象的结果由async函数执行的返回值决定\n\n\n5.3.await表达式\nawait右侧的表达式一般为promise对象，但也可以是其它的值\n如果表达式是promise对象, await返回的是promise 成功的值\n如果表达式是其它值，直接将此值作为await的返回值\n\n5.4.注意\nawait 必须写在async函数中，但 async函数中可以没有await\n如果await 的promise失败了，就会抛出异常，需要通过try…catch 捕获处理\n\n","slug":"前端--Promise详解与手写实现","date":"2023-01-28T00:56:24.000Z","categories_index":"前端","tags_index":"Promise","author_index":"会思想的苇草i"},{"id":"49049ff97839855eecbcd2b661106a8a","title":"Node.js入门指南","content":"Node.js1、初识Node.js与内置模块1.1 Node.js初识JavaScript可以在浏览器中执行\n\n不同的浏览器使用不同的JavaScript解析引擎:\nChrome浏览器 &#x3D;&gt;  v8\nFirefox浏览器 &#x3D;&gt;  OdinMonkey(奥丁猴)\nSafri浏览器 &#x3D;&gt;  JSCore\nIE浏览器 &#x3D;&gt; Chakra(查克拉)\netc…\n\n\n其中，Chrome浏览器的V8解析引擎性能最好!\n\nJavaScript操作DOM和BOM\n\n每个浏览器都内置了DOM、BOM这样的API函数，因此，浏览器中的JavaScript才可以调用它们\n\n浏览器中的JavaScript运行环境\n\n运行环境是指代码正常运行所需的必要环境\n\n\n\n总结:\nv8引擎负责解析和执行JavaScript 代码\n内置API是由运行环境提供的特殊接口，只能在所属的运行环境中被调用\n\n\n\nNode.js简介\n\nNode.js is a JavaScript runtime built on Chrome’s V8 JavaScript engine\n\nNode.js是一个基于Chrome V8引擎的JavaScript运行环境\n\nNode.js 的官网地址: https://nodejs.org/zh-cn/\n\n注意：\n\n浏览器是JavaScript的前端运行环境\nNode.js是JavaScript的后端运行环境\nNode.js中无法调用DOM和 BOM等浏览器内置API\n\n\n用途：\n\n基于Express框架（http://www.expressjs.com.cn/)，可以快速构建Web应用\n基于Electron框架(https://electronjs.org/)，可以构建跨平台的桌面应用\n基于restify框架(http://restify.com/)，可以快速构建API接口项目\n读写和操作数据库、创建实用的命令行工具辅助前端开发、etc…\n\n\n\nNode.js的安装\n\n安装包可以从Node.js的官网首页直接下载，进入到Node.js的官网首页(https://nodejs.org/en/) node.js中文网 (Node.js 中文网 (nodejs.cn))，点击绿色的按钮，下载所需的版本后，双击直接安装即可\n\nLTS为长期稳定版，对于追求稳定性的企业级项目来说，推荐安装LTS版本的Node.js\n\nCurrent为新特性尝鲜版，对热衷于尝试新特性的用户来说，推荐安装Current版本的Node.js。但是，Current 版本中可能存在隐藏的Bug 或安全性漏洞，因此不推荐在企业级项目中使用Current版本的Node.js\n\n打开终端，在终端输入命令node -v后，按下回车键，即可查看已安装的Node.js的版本号\n\n在Node.js环境中执行JavaScript 代码\n\n打开终端\n输入node要执行的js文件的路径\n\n\n\n1.2 fs文件系统模块fs文件系统模块概述\n\nfs模块是Node.js官方提供的、用来操作文件的模块。它提供了一系列的方法和属性，用来满足用户对文件的操作需求、例如:\nfs.readFile()方法，用来读取指定文件中的内容\nfs.writeFile()方法，用来向指定的文件中写入内容\n\n\n\n读取指定文件中的内容\n\n使用fs.readFile()方法，可以读取指定文件中的内容，语法格式如下:\n\nfs.readFile(path[, options], callback)\n\n\n参数解读:\n参数1:必选参数，字符串，表示文件的路径\n参数2:可选参数，表示以什么编码格式来读取文件\n参数3:必选参数，文件读取完成后，通过回调函数拿到读取的结果\n\n\n代码：\n\n// 1. 导入 fs 模块，来操作文件\nconst fs = require(&#39;fs&#39;)\n\n// 2. 调用 fs.readFile() 方法读取文件\n//    参数1：读取文件的存放路径\n//    参数2：读取文件时候采用的编码格式，一般默认指定 utf8\n//    参数3：回调函数，拿到读取失败和成功的结果  err  dataStr\nfs.readFile(&#39;./files/1.txt&#39;, &#39;utf8&#39;, function (err, dataStr) &#123;\n  // 2.1 打印失败的结果\n  // 如果读取成功，则 err 的值为 null\n  // 如果读取失败，则 err 的值为 错误对象，dataStr 的值为 undefined\n  console.log(err)\n  console.log(&#39;-------&#39;)\n  // 2.2 打印成功的结果\n  console.log(dataStr)\n&#125;)\n\n\n判断文件是否读取成功：\n\nconst fs = require(&#39;fs&#39;)\n\nfs.readFile(&#39;./files/1.txt&#39;, &#39;utf8&#39;, function(err, dataStr) &#123;\n  if (err) &#123;\n    return console.log(&#39;读取文件失败！&#39; + err.message)\n  &#125;\n  console.log(&#39;读取文件成功！&#39; + dataStr)\n&#125;)\n\n向指定文件写入内容\n\n使用fs.writeFile()方法，可以向指定的文件中写入内容，语法格式如下:\n\nfs.writeFile(file,data[, options], callback)\n\n\n参数解读:\n参数1:必选参数，需要指定一个文件路径的字符串，表示文件的存放路径\n参数2:必选参数，表示要写入的内容\n参数3:可选参数，表示以什么格式写入文件内容，默认值是utf-8\n参数4:必选参数，文件写入完成后的回调函数\n\n\n代码：\n\n// 1. 导入 fs 文件系统模块\nconst fs = require(&#39;fs&#39;)\n\n// 2. 调用 fs.writeFile() 方法，写入文件的内容\n//    参数1：表示文件的存放路径\n//    参数2：表示要写入的内容\n//    参数3：回调函数\nfs.writeFile(&#39;./files/2.txt&#39;, &#39;Hello&#39;, function (err) &#123;\n  // 2.1 如果文件写入成功，则 err 的值等于 null\n  // 2.2 如果文件写入失败，则 err 的值等于一个 错误对象\n  // console.log(err)\n\n  if (err) &#123;\n    return console.log(&#39;文件写入失败！&#39; + err.message)\n  &#125;\n  console.log(&#39;文件写入成功！&#39;)\n&#125;)\n\nfs模块–路径动态拼接的问题\n\n在使用fs 模块操作文件时，如果提供的操作路径是以.&#x2F;或..&#x2F;开头的相对路径时，(非当前目录时)很容易出现路径动态拼接错误的问题\n\n原因:代码在运行的时候，会以执行node命令时所处的目录，动态拼接出被操作文件的完整路径\n\n解决方案:在使用fs模块操作文件时，直接提供完整的路径，不要提供.&#x2F;或..&#x2F;开头的相对路径，从而防止路径动态拼接的问题\n\n代码：\n\n\n// __dirname 表示当前文件所处的目录\nfs.readFile(__dirname + &#39;/files/1.txt&#39;, &#39;utf8&#39;, function(err, dataStr) &#123;\n  if (err) &#123;\n    return console.log(&#39;读取文件失败！&#39; + err.message)\n  &#125;\n  console.log(&#39;读取文件成功！&#39; + dataStr)\n&#125;)\n\n1.3 path路径模块path路径模块概述\n\npath模块是Node.js官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理需求\n例如:\npath.join()方法，用来将多个路径片段拼接成一个完整的路径字符串\npath.basename()方法，用来从路径字符串中，将文件名解析出来\n\n\n\n路径拼接\n\n使用path.join(方法，可以把多个路径片段拼接为完整的路径字符串，语法格式如下:\n\npath.join( [ .. .paths])\n\n\n参数解读:\n…paths &lt; string &gt;路径片段的序列\n返回值: &lt; string &gt;\n\n\n代码：\n\n//注意：  ../ 会抵消前面的路径\nconst pathStr = path.join(&#39;/a&#39;, &#39;/b/c&#39;, &#39;../&#39;, &#39;./d&#39;, &#39;e&#39;)\nconsole.log(pathStr)  // \\a\\b\\d\\e\n\n\n注意:今后凡是涉及到路径拼接的操作，都要使用path.join()方法进行处理，不要直接使用＋进行字符串的拼接\n代码：\n\nfs.readFile(path.join(__dirname, &#39;./files/1.txt&#39;), &#39;utf8&#39;, function (err, dataStr) &#123;\n  if (err) &#123;\n    return console.log(err.message)\n  &#125;\n  console.log(dataStr)\n&#125;)\n\n获取路径中的文件名\n\n使用path.basename()方法，可以获取路径中的最后一部分，经常通过这个方法获取路径中的文件名，语法格式如下:\n\npath.basename(path[, ext])\n\n\n参数解读:\n\npath &lt; string &gt;必选参数，表示—个路径的字符串\next &lt; string &gt;可选参数，表示文件扩展名\n返回: &lt; string &gt;表示路径中的最后—部分\n\n\n代码：\n\n\nconst path = require(&#39;path&#39;)\n\n// 定义文件的存放路径\nconst fpath = &#39;/a/b/c/index.html&#39;\n\nconst fullName = path.basename(fpath)\nconsole.log(fullName)//index.html\n\nconst nameWithoutExt = path.basename(fpath, &#39;.html&#39;)\nconsole.log(nameWithoutExt)//index\n\n获取路径中的文件扩展名\n\n使用path.extname)方法，可以获取路径中的扩展名部分，语法格式如下:\n\npath.extname(path)\n\n\n参数解读:\n\npath &lt; string &gt;必选参数，表示—个路径的字符串\n返回:&lt; string &gt;返回得到的扩展名字符串\n\n\n代码：\n\n\nconst path = require(&#39;path&#39;)\n\n// 这是文件的存放路径\nconst fpath = &#39;/a/b/c/index.html&#39;\n\nconst fext = path.extname(fpath)\nconsole.log(fext)\n\n1.4 http模块 http模块概述\n\n在网络节点中，负责消费资源的电脑，叫做客户端;负责对外提供网络资源的电脑，叫做服务器\nhttp模块是Node.js官方提供的、用来创建web服务器的模块。通过http模块提供的 http.createServer(方法，就能方便的把一台普通的电脑，变成一台Web服务器，从而对外提供Web 资源服务\n服务器和普通电脑的区别在于，服务器上安装了web服务器软件，例如:lIS、Apache等。通过安装这些服务器软件，就能把一台普通的电脑变成一台web服务器\n在Node.js 中，我们不需要使用IIS、Apache等这些第三方web服务器软件。因为我们可以基于Node.js 提供的http模块，通过几行简单的代码，就能轻松的手写一个服务器软件，从而对外提供web服务\n\n服务器相关概念：\n1、IP地址\n\nIP地址就是互联网上每台计算机的唯一地址，因此IP地址具有唯一性。如果把“个人电脑”比作“一台电话”，那么“IP地址”就相当于“电话号码”，只有在知道对方IP地址的前提下，才能与对应的电脑之间进行数据通信\nIP地址的格式:通常用“点分十进制”表示成(a.b.c.d)的形式其中，a,b,c,d都是0~255之间的十进制整数。例如:用点分十进表示的IP地址(192.168.1.1)\n注意:\n互联网中每台Web服务器，都有自己的IP地址，例如:大家可以在Windows的终端中运行ping www.baidu.com 命令，即可查看到百度服务器的IP地址\n在开发期间，自己的电脑既是一台服务器，也是一个客户端，为了方便测试，可以在自己的浏览器中输入127.0.0.1这个IP地址，就能把自己的电脑当做一台服务器进行访问了\n\n\n\n2、域名和域名服务器\n\n尽管IP地址能够唯一地标记网络上的计算机，但IP地址是一长串数字，不直观，而且不便于记忆，于是人们又发明了另一套字符型的地址方案，即所谓的域名(Domain Name)地址\nIP地址和域名是——对应的关系，这份对应关系存放在一种叫做域名服务器(DNS,Domain name server)的电脑中。使用者只需通过好记的域名访问对应的服务器即可，对应的转换工作由域名服务器实现。因此，域名服务器就是提供IР地址和域名之问的转换服务的服务器\n注意:\n单纯使用IP地址，互联网中的电脑也能够正常工作。但是有了域名的加持，能让互联网的世界变得更加方便\n在开发测试期间，127.0.0.1对应的域名是localhost，它们都代表我们自己的这台电脑，在使用效果上没有任何区别\n\n\n\n3、端口号\n\n计算机中的端口号，就好像是现实生活中的门牌号一样。通过门牌号，外卖小哥可以在整栋大楼众多的房间中，准确把外卖送到你的手中\n同样的道理，在一台电脑中，可以运行成百上千个web服务。每个web服务都对应一个唯一的端口号。客户端发送过来的网络请求，通过端口号，可以被准确地交给对应的web服务进行处理\n注意:\n每个端口号不能同时被多个web 服务占用\n在实际应用中，URL中的80端口可以被省略\n\n\n\n\n创建最基本的web服务器\n\n步骤\n\n\n导入http模块\n\n\n如果希望在自己的电脑上创建一个web服务器，从而对外提供web 服务，则需要导入http模块\n\n\n创建web 服务器实例\n\n\n调用http.createServer()方法，即可快速创建一个 web 服务器实例\n\n\n为服务器实例绑定request事件，监听客户端的请求\n\n\n为服务器实例绑定request事件，即可监听客户端发送过来的网络请求\n\n\n启动服务器\n\n\n调用服务器实例的.listen0方法，即可启动当前的web 服务器实例\n代码：\n\n// 1. 导入 http 模块\nconst http = require(&#39;http&#39;)\n// 2. 创建 web 服务器实例\nconst server = http.createServer()\n// 3. 为服务器实例绑定 request 事件，监听客户端的请求\nserver.on(&#39;request&#39;, function (req, res) &#123;\n  console.log(&#39;Someone visit our web server.&#39;)\n&#125;)\n// 4. 启动服务器\nserver.listen(8080, function () &#123;  \n  console.log(&#39;server running at http://127.0.0.1:8080&#39;)\n&#125;)\n\n\nreq请求对象\n\n只要服务器接收到了客户端的请求，就会调用通过server.on为服务器绑定的 request事件处理函数。如果想在事件处理函数中，访问与客户端相关的数据或属性，可以使用如下的方式:\n\nres响应对象\n\n在服务器的request事件处理函数中，如果想访问与服务器相关的数据或属性，可以使用如下的方式:\n\n\nserver.on(&#39;request&#39;, (req, res) =&gt; &#123;\n  // req.url 是客户端请求的 URL 地址\n  const url = req.url\n  // req.method 是客户端请求的 method 类型\n  const method = req.method\n  const str = `Your request url is $&#123;url&#125;, and request method is $&#123;method&#125;`\n  console.log(str)\n  // 调用 res.end() 方法，向客户端响应一些内容\n  res.end(str)\n&#125;)\n\n\n解决中文乱码问题\n当调用res.end()方法，向客户端发送中文内容的时候，会出现乱码问题，此时，需要手动设置内容的编码格式:\n\nserver.on(&#39;request&#39;, (req, res) =&gt; &#123;\n  // 定义一个字符串，包含中文的内容\n  const str = `您请求的 URL 地址是 $&#123;req.url&#125;，请求的 method 类型为 $&#123;req.method&#125;`\n  // 调用 res.setHeader() 方法，设置 Content-Type 响应头，解决中文乱码的问题\n  res.setHeader(&#39;Content-Type&#39;, &#39;text/html; charset=utf-8&#39;)\n  // res.end() 将内容响应给客户端\n  res.end(str)\n&#125;)\n\n根据不同的url响应不同的html内容\n\n获取请求的url地址\n设置默认的响应内容为404 Not found\n判断用户请求的是否为&#x2F;或&#x2F;index.html首页\n判断用户请求的是否为&#x2F;about.html关于页面\n设置Content-Type响应头，防止中文乱码\n使用res.end()把内容响应给客户端\n\n\n代码：\n\nconst http = require(&#39;http&#39;)\nconst server = http.createServer()\n\nserver.on(&#39;request&#39;, (req, res) =&gt; &#123;\n  // 1. 获取请求的 url 地址\n  const url = req.url\n  // 2. 设置默认的响应内容为 404 Not found\n  let content = &#39;&lt;h1&gt;404 Not found!&lt;/h1&gt;&#39;\n  // 3. 判断用户请求的是否为 / 或 /index.html 首页\n  // 4. 判断用户请求的是否为 /about.html 关于页面\n  if (url === &#39;/&#39; || url === &#39;/index.html&#39;) &#123;\n    content = &#39;&lt;h1&gt;首页&lt;/h1&gt;&#39;\n  &#125; else if (url === &#39;/about.html&#39;) &#123;\n    content = &#39;&lt;h1&gt;关于页面&lt;/h1&gt;&#39;\n  &#125;\n  // 5. 设置 Content-Type 响应头，防止中文乱码\n  res.setHeader(&#39;Content-Type&#39;, &#39;text/html; charset=utf-8&#39;)\n  // 6. 使用 res.end() 把内容响应给客户端\n  res.end(content)\n&#125;)\n\nserver.listen(80, () =&gt; &#123;\n  console.log(&#39;server running at http://127.0.0.1&#39;)\n&#125;)\n\n2、模块化2.1 模块化的基本概念什么是模块化\n\n模块化是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过程，对于整个系统来说，模块是可组合、分解和更换的单元\n编程领域中的模块化，就是遵守固定的规则，把一个大文件拆成独立并互相依赖的多个小模块。\n把代码进行模块化拆分的好处:\n提高了代码的复用性\n提高了代码的可维护性\n可以实现按需加载\n\n\n\n模块化规范\n\n模块化规范就是对代码进行模块化的拆分与组合时，需要遵守的那些规则\n例如:\n使用什么样的语法格式来引用模块\n在模块中使用什么样的语法格式向外暴露成员\n\n\n模块化规范的好处:大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块之间的相互调用，利人利己\n\n2.2 Node.js中模块化Node.js中模块的分类\n\nNode.js 中根据模块来源的不同，将模块分为了3大类，分别是:\n内置模块(内置模块是由Node.js官方提供的，例如fs、path、http 等)\n自定义模块(用户创建的每个.js 文件，都是自定义模块)\n第三方模块（由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载)\n\n\n\n加载模块\n\n使用强大的require()方法，可以加载需要的内置模块、用户自定义模块、第三方模块进行使用\n注意:使用require0方法加载其它模块时，会执行被加载模块中的代码**(加载且执行)**\n\nNode.js中模块作用域\n\n和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域\n防止全局变量污染问题\n\n向外共享模块作用域中的成员\n\nmodule对象在每个.js自定义模块中都有一个module对象，它里面存储了和当前模块有关的信息\n\nmodule.exports对象在自定义模块中，可以使用module.exports对象，将模块内的成员共享出去，供外界使用。外界用require(方法导入自定义模块时，得到的就是 module.exports 所指向的对象\n\n共享成员时的注意点使用require()方法导入模块时，导入的结果，永远以module.exports指向的对象为准\n\n\n\n代码：\n\n// 在外界使用 require 导入一个自定义模块的时候，得到的成员，\n// 就是 那个模块中，通过 module.exports 指向的那个对象\nconst m = require(&#39;./自定义模块&#39;)\n\nconsole.log(m)\n\n// 在一个自定义模块中，默认情况下， module.exports = &#123;&#125;\n\nconst age = 20//*\n\n// 1、向 module.exports 对象上挂载 username 属性\nmodule.exports.username = &#39;zs&#39;\n// 2、向 module.exports 对象上挂载 sayHello 方法\nmodule.exports.sayHello = function () &#123;\n  console.log(&#39;Hello!&#39;)\n&#125;\nmodule.exports.age = age//*\n\n///3、让 module.exports 指向一个全新的对象\nmodule.exports = &#123;\n  nickname: &#39;小黑&#39;,\n  sayHi() &#123;\n    console.log(&#39;Hi!&#39;)\n  &#125;\n&#125;\n\n\nexports 对象由于module.exports单词写起来比较复杂，为了简化向外共享成员的代码，Node 提供了exports对象。默认情况下，exports和module.exports 指向同一个对象。最终共享的结果，还是以module.exports 指向的对象为准\n时刻谨记,require()模块时，得到的永远是module.exports指向的对象\n注意:为了防止混乱，建议大家不要在同一个模块中同时使用exports和module.exports\n\n\n\n\n\n一开始指向同一个对象，得到的永远是module.exports指向的对象，关键看有没有指向新的对象！！！\n\nNode.js中的模块化规范\n\nNode.js遵循了CommonJS模块化规范，CommonJS规定了模块的特性和各模块之间如何相互依赖\nCommonJS规定:\n每个模块内部,module变量代表当前模块\nmodule变量是一个对象，它的exports 属性(即module.exports）是对外的接口\n加载某个模块，其实是加载该模块的module.exports 属性。require()方法用于加载模块\n\n\n\n2.3 npm与包包\n\nNode.js 中的第三方模块又叫做包\n不同于Node.js 中的内置模块与自定义模块，包是由第三方个人或团队开发出来的，免费供所有人使用(免费且开源)\n由于Node.js的内置模块仅提供了一些底层的API，导致在基于内置模块进行项目开发的时，效率很低。包是基于内置模块封装出来的，提供了更高级、更方便的API，极大的提高了开发效率；包和内置模块之间的关系，类似于jQuery和浏览器内置API之间的关系\n注意:\n从https://www.npmjs.com/ 网站上搜索自己所需要的包\n从https://registry.npmjs.org/服务器上**下载**自己需要的包\n\n\n这个包管理工具的名字叫做Node Package Manager(简称npm包管理工具)，这个包管理工具随着Node.js 的安装包一起被安装到了用户的电脑上\n大家可以在终端中执行npm -v命令，来查看自己电脑上所安装的npm包管理工具的版本号\n\nnpm\n\n在项目中安装指定名称的包：npm install 包的完整名称 ;可简写为：npm i 包的完整名称\n初次装包完成后，在项目文件夹下多一个叫做node_modules的文件夹和package-lock.json的配置文件\n其中:\nnode modules文件夹用来存放所有已安装到项目中的包；require()导入第三方包时，就是从这个目录中查找并加载包\npackage-lockjson配置文件用来记录node_modules目录下的每一个包的下载信息，例如包的名字、版本号、下载地址等\n注意:程序员不要手动修改node modules或package-lock.json文件中的任何代码，npm 包管理工具会自动维护它们\n\n\n默认情况下，使用npm install命令安装包的时候，会自动安装最新版本的包。如果需要安装指定版本的包，可以在包名之后，通过**@符号指定具体的版本**，例如:npm i moment@2.22.2\n包的版本号是以“点分十进制”形式进行定义的，总共有三位数字，例如2.24.0其中每一位数字所代表的的含义如下:\n第1位数字:大版本\n第2位数字:功能版本\n第3位数字: Bug修复版本\n版本号提升的规则:只要前面的版本号增长了，则后面的版本号归零\n\n\n\n包管理配置文件\n\nnpm 规定，在项目根目录中，必须提供一个叫做 package.json的包管理配置文件。用来记录与项目有关的一些配置信息。例如:\n\n项目的名称、版本号、描述等\n项目中都用到了哪些包\n哪些包只在开发期间会用到\n那些包在开发和部署时都需要用到\n\n\n多人协作 – 共享时剔除node_modules\n\n在项目根目录中，创建一个叫做package,json的配置文件，即可用来记录项目中安装了哪些包。从而方便剔除node_modules 目录之后，在团队成员之间共享项目的源代码\n\n注意:今后在项目开发中，一定要把node_modules文件夹，添加到.gitignore忽略文件中\n\n\n快速创建package.json\n\nnpm包管理工具提供了一个快捷命令，可以在执行命令时所处的目录中，快速创建package.json这个包管理配置文件: npm init -y\n注意:\n上述命令只能在英文的目录下成功运行！所以，项目文件夹的名称一定要使用英文命名，不要使用中文，不能出现空格\n运行npm install 命令安装包的时候，npm包管理工具会自动把包的名称和版本号，记录到 package.json 中\n\n\n\ndependencies节点\n\npackage.json文件中，有一个dependencies节点，专门用来记录您使用npm install命令安装了哪些包\n\n\n一次性安装所有的包\n\n可以运行npm install命令(或npm i)一次性安装所有的依赖包\n执行npm install 命令时，npm包管理工具会先读取package.json 中的 dependencies节点\n读取到记录的所有依赖包名称和版本号之后，npm包管理工具会把这些包一次性下载到项目中\n\n卸载包\n\n可以运行npm uninstall命令，来卸载指定的包\n注意: npm uninstall 命令执行成功后，会把卸载的包，自动从packagejson的dependencies中移除掉。\n\ndevDependencies节点\n\n如果某些包只在项目开发阶段会用到，在项目上线之后不会用到，则建议把这些包记录到devDependencies节点中;与之对应的，如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到dependencies节点中\n可以使用如下的命令，将包记录到devDependencies节点中:npm i 包名-D (简写) npm install包名--save-dev(完整)\n\nnpm下包速度慢的解决\n\n在使用npm下包的时候，默认从国外的 https://registry.npmjs.org/服务器进行下载，此时，网络数据的传输需要经过漫长的海底光缆，因此下包速度会很慢\n淘宝在国内搭建了一个服务器，专门把国外官方服务器上的包同步到国内的服务器，然后在国内提供下包的服务；从而极大的提高了下包的速度\n\n\n\n切换npm的下包镜像源\n\n# 查看当前的下包镜像源\nnpm config get registry\n\n# 将下包的镜像源切换为淘宝镜像源\nnpm config set registry=https : /lregistry.npm.taobao.org/\n\n# 检查镜像源是否下载成功\nnpm config get registry\n\n\n为了更方便的切换下包的镜像源，我们可以安装nrm这个小工具，利用nrm提供的终端命令，可以快速查看和切换下包的镜像源。\n\n# 通过npm包管理器，将nrm安装为全局可用的工具\nnpm i nrm -g\n\n# 查看所有可用的镜像源\nnrm ls\n\n# 将下包的镜像源切换为taobao镜像\nnrm use taobao\n\n包的分类\n\n使用npm包管理工具下载的包，共分为两大类，分别是:\n项目包\n那些被安装到项目的node_modules目录中的包，都是项目包\n项目包又分为两类，分别是:\n开发依赖包(被记录到devDependencies节点中的包，只在开发期间会用到)\n核心依赖包（被记录到dependencies节点中的包，在开发期间和项目上线之后都会用到)\n\n\n\n\n全局包\n在执行npm install 命令时，如果提供了 -g参数，则会把包安装为全局包\n全局包会被安装到C:\\Users用户目录\\AppData\\Roaminginpm\\node_modules目录下\n注意:\n只有工具性质的包，才有全局安装的必要性，因为它们提供了好用的终端命令\n判断某个包是否需要全局安装后才能使用，可以参考官方提供的使用说明即可\n\n\n\n\n\n\n\ni5ting_toc\n\ni5ting_toc是一个可以把md文档转为 html页面的小工具，使用步骤如下:\n\n# 将i5ting_toc安装为全局包\nnpm install -g i5ting toc\n\n# 调用i5ting_toc，轻松实现md转html的功能\ni5ting_toc -f 要转换的md文件路径 -o\n\n规范的包结构\n\n一个规范的包，它的组成结构，必须符合以下3点要求:\n包必须以单独的目录而存在\n包的顶级目录下要必须包含package.json这个包管理配置文件\npackage.json中必须包含name，version，main这三个属性，分别代表包的名字、版本号、包的入口\n\n\n更多约束：https://yarnpkg.com/zh-Hans/docs/package-json\n\n编写包 – 发布包 – 使用包\n2.4 模块的加载机制优先从缓存中加载\n\n模块在第一次加载后会被缓存，这也意味着多次调用require()不会导致模块的代码被执行多次\n注意:不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而提高模块的加载效率\n\n内置模块的加载机制\n\n内置模块是由Node.js官方提供的模块，内置模块的加载优先级最高\n例如，require(‘fs’)始终返回内置的fs模块，即使在node_modules目录下有名字相同的包也叫做fs\n\n自定义模块的加载机制\n\n使用require()加载自定义模块时，必须指定以.&#x2F;或..&#x2F;开头的路径标识符。在加载自定义模块时，如果没有指定.&#x2F;或..&#x2F;这样的路径标识符，则node 会把它当作内置模块或第三方模块进行加载\n同时，在使用require()导入自定义模块时，如果省略了文件的扩展名，则Nodejs 会按顺序分别尝试加载以下的文件:\n\n\n按照确切的文件名进行加载\n补全js扩展名进行加载\n补全 .json扩展名进行加载\n补全.node扩展名进行加载\n加载失败，终端报错\n\n第三方模块的加载机制\n\n如果传递给require()的模块标识符不是一个内置模块，也没有以.&#x2F;或..&#x2F;开头，则Node.js 会从当前模块的父目录开始，尝试从&#x2F;node_modules文件夹中加载第三方模块\n\n如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录\n\n例如，假设在’C:\\Users\\itheima\\project\\foojs’文件里调用require(“tools’)，则 Node.js 会按以下顺序找:\n\n\n\nC:\\Users\\heima\\project\\node_modules\\tools\nC:\\Users\\heima\\node_modules\\tools\nC:\\Users\\node_modules\\tools\nC:\\node_modules\\tools\n\n目录作为模块\n\n当把目录作为模块标识符，传递给require(进行加载的时候，有三种加载方式:\n\n\n在被加载的目录下查找一个叫做 package.json的文件，并寻找main属性，作为require()加载的入口\n如果目录里没有package.json 文件，或者main入口不存在或无法解析，则Node.js将会试图加载目录下的 index.js文件\n如果以上两步都失败了，则Nodejs 会在终端打印错误消息，报告模块的缺失: Error. Cannot find module ‘xxx’\n\n3、Express3.1 初识ExpressExpress简介\n\n官方给出的概念: Express是基于Node.js平台，快速、开放、极简的Web开发框架\n\n通俗的理解: Express 的作用和Node.,js 内置的http模块类似，是专门用来创建Web服务器的\n\nExpress 的本质:就是一个npm 上的第三方包，提供了快速创建web服务器的便捷方法\n\nExpress 的中文官网: http://www.expressjs.com.cn/\n\n对于前端程序员来说，最常见的两种服务器，分别是:\n\nWeb 网站服务器:专门对外提供Web 网页资源的服务器\n\nAPI接口服务器:专门对外提供API接口的服务器\n\n\n\n使用Express，我们可以方便、快速的创建Web 网站的服务器或API接口的服务器\n\n\nExpress基本使用\n\n安装：npm i express@4.17.1\n创建基本的Web服务器\n监听GET请求\n监听POST请求\n把内容响应给客户端\n获取URL中携带的查询参数\n获取URL中的动态参数\n\n\n代码：\n\n// 1. 导入 express\nconst express = require(&#39;express&#39;)\n// 2. 创建 web 服务器\nconst app = express()\n\n// 3. 监听客户端的 GET 和 POST 请求，并向客户端响应具体的内容\napp.get(&#39;/user&#39;, (req, res) =&gt; &#123;\n  // 调用 express 提供的 res.send() 方法，向客户端响应一个 JSON 对象\n  res.send(&#123; name: &#39;zs&#39;, age: 20, gender: &#39;男&#39; &#125;)\n&#125;)\napp.post(&#39;/user&#39;, (req, res) =&gt; &#123;\n  // 调用 express 提供的 res.send() 方法，向客户端响应一个 文本字符串\n  res.send(&#39;请求成功&#39;)\n&#125;)\napp.get(&#39;/&#39;, (req, res) =&gt; &#123;\n  // 通过 req.query 可以获取到客户端发送过来的 查询参数\n  // 注意：默认情况下，req.query 是一个空对象\n  console.log(req.query)\n  res.send(req.query)\n&#125;)\n// 注意：这里的 :id 是一个动态的参数\napp.get(&#39;/user/:ids/:username&#39;, (req, res) =&gt; &#123;\n  // req.params 是动态匹配到的 URL 参数，默认也是一个空对象\n  console.log(req.params)\n  res.send(req.params)\n&#125;)\n\n// 4. 启动 web 服务器\napp.listen(80, () =&gt; &#123;\n  console.log(&#39;express server running at http://127.0.0.1&#39;)\n&#125;)\n\n托管静态资源\n\nexpress提供了一个非常好用的函数，叫做 express.static()，通过它，我们可以非常方便地创建一个静态资源服务器例如，通过如下代码就可以将public目录下的图片、CSS文件、JavaScript文件对外开放访问了\n注意:Express在指定的静态目录中查找文件，并对外提供资源的访问路径。因此，存放静态文件的目录名不会出现在URL中\n访问静态资源文件时，express.static()函数会根据目录的添加顺序查找所需的文件\n代码：\n\nconst express = require(&#39;express&#39;)\nconst app = express()\n\n// 在这里，调用 express.static() 方法，快速的对外提供静态资源\napp.use(&#39;/files&#39;, express.static(&#39;./files&#39;))//按添加顺序查找所需文件，挂载路径前缀\napp.use(express.static(&#39;./clock&#39;))\n\napp.listen(80, () =&gt; &#123;\n  console.log(&#39;express server running at http://127.0.0.1&#39;)\n&#125;)\n\nnodemon\n\n在编写调试Nodejs项目的时候，如果修改了项目的代码，则需要频繁的手动close掉，然后再重新启动，非常繁琐；我们可以使用nodemon (https://www.npmjs.com/package/nodemon)这个工具，它能够监听项目文件的变动，当代码被修改后，nodemon 会自动帮我们重启项目，极大方便了开发和调试\n在终端中，运行如下命令，即可将nodemon安装为全局可用的工具：npm install -g nodemon\n使用：node app.js &#x3D;&gt; nodemon app.js\n\n3.2 Express路由路由的概念\n\n广义上来讲，路由就是映射关系\n\n在Express 中，路由指的是客户端的请求与服务器处理函数之间的映射关系\n\nExpress 中的路由分3部分组成，分别是请求的类型、请求的URL地址、处理函数，格式如下:app.METHOD(PATH，HANDLER)\n\n每当一个请求到达服务器之后，需要先经过路由的匹配，只有匹配成功之后，才会调用对应的处理函数\n\n在匹配时，会按照路由的顺序进行匹配，如果请求类型和请求的URL同时匹配成功，则Express 会将这次请求，转交给对应的function函数进行处理\n\n\n\n\n路由匹配的注意点:\n按照定义的先后顺序进行匹配\n请求类型和请求的URL同时匹配成功，才会调用对应的处理函数\n\n\n\n路由的使用\n\n最简单路由代码：\n\nconst express = require(&#39;express&#39;)\nconst app = express()\n\n// 挂载路由\napp.get(&#39;/&#39;, (req, res) =&gt; &#123;\n  res.send(&#39;hello world.&#39;)\n&#125;)\napp.post(&#39;/&#39;, (req, res) =&gt; &#123;\n  res.send(&#39;Post Request.&#39;)\n&#125;)\n\napp.listen(80, () =&gt; &#123;\n  console.log(&#39;http://127.0.0.1&#39;)\n&#125;)\n\n\n模块化路由 – 为了方便对路由进行模块化的管理，Express 不建议将路由直接挂载到app 上，而是推荐将路由抽离为单独的模块。将路由抽离为单独模块的步骤如下:\n\n创建路由模块对应的.js 文件\n调用express.Router()函数创建路由对象\n向路由对象上挂载具体的路由\n使用module.exports向外共享路由对象\n使用app.use()函数注册路由模块\n\n\n创建路由模块代码：\n\n\n// 1. 导入 express\nconst express = require(&#39;express&#39;)\n// 2. 创建路由对象\nconst router = express.Router()\n\n// 3. 挂载具体的路由\nrouter.get(&#39;/user/list&#39;, (req, res) =&gt; &#123;\n  res.send(&#39;Get user list.&#39;)\n&#125;)\nrouter.post(&#39;/user/add&#39;, (req, res) =&gt; &#123;\n  res.send(&#39;Add new user.&#39;)\n&#125;)\n\n// 4. 向外导出路由对象\nmodule.exports = router\n\n\n注册路由模块代码：\n\n// 1．导入路由模块\nconst userRouter = require( &#39; ./router/user.js &#39;)\n\n// 2．使用app.use()注册路由模块\napp.use(userRouter)\n// 注意： app.use() 函数的作用，就是来注册全局中间件\n\n\n为路由模块添加前缀代码：\n\n//使用app.use()注册路由模块，并添加统的访问前缀\napp.use( &#39; /api &#39;, userRouter)\n\n3.3 Express中间件中间件的概念\n\n中间件(Middleware ) ，特指业务流程的中间处理环节\n当一个请求到达Express 的服务器之后，可以连续调用多个中间件，从而对这次请求进行预处理\n\n\n\nExpress的中间件，本质上就是一个function处理函数，Express中间件的格式如下:\n\n\n\n注意:中间件函数的形参列表中，必须包含next参数，而路由处理函数中只包含req和res\nnext函数是实现多个中间件连续调用的关键，它表示把流转关系转交给下一个中间件或路由\n\n\n中间件初体验\n\n最简单的中间件函数：\n\n//常量mw所指向的,就是一个中间件函数\nconst mw = function (req. res,next) &#123;\n    console.log(&#39;这是一个最简单的中间件函数&quot;)\n    //注意:在当前中间件的业务处理完毕后，必须调用next()函数\n    //表示把流转关系转交给下一个中间件或路由\n    next()\n&#125;\n\n\n全局生效的中间件：\n\n//常量mw所指向的,就是一个中间件函数\nconst mw = function (req. res,next) &#123;\n    console.log( &quot;这是一个最简单的中间件函数&quot;)\n    next()\n&#125;\n//全局生效的中间件\napp.use(mw)\n\n\n全局中间件的简化形式：\n\n//全局生效的中间件\napp.use(function (req,res,next) &#123;\n    console.log( &#39;这是一个最简单的中间件函数&#39;)\n    next()\n&#125;)\n\n\n多个中间件之间，共享同一份req和res。基于这样的特性，我们可以在上游的中间件中，统一为req或 res对象添加自定义的属性或方法，供下游的中间件或路由进行使用\n\n\n\n定义多个全局中间件\n\napp.use( function(req, res, next) //第1个全局中间\n    console.1og(&#39;调用了第1个全局中间件&#39;)\n    next()\n&#125;)\napp.use( function(req, res, next) //第2个全局中间件\n    console.log(&#39;调用了第2个全局中间件&quot;)\n    next()\n&#125;)\napp.get( &#39; /user &#39;, (req, res) =&gt; &#123;//请求这个路由，会依次触发上述两个全局中间件\n    res.send( &#39; Home page.&quot;)\n&#125;)\n\n\n局部生效的中间件\n\n//定义中间件函数mw1\nconst mw1 = function(req. res,next) &#123;\n    console.log(&quot;这是中间件函数&quot;)\n    next()\n&#125;\n// mw1(中间件函数)这个中间件只在&quot;当前路由中生效&quot;，这种用法属于&quot;局部生效的中间件&quot;\napp.get( &#39;/&#39;，mw1,function(req, res) &#123;\n    res.send(&#39;Home page.&#39;)\n&#125;)\n//mw1这个中间件不会影响下面这个路由↓↓↓\napp.get( &#39; /user &#39;， function(req，res) &#123; \n    res.send( &#39;User page.&#39;) \n&#125;)\n\n\n定义多个局部中间件\n\n//以下两种写法是&quot;完全等价&quot;的，可根据自己的喜好，选择任意一种方式进行使用\napp.get( &#39; / &#39; ,mw1,mw2，(req，res) =&gt; &#123; res.send( &#39;Home page. &#39;)&#125;)\napp.get( &#39; / &#39;，[mw1，mw2]，(req，res) =&gt; &#123; res.send( &#39;Home page.&#39;)&#125;)\n\n\n注意事项：\n\n\n—定要在路由之前注册中间件\n客户端发送过来的请求，可以连续调用多个中间件进行处理\n执行完中间件的业务代码之后，不要忘记调用next()函数\n为了防止代码逻辑混乱，调用next()函数后不要再写额外的代码\n连续调用多个中间件时，多个中间件之间，共享req和res对象\n\n中间件分类\n\n应用级别的中间件\n\n通过app.use()或 app.get()或app.post()，绑定到app实例上的中间件，叫做应用级别的中间件\n\n\n路由级别的中间件\n\n绑定到express.Router()实例上的中间件，叫做路由级别的中间件，它的用法和应用级别中间件没有任何区别，只不过，应用级别中间件是绑定到app实例上，路由级别中间件绑定到 router 实例上\n\n\n错误级别的中间件\n\n错误级别中间件的作用:专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题\n格式:错误级别中间件的 function 处理函数中，必须有4个形参，形参顺序从前到后，分别是(err,req, res, next)\n代码：\n\n// 导入 express 模块\nconst express = require(&#39;express&#39;)\n// 创建 express 的服务器实例\nconst app = express()\n\n// 1. 定义路由\napp.get(&#39;/&#39;, (req, res) =&gt; &#123;\n  // 1.1 人为的制造错误\n  throw new Error(&#39;服务器内部发生了错误！&#39;)\n  res.send(&#39;Home page.&#39;)\n&#125;)\n\n// 2. 定义错误级别的中间件，捕获整个项目的异常错误，从而防止程序的崩溃,注册在所有路由之后\napp.use((err, req, res, next) =&gt; &#123;\n  console.log(&#39;发生了错误！&#39; + err.message)\n  res.send(&#39;Error：&#39; + err.message)\n&#125;)\n\n// 调用 app.listen 方法，指定端口号并启动web服务器\napp.listen(80, function () &#123;\n  console.log(&#39;Express server running at http://127.0.0.1&#39;)\n&#125;)\n\n\nExpress内置的中间件\n\n自Express 4.16.0版本开始，Express内置了3个常用的中间件，极大的提高了Express 项目的开发效率和体验:\n\nexpress.static快速托管静态资源的内置中间件，例如:HTML文件、图片、CSS样式等(无兼容性)\nexpress.json解析JSON格式的请求体数据（有兼容性，仅在4.16.0+版本中可用)\nexpress.urlencoded解析URL-encoded格式的请求体数据（有兼容性，仅在4.16.0+版本中可用)\n\n\n代码：\n\n\n// 导入 express 模块\nconst express = require(&#39;express&#39;)\n// 创建 express 的服务器实例\nconst app = express()\n\n// 注意：除了错误级别的中间件，其他的中间件，必须在路由之前进行配置\n// 通过 express.json() 这个中间件，解析表单中的 JSON 格式的数据\napp.use(express.json())\n// 通过 express.urlencoded() 这个中间件，来解析 表单中的 url-encoded 格式的数据\napp.use(express.urlencoded(&#123; extended: false &#125;))\n\napp.post(&#39;/user&#39;, (req, res) =&gt; &#123;\n  // 在服务器，可以使用 req.body 这个属性，来接收客户端发送过来的请求体数据\n  // 默认情况下，如果不配置解析表单数据的中间件，则 req.body 默认等于 undefined\n  console.log(req.body)\n  res.send(&#39;ok&#39;)\n&#125;)\n\napp.post(&#39;/book&#39;, (req, res) =&gt; &#123;\n  // 在服务器端，可以通过 req,body 来获取 JSON 格式的表单数据和 url-encoded 格式的数据\n  console.log(req.body)\n  res.send(&#39;ok&#39;)\n&#125;)\n\n// 调用 app.listen 方法，指定端口号并启动web服务器\napp.listen(80, function () &#123;\n  console.log(&#39;Express server running at http://127.0.0.1&#39;)\n&#125;)\n\n\n第三方的中间件\n\n非Express 官方内置的，而是由第三方开发出来的中间件，叫做第三方中间件。在项目中，大家可以按需下载并配置第三方中间件，从而提高项目的开发效率\n\n例如:在 &#x65;&#120;&#112;&#x72;&#101;&#x73;&#115;&#x40;&#x34;&#x2e;&#x31;&#x36;&#x2e;&#x30;之前的版本中，经常使用body-parser这个第三方中间件，来解析请求体数据。\n\n使用步骤如下:\n\n运行npm install body-parser安装中间件\n\n使用require导入中间件\n\n调用app.use()注册并使用中间件\n\n\n\n注意: Express 内置的express.urlencoded 中间件，就是基于body-parser这个第三方中间件进一步封装出来的\n\n\n\n\n自定义中间件\n\n定义中间件\n监听req的data 事件\n监听req的end事件\n使用querystring模块解析请求体数据\n将解析出来的数据对象挂载为req.body\n将自定义中间件封装为模块\n\n\n代码：\n\n// 导入 express 模块\nconst express = require(&#39;express&#39;)\n// 创建 express 的服务器实例\nconst app = express()\n// 导入 Node.js 内置的 querystring 模块\nconst qs = require(&#39;querystring&#39;)\n\n// 这是解析表单数据的中间件\napp.use((req, res, next) =&gt; &#123;\n  // 定义中间件具体的业务逻辑\n  // 1. 定义一个 str 字符串，专门用来存储客户端发送过来的请求体数据\n  let str = &#39;&#39;\n  // 2. 监听 req 的 data 事件\n  req.on(&#39;data&#39;, (chunk) =&gt; &#123;\n    str += chunk\n  &#125;)\n  // 3. 监听 req 的 end 事件\n  req.on(&#39;end&#39;, () =&gt; &#123;\n    // 在 str 中存放的是完整的请求体数据\n    // console.log(str)\n    // TODO: 把字符串格式的请求体数据，解析成对象格式\n    const body = qs.parse(str)\n    req.body = body\n    next()\n  &#125;)\n&#125;)\n\napp.post(&#39;/user&#39;, (req, res) =&gt; &#123;\n  res.send(req.body)\n&#125;)\n\n// 调用 app.listen 方法，指定端口号并启动web服务器\napp.listen(80, function () &#123;\n  console.log(&#39;Express server running at http://127.0.0.1&#39;)\n&#125;)\n\n3.4 使用Express写接口\n解决接口跨域问题的方案主要有两种:\n\n\nCORS (主流的解决方案，推荐使用)\nCORS 是 Express的一个第三方中间件,通过安装和配置cors 中间件，可以很方便地解决跨域问题。使用步骤分为如下3步:\n运行npm install cors安装中间件\n使用const cors &#x3D; require(‘cors’)导入中间件在路由之前调用\napp.use(cors())配置中间件\n\n\n\n\nJSONP (有缺陷的解决方案:只支持GET请求)\n\nCORS跨域资源共享\n\nCORS (Cross-Origin Resource Sharing，跨域资源共享）由一系列HTTP响应头组成，这些HTTP响应头决定浏览器是否阻止前端JS代码跨域获取资源\n浏览器的同源安全策略默认会阻止网页“跨域”获取资源。但如果接口服务器配置了CORS相关的HTTP响应头，就可以解除浏览器端的跨域访问限制\n\n\n\nCORS的注意事项\n\nCORS主要在服务器端进行配置。客户端浏览器无须做任何额外的配置，即可请求开启了CORS的接口\nCORS在浏览器中有兼容性。只有支持XMLHttpRequest Level2的浏览器，才能正常访问开启了CORS的服务端接口**(例如:IE10+、Chrome4+、FireFox3.5+)**\n\n\n响应头部中可以携带一个Access-Control-Allow-Origin字段，其语法如下:Access-Control-Allow-origin: &lt;origin&gt; | *其中,origin参数的值指定了允许访问该资源的外域URL\n\n\nres.setHeader( &#39; Access-Control-Allow-Origin &#39;, &#39;http: /litcast.cn&#39;)\n\n\n默认情况下，CORS仅支持客户端向服务器发送如下的9个请求头:Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type (值仅限于text/plain、multipart/form-data、application/x-www-form-urlencoded三者之一);如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过Access-Control-Allow-Headers 对额外的请求头进行声明，否则这次请求会失败!\n\n//允许客户端额外向服务器发送Content-Type 请求头和X-Custom-Header请求头//注意:多个请求头之间使用英文的逗号进行分割\nres.setHeader( &#39; Access-Control-Allow-Headers &#39; ，&#39;Content-Type，x-Custom-Header &#39;)\n\n\n默认情况下，CORS仅支持客户端发起GET、POST、HEAD请求。如果客户端希望通过PUT、DELETE等方式请求服务器的资源，则需要在服务器端，通过Access-Control-Alow-Method来指明实际请求所允许使用的HTTP方法\n\n//只允许POST、GET、DELETE、HEAD请求方法\nres.setHeader ( &#39; Access-Control-Allow-Methods &#39;,&#39;POST，GET，DELETE，HEAD&quot; )\n//允许所有的 HTTP请求方法\nres.setHeader( &#39;Access-Control-Allow-Methods &quot; , &#39;*&#39;)\n\n\n客户端在请求CORS接口时，根据请求方式和请求头的不同，可以将CORS的请求分为两大类，分别是:\n\n简单请求 (客户端与服务器之间只会发生一次请求)\n\n\n请求方式: GET、POST、HEAD三者之一\nHTTP头部信息不超过以下几种字段:无自定义头部字段、Accept、Accept-Language、Content-Language、DPR,Downlink、Save-Data、Viewport-Width、Width 、Content-Type(只有三个值application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain)\n\n\n预检请求 (客户端与服务器之间会发生两次请求，OPTION预检请求成功之后，才会发起真正的请求)\n\n\n请求方式为GET、POST、HEAD之外的请求Method类型\n请求头中包含自定义头部字段\n向服务器发送了application&#x2F;ison格式的数据\n\n\n\nJSONP接口\n\n概念:浏览器端通过&lt; scrip t&gt;标签的src 属性，请求服务器上的数据，同时，服务器返回一个函数的调用。这种请求数据的方式叫做JSONP\n\n特点:\n\nJSONP 不属于真正的Ajax请求，因为它没有使用XMLHttpRequest这个对象\nJSONP仅支持GET请求，不支持 POST、PUT、DELETE 等请求\n\n\n如果项目中已经配置了CORS跨域资源共享，为了防止冲突，必须在配置CORS中间件之前声明JSONP的接口\n\n步骤：\n\n获取客户端发送过来的回调函数的名字\n得到要通过JSONP形式发送给客户端的数据\n根据前两步得到的数据，拼接出—个函数调用的字符串\n把上一步拼接得到的字符串，响应给客户端的&lt; script &gt;标签进行解析执行\n\n\n代码：\n\n\n// 导入 express\nconst express = require(&#39;express&#39;)\n// 创建服务器实例\nconst app = express()\n\n// 配置解析表单数据的中间件\napp.use(express.urlencoded(&#123; extended: false &#125;))\n\n// 必须在配置 cors 中间件之前，配置 JSONP 的接口\napp.get(&#39;/api/jsonp&#39;, (req, res) =&gt; &#123;\n  // TODO: 定义 JSONP 接口具体的实现过程\n  // 1. 得到函数的名称\n  const funcName = req.query.callback\n  // 2. 定义要发送到客户端的数据对象\n  const data = &#123; name: &#39;zs&#39;, age: 22 &#125;\n  // 3. 拼接出一个函数的调用\n  const scriptStr = `$&#123;funcName&#125;($&#123;JSON.stringify(data)&#125;)`\n  // 4. 把拼接的字符串，响应给客户端\n  res.send(scriptStr)\n&#125;)\n\n// 一定要在路由之前，配置 cors 这个中间件，从而解决接口跨域的问题\nconst cors = require(&#39;cors&#39;)\napp.use(cors())\n\n// 导入路由模块\nconst router = require(&#39;./apiRouter&#39;)\n// 把路由模块，注册到 app 上\napp.use(&#39;/api&#39;, router)\n\n// 启动服务器\napp.listen(80, () =&gt; &#123;\n  console.log(&#39;express server running at http://127.0.0.1&#39;)\n&#125;)\n\nconst express = require(&#39;express&#39;)\nconst router = express.Router()\n\n// 在这里挂载对应的路由\nrouter.get(&#39;/get&#39;, (req, res) =&gt; &#123;\n  // 通过 req.query 获取客户端通过查询字符串，发送到服务器的数据\n  const query = req.query\n  // 调用 res.send() 方法，向客户端响应处理的结果\n  res.send(&#123;\n    status: 0, // 0 表示处理成功，1 表示处理失败\n    msg: &#39;GET 请求成功！&#39;, // 状态的描述\n    data: query, // 需要响应给客户端的数据\n  &#125;)\n&#125;)\n\n// 定义 POST 接口\nrouter.post(&#39;/post&#39;, (req, res) =&gt; &#123;\n  // 通过 req.body 获取请求体中包含的 url-encoded 格式的数据\n  const body = req.body\n  // 调用 res.send() 方法，向客户端响应结果\n  res.send(&#123;\n    status: 0,\n    msg: &#39;POST 请求成功！&#39;,\n    data: body,\n  &#125;)\n&#125;)\n\n// 定义 DELETE 接口\nrouter.delete(&#39;/delete&#39;, (req, res) =&gt; &#123;\n  res.send(&#123;\n    status: 0,\n    msg: &#39;DELETE请求成功&#39;,\n  &#125;)\n&#125;)\n\nmodule.exports = router\n\n4、数据库与身份认证4.1 数据库的基本概念数据库的概念\n\n数据库(database）是用来组织、存储和管理数据的仓库\n为了方便管理互联网世界中的数据，就有了数据库管理系统的概念（简称:数据库)\n用户可以对数据库中的数据进行新增、查询、更新、删除等操作\n\n常见数据库及分类\n\n市面上的数据库有很多种，最常见的数据库有如下几个:\n\nMySQL数据库（目前使用最广泛、流行度最高的开源免费数据库;Community + Enterprise)\nOracle数据库（收费)\nSQL Server数据库（收费)\nMongodb数据库(Community + Enterprise)\n\n\n其中，MySQL、Oracle、SQL Server属于传统型数据库(又叫做:关系型数据库或SQL数据库)，这三者的设计理念相同，用法比较类似\n\n而Mongodb属于新型数据库(又叫做:非关系型数据库或NoSQL数据库)，它在一定程度上弥补了传统型数据库的缺陷\n\n\n传统型数据库的数据组织结构\n\n数据的组织结构:指的就是数据以什么样的结构进行存储\n\n传统型数据库的数据组织结构，与Excel 中数据的组织结构比较类似\n\nExcel的数据组织结构\n\n\n\n\n* 整个Excel叫做工作簿\n* users和books是工作表\n* users 工作表中有3行数据\n* 每行数据由6列信息组成，每列信息都有对应的数据类型\n\n\n传统型数据库的数据组织结构\n\n在传统型数据库中，数据的组织结构分为**数据库(database)、数据表(table)、数据行(row)、字段(field)**这4大部分组成。\n数据库类似于Excel的工作簿\n数据表类似于Excel的工作表\n数据行类似于Excel的每一行数据\n字段类似于Excel的列，每个字段都有对应的数据类型\n\n\n\n4.2 安装并配置MySQL\nMySQL Server:专门用来提供数据存储和服务的软件\n\nMySQL Workbench:可视化的 MySQL管理工具，通过它，可以方便的操作存储在MySQL Server中的数据\n\nMySQL的安装（Windows系统）\n\nMac 系统配置 MySql 数据库\n\n\n4.3 MySQL的基本使用使用MySQL Workbench管理数据库\n\n连接数据库\n\n\n\n主界面的组成部分\n\n\n\n创建数据库\n\n\n\n创建数据表\n\n\n\nDataType数据类型:\n\nint 整数\n\nvarchar(len) 字符串\n\ntinyint(1) 布尔值\n\n\n\n字段的特殊标识:\n\nPK (Primary Key) 主键、唯一标识\n\nNN (Not Null) 值不允许为空\n\nUQ(Unique) 值唯一\n\nAl (Auto Increment) 值自动增长\n\n\n\n\n\n向表中写入数据\n\n\n使用SQL管理数据库\n\nSQL(英文全称: Structured Query Language)是结构化查询语言，专门用来访问和处理数据库的编程语言。能够让我们以编程的形式，操作数据库里面的数据\n\n三个关键点:\n\nSQL是一门数据库编程语言\n使用SQL语言编写出来的代码，叫做SQL语句\nSQL语言只能在关系型数据库中使用（例如MySQL、Oracle、SQL Server)；非关系型数据库（例如Mongodb)不支持SQL语言\n\n\n作用：\n\n从数据库中查询数据(查)\n向数据库中插入新的数据(增)\n更新数据库中的数据(改)\n从数据库删除数据(删)\n可以创建新数据库\n可在数据库中创建新表\n可在数据库中创建存储过程、视图\netc…\n\n\n\nSQL的SELECT语句\n\nSELECT语句用于从表中查询数据。执行的结果被存储在一个结果表中（称为结果集)。语法格式如下:\n\n--这是注释\n--从　FROM　指定的［表中］，查询出［所有的］数据。　　*　表示［所有列］\nSELECT　*　FROM　表名称\n \n--从　FROM　指定的［表中］，查询出指定　　列名称　（字段）　的数据\nSELECT 列名称 FROM 表名称\n\n\n注意:SQL语句中的关键字对大小写不敏感。SELECT等效于select，FROM等效于from\n\n我们希望从users表中选取所有的列，可以使用符号*取代列的名称，示例如下:\n\n\n\n\n如需获取名为“username”和”password”的列的内容(从名为”users”的数据库表)，请使用下面的SELECT语句:\n\n\nSQL的INSERT INTO语句\n\nINSERT INTO语句用于向数据表中插入新的数据行，语法格式如下:\n\n--语法解读：向指定的表中，插入如下几列数据，列的值通过 values  -----指定\n--注意：列和值要一一对应，多个列和多个值之间，使用英文的逗号分隔\ninsert into table_name (列1,列2...) values (值1,值2...)\n\n\n向users 表中，插入一条username为 tony stark，password为098123的用户数据，示例如下:\n\n\nSQL的UPDATE语句\n\nUpdate语句用于修改表中的数据。语法格式如下:\n\n--语法解读：\n--1.用update 指定要更新哪个表中的数据\n--2.用 set 指定列对应的新值\n--3.用 where 指定更新的条件\n \n update 表名称 set 列名称 = 新值 where 列名称 = 某值\n\n\nUPDATE示例–更新某一行中的一个列，把users表中id为7的用户密码，更新为888888。示例如下:\n\n\n\nUPDATE示例–更新某一行中的若干列，把users表中id为2的用户密码和用户状态，分别更新为admin123和1。示例如下:\n\n\nSQL的DELETE语句\n\nDELETE语句用于删除表中的行。语法格式如下:\n\n--语法解读：\n--从指定的表中，根据where条件，删除对应的数据行\ndelete from 表名称 where 列名称 = 值\n\n\n从users表中，删除id为4的用户，示例如下:\n\n\nSQL的WHERE子句\n\nWHERE子句用于限定选择的标准。在SELECT、UPDATE、DELETE语句中，皆可使用WHERE子句来限定选择的标准\n\n--查询语句中的 where 条件\nselect 列名称 from 表名称 where 列 运算符 值\n\n--更新语句中的 where 条件\nupdate 表名称 set 列=新值 where 列 运算符 值\n\n--删除语句中的 where 条件\ndelete from 表名称 where 列 运算符 值\n\n\n下面的运算符可在WHERE子句中使用，用来限定选择的标准:\n\n\n\n注意:在某些版本的SQL中，操作符&lt;&gt;可以写为!&#x3D;\n\n可以通过WHERE子句来限定SELECT的查询条件:\n\n\n--查询status为1的所有用户\nSELECT * FROM users WHERE status=1\n\n--查询id 大于2的所有用户\nSELECT * FROM users WHERE id&gt;2\n\n--查询username 不等于admin的所有用户\nSELECT * FROM users WHERE username&lt;&gt; &#39;admin&#39;\n\nSQL的AND和OR运算符\n\nAND和OR可在WHERE子语句中把两个或多个条件结合起来\n\nAND表示必须同时满足多个条件，相当于JavaScript中的&amp;&amp;运算符，例如 if (a !&#x3D;&#x3D; 10 &amp;&amp; a !&#x3D;&#x3D; 20)\n\nOR表示只要满足任意一个条件即可，相当于JavaScript中||运算符，例如if(a !&#x3D;&#x3D; 10||a !&#x3D;&#x3D; 20)\n\n使用AND来显示所有status为0，并且id小于3的用户:\n\n\n\n\n使用OR来显示所有status为1，或者username为zs 的用户:\n\n\nSQL的OEDED BY子句\n\nORDER BY语句用于根据指定的列对结果集进行排序\n\nRDER BY语句默认按照升序对记录进行排序\n\n如果您希望按照降序对记录进行排序，可以使用DESC关键字\n\n升序排序：对users表中的数据，按照status字段进行升序排序，示例如下:\n\n\n\n\n降序排序：对users表中的数据，按照id字段进行降序排序，示例如下:\n\n\n\n多重排序：对users 表中的数据，先按照status字段进行降序排序，再按照username的字母顺序，进行升序排序，示例如下:\n\n\nSQL的COUNT(*)语句\n\nCOUNT(*)函数用于返回查询结果的总数据条数，语法格式如下:\n\nSELECT COUNT(*) FROM 表名称\n\n\n杳询users表中status为0的总数据条数:\n\n\n\n如果希望给查询出来的列名称设置别名，可以使用AS关键字，示例如下:\n\n\n4.4 在项目中操作MySql步骤：\n\n\n安装操作MySQL数据库的第三方模块(mysql)\n\nnpm install mysql\n\n\n通过mysql模块连接到MySQL数据库\n//1.导入mysql模块\nconst mysql = require(&#39;mysql&#39;)\n//2.建立与mysql数据库的连接关系\nconst db = mysql.createPool(&#123;\n    host: &#39;127.0.0.1&#39;,      //数据库的IP地址\n    user: &#39;root&#39;,           //登录数据库的账号\n    password: &#39;123456&#39;,     //登录数据库的密码\n    database: &#39;my_db_01&#39;,   //待操作的数据库\n&#125;)\n\n\n通过mysql模块执行SQL语句\n//测试mysql模块能否正常工作\ndb.query(&#39;select 1&#39;, (err, results) =&gt; &#123;\n    //报错\n    if (err) return console.log(err.message)\n    //正常\n    console.log(results)\n&#125;)\n\n\n\n\n查：\n\n//查询user表中所有的数据\nconst sqlStr = &#39;select * from users&#39;\ndb.query(sqlStr, (err, results) =&gt; &#123;\n    //报错\n    if (err) return console.log(err.message)\n    //正常\n    console.log(results)\n&#125;)\n\n\n增：\n\n//新增数据\nconst user = &#123; username: &#39;ironman&#39;, password: &#39;123456&#39; &#125;\n//定义待执行的SQL语句\nconst sqlStr = &#39;insert into users (username,password) values(?,?)&#39;\n//执行SQL语句\ndb.query(sqlStr, [user.username, user.password], (err, results) =&gt; &#123;\n    //报错\n    if (err) return console.log(err.message)\n    //正常\n    if (results.affectedRows === 1) &#123;\n        console.log(&#39;插入数据成功!&#39;)\n    &#125;\n&#125;)\n\n//向表中新增数据时，如果数据对象的每个属性和数据表的字段一一对应，则可以通过如下方式快速插入数据\n//新增数据\nconst user = &#123; username: &#39;ironman&#39;, password: &#39;123456&#39; &#125;\n//定义待执行的SQL语句\nconst sqlStr = &#39;insert into users set ?&#39;\n//执行SQL语句\ndb.query(sqlStr, user, (err, results) =&gt; &#123;\n    //报错\n    if (err) return console.log(err.message)\n    //正常\n    if (results.affectedRows === 1) &#123;\n        console.log(&#39;插入数据成功!&#39;)\n    &#125;\n&#125;)\n\n\n改：\n\n//更新用户信息\nconst user = &#123; id: 6, username: &#39;aaa&#39;, password: &#39;000&#39; &#125;\n//定义SQL语句\nconst sqlStr = &#39;update users set username=?,password=? where id=?&#39;\n//执行SQL语句\ndb.query(sqlStr, [user.ueername, user.password, user.id], (err, results) =&gt; &#123;\n    //报错\n    if (err) return console.log(err.message)\n    //正常\n    if (results.affectedRows === 1) &#123;\n        console.log(&#39;更新数据成功!&#39;)\n    &#125;\n&#125;)\n\n//向表中新增数据时，如果数据对象的每个属性和数据表的字段—一对应，则可以通过如下方式快速更新数据\n//更新用户信息\nconst user = &#123; id: 6, username: &#39;aaa&#39;, password: &#39;000&#39; &#125;\n//定义SQL语句\nconst sqlStr = &#39;update users set ? where id=?&#39;\n//执行SQL语句\ndb.query(sqlStr, [user, user.id], (err, results) =&gt; &#123;\n    //报错\n    if (err) return console.log(err.message)\n    //正常\n    if (results.affectedRows === 1) &#123;\n        console.log(&#39;更新数据成功!&#39;)\n    &#125;\n&#125;)\n\n\n删：\n\n// 1．要执行的SQL语句\nconst sqlStr = &#39;DELETE FROM users WHERE id=?&#39;\n//2．调用db.query()执行SQL语句的同时，为占位符指定具体的值\n//注意:如果SQL语句中有多个占位符，则必须使用数组为每个占位符指定具体的值&quot;\n//如果SQL语句中只有一个占位符，则可以省略数组\ndb.query(sqlStr, 5, (err, results) =&gt; &#123;\n    if (err) return console.log(err.message)// 失败\n    if (results.affectedRows === 1) &#123;\n        console.log(&#39;删除数据成功! &#39;)\n    &#125; // 成功\n&#125;)\n\n//所谓的标记删除，就是在表中设置类似于status这样的状态字段，来标记当前这条数据是否被删除\n\n4.5 前后端的身份认证Web开发模式\n\n基于服务端渲染的传统Web开发模式(企业级网站)\n服务端渲染的概念:服务器发送给客户端的HTML页面，是在服务器通过字符串的拼接，动态生成的。因此，客户端不需要使用Ajax这样的技术额外请求页面的数据\n优点：前端耗时少，有利于SEO\n缺点：占用服务器资源，不利于前后端分离，开发效率低\n\n\n基于前后端分吉的新型web开发模式(后台管理项目)\n前后端分离的概念:前后端分离的开发模式，依赖于Ajax技术的广泛应用。简而言之，前后端分离的Web开发模式，就是后端只负责提供API接口，前端使用Ajax调用接口的开发模式\n优点：开发体验好，用户体验好，减轻了服务器端的渲染压力\n缺点：不利于SEO\n\n\n\n 身份认证\n\n身份认证(Authentication)又称“身份验证”、“鉴权”，是指通过一定的手段，完成对用户身份的确认\n如手机验证码登录、邮箱密码登录、二维码登录等等\n对于服务端渲染和前后端分离这两种开发模式来说，分别有着不同的身份认证方案:\n服务端渲染推荐使用Session认证机制\n前后端分离推荐使用JWT认证机制\n\n\n\nSession 认证机制\n\nHTTP协议的无状态性，指的是客户端的每次HTTP请求都是独立的，连续多个请求之间没有直接的关系，服务器不会主动保留每次HTTP请求的状态\nCookie 是存储在用户浏览器中的一段不超过4KB的字符串。它由一个名称(Name)、一个值(Value)和其它几个用于控制Cookie 有效期、安全性、使用范围的可选属性组成\n不同域名下的Cookie各自独立，每当客户端发起请求时，会自动把当前域名下所有未过期的Cookie一同发送到服务器\nCookie的几大特性:\n自动发送\n域名独立\n过期时限\n4KB限制\n\n\n\n\n\n由于Cookie 是存储在浏览器中的，而且浏览器也提供了读写Cookie的API，因此Cookie很容易被伪造，不具有安全性。因此不建议服务器将重要的隐私数据， 通过Cookie的形式发送给浏览器**(Cookie不具有安全性)**\nSession认证机制：\n\n\n在Express中使用Session 认证\n\n安装express-session中间件：npm install express-session\n配置express-session中间件\n向session中存数据\n从session中取数据\n清空session\n\n\n代码：\n\n// 导入 express 模块\nconst express = require(&#39;express&#39;)\n// 创建 express 的服务器实例\nconst app = express()\n\n// TODO_01：请配置 Session 中间件\nconst session = require(&#39;express-session&#39;)\napp.use(\n  session(&#123;\n    secret: &#39;itheima&#39;,\n    resave: false,\n    saveUninitialized: true,\n  &#125;)\n)\n\n// 托管静态页面\napp.use(express.static(&#39;./pages&#39;))\n// 解析 POST 提交过来的表单数据\napp.use(express.urlencoded(&#123; extended: false &#125;))\n\n// 登录的 API 接口\napp.post(&#39;/api/login&#39;, (req, res) =&gt; &#123;\n  // 判断用户提交的登录信息是否正确\n  if (req.body.username !== &#39;admin&#39; || req.body.password !== &#39;000000&#39;) &#123;\n    return res.send(&#123; status: 1, msg: &#39;登录失败&#39; &#125;)\n  &#125;\n\n  // TODO_02：请将登录成功后的用户信息，保存到 Session 中\n  // 注意：只有成功配置了 express-session 这个中间件之后，才能够通过 req 点出来 session 这个属性\n  req.session.user = req.body // 用户的信息\n  req.session.islogin = true // 用户的登录状态\n\n  res.send(&#123; status: 0, msg: &#39;登录成功&#39; &#125;)\n&#125;)\n\n// 获取用户姓名的接口\napp.get(&#39;/api/username&#39;, (req, res) =&gt; &#123;\n  // TODO_03：请从 Session 中获取用户的名称，响应给客户端\n  if (!req.session.islogin) &#123;\n    return res.send(&#123; status: 1, msg: &#39;fail&#39; &#125;)\n  &#125;\n  res.send(&#123;\n    status: 0,\n    msg: &#39;success&#39;,\n    username: req.session.user.username,\n  &#125;)\n&#125;)\n\n// 退出登录的接口\napp.post(&#39;/api/logout&#39;, (req, res) =&gt; &#123;\n  // TODO_04：清空 Session 信息\n  req.session.destroy()\n  res.send(&#123;\n    status: 0,\n    msg: &#39;退出登录成功&#39;,\n  &#125;)\n&#125;)\n\n// 调用 app.listen 方法，指定端口号并启动web服务器\napp.listen(80, function () &#123;\n  console.log(&#39;Express server running at http://127.0.0.1:80&#39;)\n&#125;)\n\nJWT认证机制\n\n当前端请求后端接口不存在跨域问题的时候，推荐使用Session身份认证机制\n当前端需要跨域请求后端接口的时候，不推荐使用Session身份认证机制，推荐使用JWT认证机制(JSON Web Token目前最流行的跨域认证解决方案)\nJWT工作原理：用户的信息通过Token字符串的形式，保存在客户端浏览器中。服务器通过还原Token 字符串的形式来认证用户的身份\n\n\n\nJWT通常由三部分组成，分别是Header (头部) 、Payload(有效荷载） 、Signature(签名)，三者之间使用英文的“.”分隔；Payload部分才是真正的用户信息，它是用户信息经过加密之后生成的字符串，Header和Signature是安全性相关**的部分，只是为了保证Token的安全性\n\n\n\n客户端收到服务器返回的JWT之后，通常会将它储存在localStorage或sessionStorage 中；此后，客户端每次与服务器通信，都要带上这个JWT的字符串，从而进行身份认证；推荐的做法是把JWT放在HTTP请求头的Authorization字段中：Authorization: Bearer &lt;token&gt;\n\n在Express中使用JWT\n\n安装JWT相关的包：npm install jsonwebtoken express-jwt\n导入JWT相关的包\n定义secret密钥\n在登录成功后生成JWT字符串\n将JWT字符串还原为JSON对象\n使用req.user获取用户信息\n捕获解析JWT失败后产生的错误\n\n\n代码：\n\n// 导入 express 模块\nconst express = require(&#39;express&#39;)\n// 创建 express 的服务器实例\nconst app = express()\n\n// TODO_01：安装并导入 JWT 相关的两个包，分别是 jsonwebtoken 和 express-jwt\nconst jwt = require(&#39;jsonwebtoken&#39;)\nconst expressJWT = require(&#39;express-jwt&#39;)\n\n// 允许跨域资源共享\nconst cors = require(&#39;cors&#39;)\napp.use(cors())\n\n// 解析 post 表单数据的中间件\nconst bodyParser = require(&#39;body-parser&#39;)\napp.use(bodyParser.urlencoded(&#123; extended: false &#125;))\n\n// TODO_02：定义 secret 密钥，建议将密钥命名为 secretKey\nconst secretKey = &#39;itheima No1 ^_^&#39;\n\n// TODO_04：注册将 JWT 字符串解析还原成 JSON 对象的中间件\n// 注意：只要配置成功了 express-jwt 这个中间件，就可以把解析出来的用户信息，挂载到 req.user 属性上\napp.use(expressJWT(&#123; secret: secretKey &#125;).unless(&#123; path: [/^\\/api\\//] &#125;))\n\n// 登录接口\napp.post(&#39;/api/login&#39;, function (req, res) &#123;\n  // 将 req.body 请求体中的数据，转存为 userinfo 常量\n  const userinfo = req.body\n  // 登录失败\n  if (userinfo.username !== &#39;admin&#39; || userinfo.password !== &#39;000000&#39;) &#123;\n    return res.send(&#123;\n      status: 400,\n      message: &#39;登录失败！&#39;,\n    &#125;)\n  &#125;\n  // 登录成功\n  // TODO_03：在登录成功之后，调用 jwt.sign() 方法生成 JWT 字符串。并通过 token 属性发送给客户端\n  // 参数1：用户的信息对象\n  // 参数2：加密的秘钥\n  // 参数3：配置对象，可以配置当前 token 的有效期\n  // 记住：千万不要把密码加密到 token 字符中\n  const tokenStr = jwt.sign(&#123; username: userinfo.username &#125;, secretKey, &#123; expiresIn: &#39;30s&#39; &#125;)\n  res.send(&#123;\n    status: 200,\n    message: &#39;登录成功！&#39;,\n    token: tokenStr, // 要发送给客户端的 token 字符串\n  &#125;)\n&#125;)\n\n// 这是一个有权限的 API 接口\napp.get(&#39;/admin/getinfo&#39;, function (req, res) &#123;\n  // TODO_05：使用 req.user 获取用户信息，并使用 data 属性将用户信息发送给客户端\n  console.log(req.user)\n  res.send(&#123;\n    status: 200,\n    message: &#39;获取用户信息成功！&#39;,\n    data: req.user, // 要发送给客户端的用户信息\n  &#125;)\n&#125;)\n\n// TODO_06：使用全局错误处理中间件，捕获解析 JWT 失败后产生的错误\napp.use((err, req, res, next) =&gt; &#123;\n  // 这次错误是由 token 解析失败导致的\n  if (err.name === &#39;UnauthorizedError&#39;) &#123;\n    return res.send(&#123;\n      status: 401,\n      message: &#39;无效的token&#39;,\n    &#125;)\n  &#125;\n  res.send(&#123;\n    status: 500,\n    message: &#39;未知的错误&#39;,\n  &#125;)\n&#125;)\n\n// 调用 app.listen 方法，指定端口号并启动web服务器\napp.listen(8888, function () &#123;\n  console.log(&#39;Express server running at http://127.0.0.1:8888&#39;)\n&#125;)\n\n码：\n// 导入 express 模块\nconst express = require(&#39;express&#39;)\n// 创建 express 的服务器实例\nconst app = express()\n\n// TODO_01：安装并导入 JWT 相关的两个包，分别是 jsonwebtoken 和 express-jwt\nconst jwt = require(&#39;jsonwebtoken&#39;)\nconst expressJWT = require(&#39;express-jwt&#39;)\n\n// 允许跨域资源共享\nconst cors = require(&#39;cors&#39;)\napp.use(cors())\n\n// 解析 post 表单数据的中间件\nconst bodyParser = require(&#39;body-parser&#39;)\napp.use(bodyParser.urlencoded(&#123; extended: false &#125;))\n\n// TODO_02：定义 secret 密钥，建议将密钥命名为 secretKey\nconst secretKey = &#39;itheima No1 ^_^&#39;\n\n// TODO_04：注册将 JWT 字符串解析还原成 JSON 对象的中间件\n// 注意：只要配置成功了 express-jwt 这个中间件，就可以把解析出来的用户信息，挂载到 req.user 属性上\napp.use(expressJWT(&#123; secret: secretKey &#125;).unless(&#123; path: [/^\\/api\\//] &#125;))\n\n// 登录接口\napp.post(&#39;/api/login&#39;, function (req, res) &#123;\n  // 将 req.body 请求体中的数据，转存为 userinfo 常量\n  const userinfo = req.body\n  // 登录失败\n  if (userinfo.username !== &#39;admin&#39; || userinfo.password !== &#39;000000&#39;) &#123;\n    return res.send(&#123;\n      status: 400,\n      message: &#39;登录失败！&#39;,\n    &#125;)\n  &#125;\n  // 登录成功\n  // TODO_03：在登录成功之后，调用 jwt.sign() 方法生成 JWT 字符串。并通过 token 属性发送给客户端\n  // 参数1：用户的信息对象\n  // 参数2：加密的秘钥\n  // 参数3：配置对象，可以配置当前 token 的有效期\n  // 记住：千万不要把密码加密到 token 字符中\n  const tokenStr = jwt.sign(&#123; username: userinfo.username &#125;, secretKey, &#123; expiresIn: &#39;30s&#39; &#125;)\n  res.send(&#123;\n    status: 200,\n    message: &#39;登录成功！&#39;,\n    token: tokenStr, // 要发送给客户端的 token 字符串\n  &#125;)\n&#125;)\n\n// 这是一个有权限的 API 接口\napp.get(&#39;/admin/getinfo&#39;, function (req, res) &#123;\n  // TODO_05：使用 req.user 获取用户信息，并使用 data 属性将用户信息发送给客户端\n  console.log(req.user)\n  res.send(&#123;\n    status: 200,\n    message: &#39;获取用户信息成功！&#39;,\n    data: req.user, // 要发送给客户端的用户信息\n  &#125;)\n&#125;)\n\n// TODO_06：使用全局错误处理中间件，捕获解析 JWT 失败后产生的错误\napp.use((err, req, res, next) =&gt; &#123;\n  // 这次错误是由 token 解析失败导致的\n  if (err.name === &#39;UnauthorizedError&#39;) &#123;\n    return res.send(&#123;\n      status: 401,\n      message: &#39;无效的token&#39;,\n    &#125;)\n  &#125;\n  res.send(&#123;\n    status: 500,\n    message: &#39;未知的错误&#39;,\n  &#125;)\n&#125;)\n\n// 调用 app.listen 方法，指定端口号并启动web服务器\napp.listen(8888, function () &#123;\n  console.log(&#39;Express server running at http://127.0.0.1:8888&#39;)\n&#125;)\n\n","slug":"前端--详解Node.js(快速入门)","date":"2023-01-26T00:36:42.000Z","categories_index":"前端","tags_index":"Node","author_index":"会思想的苇草i"},{"id":"ad76127bba596077a6c93849dfcec704","title":"Git版本控制：提升开发效率的利器","content":"Git1、Git 概念1.1 关于版本控制文件的版本管理的问题\n\n操作麻烦：每次都需要复制 → 粘贴 → 重命名\n命名不规范：无法通过文件名知道具体做了哪些修改\n容易丢失：如果硬盘故障或不小心删除，文件很容易丢失\n协作困难：需要手动合并每个人对项目文件的修改，合并时极易出错\n\n版本控制软件\n\n概念：版本控制软件是一个用来记录文件变化，以便将来查阅特定版本修订情况的系统，因此有时也叫做“版本控制系统”\n解释：把手工管理文件版本的方式,改为由软件管理文件的版本;这个负责管理文件版本的软件，叫做“版本控制软件”。\n\n使用版本控制软件的好处\n\n操作简便：只需识记几组简单的终端命令，即可快速上手常见的版本控制软件\n易于对比：基于版本控制软件提供的功能，能够方便地比较文件的变化细节，从而查找出导致问题的原因\n易于回溯：可以将选定的文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态\n不易丢失：在版本控制软件中，被用户误删除的文件，可以轻松的恢复回来\n协作方便：基于版本控制软件提供的分支功能，可以轻松实现多人协作开发时的代码合并操作\n\n版本控制系统的分类\n\n\n本地版本控制系统\n\n\n\n优点：使用软件来记录文件的不同版本，提高了工作效率，降低了手动维护版本的出错率\n缺点：单机运行，不支持多人协作开发；版本数据库故障后，所有历史更新记录会丢失\n\n\n集中化的版本控制系统（SVN）\n\n\n\n特点:基于服务器、客户端的运行模式\n服务器保存文件的所有更新记录\n客户端只保留最新的文件版本\n\n\n优点:联网运行，支持多人协作开发\n缺点:\n不支持离线提交版本更新\n中心服务器崩溃后，所有人无法正常工作\n版本数据库故障后，所有历史更新记录会丢失\n\n\n\n\n分布式版本控制系统（Git）\n\n\n\n特点:基于服务器、客户端的运行模式\n\n服务器保存文件的所有更新版本\n\n客户端是服务器的完整备份，并不是只保留文件的最新版本\n\n\n\n优点:\n\n联网运行，支持多人协作开发\n客户端断网后支持离线本地提交版本更新\n服务器故障或损坏后，可使用任何一个客户端的备份进行恢复\n\n\n\n1.2 Git 基础概念Git 概念\n\nGit 是一个开源的分布式版本控制系统，是目前世界上最先进、最流行的版本控制系统。可以快速高效地处理从很小到非常大的项目版本管理\n特点:项目越大越复杂，协同开发者越多，越能体现出 Git 的高性能和高可用性!\n\nGit 特性\n\nGit 之所以快速和高效，主要依赖于它的如下两个特性:\n\n直接记录快照，而非差异比较\n近乎所有操作都是本地执行\n\n\n传统的版本控制系统（例如 SVN)是基于差异的版本控制，它们存储的是一组基本文件和每个文件随时间逐步累积的差异\n\n\n\n\n好处：节省磁盘空间\n\n缺点：耗时、效率低、在每次切换版本的时候，都需要在基本文件的基础上，应用每个差异，从而生成目标版本对应的文件\n\nGit 快照是在原有文件版本的基础上重新生成一份新的文件，类似于备份。为了效率，如果文件没有修改,Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件\n\n\n\n\n缺点:占用磁盘空间较大\n\n优点:版本切换时非常快，因为每个版本都是完整的文件快照，切换版本时直接恢复目标版本的快照即可\n\n特点:空间换时间\n\n在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息\n\n特性:\n\n断网后依旧可以在本地对项目进行版本管理\n联网后，把本地修改的记录同步到云端服务器即可\n\n\n\nGit 中的三个区域\n\n使用 Git 管理的项目，拥有三个区域，分别是：\n工作区：处理工作的区域\n暂存区：已完成的工作的临时存放区域，等待被提交\nGit 仓库：最终的存放区域\n\n\n\nGit 中的三种状态\n\n\n注意:\n工作区的文件被修改了，但还没有放到暂存区，就是已修改状态。\n如果文件已修改并放入暂存区，就属于已暂存状态。\n如果 Git 仓库中保存着特定版本的文件，就属于已提交状态。\n\n\n\n基本的 Git 工作流程\n\n\n基本的 Git 工作流程如下:\n在工作区中修改文件\n将你想要下次提交的更改进行暂存\n提交更新，找到暂存区的文件，将快照永久性存储到 Git 仓库\n\n\n\n2、Git 基础操作2.1 安装并配置 Git下载并安装\n\n下载地址：Git - Downloads (git-scm.com)\n\n\n配置用户信息\n\n安装完 Git 之后，要做的第一件事就是设置自己的用户名和邮件地址。因为通过 Git 对项目进行版本管理的时候，Git 需要使用这些基本信息，来记录是谁对项目进行了操作:\n\ngit config --global user.name &quot;xxxx&quot;\ngit config --global user.email &quot;xxxxxxxx&quot;\n\n\n注意:如果使用了–global 选项，那么该命令只需要运行一次，即可永久生效\n\n通过 git config –global user.name 和 git config –global user.email 配置的用户名和邮箱地址，会被写入到 C:&#x2F;Users&#x2F;用户名文件夹&#x2F;.gitconfig 文件中\n\n\n检查配置信息\n\n除了使用记事本查看全局的配置信息之外，还可以运行如下的终端命令，快速的查看 Git 的全局配置信息:\n\n# 查看所有的全局配置项\n\ngit config --list --global\n\n# 查看指定的全局配置项\n\ngit config user.name\ngit config user.email\n\n获取帮助信息\n\n可以使用 git help &lt; verb &gt;命令，无需联网即可在浏览器中打开帮助手册，例如:\n\n# 打开 git config 命令的帮助手册\n\ngit help config\n\n\n如果不想查看完整的手册，那么可以用-h 选项获得更简明的”help” 输出:\n\n# 想要获取 git config 命令的快速参考\n\ngit config -h\n\n2.2 Git 的基本操作获取 Git 仓库的两种方式\n\n将尚未进行版本控制的本地目录转换为 Git 仓库(git init)\n从其它服务器克隆一个已存在的 Git 仓库(git clone xxx)\n\n在现有目录中初始化仓库\n\n如果自己有一个尚未进行版本控制的项目目录，想要用 Git.来控制它，需要执行如下两个步骤:\n在项目目录中，通过鼠标右键打开“Git Bash Here“\n执行git init命令将当前的目录转化为 Git 仓库\n\n\ngit init 命令会创建一个名为.git 的隐藏目录，这个.git 目录就是当前项目的 Git 仓库，里面包含了初始的必要文件，这些文件是 Git 仓库的必要组成部分。\n\n工作区文件的 4 种状态\n\n\ngit 操作的终极结果：让工作区的文件都处于“未修改”的状态\n\n检查文件的状态\n\n先创建一个文件夹，里面新建一个 index.html 文件，可以使用git status命令查看文件处于什么状态，例如:\n\n\n\n在状态报告中可以看到新建的 index.html 文件出现在 Untracked files(未跟踪的文件）下面\n\n未跟踪的文件意味着 Git 在之前的快照(提交）中没有这些文件;Git 不会自动将之纳入跟踪范围除非明确地告诉它“我需要使用 Git 跟踪管理该文件”\n\n使用 git status 输出的状态报告很详细，但有些繁琐。如果希望以精简的方式显示文件的状态，可以使用如下两条完全等价的命令，其中-s 是–short 的简写形式:\n\n\n# 以精简的方式显示文件状态\n\ngit status -s\ngit status --short\n\n\n未跟踪文件前面有红色的??标记，例如：\n\n\n跟踪新文件\n\n使用命令 git add 开始跟踪一个文件。所以，要跟踪 index.html 文件，运行如下的命令即可:\n\ngit add xxx(文件名)\n\n\n此时再运行 git status 命令，会看到 index.html 文件在 Changes to be committed 这行的下面，说明已被跟踪，并处于暂存状态:\n\n\n\n以精简的方式显示文件的状态，新添加到暂存区中的文件前面有绿色的 A 标：\n\n\n提交更新\n\n现在暂存区中有一个 index.html 文件等待被提交到 Git 仓库中进行保存。可以执行 git commit 命令进行提交,其中-m 选项后面是本次的提交消息，用来对提交的内容做进一步的描述:\n\ngit commit -m &quot;新建了 index.html 文件&quot;\n\n\n提交成功后，显示如下信息：\n\n\n\n提交成功之后，再次检查文件的状态，得到提示如下:\n\n\n\n证明工作区中所有的文件都处于“未修改”的状态，没有任何文件需要被提交\n\n\n对已提交的文件进行修改\n\n目前，index.html 文件已经被 Git 跟踪，并且工作区和 Git 仓库中的 index.html 文件内容保持一致。当我们修改了工作区中 index.html 的内容之后，再次运行 git status 和 git status -s 命令，会看到如下的内容\n\n\n\n文件 index.html 出现在 Changes not staged for commit 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区\n注意:修改过的、没有放入暂存区的文件前面有红色的 M 标记\n\n暂存已修改的文件\n\n目前，工作区中的 index.html 文件已被修改，如果要暂存这次修改，需要再次运行git add 命令，这个命令是个多功能的命令，主要有如下 3 个功效:\n可以用它开始跟踪新文件\n把已跟踪的、且已修改的文件放到暂存区\n把有冲突的文件标记为已解决状态\n\n\n\n\n提交已暂存的文件\n\n再次运行**git commit -m “提交消息”**命令，即可将暂存区中记录的 index.html 的快照，提交到 Git 仓库中进行保存:\n\n\n\n撤销对文件的修改\n\n撤销对文件的修改指的是:把对工作区中对应文件的修改，还原成 Git 仓库中所保存的版本\n操作的结果:所有的修改会丢失，且无法恢复!危险性比较高，请慎重操作!\n\n\n\n撤销操作的本质:用 Git 仓库中保存的文件，覆盖工作区中指定的文件\n\n向暂存区中一次性添加多个文件\n\n如果需要被暂存的文件个数比较多，可以使用如下的命令，一次性将所有的新增和修改过的文件加入暂存区\n\ngit add .\n\n\n取消暂存的文件\n\n如果需要从暂存区中移除对应的文件，可以使用如下的命令:\n\ngit reset HEAD 要移除的文件名\n\n\n# 批量移除\n\ngit reset HEAD .\n\n\n跳过使用暂存区域\n\nGit 标准的工作流程是工作区 → 暂存区 →Git 仓库，但有时候这么做略显繁琐，此时可以跳过暂存区，直接将工作区中的修改提交到 Git 仓库，这时候 Git 工作的流程简化为了工作区 →Git 仓库。\nGit 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给git commit 加上-a选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤:\n\ngit commit -a -m &quot;描述信息&quot;\n\n\n移除文件\n\n从 Git 仓库中移除文件的方式有两种:\n从 Git 仓库和工作区中同时移除对应的文件\n只从 Git 仓库中移除指定的文件，但保留工作区中对应的文件\n\n\n\n# 从 Git 仓库和工作区中同时移除 index.js 文件\n\ngit rm -f index.js\n\n# 只从 Git 仓库中移除 index.css，但保留工作区中的 index.css 文件\n\ngit rm --cached index.css\n\n忽略文件\n\n一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。在这种情况下，我们可以创建一个名为**.gitignore**的配置文件，列出要忽略的文件的匹配模式。文件.gitignore 的格式规范如下:\n\n以#开头的是注释\n以&#x2F;结尾的是目录\n以&#x2F;开头防止递归\n以!开头表示取反\n可以使用 glob 模式进行文件和文件夹的匹配 (glob 指简化了的正则表达式)\n\n\n所谓的 glob 模式是指简化了的正则表达式:\n\n星号*匹配零个或多个任意字符\n[abc]匹配任何一个列在方括号中的字符（此案例匹配一个 a 或匹配一个 b 或匹配一个 c)\n问号?只匹配一个任意字符\n在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如[0-9]表示匹配所有 0 到 9 的数字)\n两个星号* *表示匹配任意中间目录(比如 a&#x2F; **&#x2F;z 可以匹配 a&#x2F;z、 a&#x2F;b&#x2F;z 或 a&#x2F;b&#x2F;c&#x2F;z 等)\n\n\n\n# 忽略了所有的 .a 文件\n\n\\*.a\n\n# 跟踪所有的 lib.a，即便你在前面忽略了.a 文件\n\n!lab.a\n\n# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO\n\n/TODO\n\n# 忽略任何目录下名为 build 的文件夹\n\nbuild/\n\n# 忽略任何目录下名为 build 的文件夹\n\ndoc/\\*. txt\n\n# 忽略 doc/目录及其所有子目录下的.pdf 文件\n\ndoc/\\*_/_.pdf\n\n查看提交历史\n\n如果希望回顾项目的提交历史，可以使用 git log 这个简单且有效的命令\n\n# 按时间先后顺序列出所有的提交历史\n\ngit log\n\n# 只展示最新的两条提交历史，数字可以按需进行填写\n\ngit log -2\n\n# 在一行上展示最近两条提交历史的信息\n\ngit log -2 --pretty=oneline\n\n# 在一行上展示最近两条提交历史的信息，并自定义输出的格式\n\n# %h 提交的简写哈希值 %an 作者名字 %ar 作者修订日期，按多久以前的方式显示 %s 提交说明\n\ngit log -2 --pretty=format:&quot;%h | %an | %ar | %s&quot;\n\n回退到指定版本\n# 在一行上展示所有的提交历史\n\ngit log --pretty=oneline\n\n# 使用 git reset --hard 命令，根据指定的提交 ID 回退到指定版本\n\ngit reset --hard&lt; CommitID &gt;\n\n# 在旧版本中使用 git relog --pretty=online 命令，查看命令操作的历史\n\ngit relog --pretty=oneline\n\n# 再次根据最新的提交 ID，跳转到最新的版本\n\ngit reset --hard&lt; CommitID &gt;\n\n3、Github 操作3.1 关于开源\n开源是指不仅提供程序还提供程序的源代码；闭源是只提供程序，不提供源代码\n\n开源并不意味着完全没有限制，为了限制使用者的使用范围和保护作者的权利，每个开源项目都应该遵守开源许可协议（ Open Source License )\n\nBSD (Berkeley Software Distribution)\n\nApache Licence 2.0\n\nGPL (GNU General Public License)\n\n具有传染性的一种开源协议，不允许修改后和衍生的代码做为闭源的商业软件发布和销售\n\n使用 GPL 的最著名的软件项目是:Linux\n\n\n\nLGPL (GNU Lesser General Public License)\n\nMIT(Massachusetts Institute of Technology, MIT)\n\n是目前限制最少的协议，唯一的条件:在修改后的代码或者发行包中，必须包含原作者的许可信息\n使用 MIT 的软件项目有: jquery、Node.js\n\n\n\n\n各种开源协议介绍 | 菜鸟教程 (runoob.com)\n\n开源给使用者更多的控制权;开源让学习变得容易;开源才有真正的安全(我为人人，人人为我)\n\n专门用于免费存放开源项目源代码的网站，叫做开源项目托管平台。目前世界上比较出名的开源项目托管平台主要有以下 3 个:\n\n**Github(**全球最牛的开源项目托管平台，没有之一)\nGitlab(对代码私有性支持较好，因此企业用户较多)\nGitee(又叫做码云，是国产的开源项目托管平台。访问速度快、纯中文界面、使用友好)\n\n\nGithub（Github≠Git）是全球最大的开源项目托管平台。因为只支持 Git 作为唯一的版本控制工具，故名 GitHub。在 Github 中，你可以:\n\n关注自己喜欢的开源项目，为其点赞打 call\n为自己喜欢的开源项目做贡献(Pull Request)\n和开源项目的作者讨论 Bug 和提需求(lssues)\n把喜欢的项目复制一份作为自己的项目进行修改(Fork)\n创建属于自己的开源项目\netc…\n\n\n\n3.2 注册账号\n访问 Github 的官网首页https://github.com/\n点击“Sign up”按钮跳转到注册页面\n填写可用的用户名、邮箱、密码\n通过点击箭头的形式，将验证图片摆正点击“Create account”按钮注册新用户\n登录到第三步填写的邮箱中，点击激活链接，完成注册\n\n3.3 远程仓库的使用\n新建空白远程仓库\n\n\n\n成功创建\n\n\n\n远程仓库的两种访问方式\n\n\nGithub 上的远程仓库，有两种访问方式，分别是 HTTPS 和 SSH。它们的区别是:\n**HTTPS:**零配置;但是每次访问仓库时，需要重复输入 Github 的账号和密码才能访问成功\n**SSH:**需要进行额外的配置;但是配置成功后，每次访问仓库时，不需重复输入 Github 的账号和密码\n\n\n注意:在实际开发中，推荐使用 SSH 的方式访问远程仓库。\n\n\n使用 HTTPS 将本地仓库上传到 Github\n\n\n\n修改本地文件暂存提交后想同步 Github 仓库直接 git push即可\n\n\nSSH key\n\n\nSSH key 的作用:实现本地仓库和 Github 之间免登录的加密数据传输\n\nSSH key 的好处:免登录身份认证、数据加密传输\n\nSSH key 由两部分组成，分别是:\n\nid_rsa(私钥文件，存放于客户端的电脑中即可)\nid_rsa.pub(公钥文件，需要配置到 Github 中)\n\n\n\n\n生成 SSH key\n\n\n打开 Git Bash\n粘贴如下的命令，并将&#x79;&#111;&#x75;&#x72;&#95;&#x65;&#x6d;&#x61;&#105;&#x6c;&#x40;&#x65;&#120;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#109;替换为注册 Github 账号时填写的邮箱:\nssh-keygen -t rsa -b 4096 -C “&#x79;&#111;&#117;&#x72;&#95;&#x65;&#109;&#x61;&#105;&#108;&#x40;&#101;&#x78;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#99;&#x6f;&#x6d;“\n\n\n连续敲击 3 次回车，即可在 C\\Users\\用户名文件夹.ssh 目录中生成 id_rsa 和 id_rsa.pub 两个文件\n\n\n配置 SSH key\n\n\n使用记事本打开 id_rsa.pub 文件，复制里面的文本内容\n在浏览器中登录 Github，点击头像-&gt; Settings -&gt; SSH and GPG Keys -&gt; New SSH key\n将 id_rsa.pub 文件中的内容，粘贴到 Key 对应的文本框中\n在 Title 文本框中任意填写一个名称，来标识这个 Key 从何而来\n\n\n检测 Github 的 SSH key 是否配置成功\n\n\n打开 Git Bash，输入如下命令并回车，输入 yes 看到如下信息，说明 SSH key 已经配置成功了：\n\n\n\n基于 SSH 将本地仓库上传到 Github\n\n\n\n将远程仓库克隆到本地\n\ngit clone 远程仓库的地址\n\n4、Git 分支操作4.1 本地分支操作分支的概念\n\n相当于科幻电影的平行宇宙，在进行多人协作开发的时候，为了防止互相干扰，提高协同开发的体验，建议每个开发者都基于分支进行项目功能的开发\n\nmaster(main)主分支\n\n在初始化本地 Git 仓库的时候，Git 默认已经帮我们创建了一个名字叫做 master(main)的分支。通常我们把这个 master(main)分支叫做主分支。\n在实际工作中，master(main)主分支的作用是:用来保存和记录整个项目已完成的功能代码。\n因此，不允许程序员直接在 master(main)分支上修改代码，因为这样做的风险太高，容易导致整个项目崩溃。\n\n功能分支\n\n由于程序员不能直接在 master (main)分支上进行功能的开发，所以就有了功能分支的概念。\n功能分支指的是专门用来开发新功能的分支，它是临时从 master(main)主分支上分叉出来的，当新功能开发且测试完毕后，最终需要合并到 master(main)主分支上，如图所示:\n\n\n查看分支列表\ngit branch\n\n\n\n分支名字前面的*号表示当前所处的分支\n\n创建新分支\n\n使用如下的命令，可以基于当前分支，创建一个新的分支，此时，新分支中的代码和当前分支完全一样:\n\ngit branch 分支名称\n\n\n切换分支\n\n使用如下的命令，可以切换到指定的分支上进行开发:\n\ngit checkout 分支名称\n\n\n分支的快速创建和切换\n\n使用如下的命令，可以创建指定名称的新分支，并立即切换到新分支上:\n\n# -b 表示创建一个新分支\n\n# checkout 表示切换到刚才新建的分支上\n\ngit checkout -b 分支名称\n\n\n分支合并\n\n功能分支的代码开发测试完毕之后，可以使用如下的命令，将完成后的代码合并到 master 主分支上:\n\n# 1.切换到 main 分支\n\ngit checkout main\n\n# 2.在 main 分支上运行 git merge 命令，将 login 分支的代码合并到 main 分支\n\ngit merge login\n\n\n\n合并分支时的注意点:假设要把 C 分支的代码合并到 A 分支,则必须先切换到 A 分支上，再运行 git merae 命令，来合并 C 分支!\n\n删除分支\n\n当把功能分支的代码合并到 master 主分支上以后，就可以使用如下的命令，删除对应的功能分支:\n\ngit branch -d 分支名称\n\n\n遇到冲突时的分支合并\n\n如果在两个不同的分支中，对同一个文件进行了不同的修改，Git 就没法干净的合并它们。此时，我们需要打开这些包含冲突的文件然后手动解决冲突\n\n# 假设：在把reg分支合并到main分支期间，代码发生了冲突\ngit checkout main\ngit merge reg\n\n# 打开包含冲突的文件，手动解决冲突之后(vscode智能解决)，再执行下列命令\ngit add .\ngit commit -m &quot;解决了分支合并冲突的问题&quot;\n\n4.2 远程分支操作将本地分支推送到远程仓库\n\n如果是第一次将本地分支推送到远程仓库，需要运行如下的命令:\n\n# -u 表示把本地分支和远程分支进行关联，只在第一次推送的时候需要带-u 参数\n\ngit push -u 远程仓库的别名 本地分支名称:远程分支名称\n\n# 实际案例:\n\ngit push -u origin payment: pay\n\n# 如果希望远程分支的名称和本地分支名称保持一致，可以对命令进行简化:\n\ngit push -u origin payment\n\n\n注意:第一次推送分支需要带-u 参数，此后可以直接使用 git push 推送代码到远程分支。\n\n查看远程仓库中所有的分支列表\n\n通过如下的命令，可以查看远程仓库中，所有的分支列表的信息:\n\ngit remote show 远程仓库名称\n\n跟踪分支\n\n跟踪分支指的是:从远程仓库中，把远程分支下载到本地仓库中。需要运行的命令如下:\n\n# 从远程仓库中，把对应的远程分支下载到本地仓库，保持本地分支和远程分支名称相同\n\ngit checkout 远程分支的名称\n\n# 示例:\n\ngit checkout pay\n\n# 从远程仓库中，把对应的远程分支下载到本地仓库，并把下载的本地分支进行重命名\n\ngit checkout -b 本地分支名称 远程仓库名称/远程分支名称\n\n# 示例:\n\ngit checkout -b payment origin/pay\n\n拉取远程分支的最新的代码\n\n可以使用如下的命令，把远程分支最新的代码下载到本地对应的分支中:\n\n# 从远程仓库，拉取当前分支最新的代码，保持当前分支的代码和远程分支代码一致\ngit pull\n\n删除远程分支\n\n可以使用如下的命令，删除远程仓库中指定的分支:\n\n# 删除远程仓库中，指定名称的远程分支\ngit push 远程仓库名称 --delete 远程分支名称\n\n# 示例:\ngit push origin --delete pay\n\n","slug":"前端--详解Git(快速入门)","date":"2023-01-17T02:06:29.000Z","categories_index":"前端","tags_index":"Git","author_index":"会思想的苇草i"},{"id":"269efa4fe53bba32d25aec66c5987385","title":"Ajax实战指南：快速入门","content":"AJAX1、AJAX概述1.1 AJAX简介\nAJAX全称为Asynchronous JavaScript And XML，就是异步的JS和XML\n通过AJAX可以在浏览器中向服务器发送异步请求，最大的优势:无刷新获取数据\nAJAX不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式\n\n1.2  XML简介\nXML可扩展标记语言\nXML被设计用来传输和存储数据\nXML和HTML类似，不同的是HTML中都是预定义标签，而XML中没有预定义标签，全都是自定义标签，用来表示一些数据\n\n&lt;!--XML表示--&gt;\n&lt;student&gt;\n    &lt;name&gt;孙情空&lt;/name&gt;\n    &lt;age&gt;18&lt;/age&gt;\n    &lt;gender&gt;男&lt;/gender&gt;\n&lt;/student&gt;\n\n//JSON表示\n&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;\n\n1.3 AJAX的特点\nAJAX的优点\n可以无需刷新页面而与服务器端进行通信\n允许你根据用户事件来更新部分页面内容\n\n\nAJAX的缺点\n没有浏览历史，不能回退\n存在跨域问题(同源)\nSEO不友好\n\n\n\n2、HTTP相关2.1 HTTP概述\nHTTP（hypertext transport protocol）协议『超文本传输协议』，协议详细规定了浏览器和万维网服务器之间互相通信的规则\n\nHTTP概述 - HTTP | MDN (mozilla.org)\n\nHTTP交互：\n\n前后应用从浏览器端向服务器发送HTTP 请求(请求报文)\n后台服务器接收到请求后, 调度服务器应用处理请求, 向浏览器端返回HTTP响应(响应报文)\n浏览器端接收到响应, 解析显示响应体&#x2F;调用监视回调\n\n\n\n2.2 请求报文行      POST  /s?ie=utf-8  HTTP/1.1 \n头      Host: atguigu.com\n        Cookie: name=guigu\n        Content-type: application/x-www-form-urlencoded\n        User-Agent: chrome 83\n空行\n体      username=admin&amp;password=admin\n\n2.3 响应报文行      HTTP/1.1  200  OK\n头      Content-Type: text/html;charset=utf-8\n        Content-length: 2048\n        Content-encoding: gzip\n空行    \n体      &lt;html&gt;\n            &lt;head&gt;\n            &lt;/head&gt;\n            &lt;body&gt;\n                &lt;h1&gt;尚硅谷&lt;/h1&gt;\n            &lt;/body&gt;\n        &lt;/html&gt;\n\n2.4 常见的响应状态码\n200 OK 请求成功。一般用于GET 与POST 请求\n201 Created 已创建。成功请求并创建了新的资源\n401 Unauthorized 未授权&#x2F;请求要求用户的身份认证\n404 Not Found 服务器无法根据客户端的请求找到资源\n500 Internal Server Error 服务器内部错误，无法完成请求\n\n2.5 不同类型的请求及其作用\nGET: 从服务器端读取数据（查）\nPOST: 向服务器端添加新数据 （增）\nPUT: 更新服务器端已有数据 （改）\nDELETE: 删除服务器端数据 （删）\n\n2.6 一般http请求 与 ajax请求\najax请求是一种特别的 http请求\n对服务器端来说, 没有任何区别, 区别在浏览器端\n浏览器端发请求: 只有XHR 或fetch 发出的才是ajax 请求, 其它所有的都是非ajax 请求\n浏览器端接收到响应  (1) 一般请求: 浏览器一般会直接显示响应体数据, 也就是我们常说的刷新&#x2F;跳转页面  (2) ajax请求: 浏览器不会对界面进行任何更新操作, 只是调用监视的回调函数并传入响应相关数据\n\n3、原生AJAX的使用3.1 准备工作安装node.js\n\nNode.js 中文网 (nodejs.cn)\n检查安装成功：node -v(命令行窗口)\n\n安装express(服务端框架)\n\nExpress - 基于 Node.js 平台的 web 应用开发框架 - Express 中文文档 | Express 中文网 (expressjs.com.cn)\n\n操作步骤：\n\n初始化环境：npm init --yes\n\n下载express包：npm install express --save\n\n编写js代码：\n// 1. 引入express\nconst express = require(&#39;express&#39;);\n\n// 2. 创建应用对象\nconst app = express();\n\n// 3. 创建路由规则\n// request 是对请求报文的封装\n// response 是对响应报文的封装\napp.get(&#39;/&#39;, (request, response) =&gt; &#123;\n  //  设置响应\n  response.send(&quot;Hello Express&quot;);\n&#125;);\n\n// 4. 监听端口，启动服务\napp.listen(8000, () =&gt; &#123;\n  console.log(&quot;服务已经启动, 8000 端口监听中...&quot;);\n &#125;)\n\n\n运行js程序：node .\\01express使用.js\n\n打开网页显示页面\n\n调试程序可以查看请求和响应\n\n\n\n\n安装nodemon自动重启工具\n\nnodemon - npm (npmjs.com)\n步骤：\n安装：npm install -g nodemon\n启动服务：nodemon server.js\n\n\n\n3.2 核心对象\n核心对象\n\nXMLHttpRequest，AJAX的所有操作都是通过该对象进行的\n\n\n使用步骤\n\n创建XMLHttpRequest对象\nvar xhr = new XMLHttpRequest();\n\n\n设置请求信息\nxhr.open(method, url);\n//可以设置请求头，一般不设置\nxhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;);\n\n\n发送请求\nxhr.send(body)//get请求不传body参数，只有post 请求使用\n\n\n接收响应\n//xhr.responseXML接收xml格式的响应数据\n//xhr.responseText接收文本格式的响应数据\nxhr.onreadystatechange = function ()&#123;\n        if(xhr.readyState == 4 &amp;&amp;xhr.status == 200)&#123;\n            var text = xhr.responseText;\n            console.log(text);\n    &#125;\n&#125;\n\n\n\n\n\n3.3 GET请求\n点击返回响应信息\n\n创建浏览器端使用的html文件和服务端使用的js文件\n\n\n\n\n服务器端server.js\n\n// 1. 引入express\nconst express = require(&#39;express&#39;);\n\n// 2. 创建应用对象\nconst app = express();\n\n// 3. 创建路由规则\napp.get(&#39;/server&#39;, (request, response) =&gt; &#123;\n  // 设置响应头 设置允许跨域\n  response.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);\n  // 设置响应体\n  response.send(&quot;Hello Ajax&quot;);\n&#125;);\n\n// 4. 监听服务\napp.listen(8000, () =&gt; &#123;\n  console.log(&quot;服务已经启动, 8000 端口监听中...&quot;);\n &#125;)\n\n\n启动服务：node server.js\n前端页面\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;AJAX GET 请求&lt;/title&gt;\n    &lt;style&gt;\n        #result &#123;\n            width: 200px;\n            height: 100px;\n            border: solid 1px #90b;\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;button&gt;点击发送请求&lt;/button&gt;\n    &lt;div id=&quot;result&quot;&gt;&lt;/div&gt;\n\n    &lt;script&gt;\n        //获取button元素\n        const btn = document.getElementsByTagName(&#39;button&#39;)[0];\n        const result = document.getElementById(&quot;result&quot;);\n        //绑定事件\n        btn.onclick = function () &#123;\n            //1. 创建对象\n            const xhr = new XMLHttpRequest();\n            //2. 初始化 设置请求方法和 url\n            xhr.open(&#39;GET&#39;, &#39;http://127.0.0.1:8000/server?a=100&amp;b=200&amp;c=300&#39;);\n            //3. 发送\n            xhr.send();\n            //4. 事件绑定 处理服务端返回的结果\n            // on  when 当....时候\n            // readystate 是 xhr 对象中的属性, 表示状态 0 1 2 3 4\n            // change  改变\n            xhr.onreadystatechange = function () &#123;\n                //判断 (服务端返回了所有的结果)\n                if (xhr.readyState === 4) &#123;\n                    //判断响应状态码 200  404  403 401 500\n                    // 2xx 成功\n                    if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123;\n                        //处理结果  行 头 空行 体\n                        //响应 \n                        // console.log(xhr.status);//状态码\n                        // console.log(xhr.statusText);//状态字符串\n                        // console.log(xhr.getAllResponseHeaders());//所有响应头\n                        // console.log(xhr.response);//响应体\n                        //设置 result 的文本\n                        result.innerHTML = xhr.response;\n                    &#125; else &#123;\n\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n\nGET请求设置请求参数\n\n设置url参数：xhr.open(&#39;GET&#39;, &#39;http://127.0.0.1:8000/server?a=100&amp;b=200&amp;c=300&#39;);\n\n\n\n3.4 POST请求\n鼠标放到div中，发post请求，将响应体放在div中呈现\n\nserver.js添加post\n\n\n//可以接收任意类型的请求 \napp.all(&#39;/server&#39;, (request, response) =&gt; &#123;\n    //设置响应头  设置允许跨域\n    response.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);\n    //响应头\n    response.setHeader(&#39;Access-Control-Allow-Headers&#39;, &#39;*&#39;);\n    //设置响应体\n    response.send(&#39;HELLO AJAX POST&#39;);\n&#125;);\n\n\n前端页面\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;AJAX POST 请求&lt;/title&gt;\n    &lt;style&gt;\n        #result&#123;\n            width:200px;\n            height:100px;\n            border:solid 1px #903;\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=&quot;result&quot;&gt;&lt;/div&gt;\n    &lt;script&gt;\n        //获取元素对象\n        const result = document.getElementById(&quot;result&quot;);\n        //绑定事件\n        result.addEventListener(&quot;mouseover&quot;, function()&#123;\n            //1. 创建对象\n            const xhr = new XMLHttpRequest();\n            //2. 初始化 设置类型与 URL\n            xhr.open(&#39;POST&#39;, &#39;http://127.0.0.1:8000/server&#39;);\n            //设置请求头\n            xhr.setRequestHeader(&#39;Content-Type&#39;,&#39;application/x-www-form-urlencoded&#39;);\n            xhr.setRequestHeader(&#39;name&#39;,&#39;atguigu&#39;);\n            //3. 发送\n            xhr.send(&#39;a=100&amp;b=200&amp;c=300&#39;);\n            // xhr.send(&#39;a:100&amp;b:200&amp;c:300&#39;);\n            // xhr.send(&#39;1233211234567&#39;);\n            \n            //4. 事件绑定\n            xhr.onreadystatechange = function()&#123;\n                //判断\n                if(xhr.readyState === 4)&#123;\n                    if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;\n                        //处理服务端返回的结果\n                        result.innerHTML = xhr.response;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;);\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\n设置请求头信息\n// 设置请求体内容的类型\nxhr.setRequesHeader(&#39;Content-Type&#39;,&#39;application/x-www-from-urlencoded&#39;);\n// 自定义头信息\nxhr.setRequesHeader(&#39;name&#39;, &#39;ashiyi&#39;);\n\n\nserver.js中设置响应头允许自定义请求头 post改成all\n\nresponse.setHeader(&#39;Access-Control-Allow-Header&#39;,&#39;*&#39;);\n\n3.5 json数据请求app.all(&#39;/json-server&#39;, (request, response) =&gt; &#123;\n  // 设置响应头, 设置允许跨域\n  response.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);\n  // 设置响应头, 设置允许自定义头信息\n  response.setHeader(&#39;Access-Control-Allow-Headers&#39;, &#39;*&#39;);\n  // 响应一个数据\n  const data = &#123;\n    name: &#39;atguigu&#39;\n  &#125;;\n  // 对 对象 进行 字符串 转换\n  let str = JSON.stringify(data)\n  // 设置响应体 \n  response.send(str);\n&#125;);\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;JSON响应&lt;/title&gt;\n    &lt;style&gt;\n        #result&#123;\n            width:200px;\n            height:100px;\n            border:solid 1px #89b;\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=&quot;result&quot;&gt;&lt;/div&gt;\n    &lt;script&gt;\n        const result = document.getElementById(&#39;result&#39;);\n        //绑定键盘按下事件\n        window.onkeydown = function()&#123;\n            //发送请求\n            const xhr = new XMLHttpRequest();\n            //设置响应体数据的类型\n            xhr.responseType = &#39;json&#39;;\n            //初始化\n            xhr.open(&#39;GET&#39;,&#39;http://127.0.0.1:8000/json-server&#39;);\n            //发送\n            xhr.send();\n            //事件绑定\n            xhr.onreadystatechange = function()&#123;\n                if(xhr.readyState === 4)&#123;\n                    if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;\n                        //\n                        // console.log(xhr.response);\n                        // result.innerHTML = xhr.response;\n                        // 1. 手动对数据转化\n                        // let data = JSON.parse(xhr.response);\n                        // console.log(data);\n                        // result.innerHTML = data.name;\n                        // 2. 自动转换\n                        console.log(xhr.response);\n                        result.innerHTML = xhr.response.name;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\n3.6 解决IE缓存问题\n问题:在一些浏览器中(IE),由于缓存机制的存在，ajax只会发送的第一次请求，剩余多次请求不会在发送给浏览器而是直接加载缓存中的数据\n解决方式:浏览器的缓存是根据url地址来记录的，所以我们只需要修改url地址即可避免缓存问题\nxhr.open(&quot;get&quot; ,&quot; /testAJAX?t=&quot;+Date.now());\n\n3.7 请求超时和网络异常\n前端页面\n\n// 超时设置 （2秒）\nxhr.timeout = 2000;\n// 超时回调\nxhr.ontimeout = function()&#123;\n    alert(&#39;网络超时，请稍后重试&#39;)\n&#125;\n// 网络异常回调\nxhr.onerror = function()&#123;\n    alert(&#39;网络异常，请稍后重试&#39;)\n&#125;\n\n\nserver.js\n\n//延时响应\napp.all(&#39;/delay&#39;, (request, response) =&gt; &#123;\n    //设置响应头  设置允许跨域\n    response.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);\n    response.setHeader(&#39;Access-Control-Allow-Headers&#39;, &#39;*&#39;);\n    setTimeout(() =&gt; &#123;\n        //设置响应体\n        response.send(&#39;延时响应&#39;);\n    &#125;, 1000)\n&#125;);\n\n3.8 取消请求// 手动取消\nxhr.abort()\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;取消请求&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;button&gt;点击发送&lt;/button&gt;\n    &lt;button&gt;点击取消&lt;/button&gt;\n    &lt;script&gt;\n        //获取元素对象\n        const btns = document.querySelectorAll(&#39;button&#39;);\n        let x = null;\n\n        btns[0].onclick = function()&#123;\n            x = new XMLHttpRequest();\n            x.open(&quot;GET&quot;,&#39;http://127.0.0.1:8000/delay&#39;);\n            x.send();\n        &#125;\n\n        // abort\n        btns[1].onclick = function()&#123;\n            x.abort();\n        &#125;\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n 重复请求问题\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;重复请求问题&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;button&gt;点击发送&lt;/button&gt;\n    &lt;script&gt;\n        //获取元素对象\n        const btns = document.querySelectorAll(&#39;button&#39;);\n        let x = null;\n        //标识变量\n        let isSending = false; // 是否正在发送AJAX请求\n\n        btns[0].onclick = function()&#123;\n            //判断标识变量\n            if(isSending) \n                x.abort();// 如果正在发送, 则取消该请求, 创建一个新的请求\n            x = new XMLHttpRequest();\n            //修改 标识变量的值\n            isSending = true;\n            x.open(&quot;GET&quot;,&#39;http://127.0.0.1:8000/delay&#39;);\n            x.send();\n            x.onreadystatechange = function()&#123;\n                if(x.readyState === 4)&#123;\n                    //修改标识变量\n                    isSending = false;//节流\n                &#125;\n            &#125;\n        &#125;\n        // abort\n        btns[1].onclick = function()&#123;\n            x.abort();\n        &#125;\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n3.9 AJAX请求状态\nxhr.readyState 可以用来查看请求当前的状态\nhttps://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/readyState\n0:表示XMLHttpRequest实例已经生成，但是open()方法还没有被调用\n1:表示send()方法还没有被调用，仍然可以使用setRequestHeader()，设定HTTP请求的头信息\n2:表示send()方法已经执行，并且头信息和状态码已经收到\n3:表示正在接收服务器传来的body 部分的数据\n4:表示服务器数据已经完全接收，或者本次接收已经失败了\n\n3.10 API总结\nXMLHttpRequest()：创建 XHR 对象的构造函数\nstatus：响应状态码值，如 200、404\nstatusText：响应状态文本，如 ’ok‘、‘not found’\nreadyState：标识请求状态的只读属性 0-1-2-3-4\nonreadystatechange：绑定 readyState 改变的监听\nresponseType：指定响应数据类型，如果是 ‘json’，得到响应后自动解析响应\nresponse：响应体数据，类型取决于 responseType 的指定\ntimeout：指定请求超时时间，默认为 0 代表没有限制\nontimeout：绑定超时的监听\nonerror：绑定请求网络错误的监听\nopen()：初始化一个请求，参数为：(method, url[, async])\nsend(data)：发送请求\nabort()：中断请求 （发出到返回之间）\ngetResponseHeader(name)：获取指定名称的响应头值\ngetAllResponseHeaders()：获取所有响应头组成的字符串\nsetRequestHeader(name, value)：设置请求头\n\n4、jQuery-AJAX4.1 get请求\n$.get(url, [data], [callback], [type])\nurl:请求的URL地址\ndata:请求携带的参数\ncallback:载入成功时回调函数\ntype:设置返回内容格式，xml, html, script, json, text,_default\n\n\n\n4.2 post请求\n$.post(url, [data], [callback], [type])\nurl:请求的URL地址\ndata:请求携带的参数\ncallback:载入成功时回调函数\ntype:设置返回内容格式，xml, html, script, json, text,_default\n\n\n\n4.3 通用方法\n前端代码\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;jQuery 发送 AJAX 请求&lt;/title&gt;\n    &lt;link crossorigin=&quot;anonymous&quot; href=&quot;https://cdn.bootcss.com/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;\n    &lt;script crossorigin=&quot;anonymous&quot; src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=&quot;container&quot;&gt;\n        &lt;h2 class=&quot;page-header&quot;&gt;jQuery发送AJAX请求 &lt;/h2&gt;\n        &lt;button class=&quot;btn btn-primary&quot;&gt;GET&lt;/button&gt;\n        &lt;button class=&quot;btn btn-danger&quot;&gt;POST&lt;/button&gt;\n        &lt;button class=&quot;btn btn-info&quot;&gt;通用型方法ajax&lt;/button&gt;\n    &lt;/div&gt;\n    &lt;script&gt;\n        $(&#39;button&#39;).eq(0).click(function()&#123;\n            $.get(&#39;http://127.0.0.1:8000/jquery-server&#39;, &#123;a:100, b:200&#125;, function(data)&#123;\n                console.log(data);\n            &#125;,&#39;json&#39;);\n        &#125;);\n\n        $(&#39;button&#39;).eq(1).click(function()&#123;\n            $.post(&#39;http://127.0.0.1:8000/jquery-server&#39;, &#123;a:100, b:200&#125;, function(data)&#123;\n                console.log(data);\n            &#125;);\n        &#125;);\n\n        $(&#39;button&#39;).eq(2).click(function()&#123;\n            $.ajax(&#123;\n                //url\n                url: &#39;http://127.0.0.1:8000/jquery-server&#39;,\n                //参数\n                data: &#123;a:100, b:200&#125;,\n                //请求类型\n                type: &#39;GET&#39;,\n                //响应体结果\n                dataType: &#39;json&#39;,\n                //成功的回调\n                success: function(data)&#123;\n                    console.log(data);\n                &#125;,\n                //超时时间\n                timeout: 2000,\n                //失败的回调\n                error: function()&#123;\n                    console.log(&#39;出错啦!!&#39;);\n                &#125;,\n                //头信息\n                headers: &#123;\n                    c:300,\n                    d:400\n                &#125;\n            &#125;);\n        &#125;);\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nserver.js添加\n\n//jQuery 服务\napp.all(&#39;/jquery-server&#39;, (request, response) =&gt; &#123;\n    //设置响应头  设置允许跨域\n    response.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);\n    response.setHeader(&#39;Access-Control-Allow-Headers&#39;, &#39;*&#39;);\n    // response.send(&#39;Hello jQuery AJAX&#39;);\n    const data = &#123;name:&#39;尚硅谷&#39;&#125;;\n    response.send(JSON.stringify(data));\n&#125;);\n\n5、Axios-AJAX\n前端界面\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;axios 发送 AJAX请求&lt;/title&gt;\n    &lt;script crossorigin=&quot;anonymous&quot; src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.19.2/axios.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;button&gt;GET&lt;/button&gt;\n    &lt;button&gt;POST&lt;/button&gt;\n    &lt;button&gt;AJAX&lt;/button&gt;\n\n    &lt;script&gt;\n        // https://github.com/axios/axios\n        const btns = document.querySelectorAll(&#39;button&#39;);\n\n        //配置 baseURL\n        axios.defaults.baseURL = &#39;http://127.0.0.1:8000&#39;;\n\n        btns[0].onclick = function () &#123;\n            //GET 请求\n            axios.get(&#39;/axios-server&#39;, &#123;\n                //url 参数\n                params: &#123;\n                    id: 100,\n                    vip: 7\n                &#125;,\n                //请求头信息\n                headers: &#123;\n                    name: &#39;atguigu&#39;,\n                    age: 20\n                &#125;\n            &#125;).then(value =&gt; &#123;\n                console.log(value);\n            &#125;);\n        &#125;\n\n        btns[1].onclick = function () &#123;\n            axios.post(&#39;/axios-server&#39;, &#123;\n                username: &#39;admin&#39;,\n                password: &#39;admin&#39;\n            &#125;, &#123;\n                //url \n                params: &#123;\n                    id: 200,\n                    vip: 9\n                &#125;,\n                //请求头参数\n                headers: &#123;\n                    height: 180,\n                    weight: 180,\n                &#125;\n            &#125;);\n        &#125;\n    \n        btns[2].onclick = function()&#123;\n            axios(&#123;\n                //请求方法\n                method : &#39;POST&#39;,\n                //url\n                url: &#39;/axios-server&#39;,\n                //url参数\n                params: &#123;\n                    vip:10,\n                    level:30\n                &#125;,\n                //头信息\n                headers: &#123;\n                    a:100,\n                    b:200\n                &#125;,\n                //请求体参数\n                data: &#123;\n                    username: &#39;admin&#39;,\n                    password: &#39;admin&#39;\n                &#125;\n            &#125;).then(response=&gt;&#123;\n                //响应状态码\n                console.log(response.status);\n                //响应状态字符串\n                console.log(response.statusText);\n                //响应头信息\n                console.log(response.headers);\n                //响应体\n                console.log(response.data);\n            &#125;)\n        &#125;\n    &lt;/script&gt; \n&lt;/body&gt;\n\n&lt;/html&gt;\n\n\nserver.js添加\n\n//axios 服务\napp.all(&#39;/axios-server&#39;, (request, response) =&gt; &#123;\n    //设置响应头  设置允许跨域\n    response.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);\n    response.setHeader(&#39;Access-Control-Allow-Headers&#39;, &#39;*&#39;);\n    // response.send(&#39;Hello jQuery AJAX&#39;);\n    const data = &#123;name:&#39;尚硅谷&#39;&#125;;\n    response.send(JSON.stringify(data));\n&#125;);\n\n6、fetch-AJAX\n前端页面\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;fetch 发送 AJAX请求&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;button&gt;AJAX请求&lt;/button&gt;\n    &lt;script&gt;\n        //文档地址\n        //https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/fetch\n        \n        const btn = document.querySelector(&#39;button&#39;);\n\n        btn.onclick = function()&#123;\n            fetch(&#39;http://127.0.0.1:8000/fetch-server?vip=10&#39;, &#123;\n                //请求方法\n                method: &#39;POST&#39;,\n                //请求头\n                headers: &#123;\n                    name:&#39;atguigu&#39;\n                &#125;,\n                //请求体\n                body: &#39;username=admin&amp;password=admin&#39;\n            &#125;).then(response =&gt; &#123;\n                // return response.text();\n                return response.json();\n            &#125;).then(response=&gt;&#123;\n                console.log(response);\n            &#125;);\n        &#125;\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nserver.js添加\n\n//fetch 服务\napp.all(&#39;/fetch-server&#39;, (request, response) =&gt; &#123;\n    //设置响应头  设置允许跨域\n    response.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);\n    response.setHeader(&#39;Access-Control-Allow-Headers&#39;, &#39;*&#39;);\n    // response.send(&#39;Hello jQuery AJAX&#39;);\n    const data = &#123;name:&#39;尚硅谷&#39;&#125;;\n    response.send(JSON.stringify(data));\n&#125;);\n\n7、跨域7.1 同源策略\n同源策略(Same-Origin Policy)最早由Netscape公司提出，是浏览器的一种安全策略\n\n同源:协议、域名、端口号必须完全相同\n\n违背同源策略就是跨域\n\n前端页面\n\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;首页&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;尚硅谷&lt;/h1&gt;\n    &lt;button&gt;点击获取用户数据&lt;/button&gt;\n    &lt;script&gt;\n        const btn = document.querySelector(&#39;button&#39;);\n\n        btn.onclick = function()&#123;\n            const x = new XMLHttpRequest();\n            //这里因为是满足同源策略的, 所以 url 可以简写\n            x.open(&quot;GET&quot;,&#39;/data&#39;);\n            //发送\n            x.send();\n            //\n            x.onreadystatechange = function()&#123;\n                if(x.readyState === 4)&#123;\n                    if(x.status &gt;= 200 &amp;&amp; x.status &lt; 300)&#123;\n                        console.log(x.response);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nserver.js\n\nconst express = require(&#39;express&#39;);\n\nconst app = express();\n\napp.get(&#39;/home&#39;, (request, response)=&gt;&#123;\n    //响应一个页面\n    response.sendFile(__dirname + &#39;/index.html&#39;);\n&#125;);\n\napp.get(&#39;/data&#39;, (request, response)=&gt;&#123;\n    response.send(&#39;用户数据&#39;);\n&#125;);\n\napp.listen(9000, ()=&gt;&#123;\n    console.log(&quot;服务已经启动...&quot;);\n&#125;);\n\n7.2如何解决跨域JSONP\n\nJSONP是什么\n\nJSONP(JSON with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明才智开发出来，只支持get请求\n\n\nJSONP工作流程\n\n在网页有一些标签天生具有跨域能力，比如:img link iframe script\nJSONP就是利用script标签的跨域能力来发送请求的\n\n\nJSONP的使用\n\n动态的创建一个script标签\n\nvar script = document.createElement(&quot;script&quot;);\n\n\n设置script的 src，设置回调函数\n\nscript.src = &quot;http://localhost:3000/testAJAX?callback=abc&quot;;\nfunction abc(data)&#123;\n           alert(data.name);\n  &#125;;\n\n\n将script添加到body 中\n\ndocument.body.appendChild(script);\n\n\n服务器中路由的处理\n\nrouter.get(&quot;/testAJAX&quot; , function (req , res) &#123;\n    console.log(&quot;收到请求&quot;);\nvar callback = req.query.callback;\nvar obj=&#123;\n    name:&quot;孙悟空&quot;,\n    age:18\n  &#125;\n  res.send(callback+&quot;(&quot;+JSON.stringify(obj)+&quot;)&quot;);\n&#125;);\n\n\n原理\n\n前端页面\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;原理演示&lt;/title&gt;\n    &lt;style&gt;\n        #result &#123;\n            width: 300px;\n            height: 100px;\n            border: solid 1px #78a;\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div id=&quot;result&quot;&gt;&lt;/div&gt;\n    &lt;script&gt;\n        //处理数据\n        function handle(data) &#123;\n            //获取 result 元素\n            const result = document.getElementById(&#39;result&#39;);\n            result.innerHTML = data.name;\n        &#125;\n    &lt;/script&gt;\n    &lt;!-- &lt;script src=&quot;http://127.0.0.1:5500/%E8%AF%BE%E5%A0%82/%E4%BB%A3%E7%A0%81/7-%E8%B7%A8%E5%9F%9F/2-JSONP/js/app.js&quot;&gt;&lt;/script&gt; --&gt;\n    &lt;script src=&quot;http://127.0.0.1:8000/jsonp-server&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n\n\nserver.js\n\n//jsonp服务\napp.all(&#39;/jsonp-server&#39;,(request, response) =&gt; &#123;\n    // response.send(&#39;console.log(&quot;hello jsonp&quot;)&#39;);\n    const data = &#123;\n        name: &#39;尚硅谷atguigu&#39;\n    &#125;;\n    //将数据转化为字符串\n    let str = JSON.stringify(data);\n    //返回结果\n    response.end(`handle($&#123;str&#125;)`);\n&#125;);\n\n\nJSONP实践\n\n前端页面\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;案例&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    用户名: &lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;\n    &lt;p&gt;&lt;/p&gt;\n    &lt;script&gt;\n        //获取 input 元素\n        const input = document.querySelector(&#39;input&#39;);\n        const p = document.querySelector(&#39;p&#39;);\n        \n        //声明 handle 函数\n        function handle(data)&#123;\n            input.style.border = &quot;solid 1px #f00&quot;;\n            //修改 p 标签的提示文本\n            p.innerHTML = data.msg;\n        &#125;\n\n        //绑定事件\n        input.onblur = function()&#123;\n            //获取用户的输入值\n            let username = this.value;\n            //向服务器端发送请求 检测用户名是否存在\n            //1. 创建 script 标签\n            const script = document.createElement(&#39;script&#39;);\n            //2. 设置标签的 src 属性\n            script.src = &#39;http://127.0.0.1:8000/check-username&#39;;\n            //3. 将 script 插入到文档中\n            document.body.appendChild(script);\n        &#125;\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nserver.js中添加\n\n//用户名检测是否存在\napp.all(&#39;/check-username&#39;,(request, response) =&gt; &#123;\n    // response.send(&#39;console.log(&quot;hello jsonp&quot;)&#39;);\n    const data = &#123;\n        exist: 1,\n        msg: &#39;用户名已经存在&#39;\n    &#125;;\n    //将数据转化为字符串\n    let str = JSON.stringify(data);\n    //返回结果\n    response.end(`handle($&#123;str&#125;)`);\n&#125;);\n\n\nJQuery中的JSONP\n\n前端页面\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;jQuery-jsonp&lt;/title&gt;\n    &lt;style&gt;\n        #result&#123;\n            width:300px;\n            height:100px;\n            border:solid 1px #089;\n        &#125;\n    &lt;/style&gt;\n    &lt;script crossorigin=&quot;anonymous&quot; src=&#39;https://cdn.bootcss.com/jquery/3.5.0/jquery.min.js&#39;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;button&gt;点击发送 jsonp 请求&lt;/button&gt;\n    &lt;div id=&quot;result&quot;&gt;\n\n    &lt;/div&gt;\n    &lt;script&gt;\n        $(&#39;button&#39;).eq(0).click(function()&#123;\n            $.getJSON(&#39;http://127.0.0.1:8000/jquery-jsonp-server?callback=?&#39;, function(data)&#123;\n                $(&#39;#result&#39;).html(`\n                    名称: $&#123;data.name&#125;&lt;br&gt;\n                    校区: $&#123;data.city&#125;\n                `)\n            &#125;);\n        &#125;);\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nserver.js中添加\n\napp.all(&#39;/jquery-jsonp-server&#39;,(request, response) =&gt; &#123;\n    // response.send(&#39;console.log(&quot;hello jsonp&quot;)&#39;);\n    const data = &#123;\n        name:&#39;尚硅谷&#39;,\n        city: [&#39;北京&#39;,&#39;上海&#39;,&#39;深圳&#39;]\n    &#125;;\n    //将数据转化为字符串\n    let str = JSON.stringify(data);\n    //接收 callback 参数\n    let cb = request.query.callback;\n\n    //返回结果\n    response.end(`$&#123;cb&#125;($&#123;str&#125;)`);\n&#125;);\n\n\n\n\n\n CORS\n\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access control CORS\n\nCORS\n\nCORS(Cross-Origin Resource Sharing)，跨域资源共享\nCORS是官方的跨域解决方案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持get和 post请求。跨域资源共享标准新增了一组HTTP首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源\n\n\nCORS工作过程\n\nCORS是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行\n\n\n前端界面\n\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;CORS&lt;/title&gt;\n    &lt;style&gt;\n        #result&#123;\n            width:200px;\n            height:100px;\n            border:solid 1px #90b;\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;button&gt;发送请求&lt;/button&gt;\n    &lt;div id=&quot;result&quot;&gt;&lt;/div&gt;\n    &lt;script&gt;\n        const btn = document.querySelector(&#39;button&#39;);\n\n        btn.onclick = function()&#123;\n            //1. 创建对象\n            const x = new XMLHttpRequest();\n            //2. 初始化设置\n            x.open(&quot;GET&quot;, &quot;http://127.0.0.1:8000/cors-server&quot;);\n            //3. 发送\n            x.send();\n            //4. 绑定事件\n            x.onreadystatechange = function()&#123;\n                if(x.readyState === 4)&#123;\n                    if(x.status &gt;= 200 &amp;&amp; x.status &lt; 300)&#123;\n                        //输出响应体\n                        console.log(x.response);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nserver.js中添加\n\napp.all(&#39;/cors-server&#39;, (request, response)=&gt;&#123;\n    //设置响应头\n    response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);\n    response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &#39;*&#39;);\n    response.setHeader(&quot;Access-Control-Allow-Method&quot;, &#39;*&#39;);\n    // response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:5500&quot;);\n    response.send(&#39;hello CORS&#39;);\n&#125;);\n\n&lt;style&gt;\n    #result&#123;\n        width:200px;\n        height:100px;\n        border:solid 1px #90b;\n    &#125;\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;button&gt;发送请求&lt;/button&gt;\n    &lt;div id=&quot;result&quot;&gt;&lt;/div&gt;\n    &lt;script&gt;\n        const btn = document.querySelector(&#39;button&#39;);\n         btn.onclick = function()&#123;\n        //1. 创建对象\n        const x = new XMLHttpRequest();\n        //2. 初始化设置\n        x.open(&quot;GET&quot;, &quot;http://127.0.0.1:8000/cors-server&quot;);\n        //3. 发送\n        x.send();\n        //4. 绑定事件\n        x.onreadystatechange = function()&#123;\n            if(x.readyState === 4)&#123;\n                if(x.status &gt;= 200 &amp;&amp; x.status &lt; 300)&#123;\n                    //输出响应体\n                    console.log(x.response);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\n* server.js中添加\n\n~~~JavaScript\napp.all(&#39;/cors-server&#39;, (request, response)=&gt;&#123;\n    //设置响应头\n    response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);\n    response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &#39;*&#39;);\n    response.setHeader(&quot;Access-Control-Allow-Method&quot;, &#39;*&#39;);\n    // response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:5500&quot;);\n    response.send(&#39;hello CORS&#39;);\n&#125;);\n\n","slug":"前端--详解AJAX(快速入门)","date":"2023-01-15T01:38:59.000Z","categories_index":"前端","tags_index":"Ajax","author_index":"会思想的苇草i"},{"id":"26420f1034bff9b91a54684d743949a2","title":"提高开发效率：ES6技巧大全","content":"ECMAScript 6-111、ECMAScript 相关介绍1.1 ECMAScript简介\n\nECMA（European Computer Manufacturers Association）中文名称为欧洲计算机制造商协会，这个组织的目标是评估、开发和认可电信和计算机标准。1994 年后该组织改名为 ECMA 国际\nECMAScript 是由 Ecma 国际通过 ECMA-262 标准化的脚本程序设计语言\nEcma 国际制定了许多标准，而 ECMA-262 只是其中的一个，所有标准列表查看：http://www.ecma-international.org/publications/standards/Standard.html\nECMA-262（ECMAScript）历史版本查看网址： http://www.ecma-international.org/publications/standards/Ecma-262-arch.htm\n\n1.2 ES6的重要性\nES6 的版本变动内容最多，具有里程碑意义\n\nES6 加入许多新的语法特性，编程实现更简单、高效\n\nES6 是前端发展趋势，就业必备技能\n\n http://kangax.github.io/compat-table/es6/ 可查看兼容性\n\n\n\n2、ECMAScript 6新特性2.1 let关键字\nlet关键字用来声明变量，使用let声明的变量有几个特点:\n\n不允许重复声明\n\n块级作用域\n\n不存在变量提升\n\n不影响作用域链\n\n\n\n代码：\n\n\n//声明变量\nlet a;\nlet b, c, d;\nlet e = 100;\nlet f = 521, g = &#39;iloveyou&#39;, h = [];\n\n//1. 变量不能重复声明\n// let star = &#39;罗志祥&#39;;\n// let star = &#39;小猪&#39;;报错\n\n//2. 块儿级作用域  全局, 函数, eval\n// if else while for \n// &#123;\n//     let girl = &#39;周扬青&#39;;\n// &#125;\n// console.log(girl);//报错\n\n//3. 不存在变量提升\n// console.log(song);\n// let song = &#39;恋爱达人&#39;;//报错\n\n//4. 不影响作用域链\nlet school = &#39;河工大&#39;;\n     function fn() &#123;\n          console.log(school);\n     &#125;\n     fn();\n&#125;\n\n\n应用场景:以后声明变量直接使用let\n\n2.2 const关键字\nconst关键字用来声明常量，const声明有以下特点：\n\n声明必须赋初始值\n\n标识符一般为大写\n\n不允许重复声明\n\n值不允许修改\n\n块级作用域\n\n\n\n代码：\n\n\n//声明常量\nconst SCHOOL = &#39;河工大&#39;;\n\n//1. 一定要赋初始值\n// const A;//报错\n\n//2. 一般常量使用大写(潜规则)\n// const a = 100;\n\n//3. 常量的值不能修改\n// SCHOOL = &#39;HAUT&#39;;//报错\n\n//4. 块儿级作用域\n// &#123;\n// \t\tconst PLAYER = &#39;UZI&#39;;\n// &#125;\n// console.log(PLAYER);\n\n//5. 对于数组和对象的元素修改, 不算做对常量的修改, 不会报错\n//const TEAM = [&#39;UZI&#39;,&#39;MXLG&#39;,&#39;Ming&#39;,&#39;Letme&#39;];\n// TEAM.push(&#39;Meiko&#39;);\n\n\n注意:对象属性修改和数组元素变化不会出现const错误\n应用场景:声明对象类型使用const，非对象类型声明选择let\n\n2.3 变量的解构赋值\nES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构赋值\n代码：\n\n//1. 数组的结构\n// const F4 = [&#39;小沈阳&#39;, &#39;刘能&#39;, &#39;赵四&#39;, &#39;宋小宝&#39;];\n// let [xiao, liu, zhao, song] = F4;//解构赋值\n// console.log(xiao);\n// console.log(liu);\n// console.log(zhao);\n// console.log(song);\n\n//2. 对象的解构\nconst zhao = &#123;\n    name: &#39;赵本山&#39;,\n    age: &#39;不详&#39;,\n    xiaopin: function()&#123;\n             console.log(&quot;我可以演小品&quot;);\n         &#125;\n    &#125;;\n\nlet &#123;name, age, xiaopin&#125; = zhao;//解构赋值\nconsole.log(name);\nconsole.log(age);\nconsole.log(xiaopin);\nxiaopin();\n\nlet &#123; xiaopin &#125; = zhao;\nxiaopin();\n\n\n注意:频繁使用对象方法、数组元素，就可以使用解构赋值形式\n\n2.4 模板字符串\n模板字符串(template string）是增强版的字符串，用反引号（&#96;&#96;）标识，\n\n特点:\n\n字符串中可以出现换行符\n可以使用${xxx}形式输出变量\n\n\n代码：\n\n\n//1. 声明\nlet str = `我也是一个字符串哦!`;\nconsole.log(str, typeof str);\n\n//2. 内容中可以直接出现换行符\nlet str = `&lt;ul&gt;\n            &lt;li&gt;沈腾&lt;/li&gt;\n            &lt;li&gt;玛丽&lt;/li&gt;\n            &lt;li&gt;魏翔&lt;/li&gt;\n               &lt;li&gt;艾伦&lt;/li&gt;\n           &lt;/ul&gt;`;\n//3. 变量拼接\nlet lovest = &#39;魏翔&#39;;\nlet out = `$&#123;lovest&#125;是我心目中最搞笑的演员!!`;\nconsole.log(out);\n\n\n注意:当遇到字符串与变量拼接的情况使用模板字符串\n\n2.5 简化对象写法\nES6允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁\n代码：\n\nlet name = &#39;尚硅谷&#39;;\nlet change = function()&#123;\n    console.log(&#39;我们可以改变你!!&#39;);\n&#125;\n\nconst school = &#123;\n    name,\n    change,\n    improve()&#123;\n        console.log(&quot;我们可以提高你的技能&quot;);\n    &#125;\n&#125;\n\nconsole.log(school);\n\n\n注意:对象简写形式简化了代码，所以以后用简写就对了\n\n2.6 箭头函数\nES6允许使用「箭头」（&#x3D;&gt;)定义函数\n\n箭头函数的注意点:\n\n如果形参只有一个，则小括号可以省略\n函数体如果只有一条语句，则花括号可以省略，函数的返回值为该条语句的执行结果\n箭头函数this 指向声明时所在作用域下this 的值\n箭头函数不能作为构造函数实例化\n不能使用arguments\n\n\n代码：\n\n\n//普通函数\nlet fn = function()&#123;\n\n&#125;\n//箭头函数\nlet fn = (a,b) =&gt; &#123;\n     return a + b;\n&#125;\n\n//1. this 是静态的. this 始终指向函数声明时所在作用域下的 this 的值\nfunction getName() &#123;\n    console.log(this.name);\n&#125;\nlet getName2 = () =&gt; &#123;\n    console.log(this.name);\n&#125;\n\n//设置 window 对象的 name 属性\nwindow.name = &#39;河工大&#39;;\n    const school = &#123;\n        name: &quot;haut&quot;\n&#125;\n\n//直接调用\ngetName();//河工大\ngetName2();//河工大\n\n//call 方法调用\ngetName.call(school);//haut\ngetName2.call(school);//河工大\n\n//2. 不能作为构造实例化对象\n// let Person = (name, age) =&gt; &#123;\n// \t\tthis.name = name;\n// \t\tthis.age = age;\n// &#125;\n// let me = new Person(&#39;xiao&#39;,30);\n// console.log(me);\n\n//3. 不能使用 arguments 变量\n// let fn = () =&gt; &#123;\n// \t\tconsole.log(arguments);\n// &#125;\n// fn(1,2,3);\n\n//4. 箭头函数的简写\n//1) 省略小括号, 当形参有且只有一个的时候\nlet add = n =&gt; &#123;\n    return n + n;\n&#125;\nconsole.log(add(9));\n//2) 省略花括号, 当代码体只有一条语句的时候, 此时 return 必须省略\n// 而且语句的执行结果就是函数的返回值\nlet pow = n =&gt; n * n;\nconsole.log(pow(8));\n\n\n注意:箭头函数不会更改this指向，用来指定回调函数会非常合适\n\n2.7 rest参数\nES6引入rest参数，用于获取函数的实参，用来代替arguments\n代码：\n\n// ES5 获取实参的方式\nfunction date() &#123;\n    console.log(arguments);\n&#125;\ndate(&#39;白芷&#39;, &#39;阿娇&#39;, &#39;思慧&#39;);//Array(3)\n\n// rest 参数\nfunction date(...args) &#123;\n    console.log(args);// filter some every map\n&#125;\ndate(&#39;阿娇&#39;, &#39;柏芝&#39;, &#39;思慧&#39;);//Array(3)\n\n// rest 参数必须要放到参数最后\nfunction fn(a, b, ...args) &#123;\n    console.log(a);\n    console.log(b);\n    console.log(args);\n&#125;\nfn(1, 2, 3, 4, 5, 6);//1,2,Array(4)\n\n\n注意: rest参数非常适合不定个数参数函数的场景\n\n补充：参数默认值\n\n代码：\n\n//1. 形参初始值 具有默认值的参数, 一般位置要靠后(潜规则)\nfunction add(a, b, c = 10) &#123;\n    return a + b + c;\n&#125;\nlet result = add(1, 2);\nconsole.log(result);\n\n//2. 与解构赋值结合\nfunction connect(&#123; host = &quot;127.0.0.1&quot;, username, password, port &#125;) &#123;\n    console.log(host)\n    console.log(username)\n    console.log(password)\n    console.log(port)\n&#125;\nconnect(&#123;\n    host: &#39;ASHIYI.com&#39;,\n    username: &#39;root&#39;,\n    password: &#39;root&#39;,\n    port: 3306\n&#125;)\n\n2.8 spread扩展运算符\n扩展运算符(spread）也是三个点(…）。它好比 rest参数的逆运算，将一个数组转为用逗号分隔的参数序列，对数组进行解包\n代码：\n\nconst tfboys = [&#39;易烊千玺&#39;,&#39;王源&#39;,&#39;王俊凯&#39;];\n\nfunction chunwan()&#123;\n    console.log(arguments);\n&#125;\n\nchunwan(...tfboys);// chunwan(&#39;易烊千玺&#39;,&#39;王源&#39;,&#39;王俊凯&#39;)\n\n//扩展运算符的应用\n//1. 数组的合并\nconst kuaizi = [&#39;王太利&#39;, &#39;肖央&#39;];\nconst fenghuang = [&#39;曾毅&#39;, &#39;玲花&#39;];\n// const zuixuanxiaopingguo = kuaizi.concat(fenghuang);\nconst zuixuanxiaopingguo = [...kuaizi, ...fenghuang];\nconsole.log(zuixuanxiaopingguo);\n\n//2. 数组的克隆\nconst sanzhihua = [&#39;E&#39;, &#39;G&#39;, &#39;M&#39;];\nconst sanyecao = [...sanzhihua];// [&#39;E&#39;,&#39;G&#39;,&#39;M&#39;]\nconsole.log(sanyecao);\n\n//3. 将伪数组转为真正的数组\nconst divs = document.querySelectorAll(&#39;div&#39;);\nconst divArr = [...divs];\nconsole.log(divArr);// arguments\n\n2.9 SymbolSymbol基本使用\n\nES6引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是JavaScript语言的第七种数据类型，是一种类似于字符串的数据类型\n\nSymbol特点\n\nSymbol的值是唯一的，用来解决命名冲突的问题\nSymbol值不能与其他数据进行运算\nSymbol定义的对象属性不能使用for …in循环遍历，但是可以使用Reflect.ownKeys来获取对象的所有键名\n\n\n代码：\n\n\n//创建Symbol\nlet s = Symbol();\n// console.log(s, typeof s);\nlet s2 = Symbol(&#39;尚硅谷&#39;);\nlet s3 = Symbol(&#39;尚硅谷&#39;);\nconsole.log(s2 === s3)//false\n\n//Symbol.for 创建\nlet s4 = Symbol.for(&#39;尚硅谷&#39;);\nlet s5 = Symbol.for(&#39;尚硅谷&#39;);\nconsole.log(s4 === s5)//true\n//Symbol.for()不会每次调用就返回一个新的Symbol类型的值，而是先检查给定的参数字符串是否已存在，如果不存在才会新建一个并返回一个该字符串为名称的Symbol值\n\n\n注:遇到唯一性的场景时要想到symbol\n\nSymbol内置值\n\n除了定义自己使用的Symbol值以外,ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。可以称这些方法为魔术方法，因为它们会在特定的场景下自动执行\n\n\n\n\n名称\n功能\n\n\n\nSymbol.hasInstance\n当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法\n\n\nSymbol.isConcatSpreadable\n对象的Symbol.isConcatSpreadable属性等于的是一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开\n\n\nSymbol.species\n创建衍生对象时，会使用该属性\n\n\nSymbol.match\n当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值\n\n\nsymbol.replace\n当该对象被str.replace(myObject)方法调用时，会返回该方法的返回值\n\n\nsymbol.search\n当该对象被str.search (myObject)方法调用时，会返回该方法的返回值\n\n\nSymbol.split\n当该对象被str.split (myObject)方法调用时，会返回该方法的返回值\n\n\nSymbol.iterator\n对象进行for..of 循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器\n\n\nsymbol.toPrimitive\n该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值\n\n\nSymbol.toStringTag\n在该对象上面调用toString方法时，返回该方法的返回值\n\n\nsymbol. unscopables\n该对象指定了使用with关键字时,哪些属性会被with环境排除\n\n\n2.10 迭代器\n遍历器（lterator）就是一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署lterator接口,就可以完成遍历操作\n\nES6创造了一种新的遍历命令for…of循环，lterator接口主要供 for…of消费\n\n原生具备iterator接口的数据(可用for of 遍历)a)Array\nb)Arguments\nc)Set\nd)Map\ne)string\nf)TypedArray\ng)NodeList\n\n工作原理 a)创建一个指针对象，指向当前数据结构的起始位置\n b)第一次调用对象的next方法，指针自动指向数据结构的第一个成员\n c)接下来不断调用next方法，指针一直往后移动，直到指向最后一个成员\n d)每调用next方法返回一个包含value(值)和 done(判断循环是否完成)属性的对象\n\n\n\n代码：\n\n\n//声明一个数组\nconst xiyou = [&#39;唐僧&#39;, &#39;孙悟空&#39;, &#39;猪八戒&#39;, &#39;沙僧&#39;];\n\n//使用 for...of 遍历数组\nfor (let v of xiyou) &#123;\n    console.log(v);\n&#125;\n\n\n注:需要自定义遍历数据的时候，要想到迭代器\n\n2.11 生成器\n生成器函数是ES6提供的一种异步编程解决方案,语法行为与传统函数完全不同\n代码：\n\nfunction * gen()&#123;\n\n    yield &#39;一只没有耳朵&#39;;\n\n    yield &#39;一只没有尾部&#39;;\n    \n    yield &#39;真奇怪&#39;;\n&#125;\n\nlet iterator = gen();\nconsole.log(iterator.next());\nconsole.log(iterator.next());\nconsole.log(iterator.next());\nconsole.log(iterator.next());\n\n\n代码说明:\n*的位置没有限制\n生成器函数返回的结果是迭代器对象,调用迭代器对象的next方法可以得到yield 语句后的值\nyield相当于函数的暂停标记，也可以认为是函数的分隔符，每调用一次next方法，执行一段代码\nnext方法可以传递实参，作为yield语句的返回值\n\n\n\n2.12 Promise\nPromise是ES6引入的异步编程的新解决方案。语法上 Promise是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果\n\nPromise构造函数: Promise (excutor){}\nPromise.prototype.then方法；then方法的返回结果是 Promise 对象, 对象状态由回调函数的执行结果决定；如果回调函数中返回的结果是 非 promise 类型的属性, 状态为成功, 返回值为对象的成功的值；如果返回是 promise类型 对象，内部返回promise状态决定than方法返回promise状态；抛出错误，状态是失败，值为抛出的值\nPromise.prototype.catch方法；\n\n\n代码：\n\n\n//Promise基本语法\n//实例化 Promise 对象\nconst p = new Promise(function(resolve, reject)&#123;\n    setTimeout(function()&#123;\n\n        // let data = &#39;数据库中的用户数据&#39;;\n        // resolve\n        // resolve(data);\n\n        let err = &#39;数据读取失败&#39;;\n        reject(err);\n    &#125;, 1000);\n&#125;);\n\n//调用 promise 对象的 then 方法\np.then(function(value)&#123;//成功执行\n    console.log(value);\n&#125;, function(reason)&#123;//失败执行\n    console.error(reason);\n&#125;)\n\n2.13 set\nES6提供了新的数据结构Set(集合)。它类似于数组，但成员的值都是唯一的，集合实现了iterator接口，所以可以使用『扩展运算符』和『for…of…』扩展运算符进行遍历，集合的属性和方法:\n\nsize返回集合的元素个数\nadd增加一个新元素，返回当前集合\ndelete删除元素，返回boolean值\nhas检测集合中是否包含某个元素，返回boolean值\nclear清空集合，返回undefined\n\n\n代码:\n\n\n//声明一个 set\nlet s = new Set();\nlet s2 = new Set([&#39;大事儿&#39;, &#39;小事儿&#39;, &#39;好事儿&#39;, &#39;坏事儿&#39;, &#39;小事儿&#39;]);\n\nfor (let v of s2) &#123;\n    console.log(v);\n&#125;\n\n//元素个数\nconsole.log(s2.size);\n//添加新的元素\ns2.add(&#39;喜事儿&#39;);\n//删除元素\ns2.delete(&#39;坏事儿&#39;);\n//检测\nconsole.log(s2.has(&#39;糟心事&#39;));\n//清空\ns2.clear();\nconsole.log(s2);\n\nfor (let v of s2) &#123;\n    console.log(v);\n&#125;\n\n//集合应用\nlet arr = [1, 2, 3, 4, 5, 4, 3, 2, 1];\n//1. 数组去重\nlet result1 = [...new Set(arr)];\nconsole.log(result1);\n\n//2. 交集\nlet arr2 = [4, 5, 6, 5, 6];\nlet result2 = [...new Set(arr)].filter(item =&gt; new Set(arr2).has(item));\nconsole.log(result2);\n\n//3. 并集\nlet union = [...new Set([...arr, ...arr2])];\nconsole.log(union);\n\n//4. 差集\nlet diff = [...new Set(arr)].filter(item =&gt; !(new Set(arr2).has(item)));\nconsole.log(diff);\n\n2.14 map\nES6提供了Map数据结构。它类似于对象，也是键值对的集合。但是“键”的范围不限于字符串，各种类型的值(包括对象）都可以当作键。Map也实现了iterator接口，所以可以使用『扩展运算符』和『for ….of…』。进行遍历。Map的属性和方法:\nsize返回Map 的元素个数\nset 增加一个新元素，返回当前Map\nget返回键名对象的键值\nhas检测Map中是否包含某个元素，返回boolean值\nclear清空集合，返回undefined\n\n\n\n//声明 Map\nlet m = new Map();\n\n//添加元素\nm.set(&#39;name&#39;, &#39;河工大&#39;);\nm.set(&#39;change&#39;, function () &#123;\n    console.log(&quot;我们可以改变你!!&quot;);\n&#125;);\nlet key = &#123;\n    school: &#39;大学&#39;\n&#125;;\nm.set(key, [&#39;北京&#39;, &#39;上海&#39;, &#39;深圳&#39;]);\n\n2.15 class类\nES6提供了更接近传统语言的写法，引入了Class(类)这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已；知识点:\nclass声明类\nconstructor定义构造函数初始化\nextends继承父类\nsuper调用父级构造方法\nstatic定义静态方法和属性\n父类方法可以重写（子类不能调用父类的重名方法）\n\n\n\n//class\nclass Shouji &#123;\n//构造方法 名字不能修改\n    constructor(brand, price) &#123;\n        this.brand = brand;\n        this.price = price;\n    &#125;\n\n//方法必须使用该语法, 不能使用 ES5 的对象完整形式\n    call() &#123;\n        console.log(&quot;我可以打电话!!&quot;);\n    &#125;\n&#125;\n\nlet onePlus = new Shouji(&quot;1+&quot;, 1999);\n\nconsole.log(onePlus);\n\nclass Phone&#123;\n    //静态属性 属于类，不属于实例对象\n    static name = &#39;手机&#39;;\n    static change()&#123;\n        console.log(&quot;我可以改变世界&quot;);\n    &#125;\n&#125;\n\nlet nokia = new Phone();\nconsole.log(nokia.name);//undefined\nconsole.log(Phone.name);//手机\n\nclass Phone&#123;\n    //构造方法\n    constructor(brand, price)&#123;\n        this.brand = brand;\n        this.price = price;\n    &#125;\n    //父类的成员属性\n    call()&#123;\n        console.log(&quot;我可以打电话!!&quot;);\n    &#125;\n&#125;\n\nclass SmartPhone extends Phone &#123;\n    //构造方法\n    constructor(brand, price, color, size)&#123;\n        super(brand, price);// Phone.call(this, brand, price)\n        this.color = color;\n        this.size = size;\n    &#125;\n\n    photo()&#123;\n        console.log(&quot;拍照&quot;);\n    &#125;\n\n    playGame()&#123;\n        console.log(&quot;玩游戏&quot;);\n    &#125;\n\n    call()&#123;\n        console.log(&#39;我可以进行视频通话&#39;);\n    &#125;\n&#125;\n\n    const xiaomi = new SmartPhone(&#39;小米&#39;,799,&#39;黑色&#39;,&#39;4.7inch&#39;);\n    // console.log(xiaomi);\n    xiaomi.call();\n    xiaomi.photo();\n    xiaomi.playGame();\n\n// get 和 set\nclass Phone &#123;\n    get price() &#123;//无需参数，有返回值(没写默认undefined)\n        console.log(&quot;价格属性被读取了&quot;);\n        return &#39;iloveyou&#39;;\n    &#125;\n\n    set price(newVal) &#123;//需要参数(否则报错)，无返回值\n        console.log(&#39;价格属性被修改了&#39;);\n    &#125;\n&#125;\n\n//实例化对象\nlet s = new Phone();\n\n// console.log(s.price);\ns.price = &#39;free&#39;;\n\n2.16 数值扩展Number.EPSILON \n\nJavaScript 表示的最小精度\n\nEPSILON 属性的值接近于 2.2204460492503130808472633361816E-16（小于这个数认为相等）\n\n\nfunction equal(a, b) &#123;\n    if (Math.abs(a - b) &lt; Number.EPSILON) &#123;\n        return true;\n    &#125; else &#123;\n        return false;\n    &#125;\n&#125;\nconsole.log(0.1 + 0.2 === 0.3);//false\nconsole.log(equal(0.1 + 0.2, 0.3)//true\n\n二进制和八进制\n\nES6提供了二进制和八进制数值的新的写法，分别用前缀0b和0o表示。\n\nNumber.isFinite()与Number.isNaN()\n\nNumber.isFinite()用来检查一个数值是否为有限的\nNumber.isNaN()用来检查一个值是否为NaN\n\nNumber.parselnt()与Number.parseFloat()\n\nES6将全局方法parseInt和 parseFloat，移植到Number对象上面，使用不变。\n\nMath.trunc\n\n用于去除一个数的小数部分，返回整数部分\n\nNumber.islnteger\n\nNumber.islnteger()用来判断一个数值是否为整数\n值为正，返回1\n值为0，返回0\n值为负，返回-1\n\n\n\n2.17 对象扩展\nES6新增了一些object对象的方法\nobject.is比较两个值是否严格相等，与「&#x3D;&#x3D;&#x3D;』行为基本一致（ NaN)\nObject.assign对象的合并，将源对象的所有可枚举属性，复制到目标对象(覆盖)\nObject.setPrototypeOf可以直接给实例对象的构造函数设置对象的原型\n\n\n\n2.18 模块化模块化的好处\n\n模块化的优势有以下几点:\n\n\n防止命名冲突\n代码复用\n高维护性\n\n模块化规范产品\n\nES6之前的模块化规范有:\n\n\nCommonJS  &#x3D;&gt; NodeJS、Browserify\nAMD &#x3D;&gt; requireJS\nCMD &#x3D;&gt; seaJS\n\nES6模块化语法\n\n模块功能主要由两个命令构成: export和import\nexport命令用于规定模块的对外接口(分别暴露、统一暴露、默认暴露)\nimport命令用于输入其他模块提供的功能\n\n\n\n3、ECMAScript 7新特性3.1 Array.prototype.includes\nIncludes方法用来检测数组中是否包含某个元素，返回布尔类型值\n\n3.2 指数操作符\n在ES7中引入指数运算符「**」，用来实现幂运算，功能与Math.pow结果相同\n\n4、ECMAScript 8新特性4.1 async和awaitasync和 await 两种语法结合可以让异步代码像同步代码一样\nasync函数\n\nasync函数的返回值为promise对象\n\npromise对象的结果由async函数执行的返回值决定\n\n\n\n代码：\n\n//async 函数\nasync function fn()&#123;\n    // 返回一个字符串\n    // return &#39;尚硅谷&#39;;\n    \n    // 返回的结果不是一个 Promise 类型的对象, 返回的结果就是成功 Promise 对象\n    // return;//(resolved undefined)\n    \n    //抛出错误, 返回的结果是一个失败的 Promise\n    // throw new Error(&#39;出错啦!&#39;);//(rejected 对象)\n    \n    //返回的结果如果是一个 Promise 对象\n    return new Promise((resolve, reject)=&gt;&#123;\n        resolve(&#39;成功的数据&#39;);//(resolved 对象)\n        // reject(&quot;失败的错误&quot;);//(rejected 对象)\n    &#125;);\n&#125;\n\nawait表达式\n\nawait必须写在 async函数中\nawait右侧的表达式一般为promise对象\nawait返回的是promise成功的值\nawait 的promise失败了，就会抛出异常，需要通过try…catch 捕获处理\n\n\n代码：\n\n//创建 promise 对象\nconst p = new Promise((resolve, reject) =&gt; &#123;\n    // resolve(&quot;用户数据&quot;);\n    reject(&quot;失败啦!&quot;);\n&#125;)\n\n// await 要放在 async 函数中.\nasync function main() &#123;\n    try &#123;\n        let result = await p;\n        console.log(result);\n    &#125; catch (e) &#123;\n        console.log(e);\n    &#125;\n&#125;\n//调用函数\nmain();\n\n4.2 对象方法的扩展Object.values和Object.entries\n\nObject.values()方法返回一个给定对象的所有可枚举属性值的数组\n\nObject.entries()方法返回一个给定对象自身可遍历属性**[key,value]**的数(创建map)\n\n\nObject.getOwnPropertyDescriptors\n\n该方法返回指定对象所有自身属性的描述对象\n\n5、ECMAScript 9新特性5.1 Rest&#x2F;Spread属性\nRest参数(省略)与spread扩展运算符(对象合并)在ES6中已经引入，不过ES6中只针对于数组，在ES9中为对象提供了像数组一样的rest参数和扩展运算符\n\n5.2.正则表达式命名捕获组\nES9允许命名捕获组使用符号『?&lt; name&gt;』 ,这样获取捕获结果可读性更强\n代码：\n\nlet str = &#39;&lt;a href=&quot;http://www.atguigu.com&quot;&gt;尚硅谷&lt;/a&gt;&#39;;\n//分组命名\nconst reg = /&lt;a href=&quot;(?&lt;url&gt;.*)&quot;&gt;(?&lt;text&gt;.*)&lt;\\ /a&gt;/;\n\nconst result = reg.exec(str);\n\nconsole.log(result.groups.url);//http://www.atguigu.com\n\nconsole.log(result.groups.text);//尚硅谷\n\n5.3.正则表达式反向断言\nES9支持反向断言，通过对匹配结果前面的内容进行判断，对匹配进行筛选\n代码：\n\n//声明字符串\nlet str = &#39;JS5211314你知道么555啦啦啦&#39;;\n//正向断言\n// const reg = /\\d+(?=啦)/;\n// const result = reg.exec(str);\n\n//反向断言\nconst reg = /(?&lt;=么)\\d+ /; \nconst result=reg.exec(str); \nconsole.log(result);\n\n5.4.正则表达式dotAll模式\n正则表达式中点 . 匹配除回车外的任何单字符，标记『s』改变这种行为，允许行终止符出现\n代码：\n\n//dot . 元字符 除换行符以外的任意单个字符\nlet str = `\n&lt;ul&gt;\n    &lt;li&gt;\n        &lt;a&gt;肖生克的救赎&lt;/a&gt;\n        &lt;p&gt;上映日期: 1994-09-10&lt;/p&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n        &lt;a&gt;阿甘正传&lt;/a&gt;\n        &lt;p&gt;上映日期: 1994-07-06&lt;/p&gt;\n    &lt;/li&gt;\n&lt;/ul&gt;`;\n//声明正则\n// const reg = /&lt;li&gt;\\s+&lt;a&gt;(.*?)&lt;\\ /a&gt;\\s+&lt;p&gt;(.*?)&lt;\\ /p&gt;/;\nconst reg = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\\ /a&gt;.*?&lt;p&gt;(.*?)&lt;\\ /p&gt;/gs;\n//执行匹配\n// const result = reg.exec(str);\nlet result;\nlet data = [];\nwhile(result = reg.exec(str))&#123;\n    data.push(&#123;title: result[1], time: result[2]&#125;);\n&#125;\n//输出结果\nconsole.log(data);\n\n6、ECMAScript 10新特性6.1 Object.fromEntries\n代码：\n\n//二维数组\nconst result1 = Object.fromEntries([\n    [&#39;name&#39;, &#39;IT&#39;],\n    [&#39;xueke&#39;, &#39;Java,大数据,前端,云计算&#39;]\n]);\nconsole.log(result1);\n\n//Map\nconst m = new Map();\nm.set(&#39;name&#39;, &#39;ATGUIGU&#39;);\nconst result2 = Object.fromEntries(m);\nconsole.log(result2);\n\n//Object.entries ES8\nconst arr = Object.entries(&#123;\n    name: &quot;IT&quot;\n&#125;)\nconsole.log(arr);\n\n6.2 trimStart 和 trimEnd\n代码：\n\n// trim\nlet str = &#39; iloveyou &#39;;\n\nconsole.log(str);\nconsole.log(str.trimStart());//清除左侧空白\nconsole.log(str.trimEnd());//清除右侧空白\n\n6.3 Array.prototype.flat 与flatMap\n代码：\n\n//flat 平\n//将多维数组转化为低位数组\n// const arr = [1, 2, 3, 4, [5, 6]];\n// console.log(arr.flat());\n// const arr = [1, 2, 3, 4, [5, 6, [7, 8, 9]]];\n//参数为深度 是一个数字\n// console.log(arr.flat(2));//三维变一维，深度为2\n\n//flatMap\nconst arr = [1, 2, 3, 4];\nconst result = arr.flatMap(item =&gt; [item * 10]);//flat+map\nconsole.log(result);\n\n6.4 Symbol.prototype.description\n代码：\n\n//创建 Symbol\nlet s = Symbol(&#39;河工大&#39;);\n//获取属性\nconsole.log(s.description);\n\n7、ECMAScript 11新特性7.1 类的私有属性\n代码:\n\nclass Person &#123;\n    //公有属性\n    name;\n    //私有属性\n    #age;\n    #weight;\n    //构造方法\n    constructor(name, age, weight) &#123;\n        this.name = name;\n        this.#age = age;\n        this.#weight = weight;\n    &#125;\n\n    intro() &#123;\n        console.log(this.name);\n        console.log(this.#age);\n        console.log(this.#weight);\n    &#125;\n&#125;\n\n//实例化\nconst girl = new Person(&#39;晓红&#39;, 18, &#39;45kg&#39;);\n\n// console.log(girl.name);\n// console.log(girl.#age);//报错\n// console.log(girl.#weight);\n\ngirl.intro();\n\n7.2 Promise.allSettled\n代码：\n\n//声明两个promise对象\nconst p1 = new Promise((resolve, reject) =&gt; &#123;\n    setTimeout(() =&gt; &#123;\n        resolve(&#39;商品数据 - 1&#39;);\n    &#125;, 1000)\n&#125;);\n\nconst p2 = new Promise((resolve, reject) =&gt; &#123;\n    setTimeout(() =&gt; &#123;\n        resolve(&#39;商品数据 - 2&#39;);\n        // reject(&#39;出错啦!&#39;);\n    &#125;, 1000)\n&#125;);\n\n//调用 allsettled 方法\nconst result = Promise.allSettled([p1, p2]);//一个成功就成功\n\n// const res = Promise.all([p1, p2]);//都成功才成功，一个失败就失败\n\nconsole.log(res);\n\n7.3 String.prototype.matchAll\n代码：\n\nlet str = `&lt;ul&gt;\n    &lt;li&gt;\n        &lt;a&gt;肖生克的救赎&lt;/a&gt;\n        &lt;p&gt;上映日期: 1994-09-10&lt;/p&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n        &lt;a&gt;阿甘正传&lt;/a&gt;\n        &lt;p&gt;上映日期: 1994-07-06&lt;/p&gt;\n    &lt;/li&gt;\n&lt;/ul&gt;`;\n\n//声明正则\nconst reg = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\\ /a&gt;.*?&lt;p&gt;(.*?)&lt;\\ /p&gt;/sg\n\n//调用方法\nconst result = str.matchAll(reg);\n\n// for(let v of result)&#123;\n// \t\tconsole.log(v);\n// &#125;\n\nconst arr = [...result];\n\nconsole.log(arr);\n\n7.4 可选链操作符\n代码：\n\n// 可选链操作符 ?. 判断前面的值是否传入，已传入则读取后面的属性\nfunction main(config) &#123;\n    // const dbHost = config &amp;&amp; config.db &amp;&amp; config.db.host;\n    const dbHost = config?.db?.host;\n\n    console.log(dbHost);\n&#125;\n\nmain(&#123;\n    db: &#123;\n        host: &#39;192.168.1.100&#39;,\n        username: &#39;root&#39;\n    &#125;,\n    cache: &#123;\n        host: &#39;192.168.1.200&#39;,\n        username: &#39;admin&#39;\n    &#125;\n&#125;)\n\n7.5 动态import 导入\n代码：\n\n//test.html\n&lt;button id=&quot;btn&quot;&gt;点击&lt;/button&gt;\n&lt;script src=&quot;./js/app.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt;\n\n//app.js 获取元素\nconst btn = document.getElementById(&#39;btn&#39;);\n\nbtn.onclick = function()&#123;\n    import(&#39;./hello.js&#39;).then(module =&gt; &#123;\n        module.hello();\n    &#125;);\n&#125;\n\n//hello.js\nexport function hello()&#123;\n    alert(&#39;Hello&#39;);\n&#125;\n\n7.6 BigInt\n代码：\n\n//大整形\n// let n = 521n;\n// console.log(n, typeof(n));//521n &#39;bigint&#39;\n\n//函数\n// let n = 123;\n// console.log(BigInt(n));//123n\n// console.log(BigInt(1.2));//报错\n\n//大数值运算\nlet max = Number.MAX_SAFE_INTEGER;\nconsole.log(max);//9007199254740991\nconsole.log(max + 1);//9007199254740992\nconsole.log(max + 2);//9007199254740993\n\nconsole.log(BigInt(max))//9007199254740991n\nconsole.log(BigInt(max) + BigInt(1))//9007199254740992n\nconsole.log(BigInt(max) + BigInt(2))//9007199254740993n\n\n7.7 globalThis对象\n代码：\n\nconsole.log(globalThis);//输出当前全局对象\n\n","slug":"前端--一文轻松搞懂ES6-ES11(ES6详解)","date":"2023-01-12T00:36:22.000Z","categories_index":"前端","tags_index":"JavaScript","author_index":"会思想的苇草i"},{"id":"da652f0027f23ff5ab9b268e0c44336d","title":"前端进阶：探索JavaScript高级语法","content":"JavaScript高级1、基础总结深入1.1 数据类型的分类和判断\n基本(值)类型\n\nNumber —  任意数值— typeof\nString —  任意字符串— typeof\nBoolean —  true&#x2F;false —  typeof\nundefined — undefined —– typeof&#x2F;&#x3D;&#x3D;&#x3D;(代表没有赋值)\nnull —  null —  &#x3D;&#x3D;&#x3D;(代表赋值了, 只是值为null)\n\n\n对象(引用)类型\n\nObject —  任意对象— typeof&#x2F;instanceof\nArray — 特别的对象类型(下标&#x2F;内部数据有序) — instanceof\nFunction — 别的对象类型(可执行) — typeof\n\n\n判断：\n\ntypeof：\n\n可以区别: 数值, 字符串, 布尔值, undefined, function\n不能区别: null与对象, 一般对象与数组\ntypeof: 返回的是数据类型的字符串表达形式\n\n\ninstanceof\n\n专门用来判断对象数据的类型: Object, Array与Function\n\n\n&#x3D;&#x3D;&#x3D;\n\n可以判断: undefined和null\n\n\n\n\n代码：\n\n\n  &lt;script type=&quot;text/javascript&quot;&gt;\n    //1. 基本类型\n    var a\n    console.log(a, typeof a, a === undefined) // undefined &#39;undefined&#39; true\n    console.log(a === typeof a) // false  undefined ≠ &#39;undefined&#39;\n    //typeof返回字符串类型\n    a = 3\n    console.log(typeof a === &#39;number&#39;) // true\n    a = &#39;atguigu&#39;\n    console.log(typeof a === &#39;string&#39;) // true\n    a = true\n    console.log(typeof a === &#39;boolean&#39;) // true\n\n    a = null\n    console.log(a === null) // true\n    console.log(typeof a) // &#39;object&#39;\n\n    console.log(&#39;--------------------------------&#39;)\n\n    //2. 对象类型\n    var b1 = &#123;\n      b2: [2, &#39;abc&#39;, console.log],//number string function  \n      b3: function () &#123;\n        console.log(&#39;b3()&#39;)\n      &#125;\n    &#125;\n    console.log(b1 instanceof Object, typeof b1) // true &#39;object&#39;\n    console.log(b1.b2 instanceof Array, typeof b1.b2) // true &#39;object&#39;\n    console.log(b1.b3 instanceof Function, typeof b1.b3) // true &#39;function&#39;\n\n    console.log(typeof b1.b2[2]) // &#39;function&#39;\n    console.log(b1.b2[2](&#39;abc&#39;)) // 内&#39;abc&#39; 外undefined\n  &lt;/script&gt;\n\n1.2 数据,变量, 内存的理解\n数据\n\n在内存中可读的, 可传递的保存了特定信息的’东东’\n一切皆数据, 函数也是数据\n在内存中的所有操作的目标: 数据\n\n\n变量\n\n在程序运行过程中它的值是允许改变的量\n一个变量对应一块小内存, 它的值保存在此内存中\n\n\n内存\n\n内存条通电后产生的存储空间(临时的)\n一块内存包含2个方面的数据\n内部存储的数据\n地址值数据\n\n\n内存空间的分类\n栈空间: 全局变量和局部变量\n堆空间: 对象\n\n\n\n\n内存,数据, 变量三者之间的关系\n\n内存是容器, 用来存储不同数据\n变量是内存的标识, 通过变量我们可以操作(读&#x2F;写)内存中的数据\n\n\nvar a &#x3D; xxx, a内存中到底保存的是什么?\n\nxxx是一个基本数据，保存的就是这个数据\n\nxxx是一个对象，保存的是对象的地址值\n\nxxx是一个变量，保存的是xxx的内容\n\n\n1.3 对象的理解和使用\n对象\n多个数据(属性)的集合\n用来保存多个数据(属性)的容器\n\n\n属性\n属性名 : 字符串(标识)\n属性值 : 任意类型\n\n\n属性的分类:\n一般 : 属性值不是function  描述对象的状态\n方法 : 属性值为function的属性  描述对象的行为\n\n\n特别的对象\n数组: 属性名是0,1,2,3之类的索引\n函数: 可以执行的\n\n\n如何操作内部属性(方法)\n.属性名: 编码简单, 但有时不能用\n[ ‘属性名’]: 编码麻烦, 但通用(属性名不是合法的标识名、属性名不确定)\n\n\n\n  &lt;script type=&quot;text/javascript&quot;&gt;\n    // 创建对象\n    var p = &#123;&#125;\n\n    /*情形一: 属性名不是合法的标识名*/\n    /*需求: 添加一个属性: content-type: text/json */\n    //  p.content-type = &#39;text/json&#39; //不正确\n    p[&#39;content-type&#39;] = &#39;text/json&#39;\n\n    /*情形二: 属性名不确定*/\n    var prop = &#39;xxx&#39;//变量 不确定\n    var value = 123\n    // p.prop = value  //不正确\n    p[prop] = value\n    console.log(p[&#39;content-type&#39;], p[prop])\n  &lt;/script&gt;\n\n1.4 函数的理解和使用\n函数\n用来实现特定功能的, n条语句的封装体\n只有函数类型的数据是可以执行的, 其它的都不可以\n\n\n\n  &lt;script type=&quot;text/javascript&quot;&gt;\n    function f1() &#123; // 函数声明\n      console.log(&#39;f1()&#39;)\n    &#125;\n    var f2 = function () &#123; // 表达式\n      console.log(&#39;f2()&#39;)\n    &#125;\n    f1()\n    f2()\n  &lt;/script&gt;\n\n\n为什么要用函数?\n\n提高复用性\n便于阅读交流\n\n\n函数也是对象\n\ninstanceof Object&#x3D;&#x3D;&#x3D;true\n函数有属性: prototype\n函数有方法: call()&#x2F;apply()\n可以添加新的属性&#x2F;方法\n\n\n函数的3种不同角色\n\n一般函数 : 直接调用\n构造函数 : 通过new调用\n对象 : 通过.调用内部的属性&#x2F;方法\n\n\n\n函数中的this\n\n显式指定谁: obj.xxx()\n通过call&#x2F;apply指定谁调用: xxx.call(obj)\n不指定谁调用: xxx()  : window\n回调函数: 看背后是通过谁来调用的: window&#x2F;其它\n\n&lt;script type=&quot;text/javascript&quot;&gt;\n    function Person(color) &#123;\n      console.log(this)\n      this.color = color;\n      this.getColor = function () &#123;\n        console.log(this)\n        return this.color;\n      &#125;;\n      this.setColor = function (color) &#123;\n        console.log(this)\n        this.color = color;\n      &#125;;\n    &#125;\n    Person(&quot;red&quot;); //this是 windows\n    var p = new Person(&quot;yello&quot;); //this是 p\n    p.getColor(); //this是 p \n    var obj = &#123;&#125;;\n    p.setColor.call(obj, &quot;black&quot;); //this是 obj\n    var test = p.setColor;\n    test(); //this是 windows\n    function fun1() &#123;\n      function fun2() &#123;\n        console.log(this);\n      &#125;\n      fun2(); //this是 windows\n    &#125;\n    fun1();\n  &lt;/script&gt;\n\n匿名函数自调用\n  (function(w, obj)&#123;\n    //实现代码\n  &#125;)(window, obj)\n  \n  \n  (function (i) &#123;\n    var a = 4\n    function fn() &#123;\n      console.log(&#39;fn &#39;, i+a)//fn 7\n    &#125;\n    fn()\n  &#125;)(3)\n  \n\n\n专业术语为: IIFE (Immediately Invoked Function Expression) 立即调用函数表达式\n\n\t\n回调函数\n\n什么函数才是回调函数?\n你定义的\n你没有调用\n但它最终执行了(在一定条件下或某个时刻)\n\n\n常用的回调函数\ndom事件回调函数\n定时器回调函数\najax请求回调函数\n生命周期回调函数\n\n\n\n &lt;script type=&quot;text/javascript&quot;&gt;\n    //1. DOM事件函数\n    var btn = document.getElementById(&#39;btn&#39;)\n    btn.onclick = function () &#123;\n      alert(this.innerHTML)\n    &#125;\n    //2. 定时器函数\n    setInterval(function () &#123;\n      alert(&#39;到点啦!&#39;)\n    &#125;, 2000)\n  &lt;/script&gt;\n\n2、函数高级2.1 原型与原型链\n所有函数都有一个特别的属性:\nprototype : 显式原型属性\n\n\n\n  // 每个函数都有一个prototype属性, 它默认指向一个对象(即称为: 原型对象)\n  function fn() &#123;\n\n  &#125;\n  console.log(fn.prototype, typeof fn.prototype)//object &#39;object&#39;\n \n// 原型对象中有一个属性constructor, 它指向函数对象\n  console.log(fn.prototype.constructor===fn)//true\n \n  // 2. 给原型对象添加属性(一般都是方法)\n  function F() &#123;\n\n  &#125;\n  F.prototype.age = 12 //添加属性\n  F.prototype.setAge = function (age) &#123; // 添加方法\n    this.age = age\n  &#125;\n  // 创建函数的实例对象\n  var f = new F()\n  console.log(f.age)//12\n  f.setAge(23)\n  console.log(f.age)//23\n\n\n所有实例对象都有一个特别的属性:\n__proto__ : 隐式原型属性\n\n\n\n  //对象的隐式原型的值为其对应构造函数的显式原型的值 \n  function Fn() &#123;\n\n  &#125;\n  var fn = new Fn()\n  console.log(Fn.prototype, fn.__proto__)//object  object\n  console.log(Fn.prototype===fn.__proto__)//true\n\n\n显式原型与隐式原型的关系\n函数的prototype: 定义函数时被自动赋值, 值默认为{}, 即用为原型对象\n实例对象的__ proto__: 在创建实例对象时被自动添加, 并赋值为构造函数的prototype值\n原型对象即为当前实例对象的父对象\n\n\n\n\n\n原型链（隐式原型链）\n所有的实例对象都有__ proto__属性, 它指向的就是原型对象\n这样通过__ proto__属性就形成了一个链的结构—-&gt;原型链\n当查找对象内部的属性&#x2F;方法时, js引擎自动沿着这个原型链查找\n当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作\n\n\n\n\n\n函数的显示原型指向的对象默认是空object实例对象（但object除外）\n\nconsole.log(Object.prototype instanceof Object)//false\n\n\n所有函数都是Function的实例(包含Function)\n\nconsole.log(Function.__proto__===Function.prototype)//false\n\n\nObject的原型对象是原型链的尽头\n\ninstanceof\n\n表达式: A instanceof B\n如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false\n\n\n\n\n  function Foo() &#123;  &#125;\n  var f1 = new Foo();\n  console.log(f1 instanceof Foo);//true\n  console.log(f1 instanceof Object);//true\n\n\n  console.log(Object instanceof Function)//true\n  console.log(Object instanceof Object)//true\n  console.log(Function instanceof Object)//true\n  console.log(Function instanceof Function)//true\n  function Foo() &#123;&#125;\n  console.log(Object instanceof  Foo);//false\n\n\n典例\n\n var A = function() &#123;\n\n  &#125;\n  A.prototype.n = 1\n\n  var b = new A()\n\n  A.prototype = &#123;\n    n: 2,\n    m: 3\n  &#125;\n\n  var c = new A()\n  console.log(b.n, b.m, c.n, c.m)//1 undefined 2 3\n\n\n    var F = function () &#123; &#125;;\n    Object.prototype.a = function () &#123;\n      console.log(&#39;a()&#39;)\n    &#125;;\n    Function.prototype.b = function () &#123;\n      console.log(&#39;b()&#39;)\n    &#125;;\n    var f = new F();\n    f.a()//a()\n    f.b()//报错 原型链找不到\n    F.a()//a()\n    F.b()//b()\n\n2.2 执行上下文与执行上下文栈\n变量提升与函数提升\n变量提升: 在变量定义语句之前, 就可以访问到这个变量**(undefined)**\n函数提升: 通过function声明的函数，在函数定义语句之前, 就执行该函数\n先有变量提升, 再有函数提升\n\n\n\n    /*变量提升*/\n    console.log(a1) //可以访问, 但值是undefined\n    /*函数提升*/\n    a2() // 可以直接调用\n    var a1 = 3\n    function a2() &#123;\n      console.log(&#39;a2()&#39;)\n    &#125;\n\n\n理解\n执行上下文: 由js引擎自动创建的对象, 包含对应作用域中的所有变量属性\n执行上下文栈: 用来管理产生的多个执行上下文\n\n\n分类:\n全局: window\n函数: 对程序员来说是透明的\n\n\n生命周期\n全局 : 准备执行全局代码前产生, 当页面刷新&#x2F;关闭页面时死亡\n函数 : 调用函数时产生, 函数执行完时死亡\n\n\n包含哪些属性:\n全局 : \n用var定义的全局变量  &#x3D;&#x3D;&gt;undefined\n使用function声明的函数   &#x3D;&#x3D;&#x3D;&gt;function\nthis   &#x3D;&#x3D;&#x3D;&gt;window\n\n\n函数\n用var定义的局部变量  &#x3D;&#x3D;&gt;undefined\n使用function声明的函数   &#x3D;&#x3D;&#x3D;&gt;function\nthis   &#x3D;&#x3D;&#x3D;&gt; 调用函数的对象, 如果没有指定就是window \n形参变量   &#x3D;&#x3D;&#x3D;&gt;对应实参值\narguments &#x3D;&#x3D;&#x3D;&gt;实参列表的伪数组\n\n\n\n\n\nfunction fn (a1)&#123;\n    console.log(a1)//2\n    console.log(a2)//undefined\n    a3()//a3()\n    console.log(this)//window\n    console.log(atguments)//伪数组(2,3)\n    \n    var a2 = 3\n    function a3()&#123;\n        console.log(&#39;a3()&#39;)\n    &#125;\n&#125;\nfn(2,3)\n\n\n执行上下文创建和初始化的过程\n全局:\n在全局代码执行前最先创建一个全局执行上下文(window)\n收集一些全局变量, 并初始化\n将这些变量设置为window的属性\n\n\n函数:\n在调用函数时, 在执行函数体之前先创建一个函数执行上下文\n收集一些局部变量, 并初始化\n将这些变量设置为执行上下文的属性\n\n\n\n\n\n    //1. 进入全局执行上下文\n    var a = 10\n    var bar = function (x) &#123;\n      var b = 5\n      foo(x + b)              //3. 进入foo执行上下文\n    &#125;\n    var foo = function (y) &#123;\n      var c = 5\n      console.log(a + c + y)\n    &#125;\n    bar(10)                    //2. 进入bar函数执行上下文\n\n     /*\n    测试题1: 先预处理变量, 后预处理函数\n    */\n    function a() &#123; &#125;\n    var a;\n    console.log(typeof a)//function\n    /*\n    测试题2: 变量预处理, in操作符\n     */\n    if (!(b in window)) &#123;\n      var b = 1;\n    &#125;\n    console.log(b)//undefined\n    /*\n    测试题3: 预处理, 顺序执行\n     */\n    var c = 1\n    //var c\n    function c(c) &#123;\n      console.log(c)\n      var c = 3\n    &#125;\n    //c = 1\n    c(2)//报错\n\n2.3 作用域与作用域链\n理解:\n作用域: 一块代码区域, 在编码时就确定了, 不会再变化\n作用域链: 多个嵌套的作用域形成的由内向外的结构, 用于查找变量\n\n\n分类:\n全局作用域\n函数作用域\njs没有块作用域(在ES6之前)\n\n\n作用\n作用域: 隔离变量, 可以在不同作用域定义同名的变量不冲突\n作用域链**: 查找变量**\n\n\n区别作用域与执行上下文 \n作用域: 静态的, 编码时就确定了(不是在运行时), 一旦确定就不会变化了\n执行上下文: 动态的, 执行代码时动态创建, 当执行结束消失\n联系: 执行上下文环境是在对应的作用域中的\n\n\n\n    var a = 10,\n      b = 20\n    function fn(x) &#123;\n      var a = 100,\n        c = 300；\n      console.log(&#39;fn()&#39;, a, b, c, x)\n      function bar(x) &#123;\n        var a = 1000,\n          d = 400\n        console.log(&#39;bar()&#39;, a, b, c, d, x)\n      &#125;\n\n      bar(100)//bar() 1000 20 300 400 100\n      bar(200)//bar() 1000 20 300 400 200\n    &#125;\n    fn(10)//fn() 100 20 300 10\n\n  var x = 10;\n  function fn() &#123;\n    console.log(x);\n  &#125;\n  function show(f) &#123;\n    var x = 20;\n    f();\n  &#125;\n  show(fn);//fn和show是同级函数\n\n    var fn = function () &#123;\n      console.log(fn)//输出函数\n    &#125;\n    fn()\n\n    var obj = &#123;\n      fn2: function () &#123;\n        console.log(fn2)//报错\n        //console.log(this.fn2)\n      &#125;\n    &#125;\n    obj.fn2()\n\n2.4 闭包\n理解:\n\n当嵌套的内部函数引用了外部函数的变量时就产生了闭包\n通过chrome工具得知: 闭包本质是内部函数中的一个对象, 这个对象中包含引用的变量属性\n\n\n作用:\n\n延长局部变量的生命周期\n让函数外部能操作内部的局部变量\n\n\n常见的闭包\n// 1. 将函数作为另一个函数的返回值\nfunction fn1() &#123;\n  var a = 2;\n  function fn2() &#123;\n    a++;\n    console.log(a);\n  &#125;\n  return fn2;\n&#125;\nvar f = fn1();\nf();//3\nf();//4\n\n\n// 2. 将函数作为实参传递给另一个函数调用\nfunction showMsgDelay(msg, time) &#123;\n  setTimeout(function () &#123;\n    console.log(msg)\n  &#125;, time)\n&#125;\nshowMsgDelay(&#39;hello&#39;, 1000)\n\n\n闭包的生命周期\n\n产生: 在嵌套内部函数定义执行完时就产生了(不是在调用)\n死亡: 在嵌套的内部函数成为垃圾对象时\n\n\n闭包应用:\n\n模块化: 封装一些数据以及操作数据的函数, 向外暴露一些行为\n循环遍历加监听\nJS框架(jQuery)大量使用了闭包\n\n\n缺点:\n\n变量占用内存的时间可能会过长\n可能导致内存泄露\n解决:\n及时释放 : f &#x3D; null; &#x2F;&#x2F;让内部函数对象成为垃圾对象\n\n\n\n\n\n    //代码片段一\n    var name = &quot;The Window&quot;;\n    var object = &#123;\n      name: &quot;My Object&quot;,\n      getNameFunc: function () &#123;\n        return function () &#123;\n          return this.name;\n        &#125;;\n      &#125;\n    &#125;;\n    console.log(object.getNameFunc()());  //The Window 直接执行函数，this指向window 无闭包\n\n    //代码片段二\n    var name2 = &quot;The Window&quot;;\n    var object2 = &#123;\n      name2: &quot;My Object&quot;,\n      getNameFunc: function () &#123;\n        var that = this;\n        return function () &#123;\n          return that.name2;\n        &#125;;\n      &#125;\n    &#125;;\n    console.log(object2.getNameFunc()()); //My Object that保存的是函数 有闭包\n\n    function fun(n, o) &#123;\n      console.log(o)\n      return &#123;\n        fun: function (m) &#123;\n          return fun(m, n)\n        &#125;\n      &#125;\n    &#125;\n    var a = fun(0)\n    a.fun(1)\n    a.fun(2)\n    a.fun(3) //undefined,0,0,0 \n\n    var b = fun(0).fun(1).fun(2).fun(3) //undefined,0,1,2 闭包\n\n    var c = fun(0).fun(1)\n    c.fun(2)\n    c.fun(3) //undefined,0,1,1 前面闭包，后面是因为闭包延长局部变量的生命周期\n\n2.5 内存溢出与内存泄露\n内存溢出\n\n\n一种程序运行出现的错误\n当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误\n\n\n内存泄露\n\n\n占用的内存没有及时释放\n内存泄露积累多了就容易导致内存溢出\n常见的内存泄露:\n意外的全局变量\n没有及时清理的计时器或回调函数\n闭包\n\n\n\n3、对象高级3.1 对象的创建模式\nObject构造函数模式\n//适用场景: 起始时不确定对象内部数据\n//问题: 语句太多\nvar obj = &#123;&#125;;\nobj.name = &#39;Tom&#39;\nobj.setName = function(name)&#123;this.name=name&#125;\n\n\n对象字面量模式\n//适用场景: 起始时对象内部数据是确定的\n//问题: 如果创建多个对象, 有重复代码\nvar obj = &#123;\n  name : &#39;Tom&#39;,\n  setName : function(name)&#123;this.name = name&#125;\n&#125;\n\n\n工厂模式\n// 工厂函数: 返回一个需要的数据的函数\n//适用场景: 需要创建多个对象\n//问题: 对象没有一个具体的类型, 都是Object类型\n  function createPerson(name, age) &#123;\n    var p = &#123;\n      name: name,\n      age: age,\n      setName: function (name) &#123;\n        this.name = name\n      &#125;\n    &#125;\n    return p\n  &#125;\n\n\n构造函数模式\n//适用场景: 需要创建多个类型确定的对象\n//问题: 每个对象都有相同的数据, 浪费内存\nfunction Person(name, age) &#123;\n  this.name = name;\n  this.age = age;\n  this.setName = function(name)&#123;this.name=name;&#125;;\n&#125;\nnew Person(&#39;tom&#39;, 12);\n\n\n构造函数+原型的组合模式\n//适用场景: 需要创建多个类型确定的对象\nfunction Person(name, age) &#123;\n  this.name = name;\n  this.age = age;\n&#125;\nPerson.prototype.setName = function(name)&#123;this.name=name;&#125;;\nnew Person(&#39;tom&#39;, 12);\n\n\n\n3.2 继承模式\n原型链继承 : 得到方法,子类型的原型为父类型的一个实例对象(关键)function Parent()&#123;&#125;\nParent.prototype.test = function()&#123;&#125;;\n\nfunction Child()&#123;&#125;\nChild.prototype = new Parent(); // 子类型的原型指向父类型实例\n\nChild.prototype.constructor = Child\nvar child = new Child(); //有test()\n\n\n\n\n\n借用构造函数 : 得到属性，在子类型构造函数中通用super()调用父类型构造函数(关键)\nfunction Parent(xxx)&#123;this.xxx = xxx&#125;\nParent.prototype.test = function()&#123;&#125;;\nfunction Child(xxx,yyy)&#123;\n    Parent.call(this, xxx);//借用构造函数   this.Parent(xxx)\n&#125;\nvar child = new Child(&#39;a&#39;, &#39;b&#39;);  //child.xxx为&#39;a&#39;, 但child没有test()\n\n\n组合\nfunction Parent(xxx)&#123;this.xxx = xxx&#125;\nParent.prototype.test = function()&#123;&#125;;\nfunction Child(xxx,yyy)&#123;\n    Parent.call(this, xxx);//借用构造函数   this.Parent(xxx)\n&#125;\nChild.prototype = new Parent(); //得到test()\nvar child = new Child(); //child.xxx为&#39;a&#39;, 也有test()\n\n\nnew一个对象背后做了些什么?\n\n创建一个空对象\n给对象设置__ proto__ , 值为构造函数对象的prototype属性值   this.__ proto__ &#x3D; Fn.prototype\n执行构造函数体(给对象添加属性&#x2F;方法)\n\n\n\n4、线程机制与事程机制4.1 线程与进程\n进程:\n程序的一次执行, 它占有一片独有的内存空间\n可以通过windows任务管理器查看进程\n\n\n线程:\n是进程内的一个独立执行单元\n是程序执行的一个完整流程\n是CPU的基本调度单元\n\n\n关系\n一个进程至少有一个线程(主)\n程序是在某个进程中的某个线程执行的\n\n\n\n4.2 浏览器内核模块组成\n主线程\njs引擎模块 : 负责js程序的编译与运行\nhtml,css文档解析模块 : 负责页面文本的解析\nDOM&#x2F;CSS模块 : 负责dom&#x2F;css在内存中的相关处理 \n布局和渲染模块 : 负责页面的布局和效果的绘制(内存中的对象)\n\n\n分线程\n定时器模块 : 负责定时器的管理\nDOM事件模块 : 负责事件的管理\n网络请求模块 : 负责Ajax请求\n\n\n\n4.3 js线程\njs是单线程执行的(回调函数也是在主线程)\nJavaScript的单线程，与它的用途有关；作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题\nH5提出了实现多线程的方案: Web Workers；只能是主线程更新界面\n\n4.4 定时器问题\n定时器并不真正完全定时\n如果在主线程执行了一个长时间的操作, 可能导致延时才处理\n\n4. 5 事件处理机制\n代码分类\n初始化执行代码: 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码\n回调执行代码: 处理回调逻辑\n\n\njs引擎执行代码的基本流程: \n初始化代码&#x3D;&#x3D;&#x3D;&gt;回调代码\n\n\n模型的2个重要组成部分:\n事件管理模块\n回调队列\n\n\n模型的运转流程\n执行初始化代码, 将事件回调函数交给对应模块管理\n当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中\n只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行\n\n\n\n\n4.6 H5 Web Workers\n\n可以让js在分线程执行\n\nWorker\nvar worker = new Worker(&#39;worker.js&#39;);\nworker.onMessage = function(event)&#123;event.data&#125;;// 用来接收另一个线程发送过来的数据的回调\nworker.postMessage(data1);//向另一个线程发送数据\n\n\n问题:\n\nworker内代码不能操作DOM更新UI\n不是每个浏览器都支持这个新特性\n不能跨域加载JS\n\n\n\n","slug":"前端--JavaScript高级","date":"2023-01-07T05:22:11.000Z","categories_index":"前端","tags_index":"JavaScript","author_index":"会思想的苇草i"},{"id":"e5530224ca8e131eb4d30d06bd108a65","title":"JavaScript高级开发必备：Bom和Dom全解析","content":"JavaScript Bom和Dom1、Web API 基本认知\n\nAPl (Application Programming Interface,应用程序编程接口)是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。简单理解:API是给程序员提供的一种工具，以便能更轻松的实现想要完成的功能\nWeb API是浏览器提供的一套操作浏览器功能和页面元素的API( BOM和DOM )\nMDN 详细 API : https://developer.mozilla.org/zh-CN/docs/Web/API\n\n2、DOM – 基础2.1 DOM简介\n文档对象模型（Document Object Model，简称DOM)，是W3C组织推荐的处理可扩展标记语言(HTML或者XML)的标准编程接口\nW3C已经定义了一系列的DOM接口，通过这些DOM接口可以改变网页的内容、结构和样式\nDOM树：\n\n\n\n文档:一个页面就是一个文档，DOM中使用document表示\n\n元素:页面中的所有标签都是元素，DOM中使用element表示\n\n节点:网页中的所有内容都是节点(标签、属性、文本、注释等)，DOM中使用node表示\n\nDOM把以上内容都看做是对象\n\n\n2.2 获取元素根据ID获取\n\n使用**getElementByld()**方法可以获取带有ID的元素对象\n\n代码：\n\n\n    &lt;div id=&quot;time&quot;&gt;2019-9-9&lt;/div&gt;\n    &lt;script&gt;\n        // 1. 因为我们文档页面从上往下加载，所以先得有标签 所以我们script写到标签的下面\n        // 2. get 获得 element 元素 by 通过 驼峰命名法 \n        // 3. 参数 id是大小写敏感的字符串\n        // 4. 返回的是一个元素对象\n        var timer = document.getElementById(&#39;time&#39;);\n        console.log(timer);\n        console.log(typeof timer);\n        // 5. console.dir 打印我们返回的元素对象 更好的查看里面的属性和方法\n        console.dir(timer);\n    &lt;/script&gt;\n\n根据标签名获取\n\n使用**getElementsByTagName()**方法可以返回带有指定标签名的对象的集合\n\n代码：\n\n\n    &lt;ul&gt;\n        &lt;li&gt;知否知否，应是等你好久11&lt;/li&gt;\n        &lt;li&gt;知否知否，应是等你好久22&lt;/li&gt;\n        &lt;li&gt;知否知否，应是等你好久33&lt;/li&gt;\n        &lt;li&gt;知否知否，应是等你好久44&lt;/li&gt;\n\n    &lt;/ul&gt;\n    &lt;ol id=&quot;ol&quot;&gt;\n        &lt;li&gt;生僻字&lt;/li&gt;\n        &lt;li&gt;生僻字&lt;/li&gt;\n        &lt;li&gt;生僻字&lt;/li&gt;\n        &lt;li&gt;生僻字&lt;/li&gt;\n\n    &lt;/ol&gt;\n\n    &lt;script&gt;\n        // 1.返回的是 获取过来元素对象的集合 以伪数组的形式存储的\n        var lis = document.getElementsByTagName(&#39;li&#39;);\n        console.log(lis);\n        console.log(lis[0]);\n        // 2. 我们想要依次打印里面的元素对象我们可以采取遍历的方式\n        for (var i = 0; i &lt; lis.length; i++) &#123;\n            console.log(lis[i]);\n\n        &#125;\n        // 3. 如果页面中只有一个li 返回的还是伪数组的形式 \n        // 4. 如果页面中没有这个元素 返回的是空的伪数组的形式\n        // 5. element.getElementsByTagName(&#39;标签名&#39;); 父元素必须是指定的单个元素\n        // var ol = document.getElementsByTagName(&#39;ol&#39;); // [ol]\n        // console.log(ol[0].getElementsByTagName(&#39;li&#39;));\n        var ol = document.getElementById(&#39;ol&#39;);\n        console.log(ol.getElementsByTagName(&#39;li&#39;));\n    &lt;/script&gt;\n\n\n注意：\n因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历\n得到元素对象是动态的\n如果获取不到元素,则返回为空的伪数组(因为获取不到对象)\n父元素必须是单个对象(必须指明是哪一个元素对象).获取的时候不包括父元素自己\n\n\n\n通过HTML5新增的方法获取\n\n代码：\n\n    &lt;div class=&quot;box&quot;&gt;盒子1&lt;/div&gt;\n    &lt;div class=&quot;box&quot;&gt;盒子2&lt;/div&gt;\n    &lt;div id=&quot;nav&quot;&gt;\n        &lt;ul&gt;\n            &lt;li&gt;首页&lt;/li&gt;\n            &lt;li&gt;产品&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/div&gt;\n    &lt;script&gt;\n        // 1. getElementsByClassName 根据类名获得某些元素集合\n        var boxs = document.getElementsByClassName(&#39;box&#39;);\n        console.log(boxs);\n        // 2. querySelector 返回指定选择器的第一个元素对象  切记 里面的选择器需要加符号 .box  #nav\n        var firstBox = document.querySelector(&#39;.box&#39;);\n        console.log(firstBox);\n        var nav = document.querySelector(&#39;#nav&#39;);\n        console.log(nav);\n        var li = document.querySelector(&#39;li&#39;);\n        console.log(li);\n        // 3. querySelectorAll()返回指定选择器的所有元素对象集合\n        var allBox = document.querySelectorAll(&#39;.box&#39;);\n        console.log(allBox);\n        var lis = document.querySelectorAll(&#39;li&#39;);\n        console.log(lis);\n    &lt;/script&gt;\n\n\n注意：querySelector和 queryselectorAll里面的选择器需要加符号,比如:document.querySelector ( ‘#nav’)\n\n特殊元素获取\n\n代码：\n\n&lt;body&gt;\n    &lt;script&gt;\n        // 1.获取body 元素\n        var bodyEle = document.body;\n        console.log(bodyEle);\n        console.dir(bodyEle);\n        // 2.获取html 元素\n        // var htmlEle = document.html;\n        var htmlEle = document.documentElement;\n        console.log(htmlEle);\n    &lt;/script&gt;\n&lt;/body&gt;\n\n2.3 事件基础\nJavaScript使我们有能力创建动态页面，而事件是可以被JavaScript侦测到的行为。简单理解:触发—响应机制\n事件三要素：\n事件源\n事件类型\n事件处理程序\n\n\n代码：\n\n    &lt;button id=&quot;btn&quot;&gt;唐伯虎&lt;/button&gt;\n    &lt;script&gt;\n        // 点击一个按钮，弹出对话框\n        //(1) 事件源 事件被触发的对象   谁  按钮\n        var btn = document.getElementById(&#39;btn&#39;);\n        //(2) 事件类型  如何触发 什么事件 比如鼠标点击(onclick) 还是鼠标经过 还是键盘按下\n        //(3) 事件处理程序  通过一个函数赋值的方式 完成\n        btn.onclick = function () &#123;\n            alert(&#39;点秋香&#39;);\n        &#125;\n    &lt;/script&gt;\n\n\n执行事件步骤：\n获取事件源\n注册事件(绑定事件)\n添加事件处理程序(采用函数赋值形式)\n\n\n\n2.4 操作元素\nJavascript 的 DOM操作可以改变网页内容、结构和样式，我们可以利用DOM操作元索来改变元素里面的内容、属性等。注意以下都是属性\n\n改变元素内容\n\nelement.innerText:从起始位置到终止位置的内容,但它去除 html标签，同时空格和换行也会去掉\nelement.innerHTML:起始位置到终止位置的全部内容，包括html 标签，同时保留空格和换行\n代码：\n\n    &lt;button&gt;显示当前系统时间&lt;/button&gt;\n    &lt;div&gt;某个时间&lt;/div&gt;\n    &lt;p&gt;1123&lt;/p&gt;\n    &lt;script&gt;\n        // 当我们点击了按钮，  div里面的文字会发生变化\n        // 1. 获取元素 \n        var btn = document.querySelector(&#39;button&#39;);\n        var div = document.querySelector(&#39;div&#39;);\n        // 2.注册事件\n        btn.onclick = function() &#123;\n            // div.innerText = &#39;2019-6-6&#39;;\n            div.innerHTML = getDate();\n        &#125;\n\n        function getDate() &#123;\n            var date = new Date();\n            // 我们写一个 2019年 5月 1日 星期三\n            var year = date.getFullYear();\n            var month = date.getMonth() + 1;\n            var dates = date.getDate();\n            var arr = [&#39;星期日&#39;, &#39;星期一&#39;, &#39;星期二&#39;, &#39;星期三&#39;, &#39;星期四&#39;, &#39;星期五&#39;, &#39;星期六&#39;];\n            var day = date.getDay();\n            return &#39;今天是：&#39; + year + &#39;年&#39; + month + &#39;月&#39; + dates + &#39;日 &#39; + arr[day];\n        &#125;\n        // 3.我们元素可以不用添加事件\n        var p = document.querySelector(&#39;p&#39;);\n        p.innerHTML = getDate();\n    &lt;/script&gt;\n\n常见元素的属性操作\n\ninnerText、innerHTML。改变元素内容\nsrc、href\nid、alt、title\n\n\n代码：\n\n    &lt;button id=&quot;ldh&quot;&gt;刘德华&lt;/button&gt;\n    &lt;button id=&quot;zxy&quot;&gt;张学友&lt;/button&gt; &lt;br&gt;\n    &lt;img src=&quot;images/ldh.jpg&quot; alt=&quot;&quot; title=&quot;刘德华&quot;&gt;\n\n    &lt;script&gt;\n        // 修改元素属性  src\n        // 1. 获取元素\n        var ldh = document.getElementById(&#39;ldh&#39;);\n        var zxy = document.getElementById(&#39;zxy&#39;);\n        var img = document.querySelector(&#39;img&#39;);\n        // 2. 注册事件  处理程序\n        zxy.onclick = function () &#123;\n            img.src = &#39;images/zxy.jpg&#39;;\n            img.title = &#39;张学友&#39;;\n        &#125;\n        ldh.onclick = function () &#123;\n            img.src = &#39;images/ldh.jpg&#39;;\n            img.title = &#39;刘德华&#39;;\n        &#125;\n    &lt;/script&gt;\n\n表单元素的属性操作\n\n利用DOM可以操作如下表单元素的属性:type、value、checked、selected、disabled\n\n代码：\n\n\n    &lt;button&gt;按钮&lt;/button&gt;\n    &lt;input type=&quot;text&quot; value=&quot;输入内容&quot;&gt;\n    &lt;script&gt;\n        // 1. 获取元素\n        var btn = document.querySelector(&#39;button&#39;);\n        var input = document.querySelector(&#39;input&#39;);\n        // 2. 注册事件 处理程序\n        btn.onclick = function() &#123;\n            // input.innerHTML = &#39;点击了&#39;;  这个是 普通盒子 比如 div 标签里面的内容\n            // 表单里面的值 文字内容是通过 value 来修改的\n            input.value = &#39;被点击了&#39;;\n            // 如果想要某个表单被禁用 不能再点击 disabled  我们想要这个按钮 button禁用\n            // btn.disabled = true;\n            this.disabled = true;\n            // this 指向的是事件函数的调用者 btn\n        &#125;\n    &lt;/script&gt;\n\n\n仿京东显示密码代码：\n\n    &lt;div class=&quot;box&quot;&gt;\n        &lt;label for=&quot;&quot;&gt;\n            &lt;img src=&quot;images/close.png&quot; alt=&quot;&quot; id=&quot;eye&quot;&gt;\n        &lt;/label&gt;\n        &lt;input type=&quot;password&quot; name=&quot;&quot; id=&quot;pwd&quot;&gt;\n    &lt;/div&gt;\n    &lt;script&gt;\n        var eye = document.getElementById(&#39;eye&#39;);\n        var pwd = document.getElementById(&#39;pwd&#39;);\n\n        var flag = 0;\n        eye.onclick = function () &#123;\n            if (flag == 0) &#123;\n                pwd.type = &#39;text&#39;;\n                eye.scr = &#39;imagrs/open.png&#39;;\n                flag = 1;\n            &#125; else &#123;\n                pwd.type = &#39;password&#39;;\n                eye.scr = &#39;imagrs/close.png&#39;;\n                flag = 0;\n            &#125;\n        &#125;\n    &lt;/script&gt;\n\n样式属性操作\n\n我们可以通过JS修改元素的大小、颜色、位置等样式。\n\nelement.style \t行内样式操作\nelement.className     类名样式操作\n\n\n注意:\n\nJS里面的样式采取驼峰命名法比如fontsize、backgroundcolor\nJS修改style样式操作，产生的是行内样式，css权重比较高\n如果样式修改较多，可以采取操作类名方式更改元紊样式\nclass因为是个保留字，因此使用className来操作元素类名属性\nclassName会直接更改元素的类名，会覆盖原先的类名\n\n\n代码：\n\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;style&gt;\n        div &#123;\n            width: 200px;\n            height: 200px;\n            background-color: pink;\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div&gt;&lt;/div&gt;\n    &lt;script&gt;\n        // 1. 获取元素\n        var div = document.querySelector(&#39;div&#39;);\n        // 2. 注册事件 处理程序\n        div.onclick = function () &#123;\n            // div.style里面的属性 采取驼峰命名法 \n            this.style.backgroundColor = &#39;purple&#39;;\n            this.style.width = &#39;250px&#39;;\n        &#125;\n    &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;style&gt;\n        div &#123;\n            width: 100px;\n            height: 100px;\n            background-color: pink;\n        &#125;\n\n        .change &#123;\n            background-color: purple;\n            color: #fff;\n            font-size: 25px;\n            margin-top: 100px;\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n\n\n&lt;body&gt;\n    &lt;div class=&quot;first&quot;&gt;文本&lt;/div&gt;\n    &lt;script&gt;\n        // 1. 使用 element.style 获得修改元素样式  如果样式比较少 或者 功能简单的情况下使用\n        var test = document.querySelector(&#39;div&#39;);\n        test.onclick = function () &#123;\n            // 2. 我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况\n            // 3. 如果想要保留原先的类名，我们可以这么做 多类名选择器\n            this.className = &#39;change&#39;;\n            this.className = &#39;first change&#39;;\n        &#125;\n    &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n\n\n排他思想\n\n如果有同—组元素，我们想要某一个元素实现某种样式，需要用到循环的排他思想算法:\n\n所有元素全部清除样式（干掉其他人)\n给当前元素设置样式(留下我自己)\n注意顺序不能颠倒，首先干掉其他人，再设置自己\n\n\n代码：\n\n\n    &lt;button&gt;按钮1&lt;/button&gt;\n    &lt;button&gt;按钮2&lt;/button&gt;\n    &lt;button&gt;按钮3&lt;/button&gt;\n    &lt;button&gt;按钮4&lt;/button&gt;\n    &lt;button&gt;按钮5&lt;/button&gt;\n    &lt;script&gt;\n        // 1. 获取所有按钮元素\n        var btns = document.getElementsByTagName(&#39;button&#39;);\n        // btns得到的是伪数组  里面的每一个元素 btns[i]\n        for (var i = 0; i &lt; btns.length; i++) &#123;\n            btns[i].onclick = function() &#123;\n                // (1) 我们先把所有的按钮背景颜色去掉  干掉所有人\n                for (var i = 0; i &lt; btns.length; i++) &#123;\n                    btns[i].style.backgroundColor = &#39;&#39;;\n                &#125;\n                // (2) 然后才让当前的元素背景颜色为pink 留下我自己\n                this.style.backgroundColor = &#39;pink&#39;;\n\n            &#125;\n        &#125;\n        //2. 首先先排除其他人，然后才设置自己的样式 这种排除其他人的思想我们成为排他思想\n    &lt;/script&gt;\n\n自定义属性的操作\n\n获取属性值\nelement.属性\t\t获取属性值。\nelement.getAttribute(‘属性’);\n\n\n\n\n区别:\nelement.属性\t获取内置属性值(元素本身自带的属性)\nelement.getAttribute ( ‘属性’);\t主要获得自定义的属性(标准)我们程序员自定义的属性\n\n\n\n\n设置属性值\n\nelement.属性&#x3D;‘值’\t\t设置内置属性值\n\nelement.setAttribute(‘属性’，’值”);\n\n\n\n\n\n区别:\nelement.属性\t设置内置属性值\nelement.setAttribute ( ‘属性’); 主要设置自定义的属性(标准)\n\n\n\n\n移除属性\nelement.removeAttribute(‘属性’)\n\n\n\n\n代码：\n\n    &lt;div id=&quot;demo&quot; index=&quot;1&quot; class=&quot;nav&quot;&gt;&lt;/div&gt;\n    &lt;script&gt;\n        var div = document.querySelector(&#39;div&#39;);\n        // 1. 获取元素的属性值\n        // (1) element.属性\n        console.log(div.id);\n        //(2) element.getAttribute(&#39;属性&#39;)  get得到获取 attribute 属性的意思 我们程序员自己添加的属性我们称为自定义属性 index\n        console.log(div.getAttribute(&#39;id&#39;));\n        console.log(div.getAttribute(&#39;index&#39;));\n        \n        // 2. 设置元素属性值\n        // (1) element.属性= &#39;值&#39;\n        div.id = &#39;test&#39;;\n        div.className = &#39;navs&#39;;\n        // (2) element.setAttribute(&#39;属性&#39;, &#39;值&#39;);  主要针对于自定义属性\n        div.setAttribute(&#39;index&#39;, 2);\n        div.setAttribute(&#39;class&#39;, &#39;footer&#39;); // class 特殊  这里面写的就是class 不是className\n        \n        // 3 移除属性 removeAttribute(属性)    \n        div.removeAttribute(&#39;index&#39;);\n    &lt;/script&gt;\n\nH5自定义属性\n\n自定义属性目的:是为了保存并使用数据； 有些数据可以保存到页面中而不用保存到数据库中\n\n自定义属性获取是通过getAttribute( 属性)获取。\n\n1.设置H5自定义属性\n\nH5规定自定义属性 **data- **开头做为属性名并且赋值。比如&lt;div data-index&#x3D; “1”&gt; &lt; &#x2F;div&gt;；或者使用JS设置element.setAttribute( ‘data-index’ ,2)\n\n\n2.获取H5自定义属性\n\n兼容性获取\telement.getAttribute( ‘data-index’ );\nH5新增element.dataset.index或者element.dataset[‘index’ ] ie 11才开始支持\n\n\n代码：\n\n\n    &lt;div getTime=&quot;20&quot; data-index=&quot;2&quot; data-list-name=&quot;andy&quot;&gt;&lt;/div&gt;\n    &lt;script&gt;\n        var div = document.querySelector(&#39;div&#39;);\n        // console.log(div.getTime);\n        console.log(div.getAttribute(&#39;getTime&#39;));\n        div.setAttribute(&#39;data-time&#39;, 20);\n        console.log(div.getAttribute(&#39;data-index&#39;));\n        console.log(div.getAttribute(&#39;data-list-name&#39;));\n        // h5新增的获取自定义属性的方法 它只能获取data-开头的\n        // dataset 是一个集合里面存放了所有以data开头的自定义属性\n        console.log(div.dataset);\n        console.log(div.dataset.index);\n        console.log(div.dataset[&#39;index&#39;]);\n        // 如果自定义属性里面有多个-链接的单词，我们获取的时候采取 驼峰命名法\n        console.log(div.dataset.listName);\n        console.log(div.dataset[&#39;listName&#39;]);\n    &lt;/script&gt;\n\n2.5 节点操作\n获取元素通常使用两种方式\n利用DOM提供的方法获取元素 – 逻辑性不强，繁琐\n利用节点层级关系获取元素 – 利用父子兄节点关系获取元素，逻辑性强，兼容性稍差\n\n\n\n节点概述\n\n网页中的所有内容都是节点(标签、属性、文本、注释等)，在DOM中，节点使用node 来表示\nHTML DOM树中的所有节点均可通过JavaScript进行访问，所有HTML元素(节点)均可被修改，也可以创建或删除\n一般地，节点至少拥有nodeType (节点类型)、nodeName(节点名称）和**nodeValue(节点值)**这三个基本属性\n元素节点    nodeType 为1\n属性节点    nodeType 为2\n文本节点    nodeType 为3 (文本节点包含文字、空格、换行等)\n我们在实际开发中，节点操作主要操作的是元素节点\n\n节点层次\n\n利用DOM树可以把节点划分为不同的层级关系，常见的是父子兄层级关系\n\n\n\n1.父级节点 – node.parentNode\n\nparentNode属性可返回某节点的父节点，注意是最近的一个父节点\n如果指定的节点没有父节点则返回null\n\n\n代码：\n\n\n    &lt;div class=&quot;demo&quot;&gt;\n        &lt;div class=&quot;box&quot;&gt;\n            &lt;span class=&quot;erweima&quot;&gt;×&lt;/span&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n        // 1. 父节点 parentNode\n        var erweima = document.querySelector(&#39;.erweima&#39;);\n        // var box = document.querySelector(&#39;.box&#39;);\n        // 得到的是离元素最近的父级节点(亲爸爸) 如果找不到父节点就返回为 null\n        console.log(erweima.parentNode);\n    &lt;/script&gt;\n\n\n2.1子节点 – parentNode.childNodes(标准)\n\nparentNode.childNodes返回包含指定节点的子节点的集合，该集合为即时更新的集合\n注意:返回值里面包含了所有的子节点，包括元素节点，文本节点等\n如果只想要获得里面的元素节点，则需要专门处理。所以我们一般不提倡使用childNodes\n\n\n2.2子节点 – parentNode.children (非标准)\n\nparentNode.children是一个只读属性，返回所有的子元素节点。它只返回子元素节点，其余节点不返回(这个是我们重点掌握的)\n虽然children是一个非标准，但是得到了各个浏览器的支持，因此我们可以放心使用\n\n\n2.3子节点 – parentNode.firstchild\n\nfirstChild返回第一个子节点，找不到则返回null。同样，也是包含所有的节点\n\n\n2.4子节点 – parentNode. lastChild\n\nlastChild返回最后一个子节点，找不到则返回null。同样，也是包含所有的节点\n\n\n2.5子节点 – parentNode.firstElementChild\n\nfirstElementchild返回第一个子元素节点，找不到则返回null\n注意:这个方法有兼容性问题，IE9以上才支持\n\n\n2.6子节点 – parentNode . lastElementchild\n\nlastElementchild返回最后一个子元素节点，找不到则返回null\n注意:这个方法有兼容性问题，IE9以上才支持\n\n\n实际开发中，firstChild和lastChild包含其他节点，操作不方便，而firstElementChild和lastElementChild又有兼容性问题1．如果想要第一个子元素节点，可以使用parentNode.chilren[0]2．如果想要最后一个子元素节点，可以使用parentNode.chilren[parentNode.chilren.length - 1]\n\n3.1兄弟节点 – node.nextSibling\n\nnextSibling返回当前元素的下一个兄弟元素节点，找不到则返回null。同样，也是包含所有的节点\n\n\n3.2兄弟节点 – node.previousSibling\n\npreviousSibling 返回当前元素上一个兄弟元素节点，找不到则返回null。同样，也是包含所有的节点\n\n\n3.3兄弟节点 – node.nextElementSibling\n\nnextElementsibling返回当前元素下一个兄弟元素节点，找不到则返回null\n注意:这个方法有兼容性问题，IE9以上才支持\n\n\n3.4兄弟节点 – node.previousElementsibling\n\npreviousElementsibling返回当前元素上一个兄弟节点，找不到则返回null\n注意:这个方法有兼容性问题，IE9以上才支持\n\n\n兼容性函数代码\n\n\n   function getNextElementSibling(element) &#123;\n      var el = element;\n      while (el = el.nextSibling) &#123;\n        if (el.nodeType === 1) &#123;\n            return el;\n        &#125;\n      &#125;\n      return null;\n    &#125;  \n\n创建节点\n\ndocument.createElement ( “tagName “ )\ndocument.createElement()方法创建由tagName 指定的HTML元素。因为这些元素原先不存在，是根据我们的需求动态生成的，所以我们也称为动态创建元素节点\n\n添加节点\n\nnode. appendchild (child)\n\nnode.appendChild()方法将一个节点添加到指定父节点的子节点列表末尾。类似于css里面的after 伪元素\n\n\nnode . insertBefore (child，指定元素)\n\nnode.insertBefore(）方法将一个节点添加到父节点的指定子节点前面。类似于css里面的 before伪元素\n\n\n代码：\n\n\n    &lt;ul&gt;\n        &lt;li&gt;123&lt;/li&gt;\n    &lt;/ul&gt;\n    &lt;script&gt;\n        // 1. 创建节点元素节点\n        var li = document.createElement(&#39;li&#39;);\n        // 2. 添加节点 node.appendChild(child)  node 父级  child 是子级 后面追加元素  类似于数组中的push\n        var ul = document.querySelector(&#39;ul&#39;);\n        ul.appendChild(li);\n        // 3. 添加节点 node.insertBefore(child, 指定元素);\n        var lili = document.createElement(&#39;li&#39;);\n        ul.insertBefore(lili, ul.children[0]);\n        // 4. 我们想要页面添加一个新的元素 ： 1. 创建元素 2. 添加元素\n    &lt;/script&gt;\n\n删除节点\n\nnode . removeChild (child)\nnode.removechild()方法从DOM中删除一个子节点，返回删除的节点\n\n\n代码：\n\n    &lt;button&gt;删除&lt;/button&gt;\n    &lt;ul&gt;\n        &lt;li&gt;熊大&lt;/li&gt;\n        &lt;li&gt;熊二&lt;/li&gt;\n        &lt;li&gt;光头强&lt;/li&gt;\n    &lt;/ul&gt;\n    &lt;script&gt;\n        // 1.获取元素\n        var ul = document.querySelector(&#39;ul&#39;);\n        var btn = document.querySelector(&#39;button&#39;);\n        // 2. 删除元素  node.removeChild(child)\n        // ul.removeChild(ul.children[0]);\n        // 3. 点击按钮依次删除里面的孩子\n        btn.onclick = function() &#123;\n            if (ul.children.length == 0) &#123;\n                this.disabled = true;\n            &#125; else &#123;\n                ul.removeChild(ul.children[0]);\n            &#125;\n        &#125;\n    &lt;/script&gt;\n\n\n阻止链接跳转需要添加javascript:void(0);或者javascript:;\n\n复制节点\n\nnode.cloneNode ( )\n\nnode.cloneNode()方法返回调用该方法的节点的一个副本。也称为克隆节点&#x2F;拷贝节点\n\n\n注意：\n\n如果括号参数为空或者为false，则是浅拷贝，即只克隆复制节点本身，不克隆里面的子节点\n如果括号参数为true，则是深度拷贝，会复制节点本身以及里面所有的子节点\n\n\n代码：\n\n\n    &lt;ul&gt;\n        &lt;li&gt;1&lt;/li&gt;\n        &lt;li&gt;2&lt;/li&gt;\n        &lt;li&gt;3&lt;/li&gt;\n    &lt;/ul&gt;\n    &lt;script&gt;\n        var ul = document.querySelector(&#39;ul&#39;);\n        // 1. node.cloneNode(); 括号为空或者里面是false 浅拷贝 只复制标签不复制里面的内容\n        // 2. node.cloneNode(true); 括号为true 深拷贝 复制标签复制里面的内容\n        var lili = ul.children[0].cloneNode(true);\n        ul.appendChild(lili);\n    &lt;/script&gt;\n\n三种动态创建元素区别\n\ndocument.write ()\n\nelement.innerHTML\n\ndocument.createElement ()\n\n区别\n\ndocument.write 是直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致页面全部重绘\n\ninnerHTML是将内容写入某个DOM节点，不会导致页面全部重绘\n\ninnerHTML创建多个元素效率更高(不要拼接字符串，采取数组形式拼接)，结构稍微复杂\n\ncreateElement ()创建多个元素效率稍低—点点，但是结构更清晰\n\n\n\n总结:不同浏览器下, innerHTML效率要比creatElement高\n\n\n2.6 DOM重点核心\n关于dom操作，我们主要针对于元素的操作。主要有创建、增、删、改、查、属性操作、事件操作\n\n创建\n\ndocument.write\ninnerHTML\ncreateElement\n\n增\n\nappendChild\ninsertBefore\n\n删\n\nremoveChild\n\n改\n\n主要修改dom的元素属性。dom元素的内容、属性,表单的值等\n修改元素属性:src. href、 title等\n修改普通元素内容:innerHTML . innerText\n修改表单元索:value. type.disabled等\n修改元素样式:style. className\n\n\n\n查\n\n主要获取查询dom的元素\nDOM提供的API方法: getElementByld.getElementsByTagName 古老用法不太推荐\nH5提供的新方法: querySelector.querySelectorAll提倡\n利用节点操作获取元素:父(parentNode)、子(children)、兄(previousElementSibling、nextElementsibling)提倡\n\n\n\n属性操作\n\n主要针对于自定义属性\nsetAttribute:设置dom的属性值\ngetAttribute:得到dom的属性值\nremoveAttribute移除属性\n\n\n\n事件操作\n\n给元素注册事件,采取事件源.事件类型&#x3D;事件处理程序\n\n3、DOM – 事件高级3.1 注册事件(绑定事件)注册事件\n\n给元素添加事件，称为注册事件或者绑定事件，注册事件有两种方式:\n传统注册方式\n利用on开头的事件：onclick\n注册事件的唯一性\n同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数\n\n\n方法监听注册方式\naddEventListener()它是一个方法\n特点:同一个元素同一个事件可以注册多个监听器；按注册顺序依次执行\n\n\n\n\n\naddEventListener 事件监听方式 \n\neventTarget.addEventListener(type, listener[, useCapture]) \n\ntype:事件类型字符串，比如click 、mouseover，注意这里不要带on\n\nlistener:事件处理函数，事件发生时，会调用该监听函数\n\nuseCapture:可选参数，是一个布尔值，默认是false\n\n\nattachEvent 事件监听方式 (IE8及早期版本支持)\n\neventTarget.attachEvent(eventNameWithOn, callback) \n\neventNameWithOn:事件类型字符串，比如onclick 、onmouseover，这里要带 on\n\ncallback:事件处理函数，当目标触发事件时回调函数被调\n\n代码：\n\n\n    &lt;button&gt;传统注册事件&lt;/button&gt;\n    &lt;button&gt;方法监听注册事件&lt;/button&gt;\n    &lt;button&gt;ie9 attachEvent&lt;/button&gt;\n    &lt;script&gt;\n        var btns = document.querySelectorAll(&#39;button&#39;);\n        // 1. 传统方式注册事件\n        btns[0].onclick = function () &#123;\n            alert(&#39;hi&#39;);\n        &#125;\n        btns[0].onclick = function () &#123;\n            alert(&#39;hao a u&#39;);\n        &#125;\n        // 2. 事件侦听注册事件 addEventListener \n        // (1) 里面的事件类型是字符串 必定加引号 而且不带on\n        // (2) 同一个元素 同一个事件可以添加多个侦听器（事件处理程序）\n        btns[1].addEventListener(&#39;click&#39;, function () &#123;\n            alert(22);\n        &#125;)\n        btns[1].addEventListener(&#39;click&#39;, function () &#123;\n            alert(33);\n        &#125;)\n        // 3. attachEvent ie9以前的版本支持\n        btns[2].attachEvent(&#39;onclick&#39;, function () &#123;\n            alert(11);\n        &#125;)\n    &lt;/script&gt;\n\n注册事件兼容性解决方案 \n\n代码：\n\n function addEventListener(element, eventName, fn) &#123;\n      // 判断当前浏览器是否支持 addEventListener 方法\n      if (element.addEventListener) &#123;\n        element.addEventListener(eventName, fn);  // 第三个参数 默认是false\n      &#125; else if (element.attachEvent) &#123;\n        element.attachEvent(&#39;on&#39; + eventName, fn);\n      &#125; else &#123;\n        // 相当于 element.onclick = fn;\n        element[&#39;on&#39; + eventName] = fn;\n &#125; \n\n3.2 删除事件(解绑事件)\n传统注册方式\n\neventTarget.onclick &#x3D; null;\n\n\n方法监听注册方式\n\n①eventTarget.removeEventListener(type, listener[, useCapture]);\n②eventTarget.detachEvent(eventNameWithOn, callback);\n\n\n\n\n代码：\n\n    &lt;div&gt;1&lt;/div&gt;\n    &lt;div&gt;2&lt;/div&gt;\n    &lt;div&gt;3&lt;/div&gt;\n    &lt;script&gt;\n        var divs = document.querySelectorAll(&#39;div&#39;);\n        divs[0].onclick = function() &#123;\n                alert(11);\n                // 1. 传统方式删除事件\n                divs[0].onclick = null;\n            &#125;\n            // 2. removeEventListener 删除事件\n        divs[1].addEventListener(&#39;click&#39;, fn) // 里面的fn 不需要调用加小括号\n\n        function fn() &#123;\n            alert(22);\n            divs[1].removeEventListener(&#39;click&#39;, fn);\n        &#125;\n        // 3. detachEvent\n        divs[2].attachEvent(&#39;onclick&#39;, fn1);\n\n        function fn1() &#123;\n            alert(33);\n            divs[2].detachEvent(&#39;onclick&#39;, fn1);\n        &#125;\n    &lt;/script&gt;\n\n删除事件兼容性解决方案 \n function removeEventListener(element, eventName, fn) &#123;\n      // 判断当前浏览器是否支持 removeEventListener 方法\n      if (element.removeEventListener) &#123;\n        element.removeEventListener(eventName, fn);  // 第三个参数 默认是false\n      &#125; else if (element.detachEvent) &#123;\n        element.detachEvent(&#39;on&#39; + eventName, fn);\n      &#125; else &#123;\n        element[&#39;on&#39; + eventName] = null;\n &#125; \n\n3.3 DOM事件流\n事件流描述的是从页面中接收事件的顺序\n事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流\n\n\n\nDOM事件流分为3个阶段:\n\n捕获阶段\n当前目标阶段\n冒泡阶段\n\n\n事件冒泡:IE最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到到DOM最顶层节点的过程(回溯)\n\n事件捕获:网景最早提出，由DOM最顶层节点开始，然后逐级向下传播到到最具体的元素接收的过程(自顶向下)\n\n举例：我们向水里面扔一块石头，首先它会有一个下降的过程，这个过程就可以理解为从最顶层向事件发生的最具体元素（目标点)的捕获过程;之后会产生泡泡，会在最低点（最具体元素)之后漂浮到水面上，这个过程相当于事件冒泡\n\n事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流\n\n注意\n\nJS 代码中只能执行捕获或者冒泡其中的一个阶段\nonclick和attachEvent只能得到冒泡阶段\naddEventListener(type,listener[,useCapture])第三个参数如果是true，表示在事件捕获阶段调用事件处理程序;如果是 false (不写默认就是false)，表示在事件冒泡阶段调用事件处理程序\n实际开发中我们很少使用事件捕获，我们更关注事件冒泡\n有些事件是没有冒泡的，比如onblur、onfocus、onmouseenter、onmouseleave\n\n\n代码：\n\n\n    &lt;div class=&quot;father&quot;&gt;\n        &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt;\n    &lt;/div&gt;\n    &lt;script&gt;\n        // dom 事件流 三个阶段\n        // 1. JS 代码中只能执行捕获或者冒泡其中的一个阶段。\n        // 2. onclick 和 attachEvent（ie） 只能得到冒泡阶段。\n        // 3. 捕获阶段 如果addEventListener 第三个参数是 true 那么则处于捕获阶段  document -&gt; html -&gt; body -&gt; father -&gt; son\n        // var son = document.querySelector(&#39;.son&#39;);\n        // son.addEventListener(&#39;click&#39;, function() &#123;\n        //     alert(&#39;son&#39;);\n        // &#125;, true);\n        // var father = document.querySelector(&#39;.father&#39;);\n        // father.addEventListener(&#39;click&#39;, function() &#123;\n        //     alert(&#39;father&#39;);\n        // &#125;, true);\n        // 4. 冒泡阶段 如果addEventListener 第三个参数是 false 或者 省略 那么则处于冒泡阶段  son -&gt; father -&gt;body -&gt; html -&gt; document\n        var son = document.querySelector(&#39;.son&#39;);\n        son.addEventListener(&#39;click&#39;, function () &#123;\n            alert(&#39;son&#39;);\n        &#125;, false);\n        var father = document.querySelector(&#39;.father&#39;);\n        father.addEventListener(&#39;click&#39;, function () &#123;\n            alert(&#39;father&#39;);\n        &#125;, false);\n        document.addEventListener(&#39;click&#39;, function () &#123;\n            alert(&#39;document&#39;);\n        &#125;)\n    &lt;/script&gt;\n\n3.4 事件对象  eventTarget.onclick = function(event) &#123;&#125; \n  eventTarget.addEventListener(&#39;click&#39;, function(event) &#123;&#125;）\n  // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt \n\n\n官方解释: event对象代表事件的状态，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态\n代码：\n\n    &lt;div&gt;123&lt;/div&gt;\n    &lt;script&gt;\n        // 事件对象\n        var div = document.querySelector(&#39;div&#39;);\n        div.onclick = function (e) &#123;\n            // console.log(e);\n            // console.log(window.event);\n            // e = e || window.event;\n            //事件对象也有兼容性问题 ie678 通过 window.event 兼容性的写法  e = e || window.event;\n            console.log(e);\n        &#125;\n    &lt;/script&gt;\n\n事件对象的常见属性和方法\n\n\n\n事件对象属性方法\n说明\n\n\n\ne.target\n返回触发事件的对象    标准\n\n\ne.srcElement\n返回触发事件的对象    非标准  ie6-8使用\n\n\ne.type\n返回事件的类型    比如click  mouseover  不带on\n\n\ne.cancelBubble\n该属性阻止冒泡 非标准 ie6-8使用\n\n\ne.returnValue\n该方法阻止默认事件(默认行为)    非标准  ie6-8使用  比如不让链接跳转\n\n\ne.preventDefault\n该方法阻止默认事件(默认行为)    标准  比如不让链接跳转\n\n\ne.stopPropagation\n阻止冒泡    标准\n\n\ntarget与this\n    &lt;div&gt;123&lt;/div&gt;\n    &lt;ul&gt;\n        &lt;li&gt;abc&lt;/li&gt;\n        &lt;li&gt;abc&lt;/li&gt;\n        &lt;li&gt;abc&lt;/li&gt;\n    &lt;/ul&gt;\n    &lt;script&gt;\n        // 常见事件对象的属性和方法\n        // 1. e.target 返回的是触发事件的对象（元素）  this 返回的是绑定事件的对象（元素）\n        // 区别 ： e.target 点击了那个元素，就返回那个元素 this 那个元素绑定了这个点击事件，那么就返回谁\n        var div = document.querySelector(&#39;div&#39;);\n        div.addEventListener(&#39;click&#39;, function(e) &#123;\n            console.log(e.target);\n            console.log(this);\n\n        &#125;)\n        var ul = document.querySelector(&#39;ul&#39;);\n        ul.addEventListener(&#39;click&#39;, function(e) &#123;\n                // 我们给ul 绑定了事件  那么this 就指向ul  \n                console.log(this);\n                console.log(e.currentTarget);\n\n                // e.target 指向我们点击的那个对象 谁触发了这个事件 我们点击的是li e.target 指向的就是li\n                console.log(e.target);\n\n            &#125;)\n            // 了解兼容性\n            // div.onclick = function(e) &#123;\n            //     e = e || window.event;\n            //     var target = e.target || e.srcElement;\n            //     console.log(target);\n\n        // &#125;\n        // 2. 了解 跟 this 有个非常相似的属性 currentTarget  ie678不认识\n    &lt;/script&gt;\n\n返回事件类型和阻止默认行为\n    &lt;div&gt;123&lt;/div&gt;\n    &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;\n    &lt;form action=&quot;http://www.baidu.com&quot;&gt;\n        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; name=&quot;sub&quot;&gt;\n    &lt;/form&gt;\n    &lt;script&gt;\n        // 常见事件对象的属性和方法\n        // 1. 返回事件类型\n        var div = document.querySelector(&#39;div&#39;);\n        div.addEventListener(&#39;click&#39;, fn);\n        div.addEventListener(&#39;mouseover&#39;, fn);\n        div.addEventListener(&#39;mouseout&#39;, fn);\n\n        function fn(e) &#123;\n            console.log(e.type);\n\n        &#125;\n        // 2. 阻止默认行为（事件） 让链接不跳转 或者让提交按钮不提交\n        var a = document.querySelector(&#39;a&#39;);\n        a.addEventListener(&#39;click&#39;, function (e) &#123;\n            e.preventDefault(); //  dom 标准写法\n        &#125;)\n        // 3. 传统的注册方式\n        a.onclick = function (e) &#123;\n            // 普通浏览器 e.preventDefault();  方法\n            // e.preventDefault();\n            // 低版本浏览器 ie678  returnValue  属性\n            // e.returnValue;\n            // 我们可以利用return false 也能阻止默认行为 没有兼容性问题 特点： return 后面的代码不执行了， 而且只限于传统的注册方式\n            return false;\n            alert(11);\n        &#125;\n    &lt;/script&gt;\n\n阻止事件冒泡\n\n标准写法:利用事件对象里面的stopPropagation()方法\n\ne.stopPropagation ()\n\n\n非标准写法:IE 6-8利用事件对象cancelBubble 属性\n\ne.cancelBubble &#x3D; true;\n\n\n代码：\n\n\n    &lt;div class=&quot;father&quot;&gt;\n        &lt;div class=&quot;son&quot;&gt;son儿子&lt;/div&gt;\n    &lt;/div&gt;\n    &lt;script&gt;\n        // 常见事件对象的属性和方法\n        // 阻止冒泡  dom 推荐的标准 stopPropagation() \n        var son = document.querySelector(&#39;.son&#39;);\n        son.addEventListener(&#39;click&#39;, function(e) &#123;\n            alert(&#39;son&#39;);\n            e.stopPropagation(); // stop 停止  Propagation 传播\n            e.cancelBubble = true; // 非标准 cancel 取消 bubble 泡泡\n        &#125;, false);\n\n        var father = document.querySelector(&#39;.father&#39;);\n        father.addEventListener(&#39;click&#39;, function() &#123;\n            alert(&#39;father&#39;);\n        &#125;, false);\n        document.addEventListener(&#39;click&#39;, function() &#123;\n            alert(&#39;document&#39;);\n        &#125;)\n    &lt;/script&gt;\n\n\n阻止事件冒泡的兼容性解决方案\n\nif(e &amp;&amp; e.stopPropagation)&#123;\n      e.stopPropagation();\n  &#125;else&#123;\n      window.event.cancelBubble = true;\n  &#125;\n\n3.5 事件委托\n事件委托也称为事件代理，在jQuery里面称为事件委派\n\n事件委托的原理：不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点\n\n事件委托的作用：我们只操作了一次DOM，提高了程序的性能\n\n代码：\n\n\n    &lt;ul&gt;\n        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;\n        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;\n        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;\n        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;\n        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;\n    &lt;/ul&gt;\n    &lt;script&gt;\n        // 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点\n        var ul = document.querySelector(&#39;ul&#39;);\n        ul.addEventListener(&#39;click&#39;, function (e) &#123;\n            // alert(&#39;知否知否，点我应有弹框在手！&#39;);\n            // e.target 这个可以得到我们点击的对象\n            e.target.style.backgroundColor = &#39;pink&#39;;\n        &#125;)\n    &lt;/script&gt;\n\n3.6 常用事件常见的鼠标事件\n\n\n\n鼠标事件\n触发条件\n\n\n\nonclick\n鼠标点击左键触发\n\n\nonmouseover\n鼠标经过触发\n\n\nonmouseout\n鼠标离开触发\n\n\nonfocus\n获得鼠标焦点触发\n\n\nonblur\n失去鼠标焦点触发\n\n\nonmousemove\n鼠标移动触发\n\n\nonmouseup\n鼠标弹起触发\n\n\nonmousedown\n鼠标按下触发\n\n\n\n禁止鼠标右键菜单\ncontextmenu主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单\n\n\n\ndocument.addEventListener(&#39;contextmenu&#39;, function(e) &#123;\n    e.preventDefault();\n&#125;)\n\n\n禁止鼠标选中（selectstart 开始选中）\n\ndocument.addEventListener(&#39;selectstart&#39;, function(e) &#123;\n    e.preventDefault();\n&#125;)\n\n鼠标事件对象\n\nevent对象代表事件的状态，跟事件相关的一系列信息的集合。现阶段我们主要是用鼠标事件对象MouseEvent和键盘事件对象KeyboardEvent\n\n\n\n\n鼠标事件对象\n说明\n\n\n\ne.clientX\n返回鼠标相对于浏览器窗口可视区的X坐标\n\n\ne.clientY\n返回鼠标相对于浏览器窗口可视区的Y坐标\n\n\ne.pageX\n返回鼠标相对于文档页面的X坐标    IE9+支持\n\n\ne.pageY\n返回鼠标相对于文档页面的Y坐标    IE9+支持\n\n\ne.screenX\n返回鼠标相对于电脑屏幕的X坐标\n\n\ne.screenY\n返回鼠标相对于电脑屏幕的Y坐标\n\n\n\n代码：\n\n    &lt;script&gt;\n        // 鼠标事件对象 MouseEvent\n        document.addEventListener(&#39;click&#39;, function(e) &#123;\n            // 1. client 鼠标在可视区的x和y坐标\n            console.log(e.clientX);\n            console.log(e.clientY);\n            console.log(&#39;---------------------&#39;);\n\n            // 2. page 鼠标在页面文档的x和y坐标\n            console.log(e.pageX);\n            console.log(e.pageY);\n            console.log(&#39;---------------------&#39;);\n\n            // 3. screen 鼠标在电脑屏幕的x和y坐标\n            console.log(e.screenX);\n            console.log(e.screenY);\n\n        &#125;)\n    &lt;/script&gt;\n\n常用键盘事件\n\n\n\n键盘事件\n触发条件\n\n\n\nonkeyup\n某个键盘按键被松开时触发\n\n\nonkeydown\n某个键盘按键被按下时触发\n\n\nonkeypress\n某个键盘按键被松开时触发    不识别功能键\n\n\n\n代码：\n\n    &lt;script&gt;\n        // 常用的键盘事件\n        //1. keyup 按键弹起的时候触发 \n        // document.onkeyup = function() &#123;\n        //         console.log(&#39;我弹起了&#39;);\n\n        //     &#125;\n        document.addEventListener(&#39;keyup&#39;, function () &#123;\n            console.log(&#39;我弹起了&#39;);\n        &#125;)\n\n        //3. keypress 按键按下的时候触发  不能识别功能键 比如 ctrl shift 左右箭头啊\n        document.addEventListener(&#39;keypress&#39;, function () &#123;\n            console.log(&#39;我按下了press&#39;);\n        &#125;)\n        //2. keydown 按键按下的时候触发  能识别功能键 比如 ctrl shift 左右箭头啊\n        document.addEventListener(&#39;keydown&#39;, function () &#123;\n            console.log(&#39;我按下了down&#39;);\n        &#125;)\n    &lt;/script&gt;\n\n\n注意:\n\n如果使用addEventListener不需要加on\n\nonkeypress和前面2个的区别是，它不识别功能键，比如左右箭头,shift等\n\n三个事件的执行顺序是: keydown – keypress — keyup\n\n\n\n\n键盘事件对象\n\nkeyCode – 返回该键的ASCII值\n\n代码：\n\n\n    &lt;script&gt;\n        // 键盘事件对象中的keyCode属性可以得到相应键的ASCII码值\n        // 1. 我们的keyup 和keydown事件不区分字母大小写  a 和 A 得到的都是65\n        // 2. 我们的keypress 事件 区分字母大小写  a  97 和 A 得到的是65\n        document.addEventListener(&#39;keyup&#39;, function(e) &#123;\n            // console.log(e);\n            console.log(&#39;up:&#39; + e.keyCode);\n            // 我们可以利用keycode返回的ASCII码值来判断用户按下了那个键\n            if (e.keyCode === 65) &#123;\n                alert(&#39;您按下的a键&#39;);\n            &#125; else &#123;\n                alert(&#39;您没有按下a键&#39;)\n            &#125;\n\n        &#125;)\n        document.addEventListener(&#39;keypress&#39;, function(e) &#123;\n            // console.log(e);\n            console.log(&#39;press:&#39; + e.keyCode);\n\n        &#125;)\n    &lt;/script&gt;\n\n\n注意:onkeydown和onkeyup 不区分字母大小写，onkeypress区分字母大小写\n\n4、BOM4.1 BOM概述\nBOM (Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是window\nBOM缺乏标准，JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C，BOM最初是Netscape浏览器标准的一部分\n\n\n\n\nDOM\nBOM\n\n\n\n文档对象模型\n浏览器对象模型\n\n\n把**[文档]当做一个[对象]**\n把**[浏览器]当做一个[对象]**\n\n\nDOM的顶级对象是document\nBOM的顶级对象是window\n\n\nDOM主要学习的是操作页面元素\nBOM学习的是浏览窗口交互的一些对象\n\n\nDOM是W3C标准规范\nBOM是浏览器厂商在各自浏览器上定义的，兼容性较差\n\n\n\n构成\n\n\n\nwindow对象是浏览器的顶级对象，它具有双重角色。\n\n它是JS访问浏览器窗口的一个接口\n\n它是一个全局对象。定义在全局作用域中的变量、函数都会变成window对象的属性和方法\n\n\n\n在调用的时候可以省略window，前面学习的对话框都属于window对象方法，如 alert()、prompt()等\n\n注意: window下的一个特殊属性window.name(变量不要声明为name)\n\n\n4.2 windows对象的常见事件窗口加载事件\n\nwindow.onload 是窗口(页面)加载事件,当文档内容完全加载完成会触发该事件(包括图像、脚本文件、CSS文件等),就调用的处理函数\n\n注意:\n\n有了window.onload就可以把JS代码写到页面元素的上方，因为onload 是等页面内容全部加载完毕，再去执行处理函数\nwindow.onload传统注册事件方式只能写一次，如果有多个，会以最后一个window.onload为准\n如果使用addEventListener则没有限制\n\n\nDOMContentLoaded事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等。(le9以上才支持)如果页面的图片很多的话,从用户访问到onload触发可能需要较长的时间,交互效果就不能实现，必然影响用户的体验，此时用DOMContentLoaded事件比较合适\n\n代码：\n\n\n    &lt;script&gt;\n        window.addEventListener(&#39;load&#39;, function () &#123;\n            var btn = document.querySelector(&#39;button&#39;);\n            btn.addEventListener(&#39;click&#39;, function () &#123;\n                alert(11);\n            &#125;)\n        &#125;)\n        window.addEventListener(&#39;load&#39;, function () &#123;\n            alert(22);\n        &#125;)\n        document.addEventListener(&#39;DOMContentLoaded&#39;, function () &#123;\n            alert(33);\n        &#125;)\n            // load 等页面内容全部加载完毕，包含页面dom元素 图片 flash  css 等等\n            // DOMContentLoaded 是DOM 加载完毕，不包含图片 falsh css 等就可以执行 加载速度比 load更快一些\n    &lt;/script&gt;\n\n调整窗口大小事件\n\nwindow. onresize是调整窗口大小加载事件，当触发时就调用的处理函数\n\n注意:\n\n只要窗口大小发生像索变化，就会触发这个事件\n我们经常利用这个事件完成响应式布局。window.innerWidth当前屏慕的宽度\n\n\n代码：\n\n\n    &lt;script&gt;\n        window.addEventListener(&#39;load&#39;, function () &#123;\n            var div = document.querySelector(&#39;div&#39;);\n            window.addEventListener(&#39;resize&#39;, function () &#123;\n                console.log(window.innerWidth);\n\n                console.log(&#39;变化了&#39;);\n                if (window.innerWidth &lt;= 800) &#123;\n                    div.style.display = &#39;none&#39;;\n                &#125; else &#123;\n                    div.style.display = &#39;block&#39;;\n                &#125;\n\n            &#125;)\n        &#125;)\n    &lt;/script&gt;\n\n4.3 定时器setTimeout()定时器\n\nwindow.setTimeout(调用函数, [延迟的毫秒数]);\n\nsetTimeout()方法用于设置一个定时器，该定时器在定时器到期后执行调用函数\n\nsetTimeout()这个调用函数我们也称为回调函数callback；普通函数是按照代码顺序直接调用，而这个函数，需要等待时间，时间到了才去调用这个函数，因此称为回调函数\n\n注意:\n\nwindow可以省略\n这个调用函数可以直接写函数，或者写函数名或者采取字符串‘函数名0’三种形式。第三种不推荐\n延迟的毫秒数省略默认是0。如果写，必须是毫秒\n因为定时器可能有很多。所以我们经常给定时器赋值一个标识符\n\n\n代码：\n\n\n    &lt;script&gt;\n        function callback() &#123;\n            console.log(&#39;爆炸了&#39;);\n\n        &#125;\n        var timer1 = setTimeout(callback, 3000);\n        var timer2 = setTimeout(callback, 5000);\n        // setTimeout(&#39;callback()&#39;, 3000); // 我们不提倡这个写法\n    &lt;/script&gt;\n\n    //广告自动关闭\n    &lt;img src=&quot;images/ad.jpg&quot; alt=&quot;&quot; class=&quot;ad&quot;&gt;\n    &lt;script&gt;\n        var ad = document.querySelector(&#39;.ad&#39;);\n        setTimeout(function() &#123;\n            ad.style.display = &#39;none&#39;;\n        &#125;, 5000);\n    &lt;/script&gt;\n\n停止setTimeout()定时器\n\nwindow.clearTimeout(timeoutID)；\n\nclearTimeout ()方法取消了先前通过调用setTimeout(〉建立的定时器\n\n注意:\n\nwindow可以省略\n里面的参数就是定时器的标识符\n\n\n代码：\n\n\n    &lt;button&gt;点击停止定时器&lt;/button&gt;\n    &lt;script&gt;\n        var btn = document.querySelector(&#39;button&#39;);\n        var timer = setTimeout(function() &#123;\n            console.log(&#39;爆炸了&#39;);\n\n        &#125;, 5000);\n        btn.addEventListener(&#39;click&#39;, function() &#123;\n            clearTimeout(timer);\n        &#125;)\n    &lt;/script&gt;\n\nsetInterval()定时器\n\nwindow.setInterval(回调函数, [间隔的毫秒数]);\nsetinterval0方法重复调用一个函数。每限这个时间，就去调用一次回调函数\n注意基本同setTimeout()定时器\n代码：\n\n    &lt;script&gt;\n        setInterval(function () &#123;\n            console.log(&#39;继续输出&#39;);\n        &#125;, 1000);\n    &lt;/script&gt;\n\n    //定时器\n    &lt;div&gt;\n        &lt;span class=&quot;hour&quot;&gt;1&lt;/span&gt;\n        &lt;span class=&quot;minute&quot;&gt;2&lt;/span&gt;\n        &lt;span class=&quot;second&quot;&gt;3&lt;/span&gt;\n    &lt;/div&gt;\n    &lt;script&gt;\n        // 1. 获取元素 \n        var hour = document.querySelector(&#39;.hour&#39;); // 小时的黑色盒子\n        var minute = document.querySelector(&#39;.minute&#39;); // 分钟的黑色盒子\n        var second = document.querySelector(&#39;.second&#39;); // 秒数的黑色盒子\n        var inputTime = +new Date(&#39;2022-5-6 12:00:00&#39;); // 返回的是用户输入时间总的毫秒数\n        countDown(); // 我们先调用一次这个函数，防止第一次刷新页面有空白 \n        // 2. 开启定时器\n        setInterval(countDown, 1000);\n\n        function countDown() &#123;\n            var nowTime = +new Date(); // 返回的是当前时间总的毫秒数\n            var times = (inputTime - nowTime) / 1000; // times是剩余时间总的秒数 \n            var h = parseInt(times / 60 / 60 % 24); //时\n            h = h &lt; 10 ? &#39;0&#39; + h : h;\n            hour.innerHTML = h; // 把剩余的小时给 小时黑色盒子\n            var m = parseInt(times / 60 % 60); // 分\n            m = m &lt; 10 ? &#39;0&#39; + m : m;\n            minute.innerHTML = m;\n            var s = parseInt(times % 60); // 当前的秒\n            s = s &lt; 10 ? &#39;0&#39; + s : s;\n            second.innerHTML = s;\n        &#125;\n    &lt;/script&gt;\n\n停止setInterval()定时器\n\nwindow.clearInterval(intervalID);\nclearInterval()方法取消了先前通过调用setInterval()建立的定时器\n注意:基本同停止setTimeout()定时器\n代码：\n\n    &lt;button class=&quot;begin&quot;&gt;开启定时器&lt;/button&gt;\n    &lt;button class=&quot;stop&quot;&gt;停止定时器&lt;/button&gt;\n    &lt;script&gt;\n        var begin = document.querySelector(&#39;.begin&#39;);\n        var stop = document.querySelector(&#39;.stop&#39;);\n        var timer = null; // 全局变量  null是一个空对象\n        begin.addEventListener(&#39;click&#39;, function () &#123;\n            timer = setInterval(function () &#123;\n                console.log(&#39;你好&#39;);\n            &#125;, 1000);\n        &#125;)\n        stop.addEventListener(&#39;click&#39;, function () &#123;\n            clearInterval(timer);\n        &#125;)\n    &lt;/script&gt;\n\n    //发送短信\n    手机号码:&lt;input type=&quot;number&quot;&gt;&lt;button&gt;发送&lt;/button&gt;\n    &lt;script&gt;\n        var btn = document.querySelector(&#39;button&#39;);\n        var time = 5;\n        btn.addEventListener(&#39;click&#39;, function () &#123;\n            btn.disabled = true;\n            var timer = setInterval(function () &#123;\n                if (time == 0) &#123;\n                    clearInterval(timer);\n                    btn.disabled = false;\n                    btn.innerHTML = &#39;发送&#39;;\n                    time = 5;\n                &#125; else &#123;\n                    btn.innerHTML = &#39;还剩下&#39; + time + &#39;秒&#39;;\n                    time--;\n                &#125;\n            &#125;, 1000)\n        &#125;)\n    &lt;/script&gt;\n\nthis\n\nthis的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，一般情况下this的最终指向的是那个调用它的对象\n全局作用域或者普通函数中this指向全局对象window (注意定时器里面的this指向window)\n方法调用中谁调用this指向谁\n构造函数中this指向构造函数的实例\n\n\n\n4.4 JS执行机制\nJavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事\n这是Javascript这门脚本语言诞生的使命所致——JavaScript是为处理页面中用户的交互，以及操作DOM而诞生的。比如我们对某个DOM元素进行添加和删除操作，不能同时进行。应该先进行添加，之后再删除\n\n同步和异步\n\n为了解决这个问题，利用多核CPU的计算能力，HTML5提出 Web Worker标准，允许JavaScript脚本创建多个线程。于是，JS中出现了同步和异步\n本质区别:这条流水线上各个流程的执行顺序不同\n同步任务：同步任务都在主线程上执行，形成一个执行栈\n异步任务：JS的异步是通过回调函数实现的\n—般而言，异步任务有以下三种类型:\n普通事件，如click、resize等\n资源加载，如load、error等\n定时器，包括setlnterval、setTimeout等\n\n\n异步任务相关回调函数添加到任务队列中(任务队列也称为消息队列)。\n\n执行机制\n\n先执行执行栈中的同步任务\n异步任务(回调函数）放入任务队列中\n一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行\n\n\n\n由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环（event loop)\n\n代码：\n\n\n    &lt;script&gt;\n        // 第一个问题\n        // console.log(1);\n        // setTimeout(function () &#123;\n        //     console.log(3);\n        // &#125;, 1000);\n        // console.log(2);\n        // 2. 第二个问题\n        // console.log(1);\n        // setTimeout(function () &#123;\n        //     console.log(3);\n        // &#125;, 0);\n        // console.log(2);\n        // 3. 第三个问题\n        console.log(1);\n        document.onclick = function () &#123;\n            console.log(&#39;click&#39;);\n        &#125;\n        console.log(2);\n        setTimeout(function () &#123;\n            console.log(3)\n        &#125;, 3000)\n    &lt;/script&gt;\n\n4.5 location对象\nwindow对象给我们提供了一个location属性用于获取或设置窗体的URL，并且可以用于解析URL。因为这个属性返回的是一个对象，所以我们将这个属性也称为location对象\n\nUPL\n\n统一资源定位符(Uniform Resource Locator,URL)是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它\n\n一般格式：\n\nprotocol:&#x2F;&#x2F;host[:port]&#x2F;path&#x2F;[?query]#fragment\nhttp://www.itcast.cn/index.html?name=andy&amp;age=18#link\n\n\n\n\n\n\n\n组成\n说明\n\n\n\nprotocol\n通信协议 常用的http,ftp.maito等\n\n\nhost\n主机（域名） www.baidu.com\n\n\nport\n端口号 可选，省略时使用方案的默认端口\n\n\npath\n路径 由零或多个’&#x2F;‘符号隔开的字符串，一般用来表示主机上的一个目录或文件地址\n\n\nquery\n参数 以键值对的形式，通过&amp;符号分隔开来\n\n\nfragment\n片段 #后面内容 常见于链接 锚点\n\n\nlocation对象的属性\n\n\n\nlocation对象属性\n返回值\n\n\n\nlocation.href\n获取或者设置 整个URL\n\n\nlocation.host\n返回主机(域名) www.bandu.com\n\n\nlocation.port\n返回端口号 如果未写返回 空字符串\n\n\nlocation.pathname\n返回路径\n\n\nlocation.search\n返回参数\n\n\nlocation.hash\n返回片段\n\n\n\n代码：\n\n    &lt;button&gt;点击&lt;/button&gt;\n    &lt;div&gt;&lt;/div&gt;\n    &lt;script&gt;\n        var btn = document.querySelector(&#39;button&#39;);\n        var div = document.querySelector(&#39;div&#39;);\n        btn.addEventListener(&#39;click&#39;, function () &#123;\n            // console.log(location.href);\n            location.href = &#39;http://www.baidu.com&#39;;\n        &#125;)\n        var timer = 5;\n        setInterval(function () &#123;\n            if (timer == 0) &#123;\n                location.href = &#39;http://www.baidu.com&#39;;\n            &#125; else &#123;\n                div.innerHTML = &#39;您将在&#39; + timer + &#39;秒钟之后跳转到首页&#39;;\n                timer--;\n            &#125;\n\n        &#125;, 1000);\n    &lt;/script&gt;\n\nlocation对象的方法\n\n\n\nlocation对象方法\n返回值\n\n\n\nlocation.assign()\n跟href一样，可以跳转页面（(也称为重定向页面)\n\n\nlocation.replace()\n替换当前页面，因为不记录历史，所以不能后退页面\n\n\nlocation.reload()\n重新加载页面，相当于刷新按钮或者f5如果参数为true 强制刷新ctrl+f5\n\n\n\n代码：\n\n    &lt;button&gt;点击&lt;/button&gt;\n    &lt;script&gt;\n        var btn = document.querySelector(&#39;button&#39;);\n        btn.addEventListener(&#39;click&#39;, function () &#123;\n            // 记录浏览历史，所以可以实现后退功能\n            // location.assign(&#39;http://www.baidu.com&#39;);\n            // 不记录浏览历史，所以不可以实现后退功能\n            // location.replace(&#39;http://www.baidu.com&#39;);\n            location.reload(true);\n        &#125;)\n    &lt;/script&gt;\n\n4.6 navigator对象\nnavigator对象包含有关浏览器的信息，它有很多属性，我们最常用的是userAgent，该属性可以返回由客户机发送服务器的user-agent头部的值\n判断终端\n\nif((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) &#123;\n    window.location.href = &quot;&quot;;     //手机\n&#125; else &#123;\n    window.location.href = &quot;&quot;;     //电脑\n&#125;\n\n4.7 history对象\nwindow对象给我们提供了一个history对象，与浏览器历史记录进行交互。该对象包含用户(在浏览器窗口中)访问过的 URL\n\n\n\n\nhistory对象方法\n作用\n\n\n\nback()\n后退功能\n\n\nforword()\n前进功能\n\n\ngo(参数)\n前进后退功能，参数为1前进1个页面，-1后退一个页面\n\n\n\n代码：\n\n    //index.html\n    &lt;a href=&quot;list.html&quot;&gt;点击我去往列表页&lt;/a&gt;\n    &lt;button&gt;前进&lt;/button&gt;\n    &lt;script&gt;\n        var btn = document.querySelector(&#39;button&#39;);\n        btn.addEventListener(&#39;click&#39;, function() &#123;\n            // history.forward();\n            history.go(1);\n        &#125;)\n    &lt;/script&gt;\n\n    //list.html\n    &lt;a href=&quot;index.html&quot;&gt;点击我去往首页&lt;/a&gt;\n    &lt;button&gt;后退&lt;/button&gt;\n    &lt;script&gt;\n        var btn = document.querySelector(&#39;button&#39;);\n        btn.addEventListener(&#39;click&#39;, function() &#123;\n            // history.back();\n            history.go(-1);\n        &#125;)\n    &lt;/script&gt;\n\n5、PC端网页特效5.1 元素偏移量offset系列\noffset翻译过来就是偏移量，我们使用offset系列相关属性可以动态的得到该元素的位置（偏移)、大小等\n获得元素距离带有定位父元素的位置\n获得元素自身的大小(宽度高度)\n注意:返回的数值都不带单位\n\n\n\noffset常见属性：\n\n\n\n\noffset系列属性\n作用\n\n\n\nelement.offsetParent\n返回作为该元素带有定位的父级元素，如果父级都没有定位则返回body\n\n\nelement.offsetTop\n返回元素相对带有定位父元素上方的偏移\n\n\nelement.offsetLeft\n返回元素相对带有定位父元素左边框的偏移\n\n\nelement.offsetWidth\n返回自身包括padding、边框、内容区的宽度、返回数值不带单位\n\n\nelement.offsetHeight\n返回自身包括padding、边框、内容区的高度、返回数值不带单位\n\n\n\n代码：\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;style&gt;\n        * &#123;\n            margin: 0;\n            padding: 0;\n        &#125;\n\n        .father &#123;\n            /* position: relative; */\n            width: 200px;\n            height: 200px;\n            background-color: pink;\n            margin: 150px;\n        &#125;\n\n        .son &#123;\n            width: 100px;\n            height: 100px;\n            background-color: purple;\n            margin-left: 45px;\n        &#125;\n\n        .w &#123;\n            height: 200px;\n            background-color: skyblue;\n            margin: 0 auto 200px;\n            padding: 10px;\n            border: 15px solid red;\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div class=&quot;father&quot;&gt;\n        &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div class=&quot;w&quot;&gt;&lt;/div&gt;\n    &lt;script&gt;\n        // offset 系列\n        var father = document.querySelector(&#39;.father&#39;);\n        var son = document.querySelector(&#39;.son&#39;);\n        // 1.可以得到元素的偏移 位置 返回的不带单位的数值  \n        console.log(father.offsetTop);\n        console.log(father.offsetLeft);\n        // 它以带有定位的父亲为准  如果么有父亲或者父亲没有定位 则以 body 为准\n        console.log(son.offsetLeft);\n        var w = document.querySelector(&#39;.w&#39;);\n        // 2.可以得到元素的大小 宽度和高度 是包含padding + border + width \n        console.log(w.offsetWidth);\n        console.log(w.offsetHeight);\n        // 3. 返回带有定位的父亲 否则返回的是body\n        console.log(son.offsetParent); // 返回带有定位的父亲 否则返回的是body\n        console.log(son.parentNode); // 返回父亲 是最近一级的父亲 亲爸爸 不管父亲有没有定位\n    &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n\noffset与style的区别\n\n\n\noffset\nstyle\n\n\n\noffset可以得到任意样式表中的样式值\nstyle只能得到行内样式表中的样式值\n\n\noffset系列获得的数值是没有单位的\nstyle.width获得的是带有单位的字符串\n\n\noffsetWidth 包含padding+border+width\nstyle.width获得不包含padding和border的值\n\n\noffsetWidth 等属性是只读属性，只能获取不能赋值\nstyle.width是可读写属性，可以获取也可以赋值\n\n\n获取元素大小位置、用offset更合适\n想要给元素更改值，则需要用style\n\n\n\n代码：\n\n    //获取鼠标在盒子内的坐标\n    &lt;script&gt;\n        // 我们在盒子内点击， 想要得到鼠标距离盒子左右的距离。\n        // 首先得到鼠标在页面中的坐标（ e.pageX, e.pageY）\n        // 其次得到盒子在页面中的距离(box.offsetLeft, box.offsetTop)\n        // 用鼠标距离页面的坐标减去盒子在页面中的距离， 得到 鼠标在盒子内的坐标\n        var box = document.querySelector(&#39;.box&#39;);\n        box.addEventListener(&#39;mousemove&#39;, function (e) &#123;\n            var x = e.pageX - this.offsetLeft;\n            var y = e.pageY - this.offsetTop;\n            this.innerHTML = &#39;x坐标是&#39; + x + &#39; y坐标是&#39; + y;\n        &#125;)\n    &lt;/script&gt;\n\n5.2 元素可视区client系列\nclient翻译过来就是客户端，我们使用client系列的相关属性来获取元素可视区的相关信息。通过client 系列的相关属性可以动态的得到该元素的边框大小、元素大小等\n\n\n\n\nclient系列属性\n作用\n\n\n\nelement.clientTop\n返回元素上边框的大小\n\n\nelement.clientLeft\n返回元素左边框的大小\n\n\nelement.clientWidth\n返回自身包括padding 、内容区的宽度，不含边框，返回数值不带单位\n\n\nelement.clientHeight\n返回自身包括padding 、内容区的高度，不含边框，返回数值不带单位\n\n\n立即执行函数\n\n立即执行函数**(function() {})()或者(function(){}())**\n主要作用:创建一个独立的作用域；避免了命名冲突问题\n代码：\n\n    &lt;script&gt;\n        // 1.立即执行函数: 不需要调用，立马能够自己执行的函数\n        function fn() &#123;\n            console.log(1);\n        &#125;\n        fn();\n        // 2. 写法 也可以传递参数进来\n        // 1.(function() &#123;&#125;)()    或者  2. (function()&#123;&#125;());\n        (function (a, b) &#123;\n            console.log(a + b);\n            var num = 10;\n        &#125;)(1, 2); // 第二个小括号可以看做是调用函数\n        (function sum(a, b) &#123;\n            console.log(a + b);\n            var num = 10; // 局部变量\n        &#125;(2, 3));\n        // 3. 立即执行函数最大的作用就是 独立创建了一个作用域, 里面所有的变量都是局部变量 不会有命名冲突的情况\n    &lt;/script&gt;\n\nflexible.js源码分析\n\n代码：\n\n(function flexible(window, document) &#123;\n    // 获取的html 的根元素\n    var docEl = document.documentElement\n    // dpr 物理像素比\n    var dpr = window.devicePixelRatio || 1\n\n    // adjust body font size  设置我们body 的字体大小\n    function setBodyFontSize() &#123;\n        // 如果页面中有body 这个元素 就设置body的字体大小\n        if (document.body) &#123;\n            document.body.style.fontSize = (12 * dpr) + &#39;px&#39;\n        &#125; else &#123;\n            // 如果页面中没有body 这个元素，则等着 我们页面主要的DOM元素加载完毕再去设置body\n            // 的字体大小\n            document.addEventListener(&#39;DOMContentLoaded&#39;, setBodyFontSize)\n        &#125;\n    &#125;\n    setBodyFontSize();\n\n    // set 1rem = viewWidth / 10    设置我们html 元素的文字大小\n    function setRemUnit() &#123;\n        var rem = docEl.clientWidth / 10\n        docEl.style.fontSize = rem + &#39;px&#39;\n    &#125;\n\n    setRemUnit()\n\n    // reset rem unit on page resize  当我们页面尺寸大小发生变化的时候，要重新设置下rem 的大小\n    window.addEventListener(&#39;resize&#39;, setRemUnit)\n    // pageshow 是我们重新加载页面触发的事件\n    window.addEventListener(&#39;pageshow&#39;, function (e) &#123;\n        // e.persisted 返回的是true 就是说如果这个页面是从缓存取过来的页面，也需要从新计算一下rem 的大小\n        if (e.persisted) &#123;\n            setRemUnit()\n        &#125;\n    &#125;)\n\n    // detect 0.5px supports  有些移动端的浏览器不支持0.5像素的写法\n    if (dpr &gt;= 2) &#123;\n        var fakeBody = document.createElement(&#39;body&#39;)\n        var testElement = document.createElement(&#39;div&#39;)\n        testElement.style.border = &#39;.5px solid transparent&#39;\n        fakeBody.appendChild(testElement)\n        docEl.appendChild(fakeBody)\n        if (testElement.offsetHeight === 1) &#123;\n            docEl.classList.add(&#39;hairlines&#39;)\n        &#125;\n        docEl.removeChild(fakeBody)\n    &#125;\n&#125;(window, document))\n\n\n下面三种情况都会刷新页面都会触发load 事件\na标签的超链接\nF5或者刷新按钮(强制刷新)\n前进后退按钮\n\n\n但是火狐中，有个特点，有个“往返缓存”，这个缓存中不仅保存着页面数据，还保存了DOM和JavaScript的状态;实际上是将整个页面都保存在了内存里；所以此时后退按钮不能刷新页面\n此时可以使用pageshow事件来触发，这个事件在页面显示时触发，无论页面是否来自缓存。在重新加载页面中，pageshow会在load事件触发后触发;根据事件对象中的persisted来判断是否是缓存中的页面触发的pageshow事件，注意这个事件给window添加\n\n5.3 元素滚动scroll系列\nscroll翻译过来就是滚动的，我们使用scroll系列的相关属性可以动态的得到该元素的大小、滚动距离等\n\n\n\n\n\nscroll系列属性\n作用\n\n\n\nelement.scrollTop\n返回被卷去的上侧距离，返回数值不带单位\n\n\nelement.scrollLeft\n返回被卷去的左侧距离，返回数值不带单位\n\n\nelement.scrollWidth\n返回自身内容实际的宽度、不含边框、返回数值不带单位\n\n\nelement.scrollHeight\n返回自身内容实际的高度、不含边框、返回数值不带单位\n\n\n\n代码：\n\n//仿淘宝侧边栏\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;style&gt;\n        .slider-bar &#123;\n            position: absolute;\n            left: 50%;\n            top: 300px;\n            margin-left: 600px;\n            width: 45px;\n            height: 130px;\n            background-color: pink;\n        &#125;\n\n        .w &#123;\n            width: 1200px;\n            margin: 10px auto;\n        &#125;\n\n        .header &#123;\n            height: 150px;\n            background-color: purple;\n        &#125;\n\n        .banner &#123;\n            height: 250px;\n            background-color: skyblue;\n        &#125;\n\n        .main &#123;\n            height: 1000px;\n            background-color: yellowgreen;\n        &#125;\n\n        span &#123;\n            display: none;\n            position: absolute;\n            bottom: 0;\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div class=&quot;slider-bar&quot;&gt;\n        &lt;span class=&quot;goBack&quot;&gt;返回顶部&lt;/span&gt;\n    &lt;/div&gt;\n    &lt;div class=&quot;header w&quot;&gt;头部区域&lt;/div&gt;\n    &lt;div class=&quot;banner w&quot;&gt;banner区域&lt;/div&gt;\n    &lt;div class=&quot;main w&quot;&gt;主体部分&lt;/div&gt;\n    &lt;script&gt;\n        //1. 获取元素\n        var sliderbar = document.querySelector(&#39;.slider-bar&#39;);\n        var banner = document.querySelector(&#39;.banner&#39;);\n        // banner.offestTop 就是被卷去头部的大小 一定要写到滚动的外面\n        var bannerTop = banner.offsetTop\n        // 当我们侧边栏固定定位之后应该变化的数值\n        var sliderbarTop = sliderbar.offsetTop - bannerTop;\n        // 获取main 主体元素\n        var main = document.querySelector(&#39;.main&#39;);\n        var goBack = document.querySelector(&#39;.goBack&#39;);\n        var mainTop = main.offsetTop;\n        // 2. 页面滚动事件 scroll\n        document.addEventListener(&#39;scroll&#39;, function () &#123;\n            // 3 .当我们页面被卷去的头部大于等于了 172 此时 侧边栏就要改为固定定位\n            if (window.pageYOffset &gt;= bannerTop) &#123;\n                sliderbar.style.position = &#39;fixed&#39;;\n                sliderbar.style.top = sliderbarTop + &#39;px&#39;;\n            &#125; else &#123;\n                sliderbar.style.position = &#39;absolute&#39;;\n                sliderbar.style.top = &#39;300px&#39;;\n            &#125;\n            // 4. 当我们页面滚动到main盒子，就显示 goback模块\n            if (window.pageYOffset &gt;= mainTop) &#123;\n                goBack.style.display = &#39;block&#39;;\n            &#125; else &#123;\n                goBack.style.display = &#39;none&#39;;\n            &#125;\n        &#125;)\n    &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n\n页面被卷去的头部兼容性解决\n\n如果浏览器的高（或宽)度不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏掉的高度，我们就称为页面被卷去的头部。滚动条在滚动时会触发onscroll事件\n需要注意的是，页面被卷去的头部，有兼容性问题，因此被卷去的头部通常有如下几种写法:\n声明了DTD，使用document.documentElement.scrollTop\n未声明DTD，使用document.body.scrollTop\n新方法window. pageYoffset和window.pageXoffset，IE9开始支持\n\n\n\nfunction getScroll() &#123;\n    return &#123;\n      left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft||0,\n      top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0\n    &#125;;\n &#125; \n//使用的时候  getScroll().left\n\n三大系列总结\n\noffset系列经常用于获得元素位置offsetLeft offsetTop\nclient经常用于获取元素大小clientWidth clientHeight\nscroll经常用于获取滚动距离scrollTop scrollLeft\n注意页面滚动的距离通过window.pageXoffset获得\n\nmouseenter和mouseover的区别\n\n当鼠标移动到元素上时就会触发mouseenter事件，类似mouseover，它们两者之间的差别是mouseover鼠标经过自身盒子会触发，经过子盒子还会触发。mouseenter只会经过自身盒子触发。之所以这样，就是因为mouseenter不会冒泡；跟mouseenter搭配，鼠标离开 mouseleave 同样不会冒泡\n\n5.4 动画函数封装动画实现原理\n\n核心原理:通过定时器setlnterval()不断移动盒子位置\n\n实现步骤:\n\n获得盒子当前位置\n让盒子在当前位置加上1个移动距离\n利用定时器不断重复这个操作\n加一个结束定时器的条件\n注意此元素需要添加定位，才能使用element.style.left\n\n\n代码：\n\n\n    &lt;div&gt;&lt;/div&gt;//绝对定位\n    &lt;script&gt;\n        var div = document.querySelector(&#39;div&#39;);\n        var timer = setInterval(function () &#123;\n            if (div.offsetLeft &gt;= 400) &#123;\n                // 停止动画 本质是停止定时器\n                clearInterval(timer);\n            &#125;\n            div.style.left = div.offsetLeft + 1 + &#39;px&#39;;//改变 = 获取 + 1 + &#39;px&#39;\n        &#125;, 30);\n    &lt;/script&gt;\n\n动画函数简单封装\n\n函数需要传递2个参数，动画对象和移动到的距离\n代码：\n\n// 简单动画函数封装obj目标对象 target 目标位置\n        function animate(obj, target) &#123;\n            var timer = setInterval(function () &#123;\n                if (obj.offsetLeft &gt;= target) &#123;\n                    // 停止动画 本质是停止定时器\n                    clearInterval(timer);\n                &#125;\n                obj.style.left = obj.offsetLeft + 1 + &#39;px&#39;;\n\n            &#125;, 30);\n        &#125;\n\n动画函数给不同元素记录不同定时器\n\n如果多个元素都使用这个动画函数，每次都要var声明定时器。我们可以给不同的元素使用不同的定时器(自己专门用自己的定时器)\n核心原理:利用JS是一门动态语言，可以很方便的给当前对象添加属性\n代码：\n\nfunction animate(obj, target) &#123;\n            // 当我们不断的点击按钮，这个元素的速度会越来越快，因为开启了太多的定时器\n            // 解决方案就是 让我们元素只有一个定时器执行\n            // 先清除以前的定时器，只保留当前的一个定时器执行\n            clearInterval(obj.timer);\n            obj.timer = setInterval(function () &#123;\n                if (obj.offsetLeft &gt;= target) &#123;\n                    // 停止动画 本质是停止定时器\n                    clearInterval(obj.timer);\n                &#125;\n                obj.style.left = obj.offsetLeft + 1 + &#39;px&#39;;\n            &#125;, 30);\n        &#125;\n\n缓动效果原理\n\n缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来\n\n思路:\n\n让盒子每次移动的距离慢慢变小，速度就会慢慢落下来\n核心算法:(目标值-现在的位置)&#x2F; 10 作为每次移动的距离步长\n停止的条件是:让当前盒子位置等于目标位置就停止定时器\n注意步长值需要取整\n\n\n代码：\n\n\nfunction animate(obj, target) &#123;\n            // 先清除以前的定时器，只保留当前的一个定时器执行\n            clearInterval(obj.timer);\n            obj.timer = setInterval(function () &#123;\n                // 步长值写到定时器的里面\n                var step = (target - obj.offsetLeft) / 10;\n                if (obj.offsetLeft == target) &#123;\n                    // 停止动画 本质是停止定时器\n                    clearInterval(obj.timer);\n                &#125;\n                // 把每次加1 这个步长值改为一个慢慢变小的值  步长公式：(目标值 - 现在的位置) / 10\n                obj.style.left = obj.offsetLeft + step + &#39;px&#39;;\n            &#125;, 15);\n        &#125;\n\n动画函数多个目标值之间移动\n\n可以让动画函数从800移动到500\n\n当我们点击按钮时候，判断步长是正值还是负值\n\n如果是正值，则步长往大了取整\n如果是负值，则步长向小了取整\n\n\n代码：\n\n\nfunction animate(obj, target) &#123;\n            // 先清除以前的定时器，只保留当前的一个定时器执行\n            clearInterval(obj.timer);\n            obj.timer = setInterval(function () &#123;\n                // 步长值写到定时器的里面\n                // 把我们步长值改为整数 不要出现小数的问题\n                // var step = Math.ceil((target - obj.offsetLeft) / 10);\n                var step = (target - obj.offsetLeft) / 10;\n                step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);\n                if (obj.offsetLeft == target) &#123;\n                    // 停止动画 本质是停止定时器\n                    clearInterval(obj.timer);\n                &#125;\n                // 把每次加1 这个步长值改为一个慢慢变小的值  步长公式：(目标值 - 现在的位置) / 10\n                obj.style.left = obj.offsetLeft + step + &#39;px&#39;;\n            &#125;, 15);\n        &#125;\n\n动画函数添加回调函数\n\n回调函数原理:函数可以作为一个参数。将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数，这个过程就叫做回调\n\n回调函数写的位置:定时器结束的位置\n\n代码：\n\n\nfunction animate(obj, target, callback) &#123;\n            // console.log(callback);  callback = function() &#123;&#125;  调用的时候 callback()\n            // 先清除以前的定时器，只保留当前的一个定时器执行\n            clearInterval(obj.timer);\n            obj.timer = setInterval(function () &#123;\n                // 步长值写到定时器的里面\n                // 把我们步长值改为整数 不要出现小数的问题\n                // var step = Math.ceil((target - obj.offsetLeft) / 10);\n                var step = (target - obj.offsetLeft) / 10;\n                step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);\n                if (obj.offsetLeft == target) &#123;\n                    // 停止动画 本质是停止定时器\n                    clearInterval(obj.timer);\n                    // 回调函数写到定时器结束里面\n                    if (callback) &#123;\n                        // 调用函数\n                        callback();\n                    &#125;\n                &#125;\n                // 把每次加1 这个步长值改为一个慢慢变小的值  步长公式：(目标值 - 现在的位置) / 10\n                obj.style.left = obj.offsetLeft + step + &#39;px&#39;;\n            &#125;, 15);\n        &#125; \n\n动画函数封装到单独JS文件里面\n\n因为以后经常使用这个动画函数，可以单独封装到一个ls文件里面，使用的时候引用这个JS文件即可\n\n单独新建一个JS文件\nHTML文件引入JS文件\n\n\n代码：\n\n\n//animate.js\nfunction animate(obj, target, callback) &#123;\n    // console.log(callback);  callback = function() &#123;&#125;  调用的时候 callback()\n\n    // 先清除以前的定时器，只保留当前的一个定时器执行\n    clearInterval(obj.timer);\n    obj.timer = setInterval(function () &#123;\n        // 步长值写到定时器的里面\n        // 把我们步长值改为整数 不要出现小数的问题\n        // var step = Math.ceil((target - obj.offsetLeft) / 10);\n        var step = (target - obj.offsetLeft) / 10;\n        step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);\n        if (obj.offsetLeft == target) &#123;\n            // 停止动画 本质是停止定时器\n            clearInterval(obj.timer);\n            // 回调函数写到定时器结束里面\n            // if (callback) &#123;\n            //     // 调用函数\n            //     callback();\n            // &#125;\n            callback &amp;&amp; callback();\n        &#125;\n        // 把每次加1 这个步长值改为一个慢慢变小的值  步长公式：(目标值 - 现在的位置) / 10\n        obj.style.left = obj.offsetLeft + step + &#39;px&#39;;\n    &#125;, 15);\n&#125;\n\n5.5 常见网页特效案例轮播图\n\n轮播图也称为焦点图，是网页中比较常见的网页特效。\n功能需求:\n鼠标经过轮播图模块，左右按钮显示，离开隐藏左右按钮\n点击右侧按钮一次，图片往左播放一张，以此类推，左侧按钮同理\n图片播放的同时，下面小圆圈模块跟随─起变化\n点击小圆圈，可以播放相应图片\n鼠标不经过轮播图，轮播图也会自动播放图片\n鼠标经过，轮播图模块，自动播放停止\n\n\n\n节流阀\n\n防止轮播图按钮连续点击造成播放过快\n节流阀目的:当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发\n核心实现思路:利用回调函数，添加一个变量来控制，锁住函数和解锁函数(操作系统信号量PV操作)\n开始设置一个变量var flag &#x3D; true;\nlf(flag) {flag &#x3D; false; do something}关闭水龙头\n利用回调函数动画执行完毕, flag &#x3D; true打开水龙头\n\n\n\n6、移动端网页特效6.1 触屏事件触屏事件概述\n\n移动端浏览器兼容性较好，我们不需要考虑以前JS的兼容性问题，可以放心的使用原生S书写效果，但是移动端也有自己独特的地方。比如触屏事件 touch(也称触摸事件)，Android和IOS都有\ntouch对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指(或触控笔)对屏幕或者触控板操作\n常见的触屏事件如下：\n\n\n\n\n触屏touch事件\n说明\n\n\n\ntouchstart\n手指触摸到一个DOM元素时触发\n\n\ntouchmove\n手指在一个DOM元素上滑动时触发\n\n\ntouchend\n手指从一个DOM元素移开时触发\n\n\n\n代码：\n\n    &lt;div&gt;&lt;/div&gt;\n    &lt;script&gt;\n        // 1. 获取元素\n        // 2. 手指触摸DOM元素事件\n        var div = document.querySelector(&#39;div&#39;);\n        div.addEventListener(&#39;touchstart&#39;, function () &#123;\n            console.log(&#39;我摸了你&#39;);\n        &#125;);\n        // 3. 手指在DOM元素身上移动事件\n        div.addEventListener(&#39;touchmove&#39;, function () &#123;\n            console.log(&#39;我继续摸&#39;);\n        &#125;);\n        // 4. 手指离开DOM元素事件\n        div.addEventListener(&#39;touchend&#39;, function () &#123;\n            console.log(&#39;轻轻的我走了&#39;);\n        &#125;);\n    &lt;/script&gt;\n\n触摸事件对象\n\nTouchEvent是一类描述手指在触摸平面（触摸屏、触摸板等）的状态变化的事件这类事件用于描述一个或多个触点，使开发者可以检测触点的移动，触点的增加和减少，等等\ntouchstart、touchmove、touchend三个事件都会各自有事件对象\n\n\n\n\n触摸列表\n说明\n\n\n\ntouches\n正在触摸屏幕的所有手指的一个列表\n\n\ntargetTouches\n正在触摸当前DOM元素上的手指的一个列表\n\n\nchangedTouches\n手指状态发生了改变的列表，从无到有，从有到无变化\n\n\n移动端拖动元素\n\ntouchstart、touchmove、touchend可以实现拖动元素；但是拖动元素需要当前手指的坐标值；我们可以使用targetTouches[0]里面的pageX和pageY\n\n移动端拖动的原理:手指移动中，计算出手指移动的距离；然后用盒子原来的位置＋手指移动的距离\n\n手指移动的距离:手指滑动中的位置减去手指刚开始触摸的位置\n\n拖动元素三步曲:\n\n触摸元素touchstart: 获取手指初始坐标，同时获得盒子原来的位置\n移动手指touchmove: 计算手指的滑动距离，并且移动盒子\n离开手指touchend:\n\n\n注意:手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动e.preventDefault();\n\n代码：\n\n\n    &lt;div&gt;&lt;/div&gt;\n    &lt;script&gt;\n        // （1） 触摸元素 touchstart：  获取手指初始坐标，同时获得盒子原来的位置\n        // （2） 移动手指 touchmove：  计算手指的滑动距离，并且移动盒子\n        // （3） 离开手指 touchend:\n        var div = document.querySelector(&#39;div&#39;);\n        var startX = 0; //获取手指初始坐标\n        var startY = 0;\n        var x = 0; //获得盒子原来的位置\n        var y = 0;\n        div.addEventListener(&#39;touchstart&#39;, function (e) &#123;\n            //  获取手指初始坐标\n            startX = e.targetTouches[0].pageX;\n            startY = e.targetTouches[0].pageY;\n            x = this.offsetLeft;\n            y = this.offsetTop;\n        &#125;);\n\n        div.addEventListener(&#39;touchmove&#39;, function (e) &#123;\n            //  计算手指的移动距离： 手指移动之后的坐标减去手指初始的坐标\n            var moveX = e.targetTouches[0].pageX - startX;\n            var moveY = e.targetTouches[0].pageY - startY;\n            // 移动我们的盒子 盒子原来的位置 + 手指移动的距离\n            this.style.left = x + moveX + &#39;px&#39;;\n            this.style.top = y + moveY + &#39;px&#39;;\n            e.preventDefault(); // 阻止屏幕滚动的默认行为\n        &#125;);\n    &lt;/script&gt;\n\n6.2 移动端常见特效classList属性\n\nclassList属性是HTML5新增的一个属性，返回元素的类名。但是ie10以上版本支持。该属性用于在元素中添加，移除及切换CSS类，对类选择器进行操作\n添加类:element.classList.add (’类名’) ;\n移除类:element.classList.remove (’类名’);\n切换类:element.classList.toggle (’类名’)；\n注意以上方法里面，所有类名都不带点\n\nclick延时解决方案\n\n移动端click事件会有300ms的延时，原因是移动端屏幕双击会缩放(double tap to zoom)页面\n\n解决方案:\n\n\n\n禁用缩放。浏览器禁用默认的双击缩放行为并且去掉300ms的点击延迟\n缺点：有的页面就是要使用双击缩放功能\n\n\n\n&lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot;&gt;\n\n\n利用touch事件自己封装这个事件解决300ms延迟\n缺点：只能给一个元素使用\n\n\n\n\n原理就是:\n\n当我们手指触摸屏幕，记录当前触摸时间\n当我们手指离开屏幕，用离开的时间减去触摸的时间\n如果时间小于150ms，并且没有滑动过屏幕，那么我们就定义为点击\n\n\n代码：\n\n\n//封装tap，解决click 300ms 延时\nfunction tap (obj, callback) &#123;\n        var isMove = false;\n        var startTime = 0; // 记录触摸时候的时间变量\n        obj.addEventListener(&#39;touchstart&#39;, function (e) &#123;\n            startTime = Date.now(); // 记录触摸时间\n        &#125;);\n        obj.addEventListener(&#39;touchmove&#39;, function (e) &#123;\n            isMove = true;  // 看看是否有滑动，有滑动算拖拽，不算点击\n        &#125;);\n        obj.addEventListener(&#39;touchend&#39;, function (e) &#123;\n            if (!isMove &amp;&amp; (Date.now() - startTime) &lt; 150) &#123;  // 如果手指触摸和离开时间小于150ms 算点击\n                callback &amp;&amp; callback(); // 执行回调函数\n            &#125;\n            isMove = false;  //  取反 重置\n            startTime = 0;\n        &#125;);\n&#125;\n//调用  \ntap(div, function()&#123;   // 执行代码  &#125;);\n\n\n使用插件。fastclick插件解决300ms延迟\n推荐\n\n\n\n\n代码：\n\nif (&#39;addEventListener&#39; in document) &#123;\n            document.addEventListener(&#39;DOMContentLoaded&#39;, function() &#123;\n                       FastClick.attach(document.body);\n            &#125;, false);\n&#125;\n\n6.3 移动端常见开发插件插件的定义\n\nJS插件是js文件，它遵循一定规范编写，方便程序展示效果，拥有特定功能且方便调用。如轮播图和瀑布流插件\n特点:它一般是为了解决某个问题而专门存在，其功能单一，并且比较小\n\n插件的使用\n\n确认插件实现的功能\n去官网查看使用说明\n下载插件\n打开demo实例文件，查看需要引入的相关文件，并且引入\n复制demo实例文件中的结构html，样式css以及js代码\n\n移动端常见插件\n\n解决延时：ftlabs&#x2F;fastclick: Polyfill to remove click delays on browsers with touch UIs (github.com)\n轮播图：Swiper中文网-轮播图幻灯片js插件,H5页面前端开发\nSuperSlide | TouchSlide 官方网站 大话主席 (superslide2.com)\ncubiq&#x2F;iscroll: Smooth scrolling for the web (github.com)\n\n6.4 移动端常用开发框架框架概述\n\n框架，顾名思义就是一套架构，它会基于自身的特点向用户提供一套较为完整的解决方案。框架的控制权在框架本身，使用者要按照框架所规定的某种规范进行开发\n插件一般是为了解决某个问题而专门存在，其功能单一，并且比较小\n前端常用的框架有Bootstrap、Vue、Angular、React等。既能开发PC端，也能开发移动端前端常用的移动端\n插件有swiper、superslide、iscroll等\n框架:大而全，一整套解决方案\n插件:小而专一，某个功能的解决方案\n\nBootstrap\n\nBootstrap是一个简洁、直观、强悍的前端开发框架，它让web开发更迅速、简单。它能开发PC端，也能开发移动端\nBootstrap JS插件使用步骤:\n引入相关js文件\n复制HTML结构\n修改对应样式\n修改相应JS参数\n\n\n\n7、本地存储7.1 本地存储\n数据存储在用户浏览器中\n设置、读取方便、甚至页面刷新不丢失数据\n容量较大,sessionStorage约5M、localStorage约20M\n只能存储字符串，可以将对象JSON.stringify()编码后存储\n\n7.2 window.sessionStorage\n生命周期为关闭浏览器窗口\n在同一个窗口(页面)下数据可以共享\n以键值对的形式存储使用\n\n\n存储数据：sessionStorage.setItem(key, value)\n获取数据：sessionStorage.getItem(key)\n删除数据：sessionStorage.removeItem(key)\n删除所有数据：sessionStorage.clear()\n\n7.3 window.localStorage\n声明周期永久生效，除非手动删除否则关闭页面也会存在\n可以多窗口(页面)共享(同一浏览器可以共享)\n以键值对的形式存储使用\n\n\n存储数据：localStorage.setItem(key, value)\n获取数据：localStorage.getItem(key)\n删除数据：localStorage.removeItem(key)\n删除所有数据：localStorage.clear()p (obj, callback) {  var isMove &#x3D; false;  var startTime &#x3D; 0; &#x2F;&#x2F; 记录触摸时候的时间变量  obj.addEventListener(‘touchstart’, function (e) {      startTime &#x3D; Date.now(); &#x2F;&#x2F; 记录触摸时间  });  obj.addEventListener(‘touchmove’, function (e) {      isMove &#x3D; true;  &#x2F;&#x2F; 看看是否有滑动，有滑动算拖拽，不算点击  });  obj.addEventListener(‘touchend’, function (e) {      if (!isMove &amp;&amp; (Date.now() - startTime) &lt; 150) {  &#x2F;&#x2F; 如果手指触摸和离开时间小于150ms 算点击          callback &amp;&amp; callback(); &#x2F;&#x2F; 执行回调函数      }      isMove &#x3D; false;  &#x2F;&#x2F;  取反 重置      startTime &#x3D; 0;  });\n\n}&#x2F;&#x2F;调用tap(div, function(){   &#x2F;&#x2F; 执行代码  });\n\n3. 使用插件。fastclick插件解决300ms延迟\n   * 推荐\n\n* 代码：\n\n~~~javascript\nif (&#39;addEventListener&#39; in document) &#123;\n            document.addEventListener(&#39;DOMContentLoaded&#39;, function() &#123;\n                       FastClick.attach(document.body);\n            &#125;, false);\n&#125;\n\n6.3 移动端常见开发插件插件的定义\n\nJS插件是js文件，它遵循一定规范编写，方便程序展示效果，拥有特定功能且方便调用。如轮播图和瀑布流插件\n特点:它一般是为了解决某个问题而专门存在，其功能单一，并且比较小\n\n插件的使用\n\n确认插件实现的功能\n去官网查看使用说明\n下载插件\n打开demo实例文件，查看需要引入的相关文件，并且引入\n复制demo实例文件中的结构html，样式css以及js代码\n\n移动端常见插件\n\n解决延时：ftlabs&#x2F;fastclick: Polyfill to remove click delays on browsers with touch UIs (github.com)\n轮播图：Swiper中文网-轮播图幻灯片js插件,H5页面前端开发\nSuperSlide | TouchSlide 官方网站 大话主席 (superslide2.com)\ncubiq&#x2F;iscroll: Smooth scrolling for the web (github.com)\n\n6.4 移动端常用开发框架框架概述\n\n框架，顾名思义就是一套架构，它会基于自身的特点向用户提供一套较为完整的解决方案。框架的控制权在框架本身，使用者要按照框架所规定的某种规范进行开发\n插件一般是为了解决某个问题而专门存在，其功能单一，并且比较小\n前端常用的框架有Bootstrap、Vue、Angular、React等。既能开发PC端，也能开发移动端前端常用的移动端\n插件有swiper、superslide、iscroll等\n框架:大而全，一整套解决方案\n插件:小而专一，某个功能的解决方案\n\nBootstrap\n\nBootstrap是一个简洁、直观、强悍的前端开发框架，它让web开发更迅速、简单。它能开发PC端，也能开发移动端\nBootstrap JS插件使用步骤:\n引入相关js文件\n复制HTML结构\n修改对应样式\n修改相应JS参数\n\n\n\n7、本地存储7.1 本地存储\n数据存储在用户浏览器中\n设置、读取方便、甚至页面刷新不丢失数据\n容量较大,sessionStorage约5M、localStorage约20M\n只能存储字符串，可以将对象JSON.stringify()编码后存储\n\n7.2 window.sessionStorage\n生命周期为关闭浏览器窗口\n在同一个窗口(页面)下数据可以共享\n以键值对的形式存储使用\n\n\n存储数据：sessionStorage.setItem(key, value)\n获取数据：sessionStorage.getItem(key)\n删除数据：sessionStorage.removeItem(key)\n删除所有数据：sessionStorage.clear()\n\n7.3 window.localStorage\n声明周期永久生效，除非手动删除否则关闭页面也会存在\n可以多窗口(页面)共享(同一浏览器可以共享)\n以键值对的形式存储使用\n\n\n存储数据：localStorage.setItem(key, value)\n获取数据：localStorage.getItem(key)\n删除数据：localStorage.removeItem(key)\n删除所有数据：localStorage.clear()\n\n","slug":"前端--JavaScript Bom和Dom","date":"2022-12-23T13:17:23.000Z","categories_index":"前端","tags_index":"JavaScript","author_index":"会思想的苇草i"},{"id":"20bde650eb44b90bc389cc737e93f282","title":"JavaScript入门：掌握基础语法","content":"JavaScript 基础1、JavaScript介绍\nJavaScript是一种运行在客户端（浏览器）的编程语言，实现人机交互效果\n作用：\n网页特效(监听用户的一些行为让网页作出对应的反馈)\n表单验证(针对表单数据的合法性进行判断)\n数据交互(获取后台的数据,渲染到前端)\n服务端编程(node.js)\n\n\n\n\n\nJavaScript组成：\nECMAScript:\n规定了js基础语法核心知识。比如:变量、分支语句、循环语句、对象等等\n\n\nWeb APls :\nDOM操作文档，比如对页面元素进行移动、大小、添加删除等操作\nBOM操作浏览器，比如页面弹窗，检测窗口宽度、存储数据到浏览器等等\n\n\n\n\n\n\n\nJavaScript书写位置：\n\n\n\n内部JavaScript：直接写在html文件里，用script标签包住，写在&lt; &#x2F;body&gt;上面\n\n注意：我们将&lt; script&gt;放在HTML文件的底部附近的原因是浏览器会按照代码在文件中的顺序加载HTML。如果先加载的JavaScript期望修改其下方的HTML，那么它可能由于HTML尚未被加载而失效。\n\n代码：\n\n\n\n\n&lt;script&gt;\n        alert(&#39;你好， js&#39;)\n&lt;/script&gt;\n\n\n外部JavaScript：代码写在以.js结尾的文件中，通过script标签，引入html页面中\n注意：**&lt; script &gt;标签中间无需写代码，否则会被忽略**\n代码：\n\n\n\n&lt;script src=&quot;./my.js&quot;&gt;&lt;/script&gt;\n\n\n内联JavaScript：代码写在标签内部\n代码：\n\n\n\n&lt;button onclick=&quot;alert(&#39;月薪过万&#39;)&quot;&gt;点击我&lt;/button&gt;\n\n\nJavaScript注释：\n\n单行注释：\n符号：&#x2F;&#x2F;\n作用：&#x2F;&#x2F;右边这一行的代码会被忽略\n快捷键：ctrl + &#x2F;\n\n\n块注释：\n符号：&#x2F;* *&#x2F;\n\n作用：在&#x2F;* 和 *&#x2F;之间的所有内容都会被忽略\n\n快捷键：shift+alt+A\n\n\n\n\n\nJavaScript结束符\n\n代表语句结束\n英文分号；\n可写可不写\n换行符会被识别成结束符，所以一个完整的语句，不要手动换行\n\n\nJavaScript输入输出语法\n\n\n    &lt;script&gt;\n        // 1.document 向body内输入内容\n        document.write(&#39;我愿意&#39;)\n        document.write(&#39;&lt;h1&gt;我愿意&lt;/h1&gt;&#39;)\n        // 2. alert 页面弹出警告对话框\n        //alert(&#39;河工大&#39;)\n        // 3. 控制台输出语法  程序员看的\n        //console.log(&#39;我是用来测试的&#39;)\n        // 4. 输入语句 prompt\n        //prompt(&#39;您今年多大了？&#39;)\n    &lt;/script&gt;\n\n\n字面量：在计算机科学中，字面量( literal)是在计算机中描述事&#x2F;物；如数字字面量、字符串字面量，对象字面量…\n\n2、变量\n变量是计算机中用于存储数据的“容器”，它可以让计算机变得有记忆\n\n\n\n变量的基本使用\n\n声明变量：声明关键字 变量名;(let age;)\n变量赋值：(age &#x3D; 18;)\n更新变量：(let age &#x3D; 18; age &#x3D; 19;)\n声明多个变量：(let age &#x3D; 18,name &#x3D; “haut”)\n\n\n变量的本质：是程序在内存中申请的一块用来存放数据的小空间\n\n变量命名规则与规范：\n\n规则：\n\n不能用关键字（关键字:有特殊含义的字符，JavaScript内置的一些英语词汇。例如: let、var、if、for等）\n只能用下划线、字母、数字、$组成，且数字不能开头\n字母严格区分大小写，如Age和age是不同的变量\n\n\n规范：\n\n起名要有意义\n遵守小驼峰命名法：第一个单词首字母小写，后面每个单词首字母大写。例: userName\n\n\n\n\n\n扩展：let和var的区别\n\nlet为了解决var的一些问题\n\nvar声明：\n\n可以先使用再声明(不合理)\nvar声明过的变量可以重复声明(不合理)\n比如变量提升、全局变量、没有块级作用域等等\n\n\n暂时统一声明变量时使用let\n\n\n扩展：数组\n\n数组是一种可以按顺序保存多个数据\n声明代码：\n\nlet 数组名 = [数据1，数据2，..，数据n]\n\n\n取值代码：\n\n数组名[下标]\n\n3、数据类型\n\n数字类型：整数、小数、正数、负数…\n代码：\n\n    &lt;script&gt;\n        let age = 18//正整数\n        let num = 3.141592653//小数\n        let num2 = -12//负数\n    &lt;/script&gt;\n\n\n注意：JS是弱数据类型，变量到底属于那种类型，只有赋值之后，我们才能确认\n\n字符串类型：通过单引号（’  ‘)、双引号（”  “)或反引号(‘)包裹的数据都叫字符串，单引号和双引号没有本质上的区别，推荐使用单引号。\n\n代码：\n\n\n    &lt;script&gt;\n        let num = 123\n        console.log(num)\n        console.log(&#39;num&#39;)\n        let str1 = `老师`\n        console.log(str1)\n        // 外单内双  外双内单\n        console.log(&#39;我是&quot;德华&quot;&#39;)\n        console.log(&quot;我是&#39;德华&#39;&quot;)\n        // console.log(&#39;我是\\&#39;德华\\&#39;&#39;) 转义符\n    &lt;/script&gt;\n\n\n注意：\n无论单引号或是双引号必须成对使用\n单引号&#x2F;双引号可以互相嵌套，但是不以自已嵌套自已（口诀:外双内单，或者外单内双)\n必要时可以使用转义符\\，输出单引号或双引号\n\n\n字符串拼接：\n\n    &lt;script&gt;      \n        let uname = prompt(&#39;请输入您的名字&#39;)\n        document.write(&#39;我的名字是：&#39; + uname)\n    &lt;/script&gt;\n\n\n模板字符串：用于拼接字符串和变量\n符号: &#96;&#96;(内容拼接变量时，用${}包住变量)\n\n    &lt;script&gt;\n        // 模板字符串\n        let age = 81\n        document.write(`&#39;我今年&#39;+(age-20)+&#39;岁了&#39;`)\n        document.write(`我今年$&#123;age - 20&#125;岁了`)      \n    &lt;/script&gt;\n\n\n布尔类型：它有两个固定的值true和false，表示肯定的数据用true(真)，表示否定的数据用false(假)\n代码：\n\n    &lt;script&gt;\n        // 布尔型 true false \n        console.log(true)\n        console.log(false)\n    &lt;/script&gt;\n\n\n注意：\n\n未定义类型：只声明变量，不赋值的情况下，变量的默认值为undefined，一般很少【直接】为某个变量赋值为undefined\n\n代码：\n\n\n    &lt;script&gt;\n        // undefined  只声明不赋值\n        let age\n        console.log(age)\n    &lt;/script&gt;\n\n\n注意：我们开发中经常声明一个变量，等待传送过来的数据。如果我们不知道这个数据是否传递过来，此时我们可以通过检测这个变量是不是undefined，就判断用户是否有数据传递过来。\n\n空类型\n\n代码：\n\n\n    &lt;script&gt;\n        //null  空\n        let obj = null\n        console.log(obj)\n    &lt;/script&gt;\n\n\n注意：undefined 表示没有赋值，null表示赋值了，但是内容为空；把null 作为尚未创建的对象\n\n控制台输出语句：控制台语句经常用于测试结果来使用。可以看出数字型和布尔型颜色为蓝色，字符串和undefined颜色为灰色\n\n通过typeof关键字检测数据类型：\n\n代码：\n\n\n    &lt;script&gt;\n        // 检测返回的什么类型  \n        console.log(typeof 123)//number\n        console.log(typeof &#39;123&#39;)//string\n        console.log(typeof true)//boolean\n        console.log(typeof undefined)//undefined\n        console.log(typeof null)//object\n        let num = 10\n        console.log(typeof num + &#39;11&#39;)//number11(字符串拼接)\n    &lt;/script&gt;\n\n扩展：基本数据类型和引用数据类型\n\n简单类型又叫做基本数据类型或者值类型，复杂类型又叫做引用类型\n值类型:简单数据类型&#x2F;基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型string , number,boolean,undefined,null\n引用类型:复杂数据类型，在存储时变量中存储的仅仅是地址（引用)，因此叫做引用数据类型通过new关键字创建的对象（系统对象、自定义对象），如Object、Array、Date等\n堆栈空间分配区别:\n栈（操作系统）︰由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈;简单数据类型存放到栈里面\n堆（操作系统）︰存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。引用数据类型存放到堆里面\n\n\n\n\n\n\n4、类型转换\n坑:使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算。\n\n此时需要转换变量的数据类型。通俗来说，就是把一种数据类型的变量转换成我们需要的数据类型。\n\n某些运算符被执行时，系统内部自动将数据类型进行转换，这种转换称为隐式转换。规则:\n\n＋号两边只要有一个是字符串，都会把另外一个转成字符串\n\n除了+以外的算术运算符比如–、*、&#x2F;等都会把数据转成数字类型\n\n缺点:转换类型不明确，靠经验才能总结\n\n小技巧: +号作为正号解析可以转换成Number\n\n\n\n代码：\n\n\n    &lt;script&gt;\n        // let num = prompt(&#39;请输入一个数字&#39;)\n        // console.log(num, typeof num)\n        // 内部悄悄的把 18 转换为了字符串的 &#39;18&#39;\n        console.log(&#39;hauter&#39; + 18)\n        console.log(10 + &#39;10&#39;)  //  1010\n        // - *  / 把 字符串的 &#39;10&#39; 转换为 数字型 10\n        console.log(10 - &#39;10&#39;) // 0\n        // 小技巧\n        let num = &#39;10&#39;\n        console.log(num)\n        console.log(+num)\n        // console.log(-num)\n        console.log(10 + +&#39;10&#39;)//20\n    &lt;/script&gt;\n\n\n编写程序时过度依靠系统内部的隐式转换是不严禁的，因为隐式转换规律并不清晰，大多是靠经验总结的规律。为了避免因隐式转换带来的问题，通常根逻辑需要对数据进行显示转换。\n\n转成数字类型\n\nNumber(数据)\n转成数字类型\n如果字符串内容里有非数字，转换失败时结果为NaN(Not a Number）即不是一个数字\nNaN也是number类型的数据，代表非数字\n\n\nparselnt(数据)\n只保留整数\n\n\nparseFloat(数据)\n可以保留小数 ，parseFloat 经常用于过滤px单位\n\n\n代码：\n\n    &lt;script&gt;\n        // let num = &#39;10&#39;  \n        // Number(数据)\n        console.log(Number(&#39;10.01&#39;))\n        // 转换为数字型，只保留整数，没有四舍五入\n        console.log(parseInt(&#39;10&#39;))\n        console.log(parseInt(&#39;10.111&#39;))\n        console.log(parseInt(&#39;10.999px&#39;))\n        // 转换为数字型，会保留小数\n        console.log(parseFloat(&#39;10.999&#39;))\n    &lt;/script&gt;\n\n\n转换为字符型:\n\nstring(数据)\n变量.toString(进制)\n代码：\n\n\n\n    &lt;script&gt;\n        console.log(String(10))\n        let age = 10\n        console.log(age.toString())\n        // 括号里面如果是2 转换为 二进制\n        console.log(age.toString(2))\n    &lt;/script&gt;\n\n5、 运算符算数运算符\n\n数学运算符也叫算术运算符，主要包括加、减、乘、除、取余（求模)。\n\n+：求和\n-：求差\n*：求积\n&#x2F;：求商\n%:取模（取余数) – 开发中经常作为某个数字是否被整除\n\n\n代码：\n\n\n    &lt;script&gt;\n        console.log(4 / 2)\n        console.log(4 % 2)\n        console.log(2 % 4)\n        console.log(5 % 8)\n    &lt;/script&gt;\n\n赋值运算符\n\n已经学过的赋值运算符:&#x3D;将等号右边的值赋予给左边，要求左边必须是一个容器\n其他赋值运算符:\n+&#x3D;\n-&#x3D;\n*&#x3D;\n&#x2F;&#x3D;\n%&#x3D;\n\n\n\n一元运算符\n\n自增:\n\n符号:++\n作用:让变量的值＋1\n\n\n自减:\n\n符号:–\n作用:让变量的值-1\n\n\n注意：前置自增 – 先自增后运算；后置自增 – 先运算后自增\n\n\n    &lt;script&gt;\n        let i = 1 \n        //\t\t\t 1    3    3\n        console.log(i++ + ++i + i)//7\n    &lt;/script&gt;\n\n比较运算符\n\n(&gt;):左边是否大于右边\n\n(&lt;):左边是否小于右边\n\n(&gt;&#x3D;):左边是否大于或等于右边\n\n(&lt;&#x3D;):左边是否小于或等于右边\n\n(&#x3D;&#x3D;):左右两边是否相等\n\n(&#x3D;&#x3D;&#x3D;):左右两边是否类型和值都相等\n\n(!&#x3D;&#x3D;):左右两边是否不全等\n\n比较结果为boolean类型，即只会得到true或false\n\n注意：\n\n字符串比较，是比较的字符对应的ASCII码，从左往右依次比较，如果第一位一样再比较第二位，以此类推\nNaN不等于任何值，包括它本身\n尽量不要比较小数，因为小数有精度问题\n不同类型之间比较会发生隐式转换，最终把数据隐式转换转成number类型再比较，所以开发中，如果进行准确的比较我们更喜欢 &#x3D; &#x3D; &#x3D; 或者 ! &#x3D; &#x3D;\n\n\n\n逻辑运算符\n\n\n\n符号\n名称\n日常读法\n特点\n口诀\n\n\n\n&amp;&amp;\n逻辑与\n并且\n符号两边都为true结构才是true\n一假则假\n\n\n||\n逻辑或\n或者\n符号两边有一个true就为true\n一真则真\n\n\n！\n逻辑非\n取反\ntrue变false&#x2F;false变true\n真假颠倒\n\n\n\n短路：只存在于&amp;&amp;(左边为false就短路)和||(左边为true就短路)中，当满足一定条件会让右边代码不执行\n\n有5个值是当 false 来看的  其余是真的： false  数字0  ‘’  undefined  null\n\n\n运算符优先级\n\n6、语句6.1 表达式和语句\n表达式:表达式是一组代码的集合，JavaScript解释器会将其计算出一个结果\n\n语句:js整句或命令，js语句是以分号结束（可以省略)比如: if语句for循环语句\n\n区别:表达式计算出一个值，但语句用来自行以使某件事发生(做什么事)\n\n\n\n6.2 分支语句if语句\n\nif语句有三种使用:单分支、双分支、多分支\n\n单分支使用语法：\n\n\nif(条件)&#123;\n    满足条件要执行的代码\n&#125;\n\n\n括号内的条件为true时，进入大括号里执行代码\n\n小括号内的结果若不是布尔类型时，会发生隐式转换转为布尔类型\n\n双分支if语法：\n\n\nif(条件)&#123;\n    满足条件要执行的代码\n&#125;else&#123;\n    不满足条件执行的代码\n&#125;\n\n\n多分支语法：\n\nif(条件1)&#123;\n    代码1\n&#125; else if(条件2)&#123;\n    代码2\n&#125; \n......\nelse &#123;\n    代码n\n&#125;\n\n三元运算符\n\n语法：\n\n条件 ? 满足条件执行的代码 : 不满足条件执行的代码\n\n\n代码：\n\n    &lt;script&gt;\n        let num1 = 40\n        let num2 = 30\n        let re = num1 &gt; num2 ? num1 : num2\n        console.log(re)//40\n    &lt;/script&gt;\n\nswitch语句\n\n语法：\n\nswitch(数据)&#123;\n    case 值1：\n        代码1\n        break\ncase 值2：\n        代码2\n        break\n        ......\ndefault：\n        代码n\n        break\n&#125;\n\n\n找到跟小括号里数据全等的case值，并执行里面对应的代码\n若没有全等&#x3D;&#x3D;&#x3D;的则执行default里的代码\nswitch case一般需要配合break关键字使用没有break会造成case穿透\n\n6.3 循环语句while循环\n\n语法：\n\nwhile(循环条件)&#123;\n    要重复执行的代码(循环体)\n&#125;\n\n循环结束\n\ncontinue:结束本次循环，继续下次循环\n\nbreak:跳出所在的循环\n\n代码：\n\n\n    &lt;script&gt;\n        let i = 1\n        while (i &lt;= 6) &#123;\n            if (i === 3) &#123;\n                i++\n                // continue 结束本次循环 继续下一次循环\n                continue\n            &#125;\n            document.write(`我要吃第$&#123;i&#125;个包子 &lt;br&gt;`)\n            i++\n        &#125;\n    &lt;/script&gt;\n\nfor循环\n\n语法：\n\nfor(声明记录循环次数的变量;循环条件;变化值)&#123;\n    循环体\n&#125;\n\n\n当如果明确了循环的次数的时候推荐使用for循环；当不明确循环的次数的时候推荐使用while循环\n\n循环嵌套\n\n一个循环里再套一个循环，一般用在for循环里\n\nfor(声明记录循环次数的变量;循环条件;变化值)&#123;\n    for(声明记录循环次数的变量;循环条件;变化值)&#123;\n        循环体\n    &#125;\n&#125;\n\n\n代码：\n\n    &lt;script&gt;\n        // 1. 外面的循环 记录第n天 \n        for (let i = 1; i &lt; 4; i++) &#123;\n            document.write(`第$&#123;i&#125;天 &lt;br&gt;`)\n            // 2. 里层的循环记录 几个单词\n            for (let j = 1; j &lt; 6; j++) &#123;\n                document.write(`记住第$&#123;j&#125;个单词&lt;br&gt;`)\n            &#125;\n        &#125;\n    &lt;/script&gt;\n\n7、数组数据简介\n\n数组(Array)是一种可以按顺序保存数据的数据类型\n\n元素:数组中保存的每个数据都叫数组元素\n下标:数组中数据的编号\n长度:数组中数据的个数，通过数组的length属性获得\n\n\n\n数据的基本使用\n\n声明语法：\n\nlet 数组名 = [数据1，数据2，...，数据n]\n\n\n数组是按顺序保存，所以每个数据都有自己的编号\n\n计算机中的编号从0开始，所以数据1的编号为0，数据2编号为1，以此类推\n\n在数组中，数据的编号也叫索引或下标\n\n数组可以存储任意类型的数据\n\n取值语法：\n\n\n数组名[下标]\n\n\n遍历数组：\n\nfor(let i = 0; i &lt; 数组名.length; i++)&#123;\n          数组名[i]                    \n&#125;\n\n\n代码：\n\n&lt;script&gt;\n        let arr = [2, 6, 1, 7, 4]\n        // 求和变量\n        let sum = 0\n        // 求平均值变量\n        let average = 0\n        // 遍历数组\n        for (let i = 0; i &lt; arr.length; i++) &#123;\n            sum += arr[i]\n        &#125;\n        average = sum / arr.length\n        document.write(`这个同学的总分是: $&#123;sum&#125;, 平均分是:$&#123;average&#125;`)\n    &lt;/script&gt;\n\n操作数组\n\n\n数组.push()方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度\n\narr.push(元素1, ... ,元素n)\n\n\n数组.unshift(新增的内容)方法将一个或多个元素添加到数组的开头，并返回该数组的新长度\n\narr.unshift(元素1, ... ,元素n)\n\n\n数组. pop()方法从数组中删除最后一个元素，并返回该元素的值\n\narr.pop()\n\n\n数组.shift()方法从数组中删除第一个元素，并返回该元素的值\n\narr.shift()\n\n\n数组.splice()方法删除指定元素\nstart 起始位置:指定修改的开始位置（从0计数)\ndeleteCount:表示要移除的数组元素的个数;如果省略则默认从指定的起始位置删除到最后\n\n\n\narr.splice(起始位置,删除几个元素)\n\n\n冒泡排序\n\n    &lt;script&gt;\n        let arr = [2, 6, 4, 3, 5, 1]\n        // 1. 外层循环控制  趟数   循环 4次   arr.length - 1\n        for (let i = 0; i &lt; arr.length - 1; i++) &#123;\n            // 2. 里层的循环 控制 一趟交换几次  arr.length - i - 1 次序\n            for (let j = 0; j &lt; arr.length - i - 1; j++) &#123;\n                // 交换两个变量\n                // arr[j]   arr[j + 1]\n                if (arr[j] &gt; arr[j + 1]) &#123;\n                    let temp = arr[j]\n                    arr[j] = arr[j + 1]\n                    arr[j + 1] = temp\n                &#125;\n            &#125;\n        &#125;\n        console.log(arr)\n    &lt;/script&gt;\n\n8、函数\n函数:function，是被设计为执行特定任务的代码块\n说明:函数可以把具有相同或相似逻辑的代码“包裹”起来，通过函数调用执行这些被“包裹”的代码逻辑，这么做的优势是有利于精简代码方便复用。\n\n函数使用\n\n声明语法：\n\nfunction 函数名()&#123;\n    函数体\n&#125;\n\n\n函数体:函数体是函数的构成部分，它负责将相同或相似代码“包裹”起来，直到函数调用时函数体内的代码才会被执行。函数的功能代码都要写在函数体当中\n\n函数名命名规范\n\n和变量命名基本一致\n尽量小驼峰式命名法\n前缀应该为动词\n命名建议:常用动词约定\n\n\n函数的调用语法：\n\n\n函数名()\n\n函数传参\n\n若函数完成功能需要调用者传入数据，那么就需要用有参数的函数，这样可以极大提高函数的灵活性\n\n声明语法:\n\n\nfunction 函数名(参数列表)&#123;\n    函数体\n&#125;\n\n\n调用语法：\n\n函数名(传递的参数列表)\n\n形参与实参\n\n形参:声明函数时写在函数名右边小括号里的叫形参（形式上的参数)\n\n实参:调用函数时写在函数名右边小括号里的叫实参（实际上的参数)\n\n形参可以理解为是在这个函数内声明的变量（比如num1 &#x3D; 10)实参可以理解为是给这个变量赋值\n\n开发中尽量保持形参和实参个数一致\n\n我们曾经使用过的alert(‘打印’), parseInt(‘11’),Number(‘11’)本质上都是函数调用的传参\n\n代码：\n\n\n    &lt;script&gt;\n        // 声明函数\n        function getScore(arr) &#123;\n            // arr = [99, 10, 100]\n            let sum = 0\n            for (let i = 0; i &lt; arr.length; i++) &#123;\n                sum += arr[i]\n            &#125;\n            document.write(sum + &#39;&lt;br&gt;&#39;)\n        &#125;\n        // 调用函数\n        getScore([99, 10, 100])\n        getScore([100, 100, 100])\n    &lt;/script&gt;\n\n函数返回值\n\n当调用某个函数，这个函数会返回一个结果出来，这就是有返回值的函数\n当函数需要返回数据出去时，用return关键字\n语法：\n\nreturn 数据\n\n\n在函数体中使用return关键字能将内部的执行结果交给函数外部使用\n\n函数内部只能出现1次return，并且return后面代码不会再被执行，所以return后面的数据不要换行写\n\nreturn会立即结束当前函数\n\n函数可以没有return，这种情况函数默认返回值为undefined\n\n代码：\n\n\n    &lt;script&gt;\n        //返回多个值\n        function fn(x, y) &#123;\n            let jia = x + y\n            let jian = x - y\n            return [jia, jian]\n        &#125;\n        let re = fn(1, 2)   //  [3, -1]\n        document.write(`相加之后的结果是：$&#123;re[0]&#125;,相减之后的结果是: $&#123;re[1]&#125; `)\n    &lt;/script&gt;\n\n作用域\n\n通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。\n\n\n\n特殊情况:如果函数内部或者块级作用域内部，变量没有声明，直接赋值，也当全局变量看，但是强烈不推荐；但是有一种情况，函数内部的形参可以看做是局部变量。\n\n变量访问原则-作用域链：\n\n只要是代码，就至少有一个作用域\n写在函数内部的局部作用域\n如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域\n根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链\n\n\n作用域链:采取就近原则的方式来查找变量最终的值\n\n代码：\n\n\n    &lt;script&gt;\n        let num = 10\n        function fn() &#123;\n            let num = 20\n            console.log(num)//就近原则 20\n        &#125;\n        fn()\n    &lt;/script&gt;\n\n匿名函数\n\n\n将匿名函数赋值给一个变量，并且通过变量名称进行调用我们将这个称为函数表达式\n语法:\n\nlet fn = function()&#123;\n    //函数体\n&#125;\n\n\n调用：\n\nfn()\n\n\n立即执行函数：避免全局变量之间的污染\n语法：\n\n//方式一\n(function()&#123;console.log(11)&#125;)();\n//方式二\n(function()&#123;console.log(11)&#125;());\n//不需要调用，立即执行\n\n\n注意:多个立即执行函数要用 ; 隔开，要不然会报错\n\n9、对象对象简介\n\n对象（object) : JavaScript里的一种数据类型，可以理解为是一种无序的数据集合\n比如描述人信息:\n静态特征(姓名,年龄,身高,性别,爱好)&#x3D;&gt;可以使用数字,字符串,数组，布尔类型等表示\n动态行为(点名,唱，跳, rap)&#x3D;&gt;使用函数表示\n\n\n\n对象使用\n\n对象声明语法：\n\nlet 对象名 = &#123;\n    属性名:属性值,\n    方法名:函数\n&#125;\n\n\n对象有属性和方法组成\n\n属性:信息或叫特征（名词)。比如手机尺寸、颜色、重量等..\n属性都是成对出现的，包括属性名和值，它们之间使用英文∶分隔\n多个属性之间使用英文，分隔\n属性就是依附在对象上的变量（外面是变量，对象内是属性)\n属性名可以使用””或”，一般情况下省略，除非名称遇到特殊符号如空格、中横线等\n\n\n方法:功能或叫行为（动词)。比如手机打电话、发短信、玩游戏…\n方法是由方法名和函数两部分构成，它们之间使用:分隔\n多个属性之间使用英文，分隔\n方法是依附在对象中的函数\n方法名可以使用””或”，一般情况下省略，除非名称遇到特殊符号如空格、中横线等\n\n\n\n\n属性访问：声明对象，并添加了若干属性后，可以使用.或[]获得对象中属性对应的值，称之为属性访问\n\n代码：\n\n\n&lt;script&gt;\n    let person = &#123;\n        name:&#39;andy&#39;,\n        age:18,\n        sex:&#39;男&#39;\n    &#125;\n    console.log(person.name)//方式一\n    console.log(person[&#39;name&#39;])//方式二\n&lt;/script&gt;\n\n\n方法访问：声明对象，并添加了若干方法后，可以使用﹒调用对象中函数，我称之为方法调用\n代码：\n\n&lt;script&gt;\n    let person = &#123;\n        name:&#39;andy&#39;,\n        sayHi:function()&#123;\n            document.write(&#39;hi~~&#39;)\n        &#125;\n    &#125;\n    //对象名.方法名\n    person.sayHi()\n&lt;/script&gt;\n\n对象操作\n\n\n增加属性：也可以动态为对象添加属性，动态添加与直接定义是一样的，只是语法上更灵活\n\n代码：\n\n\n&lt;script&gt;\n    let person = &#123;\n        name:&#39;andy&#39;,\n        age:18,\n    &#125;\n    person.hobby = &#39;足球&#39;\n    person[&#39;sex&#39;] = &#39;男&#39;\n    console.log(person)\n&lt;/script&gt;\n\n\n增加方法：也可以动态为对象添加方法，动态添加与直接定义是一样的，只是语法上更灵活\n\n代码：\n\n\n&lt;script&gt;\n    let person = &#123;\n        name:&#39;andy&#39;,\n        age:18,\n    &#125;\n    person.move = function()&#123;\n        document.write(&#39;移动一点点&#39;)\n    &#125;\n&lt;/script&gt;\n\n\n注意:无论是属性或是方法，同一个对象中出现名称一样的，后面的会覆盖前面的。\n\n遍历对象\n\n对象没有像数组一样的length属性,所以无法确定长度\n对象里面是无序的键值对，没有规律，不像数组里面有规律的下标\n代码：\n\n&lt;script&gt;\n    let obj = &#123;\n        uname:&#39;andy&#39;,\n        age:18,\n        sex:&#39;男&#39;\n    &#125;\n    for(let k in obj)&#123;\n        console.log(k)//打印属性名\n        console.log(obj[k])//打印属性值\n    &#125;\n&lt;/script&gt;\n\n内置对象\n\n内置对象Math：Math对象是JavaScript提供的一个“数学高手”对象，提供了一系列做数学运算的方法\n方法有:\nrandom:生成0-1之间的随机数（包含0不包括1)\n生成N-M之间的随机数： Math.floor(Math.random()*(M-N+1))+N\n\n\nceil:向上取整\nfloor:向下取整\nmax:找最大数\nmin:找最小数\npow︰幂运算\nabs:绝对值\n\n\n\n10、更多MDN Web Docs（旧称Mozilla Developer Network、Mozilla Developer Center，简称MDN）是一个汇集众多Mozilla基金会产品和网络技术开发文档的免费网站。\nhttps://developer.mozilla.org/zh-CN/\n","slug":"前端--JavaScript基础知识点大全","date":"2022-12-19T13:55:31.000Z","categories_index":"前端","tags_index":"JavaScript","author_index":"会思想的苇草i"},{"id":"60a8efd9365e4c7b34bf5d8b1e7583c7","title":"前端开发实战：移动端适配CSS技巧","content":"移动Web1、字体图标\n目标：使用字体图标实现网页中简洁的图标效果\n字体图标\n字体图标展示的是图标，本质是字体\n处理简单的、颜色单一的图片\n\n\n字体图标的优点︰\n灵活性∶灵活地修改样式，例如∶尺寸、颜色等\n轻量级∶体积小、渲染快、降低服务器请求次数\n兼容性:几乎兼容所有主流浏览器\n使用方便︰\n下载字体包\n使用字体图标\n\n\n\n\n图标库：iconfont-阿里巴巴矢量图标库\n下载字体包：登录–选择图标库–选择图标–加入购物车–购物车–添加至项目–下载至本地\n\n\n\n使用字体图标：\n\n\nUnicode编码：\n\n\n\n引入样式表\n复制粘贴图标对应的Unicode代码\n\n\n\n设置文字字体\n\n\n\n类名：\n\n\n\n引入字体图标样式表\n\n\n\n调用图标对应的类名，必须调用2个类名\n\niconfont类：基本样式，包含字体的使用\n\nicon-xxx：图标对应的类名\n\n\n\n\n\n\n如果图标库没有项目所需的图标，在IconFont网站上传矢量图生成字体图标\n与设计沟通，得到SVG矢量图\nIconFont网站上传图标，下载使用\n\n\n\n\n2、平面转换\n平面转换\n改变盒子在平面内的形态（位移、旋转、缩放)\n2D转换\n\n\n平面转换属性：transform\n\n\n\n语法：transform: translate(水平移动距离,垂直移动距离);\n取值(正负均可)\n像素单位数值\n百分比(参照物为盒子自身尺寸)\n注意:X轴正向为右，Y轴正向为下\n\n\n技巧\ntranslate()如果只给出一个值,表示x轴方向移动距离\n单独设置某个方向的移动距离: translatex() &amp; translateY()\n\n\n代码：\n\n    &lt;style&gt;\n        .father &#123;\n            width: 500px;\n            height: 300px;\n            margin: 100px auto;\n            border: 1px solid #000;\n        &#125;\n        \n        .son &#123;\n            width: 200px;\n            height: 100px;\n            background-color: pink;\n            transition: all 0.5s;\n        &#125;\n    \n        /* 鼠标移入到父盒子，son改变位置 */\n        .father:hover .son &#123;\n            /* transform: translate(100px, 50px); */\n\n            /* 百分比: 盒子自身尺寸的百分比 */\n            /* transform: translate(100%, 50%); */\n\n            /* transform: translate(-100%, 50%); */\n\n            /* 只给出一个值表示x轴移动距离 */\n            /* transform: translate(100px); */\n\n            transform: translateY(100px);\n        &#125;\n    &lt;/style&gt;\n\n\n使用translate快速实现绝对定位的元素居中效果\n原理：位移取值为百分比数值，参照盒子自身尺寸计算移动距离\n\n\n代码：\n\n    &lt;style&gt;\n        .father &#123;\n            position: relative;\n            width: 500px;\n            height: 300px;\n            margin: 100px auto;\n            border: 1px solid #000;\n        &#125;\n        \n        .son &#123;\n            position: absolute;\n            left: 50%;\n            top: 50%;\n            /* margin-left: -100px;\n            margin-top: -50px; */\n\n            transform: translate(-50%, -50%);\n\n            width: 203px;\n            height: 100px;\n            background-color: pink;          \n        &#125;\n    &lt;/style&gt;\n\n\n使用translate实现元素位移效果\nleft：向左侧移动自身宽度\nright：向右侧移动自身宽度\n\n\n\n\n\n使用rotate实现元素旋转效果\n\n语法：transform: rotate(角度);注意∶角度单位是deg\n\n技巧:取值正负均可\n\n取值为正,则顺时针旋转\n取值为负,则逆时针旋转\n\n\n代码：\n\n\n    &lt;style&gt;\n        img &#123;\n            width: 250px;\n            transition: all 2s;\n        &#125;\n        \n        img:hover &#123;\n            /* 顺 */\n            transform: rotate(360deg);\n\n            /* 逆 */\n            /* transform: rotate(-360deg); */\n        &#125;\n    &lt;/style&gt;\n\n\n使用transform-origin属性改变转换原点\n\n语法\n\n默认圆点是盒子中心点\ntransform-origin:原点水平位置原点垂直位置\n\n\n取值\n\n方位名词( left、 top、right、bottom、center )\n像素单位数值\n百分比(参照盒子自身尺寸计算)\n\n\n代码：\n\n\n    &lt;style&gt;\n        img &#123;\n            width: 250px;\n            border: 1px solid #000;\n            transition: all 2s;\n            transform-origin: right bottom;\n            transform-origin: left bottom;\n        &#125;\n        \n        img:hover &#123;\n            transform: rotate(360deg);\n        &#125;\n    &lt;/style&gt;\n\n\n使用transform复合属性实现多形态转换\n\n多重转换技巧：transform: translate() rotate();\n\n多重转换原理\n\n旋转会改变网页元素的坐标轴向\n先写旋转，则后面的转换效果的轴向以旋转后的轴向为准，会影响转换结果\n\n\n代码：\n\n\n    &lt;style&gt;\n        .box &#123;\n            width: 800px;\n            height: 200px;\n            border: 1px solid #000;\n        &#125;\n        \n        img &#123;\n            width: 200px;\n            transition: all 8s;\n        &#125;\n        \n        .box:hover img &#123;\n            /* 边走边转 */\n            transform: translate(600px) rotate(360deg);\n\n            /* 旋转可以改变坐标轴向 */\n            /* transform: rotate(360deg) translate(600px); */\n            \n            /* 层叠性 */\n            /* transform: translate(600px);\n            transform: rotate(360deg); */\n        &#125;\n    &lt;/style&gt;\n\n\n使用scale改变元素的尺寸\n\n语法：transform: scale(x轴缩放倍数,y轴缩放倍数);\n\n技巧\n\n一般情况下,只为scale设置一个值,表示x轴和y轴等比例缩放\ntransform: scale(缩放倍数);\nscale值大于1表示放大, scale值小于1表示缩小\n\n\n代码：\n\n\n    &lt;style&gt;\n        .box &#123;\n            width: 300px;\n            height: 210px;\n            margin: 100px auto;\n            background-color: pink;\n            \n        &#125;\n\n        .box img &#123;\n            width: 100%;\n            transition: all 0.5s;\n        &#125;\n        \n        .box:hover img &#123;\n            /* width: 150%; */\n\n            transform: scale(1.2);\n            transform: scale(0.8);\n        &#125;\n    &lt;/style&gt;\n\n3、渐变\n渐变是多个颜色逐渐变化的视觉效果\n一般用于设置盒子的背景\n代码：\n\n    &lt;style&gt;\n        .box &#123;\n            width: 300px;\n            height: 200px;\n            /* background-image: linear-gradient(\n                pink,\n                green,\n                hotpink\n            ); */\n            background-image: linear-gradient(\n                transparent,\n                rgba(0,0,0, .6)\n            );\n        &#125;\n    &lt;/style&gt;\n\n4、空间转换空间转换\n\n空间︰是从坐标轴角度定义的。x、y和z三条坐标轴构成了一个立体空间，z轴位置与视线方向相同。\n空间转换也叫3D转换\n属性:transform\n\n\n空间位移\n\n语法\ntransform: translate3d(x, y, z);\ntransform: translateX(值);\ntransform: translateY(值);\ntransform: translateZ(值);\n\n\n取值（正负均可)\n像素单位数值\n百分比\n\n\n\n透视\n\n生活中，同一个物体观察距离不同，近小远大、近清楚远模糊，Z轴是视线方向，移动效果是距离的远和近\n\n属性（添加给父级)\n\nperspective:值;\n取值∶像素单位数值，数值一般在800 - 1200。\n透视距离也称为视距，所谓的视距就是人的眼睛到屏幕的距离。\n\n\n\n\n\n代码：\n\n    &lt;style&gt;\n    body &#123;\n      perspective: 1000px;\n      /* perspective: 200px; */\n      /* perspective: 10000px; */\n    &#125;\n\n    .box &#123;\n      width: 200px;\n      height: 200px;\n      margin: 100px auto;\n      background-color: pink;\n      transition: all 0.5s;\n    &#125;\n\n    .box:hover &#123;\n      transform: translateZ(200px);\n      /* transform: translateZ(-200px); */\n    &#125;\n  &lt;/style&gt;\n\n\n作用\n空间转换时，为元素添加近大远小、近实远虚的视觉效果\n\n\n\n空间旋转\n\n语法\n\ntransform: rotateZ(值);\ntransform: rotateX(值);\ntransform: rotateY(值);\n\n\n左手法则：判断旋转方向，左手握住旋转轴,拇指指向正值方向,手指弯曲方向为旋转正值方向\n\nrotate3d(x，y，z，角度度数)∶用来设置自定义旋转轴的位置及旋转的角度\n\nx，y，z取值为0-1之间的数字\n\n\n立体呈现\n\n实现方法\n\n添加transform-style: preserve-3d;使子元素处于真正的3d空间\n\n呈现立体图形步骤\n\n盒子父元素添加transform-style: preserve-3d ;\n\n按需求设置子盒子的位置（位移或旋转)\n\n\n\n注意：空间内，转换元素都有自已独立的坐标轴，互不干扰\n\n\n\n5、动画使用animation添加动画效果\n\n过渡可以实现两个状态的变化过程\n\n动画效果可以实现多个状态间的变化过程，动画过程可控(重复播放、最终画面、是否暂停)\n\n动画的本质是快速切换大量图片时在人脑中形成的具有连续性的画面\n\n构成动画的最小单元︰帧或动画帧\n\n实现步骤:\n\n\n\n定义动画\n\n\n\n\n使用动画\n\n\n\n代码：\n\n    &lt;style&gt;\n        .box &#123;\n            width: 200px;\n            height: 100px;\n            background-color: pink;\n\n            /* 使用动画 */\n            animation: change 1s;\n        &#125;\n\n        /* 一. 定义动画：从200变大到600 */\n        /* @keyframes change &#123;\n            from &#123;\n                width: 200px;\n            &#125;\n            to &#123;\n                width: 600px;\n            &#125;\n        &#125; */\n        \n\n        /* 二. 定义动画：200 到 500*300 到 800*500 */\n        /* 百分比指的是动画总时长的占比 */\n        @keyframes change &#123;\n            0% &#123;\n                width: 200px;\n            &#125;\n            50% &#123;\n                width: 500px;\n                height: 300px;\n            &#125;\n            100% &#123;\n                width: 800px;\n                height: 500px;\n            &#125;\n        &#125;\n    &lt;/style&gt;\n\n使用animation相关属性控制动画的执行过程\n\n\n注意:\n动画名称和动画时长必须赋值\n取值不分先后顺序\n如果有2个时间值，第一个时间表示动画时长，第二个时间表示延迟时间\n\n\n\n\n\n\n属性\n作用\n取值\n\n\n\nanimation-name\n动画名称\n\n\n\nanimation-duration\n动画时长\n\n\n\nanimation-delay\n延迟时间\n\n\n\nanimation-fill-mode\n动画执行完毕时状态\nforwards：最后一帧状态&#x2F;backwards：第一帧状态\n\n\nanimation-timing-function\n速度曲线\nsteps()：逐帧动画\n\n\nanimation-iteration-count\n重复次数\ninfinite为无限循环\n\n\nanimation-direction\n动画执行方向\nalternate为反向\n\n\nanimation-play-state\n暂停动画\npaused为暂停，通常配合:hover使用\n\n\n使用steps实现逐帧动画\n\n\n\n属性\n作用\n取值\n\n\n\nanimation-timing-function\n速度曲线\nsteps(数字):逐帧动画\n\n\n\n逐帧动画︰帧动画。开发中，一般配合精灵图实现动画效果。\n\nanimation-timing-function: steps(N);\n\n将动画过程等分成N份\n\n\n精灵动画制作步骤\n\n准备显示区域\n\n设置盒子尺寸是一张小图的尺寸，背景图为当前精灵图\n\n\n定义动画\n\n改变背景图的位置（移动的距离就是精灵图的宽度)\n\n\n使用动画\n\n添加速度曲线steps(N)，N与精灵图上小图个数相同\n添加无限重复效果\n\n\n\n能够使用animation属性给一个元素添加多个动画效果\n\n多组动画\n精灵动画的同时添加盒子位移动画\n代码：\n\n    &lt;style&gt;\n    .box &#123;\n      /* 1680/12 : 保证显示区域的尺寸和一个精灵小图的尺寸相同 */\n      width: 140px;\n      height: 140px;\n      /* border: 1px solid #000; */\n      background-image: url(./images/bg.png);\n\n      /* 12: 净零小图的个数 */\n      animation: \n        move 1s steps(12) infinite,\n        run 1s forwards\n      ;\n    &#125;\n\n\n    @keyframes move &#123;\n        /* from &#123;\n          background-position: 0 0;\n        &#125; */\n        to &#123;\n          /* 1680: 精灵图的宽度 */\n          background-position:  -1680px 0;\n        &#125;\n    &#125;\n\n    /* 定义一个盒子移动的动画  800px */\n    @keyframes run &#123;\n      /* 动画的开始状态和盒子的默认样式相同的, 可以省略开始状态的代码 */\n      /* from &#123;\n        transform: translateX(0);\n      &#125; */\n      to &#123;\n        transform: translateX(800px);\n      &#125;\n    &#125;\n  &lt;/style&gt;\n\n6、移动端特点移动端和PC端网页不同点\n\nPC端网页和移动端网页的不同：\nPC屏幕大，网页固定版心\n手机屏幕小，网页宽度多数为100%\n\n\n在电脑里面边写代码边调试移动端网页效果 – 谷歌模拟器\n\n谷歌模拟器\n\n分辨率\n\n屏幕尺寸：指屏幕对角线的长度，一般用英寸来度量\n\n\n\nPC分辨率：\n\n1920*1080\n1366*768\n…\n\n\n缩放150%：(1920&#x2F;150%)*(1080&#x2F;150%)\n\n硬件分辨率(出厂设置)；缩放调节的分辨率(软件设置)\n\n分辨率分类：\n\n物理分辨率是生产屏幕时就固定的，它是不可被改变的\n逻辑分辨率是由软件（驱动)决定的\n\n\n\n\n\n制作网页参考逻辑分辨率\n\n常见移动端主流设备分辨率\n\n\n\n视口\n\n手机屏幕尺寸都不同，网页宽度为100%\n网页的宽度和逻辑分辨率尺寸相同\n默认情况下，网页宽度是980px，如果希望网页宽度和设备宽度(分辨率)相同，可以添加视口标签\n视口(viewport)：显示HTML网页的区域，用来约束HTML尺寸\n\n\n\nwidth &#x3D; device - width：视口宽度 &#x3D; 设备宽度\ninitial - scale &#x3D; 1.0：缩放1倍(不缩放)\n\n二倍图\n\n目标:能够使用像素大厨软件测量二倍图中元素的尺寸\n图片分辨率,为了高分辨率下图片不会模糊失真\n现阶段设计稿参考iPhone6&#x2F;7&#x2F;8，设备宽度375px产出设计稿\n二倍图设计稿尺寸:750px\n\n7、百分比布局\n百分比布局，也叫流式布局\n效果︰宽度自适应，高度固定。\n\n8、Flex布局Flex\n\n多个盒子横向排列使用浮动属性\n\n设置盒子间的间距使用margin属性\n\n需要注意浮动的盒子脱标问题\n\nFlex布局&#x2F;弹性布局:\n\n是─种浏览器提倡的布局模型\n布局网页更简单、灵活\n避免浮动脱标的问题\n\n\n作用：\n\n基于Flex精确灵活控制块级盒子的布局方式，避免浮动布局中脱离文档流现象发生。\n\nFlex布局非常适合结构化布局\n\n\n\n设置方式：父元素添加display: flex，子元素可以自动的挤压或拉伸\n\n组成部分\n\n弹性容器\n弹性盒子\n主轴\n侧轴&#x2F;交叉轴\n\n\n\n\n主轴对齐方式\n\n在Flex布局模型中，调节主轴或侧轴的对齐方式来设置盒子之间的间距。\n\n修改主轴对齐方式属性：justify-content\n\n\n\n\n\n属性值\n作用\n\n\n\nflex-start\n默认值，起点开始依次排列\n\n\nflex-end\n终点开始依次排列\n\n\ncenter\n沿主轴居中排列\n\n\nspace-around\n弹性盒子沿主轴均匀排列，空白间距均分在弹性盒子两侧\n\n\nspace-between\n弹性盒子沿主轴均匀排列，空白间距均分在弹性盒子两侧\n\n\nspace-evenly\n弹性盒子沿主轴均匀排列，弹性盒子与容器之间间距相等\n\n\n\n代码：\n\n    &lt;style&gt;\n        * &#123;\n            margin: 0;\n            padding: 0;\n        &#125;\n\n        .box &#123;\n            display: flex;\n\n            /* 居中 */\n            justify-content: center;\n\n            /* 间距在弹性盒子(子级)之间 */\n            justify-content: space-between;\n\n            /* 所有地方的间距都相等 */\n            justify-content: space-evenly;\n\n            /* 间距加在子级的两侧 */\n            /* 视觉效果: 子级之间的距离是父级两头距离的2倍 */\n            justify-content: space-around;\n            \n            height: 200px;\n            margin: auto;\n            border: 1px solid #000;\n        &#125;\n        \n        .box div &#123;\n            width: 100px;\n            height: 100px;\n            background-color: pink;\n        &#125;\n    &lt;/style&gt;\n\n侧轴对齐方式\n\n修改侧轴对齐方式属性:\nalign-items(添加到弹性容器)\nalign-self:控制某个弹性盒子在侧轴的对齐方式(添加到弹性盒子)\n\n\n\n\n\n\n属性值\n作用\n\n\n\nflex-start\n默认值，起点开始依次排列\n\n\nflex-end\n终点开始依次排列\n\n\ncenter\n沿侧轴居中排列\n\n\nstretch\n默认值，弹性盒子沿着主轴被拉伸至铺满容器\n\n\n\n代码：\n\n    &lt;style&gt;\n        * &#123;\n            margin: 0;\n            padding: 0;\n        &#125;\n\n        .box &#123;\n            display: flex;\n\n            /* 居中 */\n            /* align-items: center; */\n\n            /* 拉伸,默认值(现有状态,测试的时候去掉子级的高度) */\n            /* align-items: stretch; */\n\n            height: 300px;\n            margin: auto;\n            border: 1px solid #000;\n        &#125;\n        \n        .box div &#123;\n            /* width: 100px; */\n            /* height: 100px; */\n            background-color: pink;\n        &#125;\n\n        /* 单独设置某个弹性盒子的侧轴对齐方式 */\n        .box div:nth-child(2) &#123;\n            align-self: center;\n        &#125;\n        \n    &lt;/style&gt;\n\n伸缩比\n\n属性 - flex：值\n取值分类：数值(整数)\n注意：只占用父盒子剩余尺寸\n代码：\n\n    &lt;style&gt;\n        * &#123;\n            margin: 0;\n            padding: 0;\n        &#125;\n\n        .box &#123;\n            display: flex;\n\n            height: 300px;\n            border: 1px solid #000;\n        &#125;\n\n        .box div &#123;\n            height: 200px;\n            margin: 0 20px;\n            background-color: pink;\n        &#125;\n\n        .box div:nth-child(1) &#123;\n            width: 50px;\n        &#125;\n\n        .box div:nth-child(2) &#123;\n            /* 占用父级剩余尺寸的份数 */\n            flex: 3;\n        &#125;\n\n        .box div:nth-child(3) &#123;\n            flex: 1;\n        &#125;\n        \n    &lt;/style&gt;\n\n主轴方向\n\n主轴默认是水平方向，侧轴默认是垂直方向\n修改主轴方向属性: flex-direction\n\n\n\n\n属性值\n作用\n\n\n\nrow\n行，水平(默认值)\n\n\ncolumn\n*列，垂直\n\n\nrow-reverse\n行，从右先左\n\n\ncolumn-reverse\n列，从下向上\n\n\n\n代码：\n\n    &lt;style&gt;\n        * &#123;\n            margin: 0;\n            padding: 0;\n        &#125;\n\n        li &#123;\n            list-style: none;\n        &#125;\n\n        .box li &#123;\n            display: flex;\n            /* 1. 先确定主轴方向; 2. 再选择对应的属性实现主轴或侧轴的对齐方式 */\n            /* 修改主轴方向: 列 */\n            flex-direction: column;\n\n            /* 当前视觉效果: 实现盒子水平居中 */\n            align-items: center;\n\n            /* 当前视觉效果: 垂直居中 */\n            justify-content: center;\n            \n\n            width: 80px;\n            height: 80px;\n            border: 1px solid #ccc;\n        &#125;\n        \n        .box img &#123;\n            width: 32px;\n            height: 32px;\n        &#125;\n    &lt;/style&gt;\n\n弹性盒子换行\n\n弹性盒子换行显示: flex-wrap: wrap;\n\n调整行对齐方式: align-content\n\n取值与justify-content基本相同\n\n\n代码：\n\n\n    &lt;style&gt;\n        * &#123;\n            margin: 0;\n            padding: 0;\n        &#125;\n\n        .box &#123;\n            display: flex;\n\n            /* 默认值, 不换行 */\n            /* flex-wrap: nowrap; */\n\n            /* 弹性盒子换行 */\n            flex-wrap: wrap;\n\n            /* 调节行对齐方式 */\n            /* align-content: center; */\n            /* align-content: space-around; */\n            align-content: space-between;\n\n            height: 500px;\n            border: 1px solid #000;\n        &#125;\n        \n        .box div &#123;\n            width: 100px;\n            height: 100px;\n            background-color: pink;\n        &#125;\n    &lt;/style&gt;\n\n9、移动适配9.1 rem使用rem单位设置网页元素的尺寸\n\n网页效果：屏幕宽度不同，网页元素尺寸不同（等比缩放)\n\npx单位或百分比布局可以实现吗?\n\npx单位是绝对单位\n百分比布局特点宽度自适应，高度固定\n\n\n适配方案\n\nrem\nvw &#x2F; vh\n\n\nrem单位\n\n相对单位\nrem单位是相对于HTML标签的字号计算结果\n1rem &#x3D; 1HTML字号大小\n\n\n代码：\n\n\n    &lt;style&gt;\n        * &#123;\n            margin: 0;\n            padding: 0;\n        &#125;\n        \n        /* 1rem = 1html标签字号大小 */\n        html &#123;\n            font-size: 20px;\n        &#125;\n        \n        .box &#123;\n            width: 5rem;\n            height: 3rem;\n            background-color: pink;\n        &#125;\n    &lt;/style&gt;\n\n媒体查询\n\n手机屏幕大小不同，分辨率不同，通过媒体查询设置不同的HTML标签字号\n\n媒体查询能够检测视口的宽度，然后编写差异化的CSS样式\n\n当某个条件成立,执行对应的CSS样式\n\n写法：\n\n\n\n\n设备宽度大，元素尺寸大；设备宽度小，元素尺寸小\n代码：\n\n    &lt;style&gt;\n        /* 使用媒体查询, 根据不同的视口宽度, 设置不同的根字号 */\n        @media (width:375px) &#123;\n            html &#123;\n                font-size: 40px;\n            &#125;\n        &#125;\n\n        /* 电脑缩放显示100%情况下 */\n        @media (width:320px) &#123;\n            html &#123;\n                font-size: 30px;\n            &#125;\n        &#125;\n    &lt;/style&gt;\n\nrem移动适配和适配原理\n\n目前rem布局方案中，将网页等分成10份，HTML标签的字号为视口宽度的1&#x2F;10(width:375px – font-size:37.5px)\n\nrem单位尺寸\n\n根据视口宽度，设置不同的HTML标签字号\n\n书写代码，尺寸是rem单位\n\n确定设计稿对应的设备的HTML标签字号\n查看设计稿宽度→确定参考设备宽度(视口宽度)→确定基准根字号(1&#x2F;10视口宽度)\n2.2 rem单位的尺寸\nN*37.5 &#x3D; 68→N&#x3D; 68&#x2F; 37.5\nrem单位的尺寸&#x3D; px单位数值&#x2F;基准根字号\n\n\n\n\n\nflexible\n\n使用flexible.js配合rem实现在不同宽度的设备中，网页元素尺寸等比缩放效果\n\nflexible.js是手淘开发出的一个用来适配移动端的js框架\n\n核心原理就是根据不同的视口宽度给网页中html根节点设置不同的font-size\n\n\n(function flexible (window, document) &#123;\n  var docEl = document.documentElement\n  var dpr = window.devicePixelRatio || 1\n\n  // adjust body font size\n  function setBodyFontSize () &#123;\n    if (document.body) &#123;\n      document.body.style.fontSize = (12 * dpr) + &#39;px&#39;\n    &#125;\n    else &#123;\n      document.addEventListener(&#39;DOMContentLoaded&#39;, setBodyFontSize)\n    &#125;\n  &#125;\n  setBodyFontSize();\n\n  // set 1rem = viewWidth / 10\n  function setRemUnit () &#123;\n    var rem = docEl.clientWidth / 10\n    docEl.style.fontSize = rem + &#39;px&#39;\n  &#125;\n\n  setRemUnit()\n\n  // reset rem unit on page resize\n  window.addEventListener(&#39;resize&#39;, setRemUnit)\n  window.addEventListener(&#39;pageshow&#39;, function (e) &#123;\n    if (e.persisted) &#123;\n      setRemUnit()\n    &#125;\n  &#125;)\n\n  // detect 0.5px supports\n  if (dpr &gt;= 2) &#123;\n    var fakeBody = document.createElement(&#39;body&#39;)\n    var testElement = document.createElement(&#39;div&#39;)\n    testElement.style.border = &#39;.5px solid transparent&#39;\n    fakeBody.appendChild(testElement)\n    docEl.appendChild(fakeBody)\n    if (testElement.offsetHeight === 1) &#123;\n      docEl.classList.add(&#39;hairlines&#39;)\n    &#125;\n    docEl.removeChild(fakeBody)\n  &#125;\n&#125;(window, document))\n\n9.2 less\n在px单位转换到rem单位过程中，除法运算比较麻烦，因为CSS不支持计算写法\n\n解决方案:可以通过Less实现\n\nLess是一个CSS预处理器,Less文件后缀是.less\n\n扩充了CSS语言,使CSS具备一定的逻辑性、计算能力。\n\n注意︰浏览器不识别Less代码，目前阶段，网页要引入对应的CSS文件\n\nEasy Less :vscode插件\n\n作用: less文件保存自动生成css文件\n\n\n\n\nLess代码：\n\n.father &#123;\n    color: red;\n\n    width: (68 / 37.5rem);\n\n    .son &#123;\n        background-color: pink;\n    &#125;\n&#125;\n\n\n自动生成的css代码：\n\n.father &#123;\n  color: red;\n  width: 1.81333333rem;\n&#125;\n.father .son &#123;\n  background-color: pink;\n&#125;\n\n\n注释:\n\n单行注释：语法 ：&#x2F;&#x2F;注释内容 ；快捷键: ctrl+&#x2F;\n块注释：语法∶&#x2F; * 注释内容 *&#x2F;  ；快捷键: shift + alt +A\n\n\n运算:\n\n加、减、乘直接书写计算表达式\n\n除法需要添加小括号 或 .\n\n\n\nLess代码：\n\n\n.box &#123;\n    width: 100 + 10px;\n    width: 100 - 20px;\n    width: 100 * 2px;\n\n    // 除法\n    // 68  -&gt; rem\n    width: (68 / 37.5rem);\n    height: 29 ./ 37.5rem;\n&#125;\n\n\n自动生成的css代码：\n\n.box &#123;\n  width: 110px;\n  width: 80px;\n  width: 200px;\n  width: 1.81333333rem;\n  height: 0.77333333rem;\n&#125;\n\n\n注意︰表达式存在多个单位以第一个单位为准\n\n嵌套\n\n作用：快速生成后代代码\n\n注意：&amp;不生成后代选择器，表示当前选择器，通常配合伪类或伪元素使用\n\nLess代码：\n\n\n.father &#123;\n    width: 100px;\n\n    .son &#123;\n        color: pink;\n\n        // &amp; 表示当前选择器\n        &amp;:hover &#123;\n            color: green;\n        &#125;\n    &#125;\n\n    &amp;:hover &#123;\n        color: orange;\n    &#125;\n&#125;\n\n\n自动生成的css代码：\n\n.father &#123;\n  width: 100px;\n&#125;\n\n.father .son &#123;\n  color: pink;\n&#125;\n\n.father .son:hover &#123;\n  color: green;\n&#125;\n\n.father:hover &#123;\n  color: orange;\n&#125;\n\n变量\n\n网页中文字颜色基本同一，如果网站改版，变换文字颜色，修改代码方式：\n\n逐一修改属性值(繁琐)\n把颜色提前存储到一个容器，设置属性值为这个容器名(推荐)\n\n\n把颜色提前存储到一个容器，设置属性值为这个容器名\n\n变量:存储数据，方便使用和修改。\n\n语法︰\n\n定义变量：**@变量名：值;**\n使用变量：CSS属性：**@变量名;**\n\n\nLess代码：\n\n\n// 1. 定义. 2.使用\n@colora: green;\n\n.box &#123;\n    color: @colora;\n&#125;\n\n.father &#123;\n    background-color: @colora;\n&#125;\n\n.aa &#123;\n    color: @colora;\n&#125;\n\n\n自动生成的css代码：\n\n.box &#123;\n  color: green;\n&#125;\n\n.father &#123;\n  background-color: green;\n&#125;\n\n.aa &#123;\n  color: green;\n&#125;\n\n文件操作\n\n开发网站时\n\nCSS：书写link标签\nLess：导入\n\n\n导入方式：**@import ‘文件路径’**\n\n导出方式：\n\n配置EasyLess插件，实现所有Less有相同的导出路径\n\n配置插件︰设置→搜索EasyLess→在setting.json中编辑→添加导出代码（注意，必须是双引号)\n\n\n控制当前Less文件导出路径\n\nLess文件第一行添加如下代码,注意文件夹名称后面添加&#x2F;\n\n\n\n\n\n// out: ./css/\n// out: ./css/common.css\n\n\n禁止导出：在less文件第一行添加：&#x2F;&#x2F;out.false\n\n// out: false\n\n9.3 vw&#x2F;vh\n相对单位\n\n相对视口的尺寸计算结果\nvw : viewport width；1vw &#x3D; 1&#x2F;100视口宽度\nvh : viewport height；1vh &#x3D; 1&#x2F;100视口高度\n\n\n代码：\n\n\n    &lt;style&gt;\n        * &#123;\n            margin: 0;\n            padding: 0;\n        &#125;\n\n        /* 1. vw = 1/100视口宽度 */\n        /* .box &#123;\n            width: 50vw;\n            height: 30vw;\n            background-color: pink;\n        &#125; */\n\n        /* 2. vh = 1/100视口高度 */\n        .box &#123;\n            width: 50vh;\n            height: 30vh;\n            background-color: pink;\n        &#125;\n    &lt;/style&gt;\n\nvw适配原理\n\nvw单位尺寸\n确定设计稿对应的vw尺寸( 1&#x2F;100视口宽度)\n查看设计稿宽度→确定参考设备宽度(视口宽度)→确定vw尺寸(1&#x2F;100视口宽度)\n\n\nvw单位的尺寸&#x3D; px单位数值&#x2F;( 1&#x2F;100视口宽度)\n\n\n\nvh适配原理\n\nvh单位尺寸\n\n确定设计稿对应的vh尺寸( 1&#x2F;100视口高度)\n查看设计稿宽度→确定参考设备高度(视口高度)→确定vh尺寸( 1&#x2F;100视口高度)\n\n\nvh单位的尺寸&#x3D; px单位数值&#x2F;( 1&#x2F;100视口高度)\n\n\n开发中不会混用vw和vh，vh是1&#x2F;100视口高度，全面屏视口高度尺寸大，如果混用可能会导致盒子变形。\n\n\nrem和vw&#x2F;vh的区别\n\nrem：市场比较常见\n\n需要不断修改html文字大小\n需要媒体查询media\n需要flexible.js\n\n\nvw&#x2F;vh：将来(马上)趋势（推荐）\n\n省去各种判断和修改\n……\n\n\n\n10、媒体查询基本语法\n\n开发常用写法：max-width(从小到大)、min-width(从大到小)\n\n代码：\n\n\n&lt;style&gt;\n        /*\n            视口宽度 &gt;= 768px，网页背景色是 粉色\n            视口宽度 &gt;= 992px，网页背景色是 绿色\n            视口宽度 &gt;= 1200px，网页背景色是 skyblue\n         */\n        @media (min-width: 768px) &#123;\n            body &#123;\n                background-color: pink;\n            &#125;\n        &#125;\n\n        @media (min-width: 992px) &#123;\n            body &#123;\n                background-color: green;\n            &#125;\n        &#125;\n\n        @media (min-width: 1200px) &#123;\n            body &#123;\n                background-color: skyblue;\n            &#125;\n        &#125;\n    &lt;/style&gt;\n\n\n书写具有顺序：\n\n\n完整写法\n\n\n关键词：and&#x2F;only&#x2F;not\n\n媒体类型:媒体是用来区分设备类型的，如屏幕设备、打印设备等，其中手机、电脑、平板都属于屏幕设备\n\n\n\n\n\n类型名称\n值\n描述\n\n\n\n屏幕\nscreen\n带屏幕的设备\n\n\n打印预览\nprint\n打印预览模式\n\n\n阅读器\nspeech\n屏幕阅读模式\n\n\n不区分类型\nall\n默认值，包含以上三种\n\n\n\n\n\n特性名称\n属性\n值\n\n\n\n视口的宽和高\nwidth、height\n数值\n\n\n视口最大宽或高\nmax-width、max-height\n数值\n\n\n视口最大宽或高\nmin-width、min-height\n数值\n\n\n屏幕方向\norientation\nportrait:竖屏&#x2F;landscape：横屏\n\n\n外链式引入\n\n\n代码：\n\n    &lt;!-- 视口宽度 &gt;= 992px，网页背景色为粉色 --&gt;\n    &lt;!-- 视口宽度 &gt;= 1200px，网页背景色为绿色 --&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;./one.css&quot; media=&quot;(min-width: 992px)&quot;&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;./two.css&quot; media=&quot;(min-width: 1200px)&quot;&gt;\n\n隐藏\n\n代码：\n\n    &lt;style&gt;\n        * &#123;\n            margin: 0;\n            padding: 0;\n        &#125;\n\n        .box &#123;\n            display: flex;\n            width: 100%;\n        &#125;\n\n        .left &#123;\n            width: 300px;\n            min-height: 500px;\n            background-color: pink;\n        &#125;\n\n        .main &#123;\n            flex: 1;\n            min-height: 500px;\n            background-color: skyblue;\n        &#125;\n\n        /* 如果检测到视口宽度小于768px, 认为是手机端, left隐藏 */\n        @media (max-width: 768px) &#123;\n            .left &#123;\n                display: none;\n            &#125;\n        &#125;\n    &lt;/style&gt;\n\n11、BootStrapUI框架\n\n将常见效果进行统一封装后形成的一套代码,例如:BootStrap\n作用：基于框架开发，效率高，稳定性高。\n\nBootStrap简介\n\nBootstrap是由Twitter公司开发维护的前端UI框架，它提供了大量编写好的CSS样式，允许开发者结合一定HTML结构及JavaScript，快速编写功能完善的网页及常见交互效果。\n\n中文官网: https://www.bootcss.com/\n\n使用：\n\n下载\n\n\n\n\n\n引入\n\n  &lt;link rel=&quot;stylesheet&quot; href=&quot;./bootstrap-03.3.7/css/bootstrap.css&quot;&gt;\n\n\n调用类：使用BootStrap提供的样\ncontainer :响应式布局版心类\n\n\n\nBootStrap栅格系统\n\n\n栅格化是指将整个网页的宽度分成若干等份\nBootStrap3默认将网页分成12等份\n\n\n\n\n\n超小屏幕\n小屏幕\n中等屏幕\n大屏幕\n\n\n\n响应断点\n&lt;768px\n&gt;&#x3D;768px\n&gt;&#x3D;992px\n&gt;&#x3D;1200px\n\n\n别名\nxs\nsm\nmd\nlg\n\n\n容器宽度\n100%\n750px\n970px\n1170px\n\n\n类前缀\ncol-xs-*\ncol-sm-*\ncol-md-*\ncol-lg-*\n\n\n列数\n12\n12\n12\n12\n\n\n列间隙\n30px\n30px\n30px\n30px\n\n\n\n代码：\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;栅格系统&lt;/title&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;./bootstrap-3.4.1-dist/css/bootstrap.min.css&quot;&gt;\n\n    &lt;style&gt;\n        .container div &#123;\n            height: 50px;\n            background-color: pink;\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!-- 需求: 大屏: 一行排列4个内容; 中屏:一行排列2个内容 --&gt;\n    &lt;div class=&quot;container&quot;&gt;\n        &lt;div class=&quot;col-lg-3 col-md-6&quot;&gt;1&lt;/div&gt;\n        &lt;div class=&quot;col-lg-3 col-md-6&quot;&gt;2&lt;/div&gt;\n        &lt;div class=&quot;col-lg-3 col-md-6&quot;&gt;3&lt;/div&gt;\n        &lt;div class=&quot;col-lg-3 col-md-6&quot;&gt;4&lt;/div&gt;\n    &lt;/div&gt;\n    \n&lt;/body&gt;\n&lt;/html&gt;\n\n\n.container是Bootstrap中专门提供的类名，所有应用该类名的盒子，默认已被指定宽度且居中\n\n.container-fluid也是Bootstrap 中专门提供的类名，所有应用该类名的盒子，宽度均为100%\n\n分别使用.row类名和.col类名定义栅格布局的行和列。\n\n注意：container类自带间距15px；row类自带间距-15px\n\n代码：\n\n\n    &lt;!-- 版心样式:自带左右各15px的padding --&gt;\n    &lt;div class=&quot;container&quot;&gt;1&lt;/div&gt;\n\n    &lt;!-- row类作用就是抵消container类的15px的内边距(padding), row有-15px的外边距(margin) --&gt;\n    &lt;div class=&quot;container&quot;&gt;\n        &lt;div class=&quot;row&quot;&gt;2&lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;!-- 宽度100%:自带左右各15px的padding --&gt;\n    &lt;div class=&quot;container-fluid&quot;&gt;3&lt;/div&gt;\n\n全局样式\n\nBootStrap预定义了大量类用来美化页面，掌握手册的查找方法是学习全局样式的重点\n\n网站首页→BootStrap3中文文档→全局CSS样式→按分类导航查找目标类\n\n布局类：表格\n\ntable:基本类名,初始化表格默认样式\ntable-bordered :边框线\ntable-striped:隔行变色\ntable-hover:鼠标悬停效果\ntable-responsive :表格宽溢出滚动\n……\n\n\n代码：\n\n\n&lt;table class=&quot;table table-striped table-bordered table-hover&quot;&gt;\n\n\n美化内容类：按钮\n\nbtn:基准样式\nbtn-info; btn-success:设置按钮背景色\nbtn-block :设置按钮为块元素\nbtn-lg; btn-sm; btn-xs:设置按钮大小\n……\n\n\n代码：\n\n\n&lt;button class=&quot;btn btn-success btn-lg&quot;&gt;成功&lt;/button&gt;\n\n\n布局类：辅助类\npull-right:强制元素右浮动\npull-left :强制元素左浮动\nclearfix:清除浮动元素的影响\ntext-left文:本左对齐\ntext-right :文本右对齐\ntext-center : 文本居中对齐\ncenter-block :块元素居中\n……\n\n\n\n组件\n\nBootStrap提供的常见功能，包含了HTML结构和CSS样式\n\n使用方法：\n\n引入BootStrap样式\n复制结构，修改内容\n\n\n字体图标使用步骤：\n\nHTML页面引入BootStrap样式文件\n准备字体文件(注意路径)\n空标签调用对应类名\nglyphicon\n图标类\n\n\n\n\n代码：\n\n\n&lt;i class=&quot;glyphicon glyphicon-user&quot;&gt;&lt;/i&gt;\n\n插件\n\n使用方法：\n\n\n引入BootStrap样式\n\n&lt;script src=&quot;./js/jquery.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;./bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;\n\n  2.引入js文件: jQuery.js +BootStrap.min.js  3.复制HTML结构,并适当调整结构或内容\n定制\n\n使用方法：\n导航菜单→定制\n输入目标变量值\n编译并下载，使用定制后的框架\n\n\n\n总结\n\n响应式适用:\n\n企业站\n内容较少的网站\n\n\n电商站两套布局，移动端用rem&#x2F;vh、vw适配，企业站用响应式布局\n\n\n","slug":"前端--移动Web知识点大全","date":"2022-12-12T00:17:21.000Z","categories_index":"前端","tags_index":"CSS","author_index":"会思想的苇草i"},{"id":"6d37bc10bf7dcfd3ccdbf8e29e0a8564","title":"前端必备之CSS基础知识点","content":"CSS1、基础认知\nCSS：层叠样式表(Cascading style sheets)，给页面中的HTML标签设置样式\nCSS写在style标签中，style标签一般写在head标签里面，title标签下面\nCSS引入方式：\n内嵌式: CSS 写在style标签中提示: style标签虽然可以写在页面任意位置，但是通常约定写在head 标签中\n外联式: CSS 写在一个单独的.css文件中提示:需要通过link标签在网页中引入\n行内式: CSS 写在标签的style属性中提示:不推荐使用，之后会配合js使用\n\n\n\n2、基础选择器\n选择器的作用：选择页面中对应的标签，方便后续设置样式\n\n2.1 标签选择器\n结构：标签名 {css属性名：属性值；}\n作用：通过标签名，找到页面中所有这类标签，设置样式\n\n\n\n注意点：\n标签选择器选择的是一类标签，而不是单独某一个\n标签选择器无论嵌套关系有多深，都能找到对应的标签\n\n\n\n2.2 类选择器\n结构：. 类名 {css属性名：属性值}\n作用：通过类名，找到页面中所有带有这个类名的标签，设置样式\n\n\n\n注意点：\n所有标签上都有class属性，class属性的属性值称为类名\n类名可以有数字、字母、下划线、中划线组成，但不能由数字或中划线开头\n一个标签可以同时有多个类名，类名之间以空格隔开\n类名可以重复，一个类选择器可以同时选中多个标签\n\n\n\n2.3 id选择器\n结构：#id属性值 {css属性名：属性值；}\n作用：通过id属性值，找到页面中带有这个id属性值的标签，设置样式\n\n\n\n注意点：\n\n所有标签上都有id属性\nid属性值类似于身份证号码，在一个页面中是唯一的，不可重复的！（强行使用会展示效果，但是不符合语法规范！！！）\n一个标签上只能有一个id属性值\n一个id选择器只能选中一个标签\n\n\n类与id的区别：\n\nclass类名相当于姓名，可以重复，一个标签可以同时有多个class类名\nid属性值相当于身份证号码，不可重复，一个标签只能有一个id属性值\n\n\n实际开发的情况\n\n类选择器用的最多\nid一般配合js使用，除非特殊情况，否则不要使用id设置样式\n实际开发中会遇到冗余代码的抽取(可以将一些公共的代码抽取到一个公共的类中去)\n\n\n\n2.4 通配符选择器\n结构：* {css属性名：属性值；}\n作用：找到页面中所有的标签，设置样式\n\n\n\n注意点：\n开发中使用极少，只会在特殊情况下使用\n用于去除标签默认的margin和padding\n\n\n\n\n3、字体和文本样式3.1 字体样式字体大小\n\n属性名：font-size\n取值：数字+px\n代码：\n\n&lt;style&gt;\n       p &#123;\n            font-size: 30px;\n        &#125;\n&lt;/style&gt;\n\n\n注意点：\n谷歌浏览器默认文字大小是16px\n单位需要设置，否则无效\n\n\n\n字体粗细\n\n属性名：font-weight\n取值：\n关键字：正常 - - normal，加粗 - - bold\n纯数字：100~900的整百数，正常 - - 400，加粗 - - 700\n\n\n代码：\n\n    &lt;style&gt;\t\n    div &#123;\n            /* 加粗 */\n            font-weight: 700;\n        &#125;\n\n        h1 &#123;\n            /* 不加粗 */\n            font-weight: 400;\n        &#125;\n    &lt;/style&gt;\n\n\n注意点：\n不是所有的字体都提供了九种粗细，因此部分取值页面无变化\n实际开发中正常、加粗两种取值使用最多\n\n\n\n字体样式\n\n属性名：font-style\n取值：正常(默认)：normal，倾斜：italic\n代码：\n\n    &lt;style&gt;\n        div &#123;\n            /* 倾斜 */\n            font-style: italic;\n        &#125;\n\n        em &#123;\n            /* 正常的, 不倾斜 */\n            font-style: normal;\n        &#125;\n    &lt;/style&gt;\n\n常见字体系列\n\n无衬线字体(sans-serif)\n\n\n特点:文字笔画粗细均匀，并且首尾无装饰\n场景:网页中大多采用无衬线字体\n常见该系列字体:黑体、Arial\n\n\n衬线字体( serif)\n\n\n特点:文字笔画粗细不均，并且首尾有笔锋装饰\n场景:报刊书籍中应用广泛\n常见该系列字体:宋体、Times New Roman\n\n\n等宽字体(monospace)\n\n\n特点:每个字母或文字的宽度相等\n场景:一般用于程序代码编写，有利于代码的阅读和编写\n常见该系列字体:Consolas、fira code\n\n字体系列\n\n属性名: font-family\n常见取值:具体字体1,具体字体2,具体字体3,具体字体4….字体系列\n具体字体:”Microsoft YaHei”、微软雅黑、黑体、宋体、楷体等…….\n字体系列: sans-serif、serif、monospace等……\n\n\n渲染规则:\n从左往右按照顺序查找，如果电脑中未安装该字体，则显示下一个字体\n如果都不支持，此时会根据操作系统，显示最后字体系列的默认字体\n\n\n代码：\n\n    &lt;style&gt;\n        div &#123;\n            /* 如果用户电脑没有安装微软雅黑, 就按黑体显示文字 */\n            /* 如果电脑没有安装黑体, 就按任意一种非衬线字体系列显示 */\n            font-family: 微软雅黑, 黑体, sans-serif;\n        &#125;\n    &lt;/style&gt;\n\n\n注意点:\n如果字体名称中存在多个单词，推荐使用引号包裹\n最后一项字体系列不需要引号包裹\n网页开发时，尽量使用系统常见自带字体，保证不同用户浏览网页都可以正常浏览\n\n\n\n字体属性连写\n\n属性名：font（复合属性）\n取值：font：style weight size family;\n省略要求：只能省略前两个，如果省略了相当于设置了默认值\n代码：\n\n    &lt;style&gt;\n        p &#123;         \n            /* font: italic 700 66px 宋体;*/\n            font: 100px 微软雅黑;\n        &#125;\n    &lt;/style&gt;\n\n\n注意点：如果需要同时设置单独和连写形式，要么把单独的样式写在连写下面，要么把单独的样式写在连写里面\n\n3.2 文本样式文本缩进\n\n属性名：text-indent\n取值：\n数字+px;\n数字+em；（1em &#x3D; 当前标签的font-size的大小）\n\n\n代码：\n\n    &lt;style&gt;\n        p &#123;\n            /* 默认字号: 16px ; 32 */\n\n            /* em: 一个字的大小 */\n            text-indent: 2em;\n            font-size: 40px;\n        &#125;\n    &lt;/style&gt;\n\n文本水平对齐\n\n属性名：text-align\n取值：\n\n\n\n\n属性值\n效果\n\n\n\nleft\n左对齐\n\n\ncenter\n居中对齐\n\n\nright\n右对齐\n\n\n\n注意点：如果需要让文本水平居中，text-aligh属性给文本所在标签（文本的父元素）设置\ntext-align：center能让哪些元素水平居中\n文本\nspan标签、a标签\ninput标签、img标签\n\n\n代码：\n\n    &lt;style&gt;\n        h1 &#123;\n            text-align: center;\n        &#125;\n\n        body &#123;\n            text-align: right;\n        &#125;\n    &lt;/style&gt;\n\n文本修饰\n\n属性名：text-decoration\n取值：\n\n\n\n\n属性值\n效果\n\n\n\nunderline\n下划线（常用）\n\n\nline-through\n删除线（不常用）\n\n\noverline\n上划线（几乎不用）\n\n\nnone\n无装饰线（常用）\n\n\n\n代码：\n\n    &lt;style&gt;\n        div &#123;\n            text-decoration: underline;\n        &#125;\n\n        p &#123;\n            text-decoration: line-through;\n        &#125;\n\n        h2 &#123;\n            text-decoration: overline;\n        &#125;\n\n        a &#123;\n            text-decoration: none;\n        &#125;\n    &lt;/style&gt;\n\n\n注意点:开发中使用text-decoration：none；清除a标签默认的下划线\n\n3.3 line-height行高\n作用:控制一行的上下行间距\n属性名:line-height\n取值:数字+px；倍数（当前标签font-size的倍数)\n应用:\n让单行文本垂直居中可以设置line-height :文字父元素高度\n网页精准布局时，会设置line-height ，可以取消上下间距\n\n\n代码：\n\n    &lt;style&gt;\n        p &#123;\n            /* line-height: 50px; */\n            /* 自己字号的1.5倍 */\n            /* line-height: 1.5; */\n\n            /* 66px 宋体 倾斜 加粗 行高是2倍 */\n            font: italic 700 66px/2 宋体;\n        &#125;\n    &lt;/style&gt;\n\n    &lt;style&gt;\n        div &#123;\n            width: 552px;\n            height: 400px;\n            background-color: pink;\n            /* background-color: green; */\n            text-align: center;\n            /* 文字是单行的 */\n            /* 垂直居中技巧: 设置行高属性值 = 自身高度属性值 */\n            line-height: 400px;\n            font-size: 61px;\n        &#125;\n    &lt;/style&gt;\n\n\n行高与font连写的注意点:\n如果同时设置了行高和font连写，注意覆盖问题\nfont : style weight size&#x2F;line-height family ;\n\n\n\n\n4、扩展 -  颜色、居中4.1 颜色常见取值关键词\n\n常见颜色取值：red：红色、green：绿色、pink：粉色…\n\nrgb表示法\n\n每项取值范围：0~255\n常见颜色取值：rgb（255,0,0）：红色、rgb（0,255,0）：绿色、rgb（0,0,255）：黑色…\n\nrgba表示法\n\n比rgb表示法多一个a，a表示透明度\na的取值范围：0~1；1-完全不透明，0-完全透明\n省略写法：raga（0,0,0,0.5）可以省略写成rgba（0,0,0,.5）\n\n十六进制表达式\n\n取值范围：两个数字为一组，每个数字的取值范围：0~9，a,b,c,d,e,f\n省略写法：\n三组中每个数字都相同，此时可以每组可以省略只写一个数字\n正确写法：#ffaabb改写成#fab\n\n\n常见取值\n#fff:白色\n#000：黑色\n\n\n注意点\n类似于：#ffaabc不能改写成#fabc\n实际开发中会直接使用测量工具直接得到颜色，不需要前端自己设置颜色\n\n\n\n4.2 标签水平居中\n通过设置margin: 0 auto;实现div、p、h水平居中\n代码：\n\n    &lt;style&gt;\n        div &#123;\n            width: 300px;\n            height: 300px;\n            background-color: pink;\n            margin: 0 auto;\n        &#125;\n    &lt;/style&gt;\n\n\n注意点：\n让div、p、 h (大盒子)水平居中，直接给当前元素本身设置即可\nmargin: 0 auto一般针对于固定宽度的盒子，如果大盒子没有设置宽度，此时会默认占满父元素的宽度\n\n\n\n5、选择器进阶5.1 复合选择器后代选择器:空格\n\n作用:根据HTML标签的嵌套关系，选择父元素后代中满足条件的元素\n选择器语法:选择器1选择器2{ css }\n代码：\n\n    &lt;style&gt;\n        /* 找到div的儿子p设置文字颜色是红色 */\n        /* 父选择器   后代选择器 &#123;&#125; */\n        div p &#123;\n            color: red;\n        &#125;\n    &lt;/style&gt;\n\n\n结果:\n在选择器1所找到标签的后代(儿子.孙子、重孙子…）中，找到满足选择器2的标签，设置样式\n\n\n注意点:\n后代包括:儿子、孙子、重孙子……\n后代选择器中，选择器与选择器之前通过空格隔开\n\n\n\n子代选择器:&gt;\n\n作用:根据HTML标签的嵌套关系，选择父元素子代中满足条件的元素\n选择器语法:选择器1&gt;选择器2{ css }\n代码：\n\n    &lt;style&gt;\n        /* 只想选中儿子a */\n        /* div的儿子a文字颜色是红色 */\n        div&gt;a &#123;\n            color: red;\n        &#125;\n    &lt;/style&gt;\n\n\n结果:\n在选择器1所找到标签的子代(儿子)中，找到满足选择器2的标签，设置样式\n\n\n注意点:\n子代只包括:儿子\n子代选择器中，选择器与选择器之前通过&gt;隔开\n\n\n\n5.2 并集选择器并集选择器:，\n\n作用:同时选择多组标签，设置相同的样式\n选择器语法:选择器1 ，选择器2{ css }\n代码：\n\n    &lt;style&gt;\n        /* p div span h1 文字颜色是红色 */\n        /* 选择器1, 选择器2 &#123;&#125; */\n        p, \n        div, \n        span, \n        h1 &#123;\n            color: red;\n        &#125;\n    &lt;/style&gt;\n\n\n结果:找到选择器1和选择器2选中的标签，设置样式\n\n注意点:\n\n并集选择器中的每组选择器之间通过，分隔\n\n并集选择器中的每组选择器可以是基础选择器或者复合选择器\n\n并集选择器中的每组选择器通常一行写一个，提高代码的可读性\n\n\n\n\n5.3 交集选择器交集选择器:紧挨着\n\n作用:选中页面中同时满足多个选择器的标签\n选择器语法:选择器1选择器2{ css }\n代码：\n\n    &lt;style&gt;\n        /*必须是p标签,而且添加了box类 */\n        p.box &#123;\n            color: red;\n        &#125;\n        /* .box是类选择器 */\n    &lt;/style&gt;\n\n\n结果:(既又原则)找到页面中既能被选择器1选中，又能被选择器2选中的标签，设置样式\n注意点:\n交集选择器中的选择器之间是紧挨着的，没有东西分隔\n交集选择器中如果有标签选择器，标签选择器必须写在最前面\n\n\n\n5.4 hover伪类选择器hover伪类选择器\n\n作用:选中鼠标悬停在元素上的状态，设置样式\n选择器语法:选择器:hover { css }\n代码：\n\n    &lt;style&gt;\n        /* 悬停的时候文字颜色是红色 */\n        a:hover &#123;\n            color: red;\n            background-color: green;\n        &#125;\n    &lt;/style&gt;\n\n\n注意点:伪类选择器选中的元素的某种状态\n\n5.5 Emmet语法\n作用：通过简写语法，快速生成代码\n语法：\n\n\n\n\n记忆\n示例\n效果\n\n\n\n标签名\ndiv\n&lt; div&gt;&lt; &#x2F;div&gt;\n\n\n类选择器\n.red\n&lt; div class&#x3D;”red”&gt;&lt; &#x2F;div&gt;\n\n\nid选择器\n#one\n&lt; div id&#x3D;”one”&gt;&lt; &#x2F;div&gt;\n\n\n交集选择器\np.red#one\n&lt; p class&#x3D;”red” id &#x3D;”one”&gt;&lt; &#x2F;p&gt;\n\n\n子代选择器\nui&gt;li\n&lt; ul&gt;&lt; li&gt;&lt; &#x2F;li&gt;&lt; &#x2F;ul&gt;\n\n\n内部文本\nul&gt;li(li的文本内容)\n&lt; ul&gt;&lt; li&gt;li的文本内容&lt; &#x2F;li&gt;&lt; &#x2F;ul&gt;\n\n\n创建多个\nul&gt;li*3\n&lt; ul&gt;&lt; li&gt;&lt; li&gt;&lt; li&gt;&lt; &#x2F;li&gt;&lt; &#x2F;li&gt;&lt; &#x2F;li&gt;&lt; &#x2F;ul&gt;\n\n\n6、背景相关属性6.1 背景颜色\n属性名: background-color (bgc)\n属性值:颜色取值:关键字、rgb表示法、rgba表示法、十六进制……\n代码：\n\n    &lt;style&gt;\n        div &#123;\n            width: 400px;\n            height: 400px;\n            /* background-color: pink; */\n            /* background-color: #ccc; */\n            /* 红绿蓝三原色, a是透明度0-1 */\n            background-color: rgba(0, 0, 0, .5);\n        &#125;\n    &lt;/style&gt;\n\n\n注意点:\n\n背景颜色默认值是透明: rgba(0,0,0,0). transparent\n\n背景颜色不会影响盒子大小，并且还能看清盒子的大小和位置，一般在布局中会习惯先给盒子设置背景颜色\n\n\n\n\n6.2 背景图片\n属性名: background-image (bgi)\n属性值: background-image: url(‘图片的路径’);\n代码：\n\n    &lt;style&gt;\n        div &#123;\n            width: 400px;\n            height: 400px;\n            background-color: pink;\n            background-image: url(./images/1.jpg);\n        &#125;\n    &lt;/style&gt;\n\n\n注意点:\n\n背景图片中url中可以省略引号\n背景图片默认是在水平和垂直方向平铺的\n背景图片仅仅是指给盒子起到装饰效果，类似于背景颜色，是不能撑开盒子的\n\n\n\n(拓展) img标签和背景图片的区别\n\n需求:需要在网页中展示—张图片的效果\n方法一:直接写上img标签即可\nimg标签是一个标签，不设置宽高默认会以原尺寸显示\n\n\n方法二:div标签＋背景图片\n需要设置div的宽高，因为背景图片只是装饰的CSS样式，不能撑开div标签\n\n\n\n6.3 背景平铺\n属性名：background-repeat(bgr)\n属性值:\n\n\n\n\n取值\n效果\n\n\n\nrepeat\n水平和垂直方向都平铺（默认）\n\n\nno-repeat\n不平铺\n\n\nrepeat-x\n沿着水平方向（x轴）平铺\n\n\nrepeat-y\n沿着垂直方向（y轴）平铺\n\n\n\n代码：\n\n    &lt;style&gt;\n        div &#123;\n            width: 400px;\n            height: 400px;\n            background-color: pink;\n            background-image: url(./images/1.jpg);\n            /* background-repeat: repeat; */\n            /* 不平铺: 图片只显示一个 */\n            /* background-repeat: no-repeat; */\n            /* background-repeat: repeat-x; */\n            /* background-repeat: repeat-y; */\n        &#125;\n    &lt;/style&gt;\n\n6.4 背景位置\n属性名：background-position（bgp）\n\n属性值：background-position:水平方向位置 垂直方向位置；\n\n\n\n\n代码：\n\n    &lt;style&gt;\n        div &#123;\n            width: 400px;\n            height: 400px;\n            background-color: pink;\n            background-image: url(./images/1.jpg);\n            background-repeat: no-repeat;\n            /* background-position: right 0; */\n            /* background-position: center center; */\n            /* background-position: 50px 100px; */\n            background-position: -50px -100px;\n            /* 正数: 向右向下移动; 负数:向左向上移动 */\n            /* 注意: 背景色和背景图只显示在盒子里面 */\n        &#125;\n    &lt;/style&gt;\n\n\n注意点：方位名词取值和坐标取值可以混使用，第一个取值表示水平，第二个取值表示垂直\n\n6.5 背景相关属性连写\n属性名: background (bg）\n属性值:单个属性值的合写，取值之间以空格隔开\n书写顺序:推荐: background: color image repeat position\n代码：\n\n    &lt;style&gt;\n        div &#123;\n            width: 400px;\n            height: 400px;\n            /* 不分先后顺序 背景色  背景图  背景图平铺  背景图位置 */\n            /* background: pink url(./images/1.jpg) no-repeat center bottom; */\n            /* 背景图位置如果是英文单词可以颠倒顺序 */\n            background: pink url(./images/1.jpg) no-repeat bottom center ;\n            /* 测试背景图位置如果是数值 不要颠倒顺序 */\n            /* 水平50px, 垂直100px */\n            /* background: pink url(./images/1.jpg) no-repeat 50px 100px; */\n            background: pink url(./images/1.jpg) no-repeat 100px 50px;\n        &#125;\n    &lt;/style&gt;\n\n\n省略问题:\n可以按照需求省略\n特殊情况:在pc端，如果盒子大小和背景图片大小一样，此时可以直接写background: url（)\n\n\n注意点\n如果需要设置单独的样式和连写\n① 要么把单独的样式写在连写的下面\n② 要么把单独的样式写在连写的里面\n\n\n\n7、元素显示模式7.1 块级元素\n显示特点:\n\n独占一行（一行只能显示一个)\n宽度默认是父元素的宽度，高度默认由内容撑开\n可以设置宽高\n\n\n代表标签:div、p、 h系列、ul、 li、dl、dt、dd、form、header、nav、footer……\n\n代码：\n\n\n    &lt;style&gt;\n        /* 块: 独占一行; 宽度默认是父级100%; 添加宽度都生效 */\n        div &#123;\n            width: 300px;\n            height: 300px;\n            background-color: pink;\n\n            /* 行内块 */\n            /* display: inline-block; */\n\n            /* 行内 */\n            /* display: inline; */\n        &#125;\n    &lt;/style&gt;\n\n7.2 行内元素\n显示特点:\n\n一行可以显示多个\n宽度和高度默认由内容撑开\n不可以设置宽高\n\n\n代表标签: a、span、b、u、i、 s、strong、ins、em、del……\n\n代码：\n\n\n    &lt;style&gt;\n        /* 行内: 不换行; 设置宽高不生效; 尺寸和内容的大小相同 */\n        span &#123;\n            width: 300px;\n            height: 300px;\n            background-color: pink;\n\n            /* 行内块 */\n            /* display: inline-block; */\n\n            /* 块 */\n            /* display: block; */\n        &#125;\n    &lt;/style&gt;\n\n7.3 行内块元素\n显示特点:\n\n一行可以显示多个\n\n可以设置宽高\n\n\n\n代表标签:\n\ninput、textarea、button、select…..\n特殊情况: img标签有行内块元素特点，但是Chrome调试工具中显示结果是inline\n\n\n代码：\n   &lt;style&gt;\n           /* 行内块: 一行显示多个; 加宽高生效 */\n           img &#123;\n               width: 100px;\n               height: 100px;\n           &#125;\n       &lt;/style&gt;\n\n\n\n7.4 元素显示模式转换\n目的改变元素默认的显示特点，让元素符合布局要求\n语法;\n\n\n\n\n属性\n效果\n使用频率\n\n\n\ndisplay:block\n转换成块级元素\n较多\n\n\ndisplay:inline-block\n转换成行内块元素\n较多\n\n\ndisplay:inline\n转换成行内元素\n较少\n\n\n拓展：HTML嵌套规范注意点\n\n块级元素一般作为大容器，可以嵌套:文本、块级元素、行内元素、行内块元素等等…….但是:p标签中不要嵌套div、p、h等块级元素\n\na标签内部可以嵌套任意元素，但是:a标签不能嵌套a标签\n\n\n扩展：居中方法总结：\n\n8、CSS特性8.1 继承性\n特性:子元素有默认继承父元素样式的特点（子承父业)\n可以继承的常见属性**(文字控制属性都可以继承)**\n\n\ncolor\nfont-style、font-weight、font-size、font-family\ntext-indent、text-align\nline-height\n……\n\n\n代码：\n\n    &lt;style&gt;\n        /* 控制文字的属性都能继承; 不是控制文字的都不能继承 */\n        div &#123;\n            color: red;\n            font-size: 30px;\n            height: 300px;\n        &#125;\n    &lt;/style&gt;\n\n\n注意点:可以通过调试工具判断样式是否可以继承\n\n拓展：继承的应用\n\n好处:可以在—定程度上减少代码\n常见应用场景:\n\n\n可以直接给ul设置list-style:none属性，从而去除列表默认的小圆点样式\n直接给body标签设置统一的font-size，从而统一不同浏览器默认文字大小\n\n拓展：继承失效的特殊情况\n\n如果元素有浏览器默认样式，此时继承性依然存在，但是优先显示浏览器的默认样式\na标签的color会继承失效\n其实color属性继承下来了，但是被浏览器默认设置的样式给覆盖掉了\n\n\nh系列标签的font-size会继承失效\n其实font-size属性继承下来了，但是被浏览器默认设置的样式给覆盖掉了\n\n8.2 层叠性\n特性:\n给同一个标签设置不同的样式→此时样式会层叠叠加→会共同作用在标签上\n给同一个标签设置相同的样式→此时样式会层叠覆盖→最终写在最后的样式会生效\n\n\n代码：\n\n    &lt;style&gt;\n        div &#123;\n            color: red;\n            color: green;\n        &#125;\n        /*颜色显示为绿色*/\n        .box &#123;\n            font-size: 30px;\n        &#125;\n    &lt;/style&gt;\n\n\n注意点:当样式冲突时，只有当选择器优先级相同时，才能通过层叠性判断结果\n\n8.3 优先级优先级介绍\n\n特性:不同选择器具有不同的优先级，优先级高的选择器样式会覆盖优先级低选择器样式\n优先级公式:\n继承&lt;通配符选择器&lt;标签选择器&lt;类选择器&lt; id选择器&lt;行内样式&lt; !limportant\n\n\n代码：\n\n    &lt;style&gt;\n        #box &#123;\n            color: orange;\n        &#125;\n\n        .box &#123;\n            color: blue;\n        &#125;\n\n        div &#123;\n            color: green !important;\n        &#125;\n\n        body &#123;\n            color: red;\n        &#125;\n\n        /* !important不要给继承的添加, 自己有样式无法继承父级样式 */\n    &lt;/style&gt;\n\n\n注意点:\n\n\n!important写在属性值的后面，分号的前面!\n!important不能提升继承的优先级，只要是继承优先级最低!\n**实际开发中不建议使用!important **\n\n权重叠加计算\n\n场景:如果是复合选择器，此时需要通过权重叠加计算方法，判断最终哪个选择器优先级最高会生效\n权重叠加计算公式:(每—级之间不存在进位)\n\n\n\n比较规则:\n先比较第一级数字，如果比较出来了，之后的统统不看\n如果第一级数字相同，此时再去比较第二级数字，如果比较出来了，之后的统统不看\n…\n如果最终所有数字都相同，表示优先级相同，则比较层叠性（谁写在下面，谁说了算!)\n注意点: !important如果不是继承，则权重最高，天下第一!\n\n\n\n\n\n权重叠加计算\n\n权重计算题解题步骤:\n先判断选择器是否能直接选中标签，如果不能直接选中→是继承，优先级最低→直接pass\n通过权重计算公式，判断谁权重最高\n\n\n注意点:实际开发中选择标签需要精准，尽量避免多个选择器同时选中一个标签的情况，不要自己难为自己\n\n查错流程\n\n9、盒子模型9.1 盒子模型简介\n盒子的概念\n页面中的每一个标签，都可看做是一个“盒子”，通过盒子的视角更方便的进行布局\n浏览器在渲染（显示)网页时，会将网页中的元素看做是一个个的矩形区域，我们也形象的称之为盒子\n\n\n盒子模型\nCSS中规定每个盒子分别由:内容区域(content)、内边距区域(padding)、边框区域(border)、外边距区域(margin)构成，这就是盒子模型\n\n\n记忆:可以联想现实中的包装盒\n\n\n9.2 内容区域的宽度和高度\n作用:利用width 和height属性默认设置是盒子内容区域的大小\n属性: width &#x2F; height\n代码：\n\n    &lt;style&gt;\n        div &#123;\n            width: 200px;\n            height: 200px;\n            background-color: pink;\n        &#125;\n    &lt;/style&gt;\n\n\n常见取值:数字+px\n\n\n9.3 边距(border)边框–单个属性\n\n作用：给设置边框粗细、边框样式、边框颜色效果\n单个属性：\n\n\n\n\n作用\n属性名\n属性值\n\n\n\n边框粗细\nborder-width\n数字+px\n\n\n边框样式\nborder-style\n实线solid、虚线dashed、点线dotted\n\n\n边框颜色\nborder-color\n颜色取值\n\n\n边框–连写形式\n\n属性名：border\n\n属性值：单个取值的连写，取值之间以空格隔开。如border：10px solid red；\n\n快捷键：bd+tab\n\n\n边框–单方向设置\n\n场景：只给盒子某个方向单独设置边框\n属性名：bord - 方位名词\n属性值：连写的取值\n代码：\n\n    &lt;style&gt;\n        div &#123;\n            width: 200px;\n            height: 200px;\n            background-color: pink;\n            \n            border-left: 5px dotted #000;\n            border-right: 5px dotted #000;\n            border-top: 1px solid red;\n            border-bottom: 1px solid red;\n        &#125;\n    &lt;/style&gt;\t\t\n\n9.4 内边距(padding)内边距–取值\n\n作用：设置边框与内容区域之间的距离\n属性名：padding\n常见取值：\n\n\n\n\n取值\n示例\n含义\n\n\n\n一个值\npadding：10px;\n上下左右10px\n\n\n两个值\npadding：10px 20px;\n上下10px，左右20px\n\n\n三个值\npadding：10px 20px 30px;\n上10px，左右20px，下30px\n\n\n四个值\npadding：10px 20px 30px 40px;\n上10px，右20px，下30px，左40px\n\n\n内边距–单方向设置\n\n场景：只给盒子的某个方向单独设置内边距\n属性名：padding - 方位名词\n属性值：数字+px\n代码：\n\n    &lt;style&gt;\n        div &#123;\n            width: 300px;\n            height: 300px;\n            background-color: pink;\n\n            padding-left: 10px;\n            padding-bottom: 50px;\n        &#125;\n    &lt;/style&gt;\n\n盒子实际大小计算公式\n\n需求:盒子尺寸300*300，背景粉色，边框10px实线黑色，上下左右20px的内边距，如何完成?\n\n注意点:①设置width和height是内容的宽高!②设置border会撑大盒子③设置padding会撑大盒子\n\n盒子实际大小终极计算公式:\n\n盒子宽度&#x3D;左边框＋左padding +内容宽度＋右padding +右边框\n盒子高度&#x3D;上边框＋上padding +内容宽度＋ 下padding+下边框\n\n\n代码：\n\n\n    &lt;style&gt;\n        div &#123;\n            /* 撑大盒子的都有哪些? border + padding */\n            /* width: 300px;\n            height: 300px; */\n            width: 240px;\n            height: 240px;\n            background-color: pink;\n            border: 10px solid #000;\n            padding: 20px;\n        &#125;\n    &lt;/style&gt;\n\n扩展：不会撑大盒子的特殊情况（块级元素）\n\n如果子盒子没有设置宽度，此时宽度默认是父盒子的宽\n此时给子盒子设置左右的padding或者左右的border，此时不会撑大子盒子\n\nCSS3盒模型（自动内减)\n\n需求:盒子尺寸300*300，背景粉色，边框10px实线黑色，上下左右20px的内边距，如何完成?\n\n给盒子设置border或padding时，盒子会被撑大，如果不想盒子被撑大?\n\n解决方法①∶手动内减\n\n操作:自己计算多余大小，手动在内容中减去\n缺点:项目中计算量太大，很麻烦\n\n\n解决方法②︰自动内减\n\n操作:给盒子设置属性box-sizing : border-box;即可\n优点:浏览器会自动计算多余大小，自动在内容中减去\n\n\n代码：\n\n\n    &lt;style&gt;\n        div &#123;\n            width: 300px;\n            height: 300px;\n            background-color: pink;\n            border: 10px solid #000;\n            padding: 20px;\n\n            /* 內减模式 */\n            /* 变成CSS3的盒子模型, 好处: 加了border和padding不需要手动减法 */\n            box-sizing: border-box;\n        &#125;\n    &lt;/style&gt;\n\n9.5 外边距(margin)外边距-取值\n\n作用：设置边框以外，盒子与盒子之间的距离\n\n属性名：margin\n\n常见取值：\n\n\n\n\n\n取值\n示例\n含义\n\n\n\n一个值\nmargin：10px;\n上下左右10px\n\n\n两个值\nmargin：10px 20px;\n上下10px，左右20px\n\n\n三个值\nmargin：10px 20px 30px;\n上10px，左右20px，下30px\n\n\n四个值\nmargin：10px 20px 30px 40px;\n上10px，右20px，下30px，左40px\n\n\n外边距–单方向设置\n\n场景：只给盒子的某个方向单独设置内边距\n\n属性名：margin - 方位名词\n\n属性值：数字+px\n\n代码：\n\n\n    &lt;style&gt;\n        div &#123;\n            width: 100px;\n            height: 100px;\n            background-color: pink;\n            margin: 50px;\n            margin-left: 100px;\n        &#125;\n    &lt;/style&gt;\n\n清除默认内外边距\n\n场景:浏览器会默认给部分标签设置默认的margin和padding，但一般在项目开始前需要先清除这些标签默认的margin和padding，后续自己设置\n\n解决方法：\n\n\n\n\n\n代码\n\n    &lt;style&gt;\n        * &#123;\n            margin: 0;\n            padding: 0;\n        &#125;\n    &lt;/style&gt;\n\n版型居中\n\n代码：\n\n    &lt;style&gt;\n        div &#123;\n            width: 1000px;\n            height: 300px;\n            background-color: pink;\n            margin: 0 auto;\n        &#125;\n    &lt;/style&gt;\n\n外边距正常情况\n\n场景:水平布局的盒子，左右的margin正常，互不影响\n结果:最终两者距离为左右margin的和\n\n外边距折叠现象一①合并现象\n\n场景:垂直布局的块级元素，上下的margin会合并\n结果:最终两者距离为margin的最大值\n解决方法:避免就好，只给其中一个盒子设置margin即可\n代码：\n\n    &lt;style&gt;\n        div &#123;\n            width: 100px;\n            height: 100px;\n            background-color: pink;\n        &#125;\n\n        .one &#123;\n            /* margin-bottom: 50px; */\n            margin-bottom: 60px;\n        &#125;\n\n        .two &#123;\n            margin-top: 50px;\n        &#125;\n    &lt;/style&gt;\n\n外边距折叠现象一②塌陷现象\n\n场景:互相嵌套的块级元素，子元素的margin-top会作用在父元素上\n\n结果:导致父元素—起往下移动\n\n解决方法:\n\n给父元素设置border-top 或者padding-top(分隔父子元素的margin-top)\n给父元素设置overflow: hidden\n转换成行内块元素\n设置浮动\n\n\n代码：\n\n\n    &lt;style&gt;\n        .father &#123;\n            width: 300px;\n            height: 300px;\n            background-color: pink;\n            /* padding-top: 50px; */\n            /* 如果设计稿没有border, 不能使用这个解决办法 */\n            /* border: 1px solid #000; */\n\n            /* overflow: hidden; */\n        &#125;\n\n        .son &#123;\n            width: 100px;\n            height: 100px;\n            background-color: skyblue;\n\n            margin-top: 50px;\n\n            display: inline-block;\n        &#125;\n    &lt;/style&gt;\n\n行内元素的margin和padding无效情况\n\n场景:给行内元素设置margin和padding时\n\n结果:\n\n水平方向的margin和padding布局中有效!\n垂直方向的margin和padding布局中无效!\n\n\n代码：\n\n\n    &lt;style&gt;\n        span &#123;\n            /* margin: 100px; */\n            /* padding: 100px; */\n            line-height: 100px;\n        &#125;\n    &lt;/style&gt;\n\n10、结构伪类选择器\n作用与优势:\n\n作用:根据元素在HTML中的结构关系查找元素\n优势:减少对于HTML中类的依赖，有利于保持代码整洁\n场景: 常用于查找某父级选择器中的子元素选择器\n\n\n选择器：\n\n\n\n\n\n选择器\n说明\n\n\n\nE:first-child{}\n匹配父元素中第一个子元素，并且是E元素\n\n\nE:last-child{}\n匹配父元素中最后一个子元素，并且是E元素\n\n\nE:nth-child(n){}\n匹配父元素中第n个子元素，并且是E元素\n\n\nE:nth-last-child(n){}\n匹配父元素中倒数第n个子元素，并且是E元素\n\n\n\n代码：\n\n    &lt;style&gt;\n        /* 选中第一个 */\n        /* li:first-child &#123;\n            background-color: green;\n        &#125; */\n\n        /* 最后一个 */\n        /* li:last-child &#123;\n            background-color: green;\n        &#125; */\n\n        /* 任意一个 */\n        /* li:nth-child(5) &#123;\n            background-color: green;\n        &#125; */\n\n        /* 倒数第xx个 */\n        li:nth-last-child(1) &#123;\n            background-color: blue;\n        &#125;\n    &lt;/style&gt;\n\n\nn的注意点\nn为：0、1 、2 、 3…\n通过n可以组成常见公式\n\n\n\n\n\n\n功能\n公式\n\n\n\n偶数\n2n、even\n\n\n奇数\n2n+1、2n-1、odd\n\n\n找到前5个\n-n+5\n\n\n找到第5个往后\nn+5\n\n\n\n代码：\n\n    &lt;style&gt;\n        /* ** 偶数 */\n        /* li:nth-child(2n) &#123; */\n\n            /* *** 奇数 */\n        /* li:nth-child(2n+1) &#123; */\n            /* 找到前3个 */\n        /* li:nth-child(-n+3) &#123; */\n\n            /* *** 4的倍数 */\n        li:nth-child(4n) &#123;\n            background-color: green;\n        &#125;\n    &lt;/style&gt;\n\n扩展：nth-of-type结构伪类子元素\n\n选择器：\n\n\n\n\n选择器\n说明\n\n\n\nE：nth-of-type(n){}\n只在父元素的同类型(E)子元素范围内，匹配第n个\n\n\n\n区别\n\n:nth-child →直接在所有孩子中数个数\n:nth-of-type→先通过该类型找到符合的一堆子元素，然后在这一堆子元素中数个数\n\n\n代码：\n\n\n    &lt;style&gt;\n        /* 找到第一个li 里面的  第三个a  设置文字颜色是红色 */\n        li:first-child a:nth-child(3) &#123;\n            color: red;\n        &#125;\n    &lt;/style&gt;\n\n11、伪元素\n伪元素:一般页面中的非主体内容可以使用伪元素\n区别:\n元素:HTML设置的标签\n伪元素:CSS模拟出的标签效果\n\n\n种类:\n\n\n伪元素\n作用\n\n\n\n::before\n在父元素内容的最前添加一个伪元素\n\n\n::after\n在父元素内容的最后添加一个伪元素\n\n\n\n代码：\n\n    &lt;style&gt;\n        .father &#123;\n            width: 300px;\n            height: 300px;\n            background-color: pink;\n        &#125;\n\n        .father::before &#123;\n            /* 内容 */\n            /* content属性必须添加, 否则伪元素不生效 */\n            content: &#39;老鼠&#39;;\n            color: green;\n            background-color: blue;\n        &#125;\n\n        .father::after &#123;\n            content: &#39;大米&#39;;\n        &#125;\n    &lt;/style&gt;\n\n\n注意点:\n必须设置content属性才能生效\n伪元素默认是行内元素\n\n\n\n12、标准流\n标准流︰又称文档流，是浏览器在渲染显示网页内容时默认采用的一套排版规则，规定了应该以何种方式排\n元素常见标准流排版规则:1．块级元素:从上往下，垂直布局，独占一行2．行内元素或行内块元素:从左往右，水平布局，空间不够自动折行\n\n13、浮动13.1 浮动的作用\n早期的作用：图文环绕\n\n\n\n现在的作用：网页布局\n场景：让垂直布局的盒子变成水平布局，如：一个在左，一个在右\n\n\n\n\n13.2 浮动的代码\n属性名：float\n属性值：\n\n\n\n\n属性名\n效果\n\n\n\nleft\n左浮动\n\n\nright\n右浮动\n\n\n\n代码：\n\n    &lt;style&gt;\n        div &#123;\n            width: 100px;\n            height: 100px;\n        &#125;\n\n        .one &#123;\n            background-color: pink;\n            float: left;\n        &#125;\n\n        .two &#123;\n            background-color: skyblue;\n            /* flr */\n            float: right;\n            /* float: left; */\n        &#125;\n    &lt;/style&gt;\n\n13.3 浮动的特点\n浮动元素会脱离标准流(简称:脱标)，在标准流中不占位置\n相当于从地面飘到了空中\n\n\n浮动元素比标准流高半个级别，可以覆盖标准流中的元素\n浮动找浮动，下一个浮动元素会在上一个浮动元素后面左右浮动\n浮动元素有特殊的显示效果\n一行可以显示多个\n可以设置宽高\n\n\n注意点:\n浮动的元素不能通过text-align:center或者margin:0 auto\n\n\n\n13.4 清除浮动\n含义:清除浮动带来的影响\n\n影响∶如果子元素浮动了，此时子元素不能撑开标准流的块级父元素\n\n\n原因:\n\n子元素浮动后脱标→不占位置\n\n\n目的:\n\n需要父元素有高度，从而不影响其他网页元素的布局\n\n\n\n清除浮动的方法一- -直接设置父元素高度\n\n特点:\n优点:简单粗暴，方便\n缺点:有些布局中不能固定父元素高度。\n\n\n\n清除浮动的方法二- -额外标签法\n\n操作:\n\n在父元素内容的最后添加一个块级元素\n\n给添加的块级元素设置clear:both特点:\n\n\n\n代码：\n\n\n    &lt;style&gt;\n    .clearfix &#123;\n            /* 清除左右两侧浮动的影响 */\n            clear: both;\n        &#125;\n    &lt;/style&gt;\n\n\n缺点: 会在页面中添加额外的标签，会让页面的HTML结构变得复杂\n\n清除浮动的方法三- -单伪元素清除法\n\n操作：用伪元素替代了额外标签\n\n基本写法\n\n\n\n\n\n补充写法\n\n\n\n特点：项目中使用，直接给标签加类即可清除\n\n清除浮动的方法四- -双伪元素清除法\n\n操作：\n\n\n\n特点：在项目中使用，直接给标签加类即可清除浮动\n\n清除浮动的方法五- -给父元素设置overflow:hidden\n\n操作：直接给父元素设置overflow:hidden\n代码：\n\n    &lt;style&gt;\n        .top &#123;\n            margin: 0 auto;\n            width: 1000px;\n            height: 600px;\n            background-color: pink;\n\n            overflow: hidden;\n        &#125;\n    &lt;/style&gt;\n\n\n特点：方便\n\n扩展：BFC的介绍\n\n块格式化上下文(Block Formatting Context) : BFC\n\n是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。\n\n\n创建BFC方法:\n\nhtml标签是BFC盒子\n浮动元素是BFC盒子\n行内块元素是BFC盒子\noverflow属性取值不为visible。如: auto、hidden…\n……\n\n\nBFC盒子常见特点:\n\nBFC盒子会默认包裹住内部子元素（标准流、浮动)→应用:清除浮动\nBFC盒子本身与子元素之间不存在margin的塌陷现象→应用:解决margin的塌陷\n…\n\n\n\n14、定位14.1 定位概述\n定位：\n\n可以让元素自由的摆放在网页的任意位置\n一般用于盒子之间的层叠情况\n\n\n场景：\n\n定位之后的元素层级最高，可以层叠在其他盒子上面\n可以让盒子始终固定在屏幕中的某个位置\n\n\n定位的使用步骤：\n\n\n\n设置定位方式：\n\n属性名：position；\n常见属性值：\n\n\n\n\n\n\n定位方式\n属性值\n\n\n\n静态定位\nstatic\n\n\n相对定位\nrelative\n\n\n绝对定位\nabsolute\n\n\n固定定位\nfixed\n\n\n\n设置偏移量\n偏移值设置分为两个方向，水平和垂直方向各选一个使用即可\n选取的原则一般是就近原则（离哪边近用哪个)\n\n\n\n\n\n\n方向\n属性名\n属性值\n含义\n\n\n\n水平\nleft\n数字+px\n距离左边的距离\n\n\n水平\nright\n数字+px\n距离右边的距离\n\n\n垂直\ntop\n数字+px\n距离上边的距离\n\n\n垂直\nbottom\n数字+px\n距离下边的距离\n\n\n14.2 静态定位\n介绍:静态定位是默认值,就是之前认识的标准流。\n代码:\n\n    &lt;style&gt;\n        /* css书写: 1. 定位 / 浮动 / display ; 2. 盒子模型; 3. 文字属性 */\n        .box &#123;\n            /* 静态定位, 默认值, 标准流 */\n            position: static;\n        &#125;\n    &lt;/style&gt;\n\n\n注意点:\n静态定位就是之前标准流,不能通过方位属性进行移动\n之后说的定位不包括静态定位，一般特指后几种:相对、绝对、固定\n\n\n\n14.3 相对定位\n介绍:自恋型定位，相对于自己之前的位置进行移动\n代码:\n\n    &lt;style&gt;\n        /* 如果left和right都有, 以left为准; top和bottom都有以top 为准 */\n        .box &#123;\n            position: relative;\n            right: 200px;\n            bottom: 400px;\n            left: 100px;\n            top: 200px;\n        &#125;\n    &lt;/style&gt;\n\n\n特点:\n需要配合方位属性实现移动\n相对于自己原来位置进行移动\n在页面中占位置→没有脱标\n\n\n应用场景:\n配合绝对定位组CP(子绝父相)\n用于小范围的移动\n\n\n\n14.4 绝对定位\n介绍:拼爹型定位，相对于非静态定位的父元素进行定位移动\n代码:\n\n    &lt;style&gt;\n        .box &#123;\n\n            position: absolute;\n            /* left: 50px; */\n            left: 0;\n            top: 0;  \n        &#125;\n    &lt;/style&gt;\n\n\n特点:\n需要配合方位属性实现移动\n默认相对于浏览器可视区域进行移动\n在页面中不占位置→已经脱标\n\n\n应用场景:配合绝对定位组CP(子绝父相)\n绝对定位偏移参照物\n祖先元素中没有定位，默认相当于浏览器进行移动\n祖先元素中有定位，相对于最近的有定位的祖先元素进行移动\n\n\n\n14.5 子绝父相\n场景:让子元素相对于父元素进行自由移动\n特殊场景：使用子绝父相的时候，发现父元素已经有相对定位了，此时直接子绝即可，因为父元素已经有定位满足需求，如果盲目修改父元素定位方式，可能会影响之前写好的布局\n代码：\n\n    &lt;style&gt;\n        .father &#123;\n            position: relative;\n        &#125;\n        .son &#123;\n            position: absolute;\n            /* left: 20px;\n            top: 30px; */\n            right: 20px;\n            bottom: 50px;\n        &#125;\n    &lt;/style&gt;\n\n\n含义:\n子元素:绝对定位\n父元素:相对定位\n子绝父相好处:\n父元素是相对定位，则对网页布局影响最小\n\n\n\n\n\n14.6 固定定位\n介绍:死心眼型定位，相对于浏览器进行定位移动\n代码:\n\n    &lt;style&gt;\n        .box &#123;\n            position: fixed;\n            left: 0;\n            top: 0;\n        &#125;\n    &lt;/style&gt;\n\n\n特点:\n\n需要配合方位属性实现移动\n\n相对于浏览器可视区域进行移动\n\n在页面中不占位置→已经脱标\n\n\n\n\n应用场景:让盒子固定在屏幕中的某个位置\n14.7 元素的层级关系\n不同布局方式元素的层级关系:标准流&lt;浮动&lt;定位\n\n不同定位之间的层级关系:\n\n相对、绝对、固定默认层级相同\n此时HTML中写在下面的元素层级更高，会覆盖上面的元素\n\n\n场景:改变定位元素的层级\n\n属性名:z-index\n\n属性值:数字\n\n数字越大，层级越高\n\n\n代码：\n\n\n    &lt;style&gt;\n        div &#123;\n            width: 200px;\n            height: 200px;\n        &#125;\n\n        .one &#123;\n            position: absolute;\n            left: 20px;\n            top: 50px;\n            \n            z-index: 1;\n\n            background-color: pink;\n        &#125;\n\n        .two &#123;\n            position: absolute;\n            left: 50px;\n            top: 100px;\n            \n            background-color: skyblue;\n        &#125;\n\n        /* \n            默认情况下, 定位的盒子  后来者居上 ,\n            z-index:整数; 取值越大, 显示顺序越靠上, z-index的默认值是0\n            注意: z-index必须配合定位才生效\n        */\n    &lt;/style&gt;\n\n15、装饰15.1 垂直对齐方式\n基线：浏览器文字类型元素排版中存在用于对齐的基线(baseline)\n\n\n垂直对齐方式\n\n属性名：vertical-align\n属性值：\n\n\n\n\n属性值\n效果\n\n\n\nbaseline\n默认，基线对齐\n\n\ntop\n顶部对齐\n\n\nmiddle\n中部对齐\n\n\nbottom\n底部对齐\n\n\n项目中垂直居中可以解决的问题\n\n文本框和表单按钮无法对齐问题\n\n\n代码：\n\n    &lt;style&gt;\n    /* 浏览器遇到行内和行内块标签当做文字处理, 默认文字是按基线对象 */\n    input &#123;\n      height: 50px;\n      box-sizing: border-box;\n\n      vertical-align: middle;\n    &#125;\n\n  &lt;/style&gt;\n\n\ninput和img无法对齐问题\n\n\n代码：\n\n    &lt;style&gt;\n   img &#123;\n     vertical-align: middle;\n   &#125;\n  &lt;/style&gt;\n\n\ndiv中的文本框，文本框无法贴顶问题\n\n\n代码：\n\n    &lt;style&gt;\n    .father &#123;\n      width: 400px;\n      height: 400px;\n      background-color: pink;\n    &#125;\n\n    input &#123;\n      /* vertical-align: middle; */\n      vertical-align: top;\n    &#125;\n\n  &lt;/style&gt;\n\n\ndiv不设高度由img标签撑开，此时img标签下面会存在额外间隙问题\n\n\n代码：\n\n    &lt;style&gt;\n    .father &#123;\n      width: 400px;\n      background-color: pink;\n    &#125;\n\n    img &#123;\n      /* 浏览器把行内和行内块标签当做文字处理,默认基线对齐 */\n      /* vertical-align: middle; */\n      display: block;\n    &#125;\n\n  &lt;/style&gt;\n\n\n使用line-heigh解决img标签垂直居中问题\n\n\n代码：\n\n    &lt;style&gt;\n    .father &#123;\n      width: 600px;\n      height: 600px;\n      background-color: pink;\n      line-height: 600px;\n      text-align: center;\n    &#125;\n\n    img &#123;\n      vertical-align: middle;\n    &#125;\n  &lt;/style&gt;\n\n\n注意点:\n学习浮动之后，不推荐使用行内块元素让div一行中显示，因为可能会出现垂直对齐问题\n推荐优先使用浮动完成效果\n\n\n\n15.2 光标类型\n场景：设置鼠标光标在元素上时显示的样式\n属性名：cursor\n常见属性值：\n\n\n\n\n属性值\n效果\n\n\n\ndefault\n默认值、通常是箭头\n\n\npointer\n小手效果，提示用户可以点击\n\n\ntext\n工子型，提示用户可以选择文字\n\n\nmove\n十字光标，提示用户可以移动\n\n\n\n代码：\n\n    &lt;style&gt;\n        div &#123;\n            /* 手型 */\n            /* cursor: pointer; */\n\n            /* 工字型, 表示可以复制 */\n            /* cursor: text; */\n\n            /* 十字型, 表示可以移动 */\n            cursor: move;\n        &#125;\n    &lt;/style&gt;\n\n15.3 边框圆角\n场景:让盒子四个角变得圆润，增加页面细节，提升用户体验\n\n属性名: border-radius\n\n常见取值:数字+px、百分比\n\n原理:\n\n\n\n\n赋值规则:从左上角开始赋值，然后顺时针赋值，没有赋值的看对角!\n\n代码：\n\n\n    &lt;style&gt;\n        .box &#123;\n            margin: 50px auto;\n            width: 200px;\n            height: 200px;\n            background-color: pink;\n\n            /* 一个值: 表示4个角是相同的 */\n            border-radius: 10px;\n\n            /* 4值: 左上  右上   右下   左下 -- 从左上顺时针转一圈 */\n            /* border-radius: 10px 20px 40px 80px; */\n\n            /* border-radius: 10px 40px 80px; */\n\n            /* border-radius: 10px 80px; */\n        &#125;\n    &lt;/style&gt;\n\n边框圆角的常见应用\n\n画一个正圆:\n\n盒子必须是正方形\n\n设置边框圆角为盒子宽高的一半→border-radius:50%\n\n\n\n胶囊按钮:\n\n盒子要求是长方形\n设置→border-radius:盒子高度的一半\n\n\n代码：\n\n\n    &lt;style&gt;\n        /* 第一个盒子样式 */\n        .one &#123;\n            width: 200px;\n            height: 200px;\n            background-color: pink;\n\n            /* border-radius: 100px; */\n            /* 50% : 取盒子尺寸的一半 */\n            border-radius: 50%;\n        &#125;\n\n        /* 第二个盒子样式 */\n        /* 胶囊状: 长方形, border-radius取值是高度的一半 */\n        .two &#123;\n            width: 400px;\n            height: 200px;\n            background-color: skyblue;\n\n            border-radius: 100px;\n        &#125;\n    &lt;/style&gt;\n\n15.4 overflow溢出部分显示效果\n溢出部分:指的是盒子内容部分所超出盒子范围的区域\n场景:控制内容溢出部分的显示效果，如:显示、隐藏、滚动条……\n属性名: overflow\n常见属性值:\n\n\n\n\n属性值\n效果\n\n\n\nvisible\n默认值，溢出部分可见\n\n\nhidden\n溢出部分隐藏\n\n\nscroll\n无论是否溢出，都显示滚动条\n\n\nauto\n根据是否溢出，自动显示或隐藏滚动条\n\n\n\n代码：\n\n    &lt;style&gt;\n        .box &#123;\n            width: 300px;\n            height: 300px;\n            background-color: pink;\n\n            /* 溢出隐藏 */\n            overflow: hidden;\n\n            /* 滚动: 无论内容是否超出都显示滚动条的位置 */\n            /* overflow: scroll; */\n\n            /* auto: 根据内容是否超出, 判断是否显示滚动条 */\n            /* overflow: auto; */\n        &#125;\n    &lt;/style&gt;\n\n15.5 元素本身隐藏\n场景:让某元素本身在屏幕中不可见。如:鼠标:hover之后元素隐藏\n常见属性:\n\n\nvisibility: hidden\n\ndisplay: none\n\n\n\n区别:\n\n\nvisibility: hidden隐藏元素本身，并且在网页中占位置\ndisplay: none隐藏元素本身，并且在网页中不占位置\n\n\n注意点:\n开发中经常会通过display属性完成元素的显示隐藏切换\ndisplay: none;(隐藏)、display: block;(显示)\n\n\n\n扩展：元素整体透明度\n\n场景:让某元素整体（包括内容)一起变透明\n属性名: opacity\n属性值:0~1之间的数字\n1:表示完全不透明\n0:表示完全透明\n\n\n注意点:\nopacity会让元素整体透明，包括里面的内容，如:文字、子元素等…\n\n扩展：边框合并\n\n场景:让相邻表格边框进行合并，得到细线边框效果\n代码: border-collapse: collapse\n\n扩展：用CSS画三角形技巧\n\n实现原理：利用盒子边框完成\n实现步骤：\n设置一个盒子\n设置四周不同的颜色\n将盒子宽高设置为0，仅保留边框\n得到四个三角形，选择其中一个后，其他三角形（边框）设置颜色为透明\n\n\n\n\n\n代码：\n\n    &lt;style&gt;\n        div &#123;\n            /* width: 100px;\n            height: 100px; */\n            width: 0;\n            height: 0;\n            /* background-color: pink; */\n            /* transparent: 透明 */\n            border-top: 10px solid transparent;\n            border-right: 10px solid transparent;\n            border-bottom: 10px solid transparent;\n            border-left: 10px solid orange;\n        &#125;\n    &lt;/style&gt;\n\n\n通过调整不同边框的宽度，可以调整三角形的形态\n\n16、选择器扩展1、链接伪类选择器\n场景：常用于选中超链接的不同状态\n选择器语法：\n\n\n\n\n选择器语法\n功能\n\n\n\na:link{ }\n选中a链接未访问过的状态\n\n\na:visited { }\n选中a链接访问之后的状态\n\n\na:hover{ }\n选中鼠标悬停的状态\n\n\na:active{ }\n选中鼠标按下的状态\n\n\n\n注意点：同时实现四种伪类状态，需要按照LVHA的顺序书写\n\n2、焦点伪类选择器\n场景：用于选中元素获取焦点时状态，常用于表单控件\n选择器语法：\n\n\n\n效果：表单控件获取焦点时默认会显示外部轮廓线\n\n3、属性选择器\n场景：\n选择器语法：\n\n\n\n\n选择器\n功能\n\n\n\nE[attr]\n选择具有attr属性的E元素\n\n\nE[attr &#x3D; “val”]\n选择具有attr属性并且属性值等于val的E元素\n\n\n\n代码：\n\n    &lt;style&gt;\n        /* text:背景色是粉色; password背景色是skyblue */\n        input[type=&#39;text&#39;]  &#123;\n            background-color: pink;\n        &#125;\n\n        input[type=&quot;password&quot;] &#123;\n            background-color: skyblue;\n        &#125;\n    &lt;/style&gt;\n\n17、CSS样式补充17.1 精灵图\n场景:项目中将多张小图片，合并成一张大图片，这张大图片称之为精灵图\n\n优点:减少服务器发送次数，减轻服务器的压力，提高页面加载速度\n\n例如:需要在网页中展示8张小图片\n\n8张小图片分别发送→发送8次\n合成一张精灵图发送→发送1次\n\n\n步骤：\n\n\n\n创建一个盒子\n量取小图片大小，将小图片的宽高设置给盒子\n将精灵图设置为盒子的背景图片\n通过量小图片左上角坐标，分别取负值设置给盒子的background-position: x y\n\n\n代码\n\n    &lt;style&gt;\n        span &#123;\n            display: inline-block;\n            width: 18px;\n            height: 24px;\n            background-color: pink;\n            background-image: url(./images/taobao.png);\n            /* 背景图位置属性: 改变背景图的位置 */\n            /* 水平方向位置  垂直方向的位置 */\n            /* 想要向左侧移动图片, 位置取负数;  */\n            background-position: -3px 0;\n        &#125;\n    &lt;/style&gt;\n\n17.2 背景图片大小\n作用:设置背景图片的大小\n\n语法: background-size: 宽度 高度 \n\n取值:\n\n\n\n\n\n取值\n场景\n\n\n\n数字+px\n简单方便，常用\n\n\n百分比\n相当于当前盒子自身的宽高百分比\n\n\ncontain\n包含，将背景图片等比例缩放，直到不会超出盒子的最大\n\n\ncover\n覆盖，将背景图片等比例缩放，直到刚好填满整个盒子没有空白\n\n\n扩展：background连写\n\n完整连写：\n\nbackground: color image repeat position/size\n\n\n注意点：background-size和background连写同时设置时，需要注意覆盖问题\n\n解决：\n\n要么单独的样式写连写的下面\n要么单独的样式写在连写的里面\n\n\n\n17.3 文字阴影\n作用:给文字添加阴影效果，吸引用户注意\n属性名: text-shadow\n取值:\n\n\n\n\n参数\n\n\n\n\nh-shadow\n必须，水平偏移量，允许负值\n\n\nv-shadow\n必须，垂直偏移量，允许负值\n\n\nblur\n可选，模糊度\n\n\ncolor\n可选，阴影颜色\n\n\n\n扩展：阴影可以叠加设置，每组阴影取值之间以逗号隔开\n\n17.4 盒子阴影\n作用:给盒子添加阴影效果，吸引用户注意，体现页面的制作细节\n属性名:box-shadow\n取值:\n\n\n\n\n参数\n\n\n\n\nh-shadow\n必须，水平偏移量，允许负值\n\n\nv-shadow\n必须，垂直偏移量，允许负值\n\n\nblur\n可选，模糊度\n\n\nspread\n可选，阴影扩大\n\n\ncolor\n可选，阴影颜色\n\n\ninset\n可选，将阴影改为内部阴影\n\n\n\n代码：\n\n    &lt;style&gt;\n        .box &#123;\n            width: 200px;\n            height: 200px;\n            background-color: pink;\n\n            box-shadow: 5px 10px 20px 10px green inset;\n\n            /* 注意: 外阴影, 不能添加outset, 添加了会导致属性报错 */\n            /* box-shadow: 5px 10px 20px 10px green outset; */\n        &#125;\n    &lt;/style&gt;\n\n17.5 过渡\n作用:让元素的样式慢慢的变化，常配合hover使用，增强网页交互体验\n属性名: transition\n常见取值:\n\n\n\n\n参数\n取值\n\n\n\n过渡的属性\nall：所有能过渡的属性都过渡;具体属性名width：只有width有过渡\n\n\n过渡的时长\n数字+s(秒)\n\n\n\n代码：\n\n    &lt;style&gt;\n        /* 过渡配合hover使用, 谁变化谁加过渡属性 */\n        .box &#123;\n            width: 200px;\n            height: 200px;\n            background-color: pink;\n            /* 宽度200, 悬停的时候宽度600, 花费1秒钟 */\n            /* transition: width 1s, background-color 2s; */\n\n            /* 如果变化的属性多, 直接写all,表示所有 */\n            transition: all 1s;\n        &#125;\n\n        .box:hover &#123;\n            width: 600px;\n            background-color: red;\n        &#125;\n    &lt;/style&gt;\n\n\n注意点:\n\n\n过渡需要∶默认状态和hover状态样式不同，才能有过渡效果\n\ntransition属性给需要过渡的元素本身加\n\ntransition属性设置在不同状态中，效果不同的\n\n给默认状态设置，鼠标移入移出都有过渡效果\n\n给hover状态设置，鼠标移入有过渡效果，移出没有过渡效果\n\n\n\n\n18、项目扩展18.1 网页和网站\n网页:相当于是每页纸\n\n网站:相当于一本书籍\n\n用户翻阅的时候，看的是每页纸上的内容\n由多页纸整合在一起，就是完整的一本书籍了\n\n\n在互联网中，网站类似于是一本书，网页就是这本书的每一页\n\n比如:淘宝、京东、等就是一个网站，类似于是一本书\n这些网站中的每一个网页，如:主页、登录页面、商品页面就是每一个单独的页面，类似于每一页纸\n多个同主题网页整合在一起，就称之为网站。\n\n\n网页:网站中的每一“页”。例如:淘宝的主页、淘宝的登录页、淘宝的商品页等。\n\n网站:提供特定服务的一组网页集合。例如:百度、淘宝、京东等;\n\n\n18.2 骨架结构标签DOCTYPE文档说明\n\n&lt;！DOCTYPE html&gt;文档类型声明，告诉浏览器该网页的HTML版本\n注意点:DOCTYPE需要写在页面的第一行，不属于HTML标签\n\n网页语言\n\n&lt; html lang&#x3D;”en”&gt;标识网页使用的语言\n作用:搜索引擎归类＋浏览器翻译\n常见语言:zh-CN简体中文&#x2F;en英文\n\n字符编码\n\n&lt; meta charset&#x3D;”UTF-8”&gt;标识网页使用的字符编码\n\n作用:保存和打开的字符编码需要统一设置，否则可能会出现乱码\n\n常见字符编码︰\n\nUTF-8:万国码，国际化的字符编码，收录了全球语言的文字\nGB2312: 6000+汉字\nGBK: 20000+汉字\n\n\n注意点:开发中统一使用UTF-8字符编码即可\n\n代码：\n\n\n&lt;!DOCTYPE html&gt;\n&lt;!-- 中文网站 --&gt;\n&lt;html lang=&quot;zh-CN&quot;&gt;\n&lt;head&gt;\n    &lt;!--charset=&quot;UTF-8&quot; 规定网页的字符编码  --&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n\n    &lt;!-- ie(兼容性差) / edge --&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n\n    &lt;!-- 宽度 = 设备宽度 : 移动端网页的时候要用 --&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n\n18.3 SEO三大标签\nSEO ( Search Engine Optimization):搜索引擎优化\n\n作用:让网站在搜索引擎上的排名靠前\n\n提升SEO的常见方法:\n\n竞价排名\n将网页制作成html后缀\n标签语义化(在合适的地方使用合适的标签)\n…\n\n\nSEO三大标签\n\ntitle:网页标题标签\ndescription:网页描述标签\nkeywords:网页关键词标签\n\n\n代码：\n\n\n&lt;head&gt;\n    &lt;!-- meta:desc --&gt;\n    &lt;meta name=&quot;description&quot; content=&quot;京东JD.COM-专业的综合网上购物商城，为您提供正品低价的购物选择、优质便捷的服务体验。商品来自全球数十万品牌商家，囊括家电、手机、电脑、服装、居家、母婴、美妆、个护、食品、生鲜等丰富品类，满足各种购物需求。&quot;&gt;\n    &lt;!-- meta:kw --&gt;\n    &lt;meta name=&quot;keywords&quot; content=&quot;网上购物,网上商城,家电,手机,电脑,服装,居家,母婴,美妆,个护,食品,生鲜,京东&quot;&gt;\n    &lt;title&gt;京东(JD.COM)-正品低价、品质保障、配送及时、轻松购物&lt;/title&gt;\n&lt;/head&gt;\n\n18.4 ico图标的设置\n场景:显示在标签页标题左侧的小图标，习惯使用.ico格式的图标\n代码:\n\n&lt;head&gt;\n    &lt;link rel=&quot;shortcut icon&quot; href=&quot;ico图标路径&quot; type=&quot;image/x-icon&quot;&gt;\n&lt;/head&gt;\n\n18. 版心\n场景:把页面的主体内容约束在网页中间\n作用:让不同大小的屏幕都能看到页面的主体内容\n代码:\n\n&lt;style&gt;\n    .container &#123;\n        width:1240px;\n        margin:0 auto;\n    &#125;\n&lt;/style&gt;\n\n\n注意点:版心类名常用:container、wrapper、w等\n\n扩展：CSS书写顺序\n\n不同的CSS书写顺序会影响浏览器的渲染性能，推荐前端工程师使用专业的书写顺序习惯\n\n\n\n\n顺序\n类别\n属性\n\n\n\n1\n布局属性\ndisplay、position、float、clear、visibility、overflow\n\n\n2\n盒子模型+背景\nwidth、height、margin、padding、border、background\n\n\n3\n文本内容属性\ncolor、font、text-decoration、text-align、line-height\n\n\n4\n点缀属性\ncursor、border-radius、text-shadow、box-shadow\n\n\n\n注意点：开发中推荐多用类＋后代，但不是层级越多越好，一个选择器中的类选择器的个数推荐不要超过3个\n\n18.5 文件和目录\n新建项目文件夹demo-pc-client，在VScode中打开\n\n在实际开发中，项目文件夹不建议使用中文\n所有项目相关文件都保存在demo-pc-client目录中\n\n\n复制favicon.ico到demo-pc-client目录\n\n一般习惯将ico图标放在项目根目录\n\n\n复制images和uploads目录到demo-pc-client目录中\n\nimages :存放网站固定使用的图片素材，如: logo、样式修饰图片…等. \nuploads:存放网站非固定使用的图片素材，如:商品图片、宣传图片…等\n\n\n新建index.html在根目录\n\n新建css文件夹保存网站的样式，并新建以下CSS文件: \n\nbase.css:基础公共样式\n\ncommon.css:该网站中多个网页相同模块的重复样式，如:头部、底部\n\nindex.css:首页样式\n\n\n\n\n\n18.6 基础公共样式\n场景∶一般项目开始前，首先会去除掉浏览器默认样式，设置为 当前项目需要的初始化样式\n作用︰防止不同浏览器中标签默认样式不同的影响，统一不同浏览器的默认显示效果，方便后续项目开发\n要求:需要认识已有代码，项目中可以直接引入使用\n\n19、更多MDN Web Docs（旧称Mozilla Developer Network、Mozilla Developer Center，简称MDN）是一个汇集众多Mozilla基金会产品和网络技术开发文档的免费网站。\nhttps://developer.mozilla.org/zh-CN/\n","slug":"前端--CSS这一篇就够啦","date":"2022-12-07T12:20:07.000Z","categories_index":"前端","tags_index":"CSS","author_index":"会思想的苇草i"},{"id":"3f8304cf028368451948efda785c3b86","title":"前端必备之HTML基础知识点","content":"HTML1、基础认知\nHTML(HTML (Hyper Text Markup Language）中文译为︰超文本标记语言。专门用于网页开发的语言，主要通过HTML标签对网页中的文本、图片、音频、视频等内容进行描述。\n\nHTML骨架标签由html标签（网页的整体）、head标签（网页的头部）、body标签（网页的身体）、title标签（网页的标题）组成。\n\nHTML注释： \n\nHTML标签的结构：\n\n\n\n标签由&lt;、&gt;、&#x2F;、英文单词或字母组成。并且把标签中&lt;&gt;包括起来的英文单词或字母称为标签名\n常见标签由两部分组成，我们称之为:双标签。前部分叫开始标签，后部分叫结束标签，两部分之间包裹内容&lt; p &gt;&lt; p&#x2F; &gt;\n少数标签由一部分组成，我们称之为:单标签。自成一体，无法包裹内容。&lt; br &gt;\n\n\nHTML标签与标签之间的关系：\n\n\n父子关系(嵌套关系)\n\n&lt;head&gt;\n    &lt;title&gt;&lt;/title&gt;\n&lt;/head&gt;\n\n\n兄弟关系(并列关系)\n\n&lt;head&gt;&lt;/head&gt;\n&lt;body&gt;&lt;/body&gt;\n\n2、排版标签2.1 标题标签\n代码：\n\n&lt;h1&gt;1级标题&lt;/h1&gt;\n&lt;h2&gt;2级标题&lt;/h2&gt;\n&lt;h3&gt;3级标题&lt;/h3&gt;\n&lt;h4&gt;4级标题&lt;/h4&gt;\n&lt;h5&gt;5级标题&lt;/h5&gt;\n&lt;h6&gt;6级标题&lt;/h6&gt;\n\n\n语义：1~6级标题，重要程度依次递减\n特点：文字都有加粗；文字变大，并且h1~h6文字逐渐减小；独占一行\n注意点：标题标签对网页尤为重要，开发中有特定的场景，如新闻的标题，网页的logo部分\n\n2.2 段落标签\n代码：\n\n&lt;p&gt;我是一段文字&lt;/p&gt;\n\n\n语义：段落\n特点：段落之间存在间隙独占一行\n\n2.3 换行标签\n代码：\n\n&lt;br&gt;\n\n\n语义：换行\n特点：单标签；让文字强制换行\n\n2.4 水平线标签\n代码：\n\n&lt;hr&gt;\n\n\n语义：主题的分割转换\n特点： 单标签，在页面中显示一条水平线\n\n3、文本格式化标签    &lt;b&gt;加粗&lt;/b&gt;\n    &lt;strong&gt;加粗&lt;/strong&gt;\n\n    &lt;u&gt;下划线&lt;/u&gt;\n    &lt;ins&gt;下划线&lt;/ins&gt;\n\n    &lt;i&gt;倾斜&lt;/i&gt;\n    &lt;em&gt;倾斜&lt;/em&gt;\n\n    &lt;s&gt;删除线&lt;/s&gt;\n    &lt;del&gt;删除线&lt;/del&gt;\n\n\n语义：突出重要性的强调语境\n优点：有利于人的理解和记忆，有利于机器解析，对搜索引擎（SEO）有帮助\n推荐：strong&#x2F;ins&#x2F;rm&#x2F;del  表示的强调语义更强烈\n\n4、媒体标签4.1 图片标签\n代码：\n\n&lt;img src =&quot;&quot; alt=&quot;&quot;&gt;\n\n\n特点：单标签，img标签需要展示对应的效果，需要借助标签的属性进行设置\n\n\n\n属性注意点：标签的属性写在开始标签内部；标签上可以同时存在多个属性；属性之间以空格隔开；标签名与属性之间必须以空格隔开；属性之间没有顺序之分\n\nsrc属性\n\n属性名：src\n属性值：目标图片的路径\n注意点：注意路径问题\n\nalt属性\n\n属性名：alt\n属性值：替换文本\n当图片加载失败时，才显示alt的文本\n当图片加载成功时，不会显示alt的文本\n\n\n\ntitle属性\n\n属性名：title\n\n属性值：提示文本\n\n当鼠标悬停时，才显示的文本\n\n\n注意点：title属性不仅可用于图片标签，还可以用于其他标签\n\n\nwidth和height标签\n\n属性名：width和height\n\n属性值：宽度和高度\n\n注意点：\n\n只设置width和height中的一个，另一个没设置的会自动等比例缩放\n同时设置width和height两个，若设置不当此时图片可能会变形\n\n\n\n4.2 路径绝对路径\n\n指目录的绝对位置，可直接到达目标位置，通常从盘符开始的路径\n举例：\n盘符开头：D:\\images\\1.jpg\n完整的网络地址：https://www.itcast.cn/2018czgw/images/logo.gif\n\n\n\n相对路径\n\n从当前文件开始出发找目标文件的过程\n同级目录：当前文件和目标文件在同一目录中\n\n\n\n代码步骤：\n\n方法一: &lt; img src&#x3D;”目标图片.gif”&gt;\n方法二: &lt; img src&#x3D;”.&#x2F;目标图片.gif”&gt;\n\n\n下级目录：目录文件在下级目录中\n\n\n\n\n代码步骤：&lt; img src&#x3D;”images&#x2F;目标图片.gif”&gt;\n\n上级目录：目录文件在上级目录中\n\n\n\n\n代码步骤：&lt; img src&#x3D;”..&#x2F;目标图片.gif”&gt;\n\n4.3 音频文件\n代码：\n\n  &lt;audio src=&quot; ./music.mp3&quot; controls&gt;&lt;/ audio&gt;\n\n\n常见属性：\n\n\n\n\n属性名\n功能\n\n\n\nsrc\n音频的路径\n\n\ncontrols\n显示播放的控件\n\n\nautoplay\n自动播放(部分浏览器不支持)\n\n\nloop\n循环播放\n\n\n\n注意点：音频标签目前支持三种格式MP3、Wav、Ogg\n\n4.4 视频文件\n代码：\n\n&lt;video src=&quot; ./video.mp4&quot; controls&gt;&lt;/video&gt;\n\n\n常见属性：\n\n\n\n\n属性名\n功能\n\n\n\nsrc\n视频的路径\n\n\ncontrols\n显示播放的控件\n\n\nautoplay\n自动播放（谷歌浏览器中需要配合muted实现静音播放）\n\n\nloop\n循环播放\n\n\n\n注意点：视频标签目前支持三种格式MP4、WebM、Ogg\n\n5、链接标签\n代码：\n\n&lt;a href=&quot;./目标网页.html&quot;&gt;超链接&lt;/a&gt;\n\n\n特点：双标签；需要a标签点击之后去指定页面，需要设置a标签的href属性\n\nhref属性\n\n属性名：href\n\n属性值：目标网页的路径\n\n外部链接：&lt; a href&#x3D;”https : &#x2F;&#x2F; www .baidu.com&#x2F;“&gt;百度一下&lt; &#x2F;a&gt;\n内部链接：&lt; a href &#x3D;”.&#x2F;目标网页.html”&gt;目标网页&lt; &#x2F;a&gt;\n\n\n显示特点：\n\na标签默认文字有下划线\na标签从未点击过，默认文字显示蓝色\na标签点击过之后，文字显示为紫色\n\n\n\ntarget属性\n\n属性名：target\n\n属性值：目标网页的打开形式\n\n\n\n取值\n效果\n\n\n\n_self\n默认值，在当前窗口中跳转（覆盖原网页）\n\n\n_blank\n在新窗口中跳转（保留原网页）\n\n\n\n\n空链接\n\n代码：\n\n&lt;a href=&quot;#&quot;&gt;空链接&lt;/a&gt;\n\n\n功能：\n点击之后回到网页顶部\n开发中不确定该链接最终跳转位置，用空链接占个位置\n\n\n\n6、列表标签、6.1 无序列表（最常用）\n场景:在网页中表示一组无顺序之分的列表，如:新闻列表。\n\n\n\n标签组成:\n\n\n\n\n标签名\n说明\n\n\n\nul\n表示无序列表的整体，用于包裹li标签\n\n\nli\n表示无序列表的每一项，用于包含每一行的内容\n\n\n\n代码：\n\n    &lt;ul&gt;\n        &lt;li&gt;榴莲&lt;/li&gt;\n        &lt;li&gt;香蕉&lt;/li&gt;\n        &lt;li&gt;苹果&lt;/li&gt;\n    &lt;/ul&gt;\n\n\n显示特点:列表的每一项前默认显示圆点标识\n注意点:\nul标签中只允许包含li标签\nli标签可以包含任意内容\n\n\n\n6.2 有序列表（偶尔用）\n场景:在网页中表示一组有顺序之分的列表，如:排行榜。\n\n\n\n标签组成:\n\n\n\n\n标签名\n说明\n\n\n\nol\n表示有序列表的整体，用于包裹li标签\n\n\nli\n表示无序列表的每一项，用于包含每一行的内容\n\n\n\n代码：\n\n    &lt;ol&gt;\n        &lt;li&gt;C:100&lt;/li&gt;\n        &lt;li&gt;C++:95&lt;/li&gt;\n        &lt;li&gt;Java:80&lt;/li&gt;\n    &lt;/ol&gt;\n\n\n显示特点:列表的每一项前默认显示序号标识\n注意点:\nol标签中只允许包含li标签\nli标签可以包含任意内容\n\n\n\n6.3 自定义列表（底部导航用）\n场景:在网页的底部导航通常会使用自定义列表来实现\n\n\n\n标签组成:\n\n\n\n\n标签名\n说明\n\n\n\ndl\n表示自定义列表的整体，用于包裹dt&#x2F;dd标签\n\n\ndt\n表示自定义列表的主题\n\n\ndd\n表示自定义列表的针对主题的每一项内容\n\n\n\n代码：\n\n    &lt;dl&gt;\n        &lt;dt&gt;帮助中心&lt;/dt&gt;\n        &lt;dd&gt;账户管理&lt;/dd&gt;\n        &lt;dd&gt;购物指南&lt;/dd&gt;\n    &lt;/dl&gt;\n\n\n显示特点:dd前会默认显示缩进效果\n注意点:\ndl标签中只允许包含dt&#x2F;dd标签\ndt&#x2F;dd标签可以包含任意内容\n\n\n\n7、表格标签7.1 表格的基本标签\n场景：在网页中以行+列的单元格的方式整齐展示和数据，如：学生成绩表\n基本标签：\n\n\n\n\n标签名\n说明\n\n\n\ntable\n表格整体，可用于包裹多个tr\n\n\ntr\n表格每行，可以用于包裹td\n\n\ntd\n表格单元格，可用于包裹内容\n\n\n\n注意点：标签的嵌套关系 table&gt;tr&gt;td\n\n7.2 表格相关属性\n场景：设置表格基本展示效果\n常见相关属性：\n\n\n\n\n属性名\n属性值\n效果\n\n\n\nborder\n数字\n边框宽度\n\n\nwidth\n数字\n表格宽度\n\n\nheight\n数字\n表格高度\n\n\n\n代码：\n\n    &lt;!-- table 包含 tr, tr包含td --&gt;\n    &lt;table border=&quot;1&quot; width=&quot;600&quot; height=&quot;400&quot;&gt;\n        &lt;tr&gt;\n            &lt;td&gt;姓名&lt;/td&gt;\n            &lt;td&gt;成绩&lt;/td&gt;\n            &lt;td&gt;评语&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;王兴唐&lt;/td&gt;\n            &lt;td&gt;100分&lt;/td&gt;\n            &lt;td&gt;优秀&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;百的类&lt;/td&gt;\n            &lt;td&gt;85分&lt;/td&gt;\n            &lt;td&gt;良好&lt;/td&gt;\n        &lt;/tr&gt;\n    &lt;/table&gt;\n\n\n注意点：实际开发对于样式效果推荐用CSS设置\n\n7.3 表格标题和表头单元格标签\n场景：在表格中表示整体大标题和一列小标题\n其他标签：\n\n\n\n\n标签名\n名称\n说明\n\n\n\ncaption\n表格大标题\n表示表格整体大标题，默认在表格整体顶部居中位置显示\n\n\nth\n表头单元格\n表示一列小标题，通常用于表格第一行，默认内部文字加粗并居中显示\n\n\n\n代码：\n\n    &lt;table border=&quot;1&quot;&gt;\n        &lt;caption&gt;&lt;strong&gt;学生成绩单&lt;/strong&gt;&lt;/caption&gt;\n        &lt;tr&gt;\n            &lt;!-- &lt;td&gt;&lt;/td&gt; --&gt;\n            &lt;th&gt;姓名&lt;/th&gt;\n            &lt;th&gt;成绩&lt;/th&gt;\n            &lt;th&gt;评语&lt;/th&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;张三&lt;/td&gt;\n            &lt;td&gt;100分&lt;/td&gt;\n            &lt;td&gt;真棒, 第一名&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;李四&lt;/td&gt;\n            &lt;td&gt;99分&lt;/td&gt;\n            &lt;td&gt;真棒, 第二名&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;王二&lt;/td&gt;\n            &lt;td&gt;78&lt;/td&gt;\n            &lt;td&gt;再接再厉，第三名&lt;/td&gt;\n        &lt;/tr&gt;\n    &lt;/table&gt;\n\n\n注意点：\ncaption标签书写在table标签内部\nth标签书写在tr标签内部（用于替换td标签）\n\n\n\n7.4 表格的结构标签\n场景：让表格的内容结构分组，突出表格的不同部分（头部、主体、底部），使语义更加清晰\n结构标签：\n\n\n\n\n标签名\n名称\n\n\n\nthead\n表格头部\n\n\ntbody\n表格主体\n\n\ntfoot\n表格底部\n\n\n\n代码：\n\n    &lt;table border=&quot;1&quot;&gt;\n        &lt;caption&gt;&lt;strong&gt;学生成绩单&lt;/strong&gt;&lt;/caption&gt;\n        &lt;thead&gt;\n            &lt;tr&gt;\n                &lt;!-- &lt;td&gt;&lt;/td&gt; --&gt;\n                &lt;th&gt;姓名&lt;/th&gt;\n                &lt;th&gt;成绩&lt;/th&gt;\n                &lt;th&gt;评语&lt;/th&gt;\n            &lt;/tr&gt;\n        &lt;/thead&gt;\n        &lt;tbody&gt;\n            &lt;tr&gt;\n                &lt;td&gt;张三&lt;/td&gt;\n                &lt;td&gt;100分&lt;/td&gt;\n                &lt;td&gt;真棒, 第一名&lt;/td&gt;\n            &lt;/tr&gt;\n            &lt;tr&gt;\n                &lt;td&gt;李四&lt;/td&gt;\n                &lt;td&gt;99分&lt;/td&gt;\n                &lt;td&gt;真棒, 第二名&lt;/td&gt;\n            &lt;/tr&gt;\n        &lt;/tbody&gt;\n        &lt;tfoot&gt;\n            &lt;tr&gt;\n                &lt;td&gt;王二&lt;/td&gt;\n                &lt;td&gt;78&lt;/td&gt;\n                &lt;td&gt;再接再厉，第三名&lt;/td&gt;\n            &lt;/tr&gt;\n        &lt;/tfoot&gt;\n    &lt;/table&gt;\n\n\n注意：\n表格结构标签内部用于包裹tr标签\n表格的结构标签可以省略\n\n\n\n7.5 合并单元格\n场景：将水平或垂直多个单元格合并成一个单元格\n步骤：\n\n\n明确合并哪几个单元格\n通过左上原则，确定保留谁删除谁\n上下合并 - - 只保留最上的，删除其它 \n左右合并 - - 只保留最左的，删除其它\n\n\n给保留的单元格设置：跨行合并（rowspan）或者跨列合并（colspan）\n\n\n\n\n属性名\n属性值\n说明\n\n\n\nrowspan\n合并单元格的个数\n跨行合并，将多行的单元格垂直合并\n\n\ncolspan\n合并单元格的个数\n跨列合并，将多列的单元格水平合并\n\n\n\n代码：\n\n    &lt;table border=&quot;1&quot;&gt;\n        &lt;caption&gt;&lt;strong&gt;学生成绩单&lt;/strong&gt;&lt;/caption&gt;\n        &lt;thead&gt;\n            &lt;tr&gt;\n                &lt;!-- &lt;td&gt;&lt;/td&gt; --&gt;\n                &lt;th&gt;姓名&lt;/th&gt;\n                &lt;th&gt;成绩&lt;/th&gt;\n                &lt;th&gt;评语&lt;/th&gt;\n            &lt;/tr&gt;\n        &lt;/thead&gt;\n        &lt;tbody&gt;\n            &lt;tr&gt;\n                &lt;td&gt;张三&lt;/td&gt;\n                &lt;td rowspan=&quot;2&quot;&gt;100分&lt;/td&gt;\n                &lt;td&gt;真棒&lt;/td&gt;\n            &lt;/tr&gt;\n            &lt;tr&gt;\n                &lt;td&gt;李四&lt;/td&gt;\n                &lt;td&gt;真棒&lt;/td&gt;\n            &lt;/tr&gt;\n        &lt;/tbody&gt;\n        &lt;tfoot&gt;\n            &lt;tr&gt;\n                &lt;td&gt;总结&lt;/td&gt;\n                &lt;td colspan=&quot;2&quot;&gt;非常不错&lt;/td&gt;\n            &lt;/tr&gt;\n        &lt;/tfoot&gt;\n    &lt;/table&gt;\n\n\n只有同一个结构标签中的单元格才能合并，不能跨结构标签合并（不能跨：thead、tbody、tfoot）\n\n8、表单标签8.1 input系列标签\n场景：在网页中显示收集用户信息的表单效果，如：登录页、注册页\n标签名：input\ninput标签可以通过 type属性值的不同，展示不同效果\n\n\ntype属性值：\n\n\n\n\ntype属性值\n说明\n\n\n\ntext\n文本框，用于输入单行密码\n\n\npassword\n密码框，用于输入密码\n\n\nradio\n单选框，用于多选一\n\n\ncheckbox\n多选框，用于多选多\n\n\nfile\n文件选择，用于之后上传文件\n\n\nsubmit\n提交按钮，用于提交\n\n\nreset\n重置按钮，用于重置\n\n\nbutton\n普通按钮，默认无功能，之后配合js添加功能\n\n\n\n代码：\n\n    &lt;!-- 写什么就显示什么 --&gt;\n    文本框: &lt;input type=&quot;text&quot;&gt;\n    &lt;br&gt;\n    &lt;br&gt;\n    &lt;!-- 书写的内容都会变成点点显示 --&gt;\n    密码框: &lt;input type=&quot;password&quot;&gt;\n\n    &lt;br&gt;\n    &lt;br&gt;\n    单选框: &lt;input type=&quot;radio&quot;&gt;\n\n    &lt;br&gt;\n    &lt;br&gt;\n\n    多选框: &lt;input type=&quot;checkbox&quot;&gt;\n\n    &lt;br&gt;\n    &lt;br&gt;\n\n    上传文件: &lt;input type=&quot;file&quot;&gt;\n\n文本框\n\n场景：在网页中线束输入单行文本的表单控件\ntype属性值：text\n常用属性：\n\n\n\n\n属性名\n说明\n\n\n\nplaceholder\n占位符，提示用户输入内容的文本\n\n\n（扩展）value属性和name属性作用的介绍\n\nvalue属性:用户输入的内容，提交之后会发送给后端服务器\nname属性:当前控件的含义，提交之后可以告诉后端发送过去的数据是什么含义\n后端接收到数据的格式是: name的属性值&#x3D; value的属性值\n\n\n密码框\n\n场景：在网页中显示输入密码的表单控件\ntype属性值：password\n常用属性：\n\n\n\n\n属性名\n说明\n\n\n\nplaceholder\n占位符，提示用户输入内容的文本\n\n\n\n代码：\n\n    &lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot;&gt;\n    &lt;input type=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt;\n\n\n注意点：type属性值不要拼错或者多加空格，否则相当于设置了默认值状态：text - &gt; 文本框。\n\n单选框\n\n场景：在网页中显示多选一的单选表单控件\ntype属性值：radio\n常用属性：\n\n\n\n\n属性名\n说明\n\n\n\nname\n分组。有相同name属性值的单选框为一组，一组中同时只能有一个被选中\n\n\nchecked\n默认选中\n\n\n\n代码：\n\n    性别: &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;男\n          &lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked&gt;女\n\n    &lt;input type=&quot;checkbox&quot; checked&gt;\n\n\n注意点：\nname属性对于单选框有分组功能\n有相同name属性值的单选框为一组，一组中只能同时有一个被选中\n\n\n\n复选框\n\n场景：在网页中显示多选多的多选表单控件\ntype属性值：checkbox\n常用属性：\n\n\n\n\n属性名\n说明\n\n\n\nchecked\n默认选中\n\n\n文件选择\n\n场景：在网页中显示文件选择的表单控件\ntype属性值：file\n常用属性：\n\n\n\n\n属性名\n说明\n\n\n\nmultiple\n多文件选择\n\n\n\n代码：\n\n&lt;input type=&quot;file&quot; multiple&gt;\n\n按钮\n\n场景：在网页中显示不同功能的按钮的表单控件\n\ntype属性值：\n\n\n\n标签名\n说明\n\n\n\nsubmit\n提交按钮，点击之后提交数据给后端服务器\n\n\nreset\n重置按钮，点击之后恢复表单默认值\n\n\nbutton\n普通按钮，默认无功能，配合js添加功能\n\n\n\n代码：\n\n\n        用户名: &lt;input type=&quot;text&quot;&gt;\n        &lt;br&gt;\n        &lt;br&gt;\n        密码: &lt;input type=&quot;password&quot;&gt;\n        &lt;br&gt;\n        &lt;br&gt;\n        &lt;!-- 按钮 --&gt;\n        &lt;input type=&quot;submit&quot; value=&quot;免费注册&quot;&gt;\n        &lt;input type=&quot;reset&quot;&gt;\n        &lt;input type=&quot;button&quot; value=&quot;普通按钮&quot;&gt;\n        &lt;!-- 属性  xx=&quot;xxx&quot; --&gt;\n\n\n注意点：\n如果需要实现以上按钮功能，需要配合form标签使用\nform使用方法：用form标签把表单标签一起包裹起来\n\n\n\n8.2 button按钮标签\n场景：在网页中显示用户点击的按钮\n标签名：button\ntype属性值\n\n\n\n\n标签名\n说明\n\n\n\nsubmit\n提交按钮，点击之后提交数据给后端服务器\n\n\nreset\n重置按钮，点击之后恢复表单默认值\n\n\nbutton\n普通按钮，默认无功能，配合js添加功能\n\n\n\n代码：\n\n    &lt;button&gt;我是按钮&lt;/button&gt;\n    &lt;button type=&quot;submit&quot;&gt;提交按钮&lt;/button&gt;\n    &lt;button type=&quot;reset&quot;&gt;重置按钮&lt;/button&gt;\n    &lt;button type=&quot;button&quot;&gt;普通按钮, 没有任何功能&lt;/button&gt;\n\n\n注意点：\n谷歌浏览器中的button默认是提交按钮\nbutton标签是双标签，更便于包裹其他内容：文字、图片等\n\n\n\n8.3 select下拉菜单标签\n场景：在网页中提供多个选择项的下拉菜单表单控件\n标签组成：\nselect标签：下拉菜单的整体\noption标签：下拉菜单的每一项\n\n\n常见属性：selected - - 下拉菜单的默认选择\n代码：\n\n    &lt;select&gt;\n        &lt;option&gt;北京&lt;/option&gt;\n        &lt;option selected&gt;上海&lt;/option&gt;\n        &lt;option&gt;广州&lt;/option&gt;\n        &lt;option&gt;深圳&lt;/option&gt;\n    &lt;/select&gt;\n\n8.4 textarea文本域标签\n场景：在网页中提供可输入多行文本的表单控件\n标签名：textarea\n常见属性：\ncols：规定了文本域内可见宽度\nrows：规定了文本域内可见行数\n\n\n代码：\n\n&lt;textarea cols=&quot;60&quot; rows=&quot;30&quot;&gt;&lt;/textarea&gt;\n\n\n注意点：\n右下角可以拖拽改变大小\n实际开发时针对于样式效果推荐用CSS设置\n\n\n\n8.5 label系列标签\n场景:常用于绑定内容与表单标签的关系\n标签名: label\n使用方法①:\n使用label标签把内容（如:文本）包裹起来\n在表单标签上添加id属性\n在label标签的for属性中设置对应的id属性值\n\n\n使用方法②:\n直接使用label标签把内容（如:文本)和表单标签一起包裹起来\n需要把label标签的for属性删除即可\n\n\n代码：\n\n    性别: \n    &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;nan&quot;&gt; &lt;label for=&quot;nan&quot;&gt;男&lt;/label&gt;\n   \n    &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt; 女&lt;/label&gt;\n\n9、语义化标签9.1 没有语义的标签\n场景：实际开发网页时会大量频繁用到div和span这两个没有语义的布局标签\ndiv标签：一行只显示一个\nspan标签：一行可以显示多个\n代码：\n\n    普通文字\n\n    &lt;div&gt;这是div标签&lt;/div&gt;\n    &lt;div&gt;这是div标签&lt;/div&gt;\n\n    &lt;span&gt;这是span标签&lt;/span&gt;\n    &lt;span&gt;这是span标签&lt;/span&gt;\n\n9.2 有语义的标签\n场景：在HTML5新版本中，推出了一些有语义的布局标签供开发者使用\n标签：\n\n\n\n\n标签名\n语义\n\n\n\nheader\n网页头部\n\n\nnav\n网页导航\n\n\nfooter\n网页底部\n\n\naside\n网页侧边栏\n\n\nsection\n网页区块\n\n\narticle\n网页文章\n\n\n\n\n注意点：以上标签显示特点和div一致，但是比div多了不同的语义\n\n10、字符实体\n问题：在html代码中同时并列出现多个空格、换行、缩进，最终浏览器只会解析出一个空格\n场景：在网页中展示特殊符号效果时，需要使用字符实体替代\n常见字符实体：\n\n\n\n\n显示结果\n描述\n实体名称\n\n\n\n\n空格\n&amp;nbsp；\n\n\n&lt;\n小于号\n&amp; lt;\n\n\n&gt;\n大于号\n&amp; gt;\n\n\n&amp;\n和号\n&amp; amp;\n\n\n“\n引号\n&amp; quot;\n\n\n‘\n撇号\n&amp; apos;(IE不支持)\n\n\n￠\n分(cent)\n&amp; cent；\n\n\n£\n磅(pound)\n&amp; pound；\n\n\n¥\n元(yen)\n&amp; yen；\n\n\n€\n欧元(euro)\n&amp; rueo；\n\n\n§\n小节\n&amp; sect；\n\n\n©\n版权(copyright)\n&amp; copy；\n\n\n®\n注册商标\n&amp; reg；\n\n\n™\n商标\n&amp; trade；\n\n\n×\n乘号\n&amp; times；\n\n\n÷\n除号\n&amp; divide；\n\n\n11、更多MDN Web Docs（旧称Mozilla Developer Network、Mozilla Developer Center，简称MDN）是一个汇集众多Mozilla基金会产品和网络技术开发文档的免费网站。\nhttps://developer.mozilla.org/zh-CN/\n","slug":"前端--HTML这一篇就够啦","date":"2022-12-03T02:41:04.000Z","categories_index":"前端","tags_index":"HTML","author_index":"会思想的苇草i"},{"id":"47cf0316f492004489404d39cb61c662","title":"动态规划--01背包问题","content":"本文默认读者具有动态规划前置知识\n\n\n动态规划的特点：\n\n\n重叠子问题\n状态转移方程\n最优子结构\n\n\n题型：求最值\n解题套路：\n\n\n明确【状态】\n明确【选择】\n明确dp函数&#x2F;数据的定义\n明确base case\n\n\n\n例：给你一个可装载容量为W的背包和N个物品，每个物品有重量和价值两个属性。其中第i个物品的重量为wt[i]，价值为va[i]，现在让你用这个背包装物品，最多能装的价值是多少?\n在这里将问题具体化：现在有4  (N&#x3D;4)个物品，背包总容量为8  (W&#x3D;8),背包最多能装入价值为多少的物品?\n\n\n\n\n物体编号\n物体体积\n物体价值\n\n\n\n1\n2\n3\n\n\n2\n3\n4\n\n\n3\n4\n5\n\n\n4\n5\n6\n\n\n\n第一步，明确状态和选择\n\n状态：背包的空余容量剩多少；可选择的物品还有哪些\n\n选择：把这个物品装进背包；把这个物品装进背包\n\n第二步，明确dp数组的定义：对于前1个物品，当背包的容量为w时，可以装的最大价值是 dp[i][w]\n\n比如说，dp[4][8]&#x3D;10的含义为:对于给定的一系列物品中，若只对前4个物品进行选择，当背包容量为8时，最多可以装下的价值为10。\n\n根据此定义，还可得出:base case为dp[0][..] &#x3D; dp[..][0] &#x3D;0（编号为0，不装物品；容量为0，装不下任何物体），我们想计算的结果是 dp[N][W]\n\n背包容量为1，物品编号可选为1，通过上表可知，物品编号为1时物品体积为2，所以此时选择不装任何物品。\n\n背包容量为2，物品编号可选为1，装入则价值为3。依次往后填充该行。\n\n背包容量为3，物品编号可选为1、2时，装入编号为2的物品，此时价值为4。\n\n背包容量为5，物品编号可选为1、2时，装入编号为1和2的物品，此时价值为7。\n\n依次往后填充完该表格\n\n第三步，根据[选择]写出状态转移逻辑：在w的约束下，把物品i装进背包,最大价值是多少；在w的约束下，不把物品i装进背包，最大价值是多少?\n\n\nfor(let i=1;i&lt;=n;i++) &#123;\n    for(let v=w[i]; v&lt;=c;v++) &#123;\n      dp[i][v] = Math.max(dp[i-1][v], dp[i-1][v-w[i]]+value[i])\n    &#125;\n&#125;\n\n\n\n背包问题完整求解代码：\n\n// 入参是物品的个数和背包的容量上限，以及物品的重量和价值数组\nfunction knapsack(n, c, w, value) &#123;\n    // dp是动态规划的状态保存数组\n    const dp = (new Array(c+1)).fill(0)  \n    // res 用来记录所有组合方案中的最大值\n    let res = -Infinity\n    for(let i=1;i&lt;=n;i++) &#123;\n        for(let v=c;v&gt;=w[i];v--) &#123;\n            // 写出状态转移方程\n            dp[v] = Math.max(dp[v], dp[v-w[i]] + value[i])\n            // 即时更新最大值\n            if(dp[v] &gt; res) &#123;\n                res = dp[v]\n            &#125;\n        &#125;\n    &#125;\n    return res\n&#125;\n\n\n\n扩展 – 最长上升子序列模型\n\n题目描述：给定一个无序的整数数组，找到其中最长上升子序列的长度。\n示例:\n输入: [10,9,2,5,3,7,101,18]\n输出: 4\n解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。\n\n\n代码实现\n\n/**\n * @param &#123;number[]&#125; nums\n * @return &#123;number&#125;\n */\n// 入参是一个数字序列\nconst lengthOfLIS = function(nums) &#123;\n  // 缓存序列的长度\n  const len = nums.length  \n  // 处理边界条件\n  if(!len) &#123;\n      return 0\n  &#125;\n  // 初始化数组里面每一个索引位的状态值\n  const dp = (new Array(len)).fill(1)\n  // 初始化最大上升子序列的长度为1\n  let maxLen = 1 \n  // 从第2个元素开始，遍历整个数组\n  for(let i=1;i&lt;len;i++) &#123;\n      // 每遍历一个新元素，都要“回头看”，看看能不能延长原有的上升子序列\n      for(let j=0;j&lt;i;j++) &#123;  \n          // 若遇到了一个比当前元素小的值，则意味着遇到了一个可以延长的上升子序列，故更新当前元素索引位对应的状态\n          if(nums[j]&lt;nums[i]) &#123;\n              dp[i] = Math.max(dp[i], dp[j] + 1)  \n          &#125;\n      &#125;\n      // 及时更新上升子序列长度的最大值\n      if(dp[i] &gt; maxLen) &#123;\n          maxLen = dp[i]\n      &#125;\n  &#125;\n  // 遍历完毕，最后到手的就是最大上升子序列的长度\n  return maxLen\n&#125;;\n\n","slug":"数据结构--动态规划 -- 01背包问题","date":"2022-10-07T01:48:46.000Z","categories_index":"数据结构","tags_index":"算法","author_index":"会思想的苇草i"},{"id":"cac67ac11c6c333971e5ff6f7b0aa46a","title":"正则表达式(基础语法+应用案例)","content":"1、正则表达式简介\n正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。\n\n典型的搜索和替换操作要求提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，也会变得很困难。\n\n通过使用正则表达式能够：\n\n测试字符串内的模式。（数据验证）\n替换文本。（文本操作）\n基于模式匹配从字符串中提取子字符串。（目标提取）\n\n\n\n2、正则表达式语法\nJavaScript RegExp对象的创建：\n\nvar patt=new RegExp(pattern,modifiers);\n\nvar patt=/pattern/modifiers;\n//pattern（模式） 描述了表达式的模式\n//modifiers(修饰符) 用于指定全局匹配、区分大小写的匹配和多行匹配\n\n2.1 修饰符\n修饰符用于执行区分大小写和全局匹配\n\n\n\n\n修饰符\n描述\n\n\n\ni\n执行对大小写不敏感的匹配  &#x2F;a&#x2F;i\n\n\ng\n执行全局匹配 &#x2F;a&#x2F;g\n\n\nm\n执行多行匹配 &#x2F;a&#x2F;m\n\n\n2.2 方括号\n\n\n表达式\n描述\n\n\n\n[abc]\n查找方括号之间(给定集合内)的任何字符\n\n\n[^abc]\n查找任何不在方括号之间(给定集合外)的字符\n\n\n[0-9]\n查找任何从 0 至 9 的数字\n\n\n[a-z]\n查找任何从小写 a 到小写 z 的字符\n\n\n[A-Z]\n查找任何从大写 A 到大写 Z 的字符\n\n\n(a|b|c）\n查找任何指定的选项\n\n\n2.3 元字符\n元字符（Metacharacter）是拥有特殊含义的字符\n\n\n\n\n元字符\n描述\n\n\n\n.\n查找单个字符，除了换行和行结束符\n\n\n\\w\n查找数字、字母及下划线\n\n\n\\W\n查找非单词字符\n\n\n\\d\n查找数字\n\n\n\\D\n查找非数字字符\n\n\n\\s\n查找空白字符\n\n\n\\S\n查找非空白字符\n\n\n\\b\n匹配单词边界\n\n\n\\B\n匹配非单词边界\n\n\n\\0\n查找 NULL 字符\n\n\n\\n\n查找换行符\n\n\n\\f\n查找换页符\n\n\n\\r\n查找回车符\n\n\n\\t\n查找制表符\n\n\n\\v\n查找垂直制表符\n\n\n\\xxx\n查找以八进制数 xxx 规定的字符\n\n\n\\xdd\n查找以十六进制数 dd 规定的字符\n\n\n\\uxxxx\n查找以十六进制数 xxxx 规定的 Unicode 字符\n\n\n2.4 量词\n\n\n量词\n描述\n\n\n\nn+\n匹配任何包含至少一个 n 的字符串\n\n\nn*\n匹配任何包含零个或多个 n 的字符串\n\n\nn?\n匹配任何包含零个或一个 n 的字符串\n\n\nn{X}\n匹配包含 X 个 n 的序列的字符串\n\n\nn{X,}\nX 是一个正整数。前面的模式 n 连续出现至少 X 次时匹配\n\n\nn{X,Y}\nX 和 Y 为正整数。前面的模式 n 连续出现至少 X 次，至多 Y 次时匹配\n\n\nn$\n匹配任何结尾为 n 的字符串\n\n\n^n\n匹配任何开头为 n 的字符串\n\n\n?&#x3D;n\n匹配任何其后紧接指定字符串 n 的字符串\n\n\n?!n\n匹配任何其后没有紧接指定字符串 n 的字符串\n\n\n2.5 运算符优先级\n正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。相同优先级的从左到右进行运算，不同优先级的运算先高后低。\n\n\n\n\n运算符\n描述\n\n\n\n\\\n转义符\n\n\n(), (?:), (?&#x3D;), []\n圆括号和方括号\n\n\n*, +, ?, {n}, {n,}, {n,m}\n限定符\n\n\n^, $, \\任何元字符、任何字符\n定位点和序列\n\n\n|\n替换，”或”操作\n\n\n3、正则表达式API3.1 RegExp对象属性global\n\n判断是否设置了 “g” 修饰符，如果 g 标志被设置，则该属性为 true，否则为 false\nRegExpObject.global\n\nignoreCase\n\n判断是否设置了 “i” 修饰符，如果设置了 “i” 标志，则返回 true，否则返回 false\nRegExpObject.ignoreCase\n\nmultiline\n\n判断是否设置了 “m” 修饰符，如果 m 标志被设置，则该属性为 true，否则为 false\nRegExpObject.multiline\n\nsource\n\n返回正则表达式的匹配模式\nRegExpObject.source\n\nlastIndex\n\n用于规定下次匹配的起始位置，该属性只有设置标志 g 才能使用\nRegExpObject.lastIndex\n\n3.2 RegExp对象方法exec\n\n检索字符串中指定的值。返回找到的值，并确定其位置。\nRegExpObject.exec(string)\n\ntest\n\n检索字符串中指定的值。返回 true 或 false。\n\nRegExpObject.test(string)\n\n\ntoString\n\n返回正则表达式的字符串。\nRegExpObject.toString()\n\n3.3 支持正则表达式的String对象方法search\n\n检索与正则表达式相匹配的值,找到返回起始位置，如果没有找到任何匹配的子串，则返回 -1\n\nstring.search(searchvalue)\n\n\nmatch\n\n找到一个或多个正则表达式的匹配,如果 regexp 没有标志 g，那么 match() 方法就只能在 stringObject 中执行一次匹配。如果没有找到任何匹配的文本， match() 将返回 null。否则，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息\nstring.match(regexp)\n\nreplace\n\n替换与正则表达式匹配的子串\n\nstring.replace(searchvalue,newvalue)\n\n\nsplit\n\n把字符串分割为字符串数组\nstring.split(separator,limit)\n\n4、正则表达式应用\n简单表达式   /a/  ,匹配a\n\n字符匹配  /a.c  ,匹配 aac、abc、acc、adc 等等\n\n中文  /[\\u4E00-\\u9FA5]/\n\n用户名 /^[a-zA-Z0-9_-]&#123;4,16&#125;$/  4到16位字母、数字、下划线和中划线组成\n\n车牌号   /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]&#123;1&#125;[A-Z]&#123;1&#125;[A-Z0-9]&#123;4&#125;[A-Z0-9挂学警港澳]&#123;1&#125;$/\n\n微信号  /^[a-zA-Z][-_a-zA-Z0-9]&#123;5,19&#125;$/  6至20位，以字母开头，字母，数字，减号，下划线\n\nQQ号  /^[1-9][0-9]&#123;4,10&#125;$/ 5至11位数字组成\n\n16进制颜色    /^#([a-fA-F0-9]&#123;6&#125;|[a-fA-F0-9]&#123;3&#125;)$/  以#开始 ，6或3个字符（A-F、a-f、0-9）结尾\n\n电话号码 /^1(3\\d|4[5-9]|5[0-35-9]|6[2567]|7[0-8]|8\\d|9[0-35-9])\\d&#123;8&#125;$/     以1开头，3可跟任一数字（\\d），4可跟5-9，5可跟0-3或5-9 ，6后2567其中一个，7后是0-8,8后任一数字，9后是0-3或3-5，其余8位是任意数字（\\d{8}）\n\n身份证号   /^[1-9]\\d&#123;5&#125;(19|20|21)\\d&#123;2&#125;(0[1-9]|10|11|12)(0[1-9]|[1-2]\\d|30|31)\\d&#123;3&#125;[\\dX]$/     第一位在0-9区间，后面是5位任意数字，4位年份（19、20、21开头，后两位任意），两位代表月份（0开头的1-9或者是10、11、12），两位日期（01-31），三位顺序码，最后一位是校验码，可数字可X\n\n网址   /^((https?):)?\\/\\/([^?:/]+)(:(\\d+))?(\\/[^?]*)?(\\?(.*))?/\n\n邮箱   /^(([^&lt;&gt;()[\\]\\\\.,;:\\s@\\&quot;]+(\\.[^&lt;&gt;()[\\]\\\\.,;:\\s@\\&quot;]+)*)|(\\&quot;.+\\&quot;))@((\\[[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]&#123;2,&#125;))$/   \n\n最后推荐一下一个网站 – 正则表达式在线测试网站： 正则表达式在线测试 ，在这里可以书写正则表达式并在线测试，还有常见应用案例提示以及可视化图等相关功能！\n\n\n","slug":"前端--正则表达式(基础语法+应用案例)","date":"2022-08-26T00:39:52.000Z","categories_index":"前端","tags_index":"正则表达式","author_index":"会思想的苇草i"},{"id":"cafb2f7f7dd2184f94595ef0ba9d8b6c","title":"基于hexo框架快速从0到1搭建个人博客 -- 文章发布","content":"\n前言：在前面的文章中，已经实现了文章的撰写和图片的处理，接踵而至的就是文章的发表，在这里还需要向之前一样复杂吗，所以在这里尝试去实现文章的一键发表。\n\n一、文章对比\n平时在本地写文章保存在D:\\Markdown目录，而 Hexo 保存在D:\\hexoblog目录。发布 Hexo 之前需要先把文章拷贝到D:\\hexoblog\\source\\_posts目录，有时候文章有修改还要重新拷贝覆盖。通过搜寻资料，查看文章，决定用Python脚本实现拷贝文件，判断文件最后修改时间决定是否需要覆盖旧文章。\n因为我们省略了hexo create “title”这一步，直接把文件拷贝到了_posts目录，所以写文章时需要确保在开头加上 title、date、tags、category信息，不然发布的文章会没有没有标题、发布时间、标签、分类信息，其实hexo create命令做的就是这件事。注意最后的空行一定要有。\n\n---\ntitle: 基于hexo框架快速从0到1搭建个人博客 -- 文章发布\ndate: 2022-8-13 21:26:01\ntags: hexo\ncategories : 博客\n---\n\n\nPython 代码(电脑要配置好python环境)：\n\n# copy_to_hexo.py\nimport os\nimport shutil\nimport time\n\n\ndef copy_to_hexo():\n    local_list = os.listdir(LOCAL_ARTICLE_PATH)\n    hexo_list = os.listdir(HEXO_ARTICLE_PATH)\n    flag = True\n    for file in local_list:\n        if file in IGNORE_LIST:\n            continue\n        if file.endswith(&#39;.md&#39;):\n            local_version = os.path.join(LOCAL_ARTICLE_PATH, file)\n            hexo_version = os.path.join(HEXO_ARTICLE_PATH, file)\n            if file not in hexo_list:\n                flag = False\n                print(&quot;新增文章: %s...&quot; % file,\n                      &quot;最后修改时间：%s&quot; % TimeStampFormat(os.path.getmtime(local_version)))\n                shutil.copy(local_version, hexo_version)\n            elif os.path.getmtime(local_version) &gt; os.path.getmtime(hexo_version):\n                flag = False\n                print(&quot;更新文章: %s...&quot; % file,\n                      &quot;上次修改时间：%s&quot; % TimeStampFormat(os.path.getmtime(hexo_version)),\n                      &quot;最后修改时间：%s&quot; % TimeStampFormat(os.path.getmtime(local_version)))\n                shutil.copy(local_version, hexo_version)\n    print(&#39;文章无变化&#39; if flag else &#39;更新完毕&#39;)\n\n\n# 时间格式标准化\ndef TimeStampFormat(timestamp):\n    return time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;, time.localtime(timestamp))\n\n\nIGNORE_LIST = [&#39;欢迎使用Markdown编辑器.md&#39;]\nHEXO_ARTICLE_PATH = &#39;D:\\hexoblog\\source\\_posts&#39;\nLOCAL_ARTICLE_PATH = &#39;D:/Markdown&#39;\n\ncopy_to_hexo()\n\n\n运行效果\n\n\n二、发布到Github\n之前已经修改好了hexo的配置：\n\ndeploy:\n  type: git\n  repo:\n      github: git@github.com:用户名/用户名.github.io.git,main\n\n\nshell发布脚本：Git Bash支持直接运行 shell 脚本，只需要把下面代码保存为 .sh后缀的文件即可：\n\n# deploy_hexo.sh\ncd /d/hexoblog\npwd\n# 白底黑字效果\necho -e &quot;\\033[47;30m&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;hexo g&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\033[0m&quot;\nhexo g\necho -e &quot;\\033[47;30m&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;hexo d&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\033[0m&quot;\nhexo d\nsleep 5\n# 执行完毕不退出\n# exec /bin/bash\n\n\n运行效果：\n\n\n\n三、一键发布\n上面写的两个脚本一步一步实现了文章的自动发布，对于 Windows 系统来说，可以使用 bat 脚本把它们整合在一起，完成“一键”发布的需求。\n\n:: post_my_blog.bat\npython copy_to_hexo.py\n&quot;C:\\Program Files\\Git\\git-bash.exe&quot; deploy_hexo.sh\npause\n\n\n写好文章后，直接双击post_my_blog.bat就可以发布到三个地方了。\n\n\n四、总结\n本文主要实现了文章的发布，参考了许多资料和部分代码，并将其整合在一个文件中，实现真正的一键发布，减少博客文章管理压力，使更加专注于文章的撰写！\n\n","slug":"基于hexo框架快速从0到1搭建个人博客----文章一键发布","date":"2022-08-20T02:51:44.000Z","categories_index":"博客","tags_index":"hexo","author_index":"会思想的苇草i"},{"id":"2ea3dc135dc18ec110d6dc602b36997a","title":"CSDN文章打包下载","content":"CSDN文章打包下载\nCSDN 没有提供文章导出功能，只有导入功能，所以我们可以用下述方式下载 CSDN 上的文章并保存成 Markdown 格式。\n步骤：\n\n\n登录CSDN： https://blog.csdn.net/\n\n前往：https://blog-console-api.csdn.net/（出现404也没关系）\n\n点击F12，在控制台()中输入下段代码并回车：\n\n\nvar s=document.createElement(&#39;script&#39;);s.type=&#39;text/javascript&#39;;\ndocument.body.appendChild(s);\ns.src=&#39;//cdn.jsdelivr.net/gh/ame-yu/csdn-move@latest/dist/index.js&#39;;\n\n\n\nCSDN上的文章就会被下载下来啦！\n\n\n\n将下载打包的压缩包解压就可以看到文章了！\n\n\n","slug":"基于hexo框架快速从0到1搭建个人博客----CSDN文章打包下载","date":"2022-08-18T23:45:01.000Z","categories_index":"博客","tags_index":"CSDN","author_index":"会思想的苇草i"},{"id":"287062fb47b340e917d6f903629b5049","title":"基于hexo框架快速从0到1搭建个人博客--文章写作","content":"一、Github图床(图片存储)\n图床（Picture host）– 即提供外链访问的图片存储服务器\n把图片上传到一个图床提供者的图片服务器上，它会生成一个存储链接，就可以随时通过这个链接就下载这个图片，而且还可以把这个链接放到 html 里或者 Markdown 文件里，浏览时再由浏览器或者阅读器自动加载出来。咋样的话每次文章换地方不需要重新上传图片，这些网站都能根据图床链接将图片加载出来\n图床服务：\n国内的有微博图床、聚合图床、七牛云、阿里云、腾讯云等\n国外的有 imgur、imgbox、SM图床等\n\n\n这里利用 GitHub 的存储能力和对外开放访问的特点，将 GitHub 仓库作为图床\n创建步骤：\n\n\n先在 GitHub 新建一个仓库用于存储图片，打开自己 GitHub 主页，点击New新建仓库\n\nRepository name填写仓库名字，Description填写仓库描述，勾选Add a README file，点击Create repository创建仓库:\n\n\n获取repo tokens:这个 token 主要用于让 PicGo 有权限往我们的仓库 push 代码(图片)。点击自己的头像，选择Settings:\n\n选择Developer settings:\n\n点击 Personal access tokens，然后点击Generate new token(可能需要确认密码)：\n\nNote填写 token 用途，用于备忘，下面只需要勾选repo，只给更新仓库的权限，最后点击最下面的Generate token创建成功：\n\n复制字符串下一步使用：此字符串只会出现一次，一定要复制保存好！！！\n\n\n\n二、PicGo(图片上传)\nPicGo 是一位中国开发者基于 electron-vue 开发的用于快速上传图片并获取图片 URL 链接的开源工具\n\nGithub地址：PicGo\n\n只要配置好图床类型，就可以直接拖拽图片进行上传并自动返回图片链接，配合 Typora 还可以实现在文章中插入图片时自动上传并替换为链接内容，完全不用感知上传图片的过程\n\nPicGo 支持七牛云、腾讯云、又拍云、阿里云、SM、Imgur、GitHub这些图床，而且还支持自己扩展第三方图床的支持插件。更多介绍请见官方文档，下载地址：PicGo (molunerfinn.com)\n\n下载好之后直接按照提示安装即可：\n\n\n\n\nPicGo配置：打开PicGo  ,选择图床设置，选择GitHub图床，填写参数：\n设定仓库名，填写格式为用户名&#x2F;仓库名\n设定分支名，填写默认分支main\n设定Token，填写上一步获取的 token 值\n指定存储路径，选填，可以自定义名称，比如用年月来分类，不填图片会上传在仓库根目录\n设定自定义域名，用于修改返回的 url 前缀，不填则返回原始 url，后面配置CDN加速需要更改此项\n选择设为默认图床，点击确定保存配置\n\n\n\n\n三、jsDelivr(CDN加速)\nGitHub 存储的图片地址是 https://raw.githubusercontent.com 开头的网址，这个域名在某些地方可能打不开或者很慢导致图片加载失败，所以我们需要对图片配置 CDN 加速\nCDN的全称是(Content Delivery Network)，即内容分发网络。其目的是通过在现有的Internet中增加一层新的CACHE(缓存)层，将网站的内容发布到最接近用户的网络”边缘“的节点，使用户可以就近取得所需的内容，提高用户访问网站的响应速度\njsDelivr CDN，不仅开源免费而且在中国大陆建有许多服务站点，官网还声称是中国大陆唯一拥有许可证的公有 CDN，所以速度、稳定性都可以放心\n打开jsDelivr CDN 官网，可以看到 jsDelivr 支持 npm、GitHub、WordPress三个站点的加速，用于我们的GitHub图床是再适合不过了\n\n\n\n在浏览器输入https://cdn.jsdelivr.net/gh/用户名/仓库名/，(注意最后的/不要丢)，可以打开我们在 GitHub 上创建的仓库的文件列表，说明我们在 Github 上创建的仓库已经默认被 jsDelivr 缓存\n\n\n\nPicGo 中需要改一下自定义域名，之后上传图片自动生成的链接就是 jsDelivr 的链接了。具体就是在设定自定义域名填写https://cdn.jsdelivr.net/gh/用户名/仓库名@master。\n\n\n四、Typora(写文传图)\nTypora 是一款支持实时预览的 Markdown 文本编辑器，现在支持有 OS X、Windows、Linux 三个平台的版本。Typora 创新的提出实时预览这种方式，源码和显示效果合一显示，所见即所得，非常的方便。建议都学习一下Markdown语法，简单且好用\nTypora 官方中文站 (typoraio.cn)\n\n\n\n在Typora里点击文件，偏好设置，图像，选择插入图片时上传图片，勾选图中三个选项，上传服务设定选择PicGo (app)，PicGo 路径通过后面的文件夹选择自己电脑上 PicGo 的安装路径\n\n\n\n此时，使用 Typora 编辑文件，拖入或者粘贴图片时，会自动调用 PicGo 将图片上传到 GitHub 图床，并把返回的图片链接粘贴到文章中\n\n五、总结\n博客文章通过Typora + PicGo + GitHub图床 + jsDelivr CDN加速的组合，看起来较为完善，美中不足的是虽然CDN加速解决了查看图片的速度，但是上传还是有点慢的，会出现在 Typora 中粘贴了一张图片后需要5秒以上才能上传成功并加载出来，还有就是本地没有分类备份等问题，以及可能出现本地图片不显示等等问题(jsDelivr CDN 原来也挂过)。但是这是我目前所能想到的一种较好(免费)的方案，如果有其他更好的方案欢迎讨论交流~\n\n","slug":"基于hexo框架快速从0到1搭建个人博客----文章写作","date":"2022-08-17T00:00:19.000Z","categories_index":"博客","tags_index":"hexo","author_index":"会思想的苇草i"},{"id":"a11af56428ea215f0c979eabeef2dc52","title":"基于hexo框架快速从0到1搭建个人博客--部署","content":"一、 GitHub Pages 介绍\n我们利用 Hexo 框架在本地搭建了一个精美的博客，可是只能本地访问，要想发布到互联网上，还需要将它部署在网站上\n\n博客的功能只要能阅读文章就够了，因此可以考虑将其部署在提供静态网页托管服务的网站上，这样就省去了购买服务器(云主机)，购买域名这些步骤，不仅省钱省事\n\n当前许多平台都提供了静态网页托管服务，其中最方便的当然是 GitHub Pages，只需要注册一个账号就可以使用\n\nGitHub Pages \n\n\n二、GitHub Pages 准备\n首先进入官网：GitHub，登录（这里需要一个账号，此处不再赘述，没有账号的根据要求提示注册一个账号即可）\n\n点击右上角 Sign in 登录后，点击左上角 New（或者右上角+）新建仓库\n\n由于每个 GitHub 账户只能建立一个 GitHub Pages 页面，所以 Repository name 必须填 &lt;你的用户名&gt;.github.io ！！！否则就会建立一个普通仓库，GitHub Pages 功能不会生效\n\n比如用户名是 demo，Repository name 这里就填 demo.github.io，不知道用户名是哪个，可以点击页面右上角头像，看到第一行“Signed in as xxx”字样， xxx 即为这里的用户名\n\nDescription 填写仓库描述，比如 blog 等，可不填。注意勾选 Public ，否则 GitHub Pages 功能不会生效。建议勾选 Add a README file，会自动生成一个 readme.md 文件。最后点击 Create repository 创建仓库\n\n\n\n三、GitHub Pages 发布3.1 配置\n我们把自己的博客生成静态 html 网页，提交到这个仓库目录下，就可以在我们的网址看到博客页面了，这就是 Hexo 框架部署博客的原理。对于 Hexo 来说，提交部署只需要几条命令即可。\n在博客根目录下，右键，打开 Git Bash Here。配置用户名和邮箱，这两个参数用于 Git 提交时的身份识别：\n\n# 其中 username 和 username@XXX.com 是你注册 GitHub 的用户名和邮箱\ngit config --global user.name &quot;username&quot;\ngit config --global user.email &quot;username@XXX.com&quot;\n\n\n生成 SSH keys，主要用于 Git 提交时的权限控制和加密，本地根据 RSA 算法生成公私密钥对，然后将公钥添加到 GitHub 上，本机就可以提交代码到自己的 GitHub 库了。这个是根据当前使用的电脑的一些信息生成的，所以换电脑提交时要重新生成并添加。输入下面命令，然后一直按回车，直到结束：\n\n # 其中 username@XXX.com 是你注册 GitHub 的邮箱\n ssh-keygen -t rsa -C &quot;username@XXX.com&quot;\n\n\n输入下面的命令，查看公钥内容，应该是一个ssh-rsa开头，以你的邮箱结尾的长字符串：\n\n# cat后面的路径就是上图中的公钥文件路径，直接复制过来就可以\ncat /C/Users/XXX/.ssh/id_rsa.pub\n\n\n复制公钥内容，打开自己的 Github 主页，点击右上角的头像，点击 Settings。点击 SSH and GPG keys，然后点击 New SSH keys\n\n\n\nTitle 可以随便起一个名字，Key 填写上一步复制的公钥内容，然后点击 Add SSH key\n\n最后执行下面的命令，测试一下 Git 参数是否配置成功。出现你的用户名和successfully字样，说明配置成功。\n\n\nssh -T git@github.com\n\n\n3.2 安装插件\n在博客根目录下，右键，打开 Git Bash Here。输入下面的命令，安装hexo-deployer-git。这个插件用于把生成好的静态页面上传到 GitHub Pages 仓库。\n\nnpm install hexo-deployer-git\n\n3.3 发布\n打开博客根目录配置文件(D:\\hexoblog\\ _config.yaml)，拉到文件最后一行，修改为下面的配置（没有的配置项自行添加），保存：\n\n# 其中 xxxxxx 是前面多次用到的你的GitHub用户名\ndeploy:\n  type: git\n  repo: git@github.com:xxxxxx/xxxxxx.github.io.git\n  branch: main\n\n\n\n执行下列命令：\n\n# 注意最后变成d了，原来的s表示服务起在本地，现在的d表示部署在远端\nhexo g &amp;&amp; hexo d\n\n\n待命令执行完毕，打开浏览器，输入网址https://你的用户名.github.io，可以看到一个本地部署的一模一样的博客出现了。https://你的用户名.github.io就是你的个人博客地址了，其他人都可以访问。\n\n四、总结\n至此，我们从 0 到 1 快速搭建一个博客的任务初步完成了。本篇文章介绍了利用 GitHub Pages 发布个人博客的方法，如果觉得 GitHub 访问速度太慢，也可以参考对照着基于 Gitee Pages 搭建国内博客站点。后续就是对文章发布，博客迁移，网站优化的内容了，创作不易，感谢三连~\n\n","slug":"基于hexo框架快速从0到1搭建个人博客----部署","date":"2022-08-14T23:40:56.000Z","categories_index":"博客","tags_index":"hexo","author_index":"会思想的苇草i"},{"id":"751b4d19fb5d415ca6cc059441dc288b","title":"基于hexo框架快速从0到1搭建个人博客--评论功能","content":"1、Valine简介\n在前面我们已经实现了博客的大致功能，但是没有添加评论模块，因此在此使用 Valine来添加评论功能\n\n Valine 诞生于 2017 年 8 月 7 日，是一款基于 LeanCloud 的快速、简洁且高效的无后端评论系统。理论上支持但不限于静态博客，目前已有 Hexo、Jekyll、Typecho、Hugo、Ghost 等博客程序在使用 Valine\n\nGithub地址 ：Valine Github\n\n\n2、LeanCloud\n首先在LeanCloud创建账号并登录\n点击左上角创建应用：\n\n\n\n填写基本信息，应用名称随意，计价方案选择开发版，点击创建：\n\n\n\n点击创建好的应用的设置，选择应用凭证并复制appid和appkey，便于后续使用：\n\n\n\n\n\n查看评论：点击 存储 -&gt; 结构化数据，选择 创建 Class，名称 Comment，其他保持默认，以后就可在此 Class 内查看\n\n点击 存储 -&gt; 结构化数据，选择创建 Class，名称 Counter，其他保持默认，以后就可在此 Class 内查看\n\n\n\n3、Valine配置与优化\n来到hexo博客ayer主题的_config.yml配置文件中，将配置文件中的enable修改为true，并将刚刚获取的appid与appkey填入相应位置。修改完成后每一篇博客的篇尾便会出现评论系统\n\n\n\n\n去除Valine的Powered By，在hexo-theme-ayer/source/css/custom.styl 文件中，添加以下内容：\n\n\n\n更改评论头像，可以参考头像配置说明，选择对应的样式填入即可：\n\n\n\n4、总结\n评论功能主要依靠Valine实现，除了文章中描述到的基本内容，还可以参考官方文档对评论功能进行优化和改善，做出更美观的评论界面。\n\n","slug":"基于hexo框架快速从0到1搭建个人博客----评论功能","date":"2022-08-13T01:19:27.000Z","categories_index":"博客","tags_index":"hexo","author_index":"会思想的苇草i"},{"id":"25063fa96485e57855d965af2ddfa51b","title":"基于hexo框架快速从0到1搭建个人博客--搭建","content":"一、HEXO 框架\nHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。Hexo 不仅搭建过程简单快捷，配置灵活，可定制型非常高，拥有众多的主题库\nHexo 中文官网 ，Hexo Github 地址\n\n\n二、安装 Node.js\nHexo 是使用 Node.js 开发的，所以我们安装 Hexo 之前需要先安装 Node.js 环境\nNode.js 就是运行在服务端的 JavaScript 。安装了 Node.js 环境，就可以不用依赖浏览器就可以运行 js 代码，其实它也是基于 Chrome 引擎开发的一个开源项目\nNode.js 官网\n\n\n\n官网下载，直接点击下一步安装即可，打开命令行窗口输入 npm-v 出现版本号即安装成功\n\n\n三、安装 Git\nGit 是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理；也是为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。\nGit 官网\n\n\n\n官网下载，直接下一步安装即可。Git 安装完成后，自带了一个命令行窗口，通过上面新增的右键菜单 Git Bash Here 就可以打开输入 git --version 出现版本号即安装成功\n\n\n四、安装 Hexo\nHexo 官网\n\n安装：命令行窗口输入npm install hexo-cli -g\n\n\n初始化：命令行窗口输入hexo init &quot;项目名称&quot;\n\n\n测试：hexo clean（清理编译文件）hexo g （编译项目）hexo s（本地预览运行项目），打开浏览器，输入网址 http://localhost:4000/ 预览\n\n\n\n\n\n\n五、设置主题\n默认主题较为简洁，可以从官方网站主题页，Github，以及网上寻找相关主题进行美化\n我选用的是 ayer 主题，该主题界面简洁，功能丰富，上手简单快速\nAyer 主题展示 ，Ayer 主题 Github 地址\n\n\n\n在 Hexo 博客根目录下（D:\\hexoblog）(这是我电脑中的路径)下右键，选择Git Bash Here，执行下面命令：\n\ngit clone https://github.com/Shen-Yu/hexo-theme-ayer.git themes/ayer\n\n\n执行上述命令后在node_modules中会有hexo-theme-ayer文件夹\n\n\n\n打开博客根目录下的 _config.yml (D:\\hexoblog\\_config.yml)，找到theme标签，默认值是landscape主题，把它改为要更换的主题名字ayer，然后执行启动命令\n\n# 清理 &amp;&amp; 生成 &amp;&amp; 启动\n\nhexo clean &amp;&amp; hexo g &amp;&amp; hexo s\n\n\n\n此时再到浏览器打开网址http://localhost:4000，可以看到我们的博客已经换上一款非常精美的主题\n\n\n\nHexo 的配置大部分都保存在博客根目录下的_config.yml 文件，我这里是D:\\hexoblog\\_config.yml，它是根目录配置文件，直接修改这个文件就可以更改博客的一些设置，像前面更换主题就是修改这个文件的参数实现的\n关于_config.yml 文件的每个参数的详细意义，可以在 官方文档 | Hexo里查看，每一个参数都有示例，讲解的非常详细\n对网站主要部分进行修改：\n\n# 网站标题\ntitle: 会思想的苇草i\n# 网站副标题\nsubtitle: 技术博客\n# 网站描述\ndescription: 一个有趣且实用的博客网站，涉及前端，算法，数据结构，操作系统等计算机相关知识。\n# 网站的关键词。支持多个关键词。\nkeywords: 前端 算法 技术\n# 名字\nauthor: 会思想的苇草i\n# 网站使用的语言。\nlanguage: zh-CN\n# 网站时区\ntimezone: Asia/Shanghai\n\n\n此外，下载的第三方主题的根目录下也有一个_config.yml文件，比如 ayer 主题，我这里就是D:\\hexoblog\\node_modules\\hexo-theme-ayer\\_config.yml文件，它是主题配置文件。\n关于这个文件每个参数的详细意义，可以在每个主题的 GitHub 主页看到详细说明，参考 ayer 主题官方帮助文档Ayer 中文说明 | 岛 (gitee.io)\n关闭不需要的侧边栏：\n\nmenu:\n  主页: /\n  归档: /archives\n  分类: /categories\n  标签: /tags\n  #  旅行: /tags/旅行/\n  #  摄影: http://shenyu-vip.lofter.com\n  #  友链: /friends\n  关于我: /2019/about\n\n\n自定义首页滚动播放的文字内容：\n\nsubtitle:\n  enable: true # 是否开启动效\n  text: 欢迎来到会思想的苇草i的博客 # 显示的文字\n  text2: When the sun shines on the sea, I miss you. # 滚动播放，如果不需要可以留空\n  text3: When the hazy moonlight sprinkles on the spring, I miss you. # 最多支持三段文字\n\n\n设置网站图标和侧边栏 logo，推荐使用ICO 转换器 — Convertio将图片转换为.ico 格式：\n\n# 网站图标和侧边栏logo\nfavicon: /favicon.ico\nlogo: /favicon.ico\n\n\n关闭右上角的 GitHub forkme：\n\ngithub:\n  # (关闭请设置为false)\n  enable: false\n  url: https://github.com/Shen-Yu/hexo-theme-ayer\n\n\n修改打赏图片，直接重命名复制到该文件夹下覆盖：\n\n# 打赏\n# 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏\nreward_type: 2\n# 打赏wording\nreward_wording: &quot;感谢打赏哈哈嗝~&quot;\n# 支付宝二维码图片地址，跟你设置logo的方式一样。比如：/images/alipay.jpg\nalipay: /images/alipay.jpg\n# 微信二维码图片地址\nweixin: /images/wechat.jpg\n\n\n改完后，执行hexo g &amp;&amp; hexo s，刷新网页看下效果：\n\n\n六、本地发布文章\n终端下输入命令：hexo new &quot;我的第一篇博客&quot;\n\n\n\n此时进入博客根目录下的 source_posts(D:\\hexoblog\\source_posts)文件夹，可以看到多了一个我的第一篇博客.md文件，这便是新生成的博客文章，因为 Hexo 默认使用 Markdown 格式，所以文件后缀是 md，可以使用记事本或者 Typora 打开并编辑\n\n编辑完毕后执行hexo g &amp;&amp; hexo s重新部署，刷新http://localhost:4000/，就可以看到博客上多了一篇文章\n\n打开新建的文章我的第一篇博客.md，可以看到它并不是空的，可是页面上却显示为空，因为 Hexo 根据默认模板帮我们自动生成了一些参数，比如文章创建时间等。这个模板是可更改的。编辑上面打开的文章我的第一篇博客.md，添加一些正文，并改一下自动生成三个参数\n\n此时先 Ctrl + C 停止服务器，执行hexo g &amp;&amp; hexo s重新部署，刷新http://localhost:4000/，可以看看到更改后的效果\n\n\n七、总结\n借助于 Hexo 的框架和 ayer 主题可以快速简易地搭建好一个个人博客，我觉得相对而言更加复杂的是对网页布局和内容的修改和美化，在这里还只是在本地搭建好了一个个人博客，只能实现本地预览效果，因此需要对网站进行部署，我采用的是 GitHub Page ，相关内容请关注后续文章。\n\n","slug":"基于hexo框架快速从0到1搭建个人博客----搭建","date":"2022-08-12T01:58:20.000Z","categories_index":"博客","tags_index":"hexo","author_index":"会思想的苇草i"},{"id":"23d4d9aa01f8e71bead8dc2e7541098c","title":"MySQL的安装（MAC系统）","content":"MySQL 官网\n1. 安装 MySQL 数据库\n1.1 双击打开安装包 mysql-8.0.19-macos10.15-x86_64.dmg：\n\n\n\n1.2 双击 mysql-8.0.19-macos10.15-x86_64.pkg 运行安装包，并点击 继续 按钮：\n\n\n\n1.3 进入 介绍 页面之后，点击 继续 按钮：\n\n\n\n1.4 进入 安装类型 页面之后，点击 安装 按钮：\n\n\n\n1.5 输入电脑的登录密码，从而确认此次安装行为：\n\n\n\n1.6 在 Configuration 页面，确认勾选了 Use Legacy Password Encryption 选项之后，点击 Next 按钮：\n\n\n\n1.7 为 root 用户设置初始密码为 admin123 之后，点击 Finish 按钮：\n\n\n\n1.8 再次输入电脑登陆密码，确认此次 设置初始密码 的操作：\n\n\n\n1.9 提示安装完成之后，点击 关闭 按钮即可：\n\n\n2. 安装 MySql Workbench 可视化工具\n2.1 双击打开安装包 mysql-workbench-community-8.0.19-macos-x86_64.dmg，进入到安装页面：\n\n\n\n2.2 使用鼠标左键，将 MySQLWorkbench 图标拖拽到右侧 Applications 图标之上后，松开鼠标左键，等待进度条完成之后，就完成了安装的过程：\n\n\n\n2.3 在启动台，找到 MySQLWorkbench 图标，点击之后，即可启动 MySQL 可视化管理工具：\n\n\n\n","slug":"工具--Mac 系统配置 MySql 数据库","date":"2022-05-30T07:45:26.000Z","categories_index":"工具","tags_index":"数据库","author_index":"会思想的苇草i"},{"id":"d6136389aad2c7825f58a3f0a2873c63","title":"MySQL的安装（Windows 系统）","content":"\nMySQL 官网\n\n下载好之后双击 mysql-installer-community-8.0.19.0.msi，启动 MySQL 安装程序。\n\n如果弹框提示如下的警告信息，证明你的电脑需要安装额外的 .NET Framework 依赖包。此时，先退出 MySQL 的安装程序，然后双击 NDP452-KB2901907-x86-x64-AllOS-ENU.exe，启动 .NET Framework 4.5.2 的安装程序。\n\n\n\n\n重新启动 MySQL 的安装程序，看到如下界面：\n\n\n\n进入如下界面：\n\n\n\n正在安装依赖项：\n\n\n\n\n\n\n\n\n\n完成依赖项的安装：\n\n\n此时，会弹出如下警告窗，直接点击 Yes 即可：\n\n\n进入 MySQL 的安装页面：\n\n\n\n\n完成 MySQL 功能项的安装：\n\n\n\n配置 MySQL：\n\n\n\n选择 MySQL 数据库的运行模式：\n\n\n\n设置网络模式：\n\n\n\n配置身份认证方式：\n\n\n\n将 MySQL 的默认 root 用户密码，设置为 admin123\n\n\n\n将 MySQL 配置为 Windows 的服务：\n\n\n\n保存刚才对 MySQL 配置的修改：\n\n\n\n\n\n继续完成后续的配置流程：\n\n\n\n\n最后一个配置项：\n\n\n测试能否正常连接到刚才安装的 MySQL 数据库：\n\n\n保存刚才的配置：\n\n\n\n\n完成 MySQL 的安装与配置：\n\n\n","slug":"工具--MySQL 在 Windows 系统下的安装","date":"2022-05-30T07:36:14.000Z","categories_index":"工具","tags_index":"数据库","author_index":"会思想的苇草i"},{"id":"f9f03627b2dbfa46b4d8f839b89a4037","title":"计算机组成原理基础知识点","content":"\n1、计算机系统概论\n冯诺伊曼型计算机的主要设计思想是什么？他包括哪些主要组成部分？\n\n&#x3D;&#x3D;主要设计思想：存储程序，将指令以代码的形式事先输入到计算机主存储器中，然后按其在存储器中的首地址执行程序的第一条指令，以后就按照该程序的规定顺序执行其他指令，直至程序执行结束。&#x3D;&#x3D;\n&#x3D;&#x3D;计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备5大部件组成。&#x3D;&#x3D;\n指令和数据以同等地位存于存储器内，并可按地址寻访。\n指令和数据均用二进制代码表示。\n指令由操作码和地址码组成，操作码用来表示操作的性质，地址码用来表示操作数在存储器中的位置。\n指令在存储器内按顺序存放。通常，指令是顺序执行的，在特定条件下，可根据运算结果或根据设定的条件改变执行顺序。\n早期的冯·诺依曼机以运算器为中心，输入&#x2F;输出设备通过运算器与存储器传送数据。\n\n\n2、运算器和方法器\n数的机器码表示\n\n补码加法\n\n补码减法\n双符号位溢出检测\n定点乘法运算 - - 带求补器的原码阵列乘法器\n定点乘法运算 - - 带求补器的补码阵列乘法器定点除法运算浮点加减法运算浮点乘除法运算\n\n\n3、多层次的存储器\n\n对存储器的要求是容量大、速度快、成本低。为了解决了这三方面的矛盾，计算机采用多级存储体系结构，即cache、主存和外存。CPU能直接访问内存(cache、主存)，但不能直接访问外存。存储器的技术指标有存储容量、存取时间、存储周期、存储器带宽。\n广泛使用的SRAM和DRAM都是半导体随机读写存储器，前者速度比后者快，但集成度不如后者高。二者的优点是体积小，可靠性高，价格低廉，缺点是断电后不能保存信息。\n只读存储器和闪速存储器正好弥补了SRAM和DRAM的缺点，即使断电也仍然保存原先写入的数据。特别是闪速存储器能提供高性能、低功耗、高可靠性以及移动性，是一种全新的存储器体系结构。\n双端存储器和多模块交叉存储器属于并行存储器结构。前者采用空间并行技术，后者采用时间并行技术。这两种类型的存储器在科研和工程中大量使用。\ncache是─种高速缓冲存储器，是为了解决CPU和主存之间速度不匹配而采用的一项重要的硬件技术,并且发展为多级cache体系，指令cache与数据cache分设体系。要求cache的命中率接近于1。主存与cache的地址映射有全相联、直接、组相联三种方式。其中组相联方式是前二者的折衷方案，适度地兼顾了二者的优点又尽量避免其缺点,从灵活性、命中率、硬件投资来说较为理想，因而得到了普遍采用。\n\n\n4、指令系统\n\n—台计算机中所有机器指令的集合，称为这台计算机的指令系统。指今系统是表征一台计算机性能的重要因素，它的格式与功能不仅直接影响到机器的硬件结构，而且也影响到系统软件。指令格式是指今学用二进制代码表示的结构形式,通常由操作码字段和地址码字段组成。\n操作码字段表征指令的操作特性与功能，而地址码字段指示操作数的地址。目前多采用二地址、单地址、零地址混合方式的指令格式。指令字长度分为:单字长、半字长、双字长三种形式。高档微机采用32位长度的单字长形式。\n形成指令地址的方式，称为指令寻址方式。有顺序寻址和跳跃寻址两种，由指令计数器来跟踪。形成操作数地址的方式，称为数据寻址方式。操作数可放在专用寄存器、通用寄存器、内存和指令中。数据寻址方式有隐含寻址、立即寻址、直接寻址、间接寻址、寄存器寻址、寄存器间接寻址、相对寻址、基值寻址、变址寻址、块寻址、段寻址等多种。按操作数的物理位置不同，有RR型和RS型。前者比后者执行的速度快。\n按结构不同，分为寄存器堆栈和存储器堆栈。不同机器有不同的指今系统。一个较完善的指令系统应当包含数据传送类指令、算术运算类指令、逻辑运算类指令、程序控制类指令、I&#x2F;O类指令、字符串类指令、系统控制类指令。RISC指令系统是前计算机发展的主流，也是CISC指令系统的改进，它的最大特点是；①指令条数少:②指令长度固定，指令榕式和寻址方式种类少；③只有取数&#x2F;存数指令访问存储器，其余指令的操作均在寄存器之间进行。\n\n常见指令寻址方式的特点及适用情况：\n\n立即寻址：操作数获取便捷，通常用于给寄存器赋初值。\n直接寻址：相对于立即寻址，缩短了指令长度。\n间接寻址：扩大了寻址范围，便于编制程序，易于完成子程序返回。\n寄存器寻址：指令字较短，指令执行速度较快。\n寄存器间接寻址：扩大了寻址范围。\n基址寻址：扩大了操作数寻址范围，适用于多道程序设计，常用于为程序或数据分配存储空间。\n变址寻址：主要用于处理数组问题，适合编制循环程序。\n相对寻址：用于控制程序的执行顺序、转移等。\n\n与CISC相比，RISC的优点：\n\n更能充分利用VLSI芯片的面积；\n更能提高运算速度；\n便于设计，可降低成本，提高可靠性；\n有利于编译程序代码优化。\n\n\n5、中央处理器\n\nCPU是计算机的中央处理部件，具有指令控制、操作控制、时间控制、数据加工等基本功能。早期的CPU由运算器和控制器两大部分组成。随着高密度集成电路技术的发展，当今的CPU芯片变成运算器、cache和控制器三大部分，其中还包括浮点运算器、存储管理部件等。\nCPU中至少要有如下六类寄存器:指令寄存器、程序计数器、地址寄存器、数据缓冲寄存器、通用寄存器、状态条件寄存器。CPU从存储器取出一条指令并执行这条指令的时间和称为指令周期。cIsc中，由于各种指令的操作功能不同，各种指令的指令周期是不尽相同的。划分指令周期，是设计操作控制器的重要依据。\nRISC中，由于流水执行，大部分指令在一个机器周期完成时序信号产生器提供CPU周期(也称机器周期)所需的时序信号。操作控制器利用这些时序信号进行定时，有条不紊地取出一条指令并执行这条指令。\n微程序设计技术是利用软件方法设计操作控制器的一门技术。具有规整性、灵活件、可维护性等一系列优点，因而在计算机设许中得到了广泛应用。但是随着ULSI技术的发展和对机器速度的要求,硬连线逻辑设计思想又得到了重视。\n硬连线控制器的基本思想是:某一微操作控制信号是指令操作码译码输出、时序信号和状态条件信号的逻辑函数即用布尔代数写出逻辑表达式，然后用门电路、触发器等器件实现。\n从简单到复杂，举出一个CPU模型以及Intel8088、IBM370CPU等传统CPU的结构，这对于建立整机概念是干分重要的。不论微型机还是超级计算机，并行处理技术已成为计算机技术发展的主流。\n并行处理技术可贯穿于信息加工的各个步骤和阶段。概括起来，主要有三种形式: ①时间并行;②空间并行;③时间并行+空间并行。\n流水CPU是以时间并行性为原理构造的处理机，是一种非常经济而实用的并行技术。目前的高性能微处理机几乎无一例外地使用了流水技术。流水技术中的主要问题是资源相关、数据相关和控制相关，为此需要采取相应的技术对策，才能保证流水线畅通而不断流。\nRISC CPU是继承CISC的成功技术，并在克服CISC机器缺点的基础上发展起来的。RISC机器的三个基本要素是:①一个有限的简单指令集，②CPU配备大量的通用寄存器,③强调指令流水线的优化。RISC机器一定是流水CPU,但流水CPU不一定是RISC机器。如奔腾CPU是流水CPU,但奔腾机是CISC机器。\n多媒体CPU是带有MMX技术的处理器。MMX是一种多媒体扩展结构技术，特别适合于图像数据处理，极大地提高了计算机在多媒体和通信应用方面的功能。多媒体CPU以新一代奔腾CPU为代表，开始采用单指令流多数据流的新型结构。\n\n\n6、总线系统\n\n总线是构成计算机系统的互联机构。是多个系统功能部件之间进行数据传送的公共通道，并在争用资源的基础上进行工作。\n总线有物理特性、功能特性、电气特性、机械特性，因此必须标准化。\n微型计算机系统的标准总线从ISA总线(16位，带宽8MB&#x2F;s)发展到EISA总线(32位，带宽33.3MB&#x2F;s)和VESA总线(32位，带宽132MB&#x2F;s) ，又进一步发展到PCI总线(64位，带宽264MB&#x2F;s ) \n衡量总线性能的重要指标是总线带宽，它定义为总线本身所能达到的最高传输速率\n当代流行的标准总线追求与结构、CPU、技术无关的开发标准。真总线内部结构包含:①数据传送总线（由地址线、数据线、控制线组成);②仲裁总线;③中断和同步总线;④公用线(电源、地线、时钟、复位等信号线)。\n计算机系统中，根据应用条件和硬件资源不同，信息的传输方式可采用:①并行传送;②串行传送;复用传送。\n各种外围设备必须通过I&#x2F;O接口与总线相连。I&#x2F;O接口是指CPU、主存、外围设备之间通过点线进行连接的逻辑部件。接口部件在它动态联结的两个切能部件间起着缓冲器和转换器的作用，以便实现彼此之间的信息传送。\n总线仲裁是总线系统的核心问题之一。为了解决多个主设备同时竞争点线控制枚的问题，必须具有总线仲裁部件。它通过采用优先级策略或公平策略，选择其中一个主设备作为总线的下一次主方，接管总线控制权。按照总线仲裁电路的位置不同:集中式仲裁:仲裁方式必有一个中央仲裁器，它受理所有功能模块的总线请求，按优先原则或公平原则。分布式仲裁：分布式仲裁不需要中央仲裁器，每个功能模块都有自己的仲裁号和仲裁器。\n总线定时是总线系统的又一核心问题之一。为了同步主方、从方的操作。必须制订定时协议，通常采用向步定时与异步定时两种方式：在同步定时协议中，事件出现在总线上的时刻由总线时钟信号来确定，总线周期的长度是固定的。在异步定时协议中，后一事件出现在总线上的时刻双决千一事件的出现,即建立在应答式或互锁机制基础上，不需要统一的公共时钟信号。在异步定时中，总线周期的长度是可变的。当代的总线标准大都能支持以下数据传送模式:①读&#x2F;写操作;②块传送操作;③写后读、读修改写操作;④广播、广集操作。\nPCI总线是当前实用的总线，是一个高带宽且与处理器无关的标准总线，又是重要的层次总线。它采用同步定时协议和集中式仲裁策略，并具有自动配置能力。PCI适合于低成本的小系统，因此在微型机系统中得到了广泛的应用。\nInfiniBand标准，瞄准了高端服务器市场的最新I&#x2F;O规范，它是一种基于开关的体系结构，可连接多达64000个服务器、存储系统、网络设备能替代当前服务器中的PCI总线，数据传输率高达30GB&#x2F;s。因此适合于高成本的较大规模计算机系统。\n\n\n7、外存和I&#x2F;O设备\n\n外围设备大体分为输入设备、输出设备、外存设备、数据通信设备、过程控制设备五大类。每一种设备，都是在它自己的设备控制器控制下进行工作，而设备控制器则通过I&#x2F;O接模块和主机相连，并受主机控制。\n磁盘、磁带属于磁表面存储器，特点是存储容量大，位价格低，记录信息永久保存，但存取速度较慢，因此在计算机系统中作为辅助大容量存储器使用。\n硬磁盘按盘片结构分为可换盘片式、固定盘片式两种，磁头也分为可移动磁头和固定磁头两种。温彻斯特磁盘是一种采用先进技术研制的可移动磁头、固定盘片的磁盘机，组装成一个不可拆卸的机电一体化整体，防尘性能好，可靠性高，因而得到了广泛的应用，成为最有代表性的硬磁盘存储器。磁盘存储器的主要技术指标有:存储密度、存储容量、平均存取时间、数据传输速率。\n磁盘阵列RAID是多台磁盘存储器组成的大容量外存系统，它实现数据的并行存储、交叉存储，单独存储，改善了IO性能，增加了存储容量，是一种先进的硬磁盘体系结构。各种可移动硬盘的诞生，是磁盘先进技术的又一个重要进展。\n光盘和磁光盘是近年发展起来的一种外存设备，是多媒体计算机不可缺少的设备。不同的CRT豆示标准所支持的最大分辨率和颜色数目是不同的。VESA标准，是一个可扩展的标准，它除兼容传统的VGA等显示方式外，还支持1280×1024像素光栅，每像素点24位颜色深度，刷新频率可达75MHZ。显示适配器作为CRT与CPU的接口，由刷新存储器、显示控制器、ROM BIOS三部分组成。先进的显示控制器具有图形加速能力。\n常用的计算机输入设备有图形输入设备(键盘、鼠标）、图像输入设备、语音输入设备。常用的打印设备有激光打印机、彩色喷墨打印机等，它们都属于硬拷贝输出设备。\n\n\n8、 输入输出系统\n\n各种外围设备的数据传输速率相差很大。如何保证主机与外围设备在时间上同步，则涉及外围设备的定时问题。在计算机系统中，CPU对外围设备的管理方式有:①程序查询方式;②程序中断方式;③DMA方式;④通道方式。 每种方式都需要硬件和软件结合起来进行。\n程序查询方式是CPU管理IO设备的最简单方式，CPU定期执行设备服务程序，主动来了解设备的工作状态。这种方式浪费CPU的宝贵资源。\n程序中断方式是各类计算机中广泛使用的一种数据交换方式。当某一外设的数据准备就绪后，它“主动”向CPU发出请求信号。CPU响应中断请求后，暂停运行主程序，自动转移到该设备的中断服务子程序，为该设备进行服务，结束时返回主程序。中断处理过程可以嵌套进行，优先级高的设备可以中断优先级低的中断服务程序。\nDMA技术的出现，使得外围设备可以通过DMA控制器直接访问内存，与此同时，CPU可以继续程序。DMA方式采用以下三种方法:①停止CPU访内;②周期挪用;③DMA与CPU交替访内。DMA控制器按其组成结构,分为选择型和多路型两类。\n通道是一个特殊功能的处理器。它有自己的指令和程序专门负责数据输入输出的传输控制，从而使CPU将“传输控制”的功能下放给通道，CPU只负责“数据处理”功能。这样，通道与CPU分时使用内存，实现了CPU内部的数据处理与IO设备的平行工作。通道有两种类型:①选择通道;②多路通道。\n标准化是建立开放式系统的基础。CPU、系统总线、IO总线及标准接口技术近年来取得了重大进步。其中并行VO接口SCSI与串行O接IEE1394是两个最具权威性和发展前景的标准接技术。\nSCSI是系统级接口，是处于主适配器和智能设备控制器之间的并行O接口，改进的SCSI可允许连接1―15台不同类型的高速外围设备。sCSI的不足处在于硬件较昂贵，并需要通用设备驱动程序和各类设备的驱动程序模块的支持。\nIEEE1394是串行UO标准接口。与SCSI并行IO接口相比，它具有更高的数据传输速率和数据传送的实时性，具有更小的体积和连接的方便性。1394的一个董大特点是，各被连接的设备的关系是平等的，不用PC介入也能自成系统。因此EEE1394已成为lntel、Microsoft等公司联手制定的新标准。\n\n\n","slug":"计算机组成原理基础知识点","date":"2022-05-12T14:21:28.000Z","categories_index":"计算机科学与技术","tags_index":"组成原理","author_index":"会思想的苇草i"},{"id":"8de25e8e132b240cdb154bdb91bce02d","title":"计算机操作系统基础知识点","content":"\n1、操作系统引论\n易错点:\n\n在一段时间内置允许一个进程访问的资源称为临界资源或者独占资源\n并发和共享是操作系统两个最基本的特征，两者之间互为存在的条件\n文件的 I&#x2F;O 需要在内核态进行，要使用系统调用接口\nshell 属于命令解析器，属于命令接口\n多道程序设计失去了封闭性和顺序性，顺序性是单道程序设计的基本特征\n中断技术使得多道批处理系统和 I&#x2F;O 设备可与 CPU 并行工作\n\n批处理操作系统、分时操作系统和实时操作系统各有什么特点?\n批处理操作系统的用户脱机使用计算机，作业都是成批处理的，系统内多道程序并发执行，交互能力差。分时操作系统可让多个用户同时使用计算机，人机交互性较强，具有每个用户独立使用计算机的独占性，系统响应及时。实时操作系统能对控制对象做出及时反映，可靠性高，响应及时，但资源利用率低。\n处理器为什么要区分核心态和用户态两种操作方式？在什么情况下进行两种方式的切换？\n区分执行态的主要目的是保护系统程序。用户态到核心态的转换发生在中断产生时，而核心态到用户态的转换则发生在中断返回用户程序时。\n\n2、进程的描述和控制\n生产者-消费者问题PV 操作题目分析步骤:\n\n关系分析。 找出题目中描述的各个进程，分析它们之间的同步、互斥关系。\n整理思路。 根据各进程的操作流程确定 P、V 操作的大致顺序。\n设置信号量。 设置需要的信号量，并根据题目条件确定信号量初值。(互斥信号量初值一般为 1，同步信号量的初始值要看对应资源的初始值是多少)\n\n利用记录型信号量解决生产者-消费者问题\nitem buffer[n]\nsemaphore mutex = 1;//互斥信号量，实现对缓冲区的互斥访问\nsemaphore empty = n;//同步信号量，表示空闲缓冲区的数量\nsemaphore full = 0; //同步信号量，表示产品的数量，也即非空缓冲区的数量\n\nprodecer ()&#123;\n    while(1)&#123;\n        生产一个产品;\n        P(emoty);\n        P(mutex);\n        把产品放入缓冲区;\n        V(mutex);\n        V(full);\n    &#125;\n&#125;\n\nconsumer ()&#123;\n    while(1)&#123;\n        P(full);\n        P(mutex);\n        从缓冲区取出一个产品;\n        V(mutex);\n        V(empty);\n        使用产品;\n    &#125;\n&#125;\n\n\n在生产者-消费者问题中应注意:&#x3D;&#x3D;首先，在每个程序中用于实现互斥的 wait(mutex)和 signal(mutex)必须成对地出现;其次，对资源信号量 empty 和 full 的 wait 和 signal 操作，同样需要成对地出现，但它们分别处于不同的程序中&#x3D;&#x3D;。\n例如，wait(empty)在计算进程中，而 signal(empty)则在打印进程中，计算进程若因执行 wait(empty)而阻塞，则以后将由打印进程将它唤醒;&#x3D;&#x3D;最后，在每个程序中的多个 wait 操作顺序不能颠倒。应先执行对资源信号量的 wait 操作，然后再执行对互斥信号量的 wait 操作，否则可能引起进程死锁。&#x3D;&#x3D;\n\n哲学家进餐问题\n解决方案：\n\n可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的\n要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子,另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。\n仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子。\n\n利用记录型信号量解决哲学家进餐问题\nsemaphore chopstick[5]=&#123;1,1,1,1,1&#125;;\nsemaphore mutex = 1;//互斥地取筷子\nPi()&#123;\t\t\t\t//i号哲学家的进程\n    while(1)&#123;\n        p(mutex);\n        P(chopstick[i]);\t\t//拿左\n        P(chopstick[(i+1)%5];\t//拿右\n        V(mutex);\n        吃饭...\n        V(chopstick[i]);\t //放左\n        V(chopstick[(i+1)%5];//放右\n        思考...\n    &#125;\n&#125;\n\n\n哲学家进餐问题的关键在于解决进程死锁。\n这些进程之间只存在互斥关系，但是与之前接触到的互斥关系不同的是，每个进程都需要同时持有两个临界资源，因此就有“死锁”问题的隐患。\n如果遇到了一个进程需要同时持有多个临界资源的情况，应该参考哲学家问题的思想，分析题中给出的进程之间是否会发生循环等待，是否会发生死锁。\n可以参考哲学家就餐问题解决死锁的三种思路。\n\n读者-写者问题\n\n读进程与读进程不存在互斥问题。写者进程和任何进程都互斥。设置一个互斥信号量 rw，在写者访问共享文件前后分别执行 P、V 操作。读者进程和写者进程也要互斥，因此读者访问共享文件前后也要对 rw 执行 P、V 操作。\n\nSemapore rmutex = 1;//计数器\nSemapore wmutex = 1;//阀门\nint readcount = 0;\n\nWruter():\n    while(true)&#123;\n        wait(wmutex);\n\n        写;\n\n        signal(wmutex);\n    &#125;;\n\nReader():\n    while(true)&#123;\n    wait(rmutex);\n\n    if(readcount == 0)\n    wait(wmutex);\n    readcount++;\n    signal(rmutex)\n\n    读;\n\n    wait(rmutex);\n    readcount--;\n    if(readcount == 0)\n    signal(wmutex);\n    signal(rmutex);\n&#125;;\n\n\n3、处理机调度与死锁\n先来先服务算法(FCFS)\n短进程优先算法(SPF)\n高优先权优先算法(HRRN)\n\n安全状态与不安全状态\n银行家算法\n\n4、存储器管理\n存储器的层次结构\n首次适应算法\n循环首次适应算法\n最佳适应算法\n最坏适应算法\n相关计算\n\n5、虚拟存储器\n最佳置换算法(OPT)\n先进先出置换算法\n最近最久未使用算法(LRU)\n\n6、输入输出设备\n先来先服务算法\n最短寻道时间优先算法\n扫描算法\n循环扫描算法\n\n7、文件管理\n\n\n\n","slug":"计算机操作系统基础知识点","date":"2022-05-06T12:09:08.000Z","categories_index":"计算机科学与技术","tags_index":"操作系统","author_index":"会思想的苇草i"},{"id":"ac07147ebfe9ea11673ae70bed7f524c","title":"JAVA图形化基础--GUI编程","content":"\n1、GUI简介GUI的核心技术：\n\nAWT： 抽象窗口工具包，早期编写图形界面应用程序的包\nSwing ： 为解决 AWT 存在的问题而新开发的图形界面包；Swing是对AWT的改良和扩展\n\nGUI因界面不美观，且运行需要jre环境（占用内存大，繁琐）被逐渐淘汰，现阶段学习GUI主要是为了了解\tMVC架构(了解监听)，写一些小工具，和工作中可能需要维护Swing界面。\n\n2、AWT2.1 AWT介绍\n包含了很多类和接口！ GUI：图形用户界面编程 \n元素：窗口，按钮，文本框 \n包都在java（awt）包\n\n2.2 组件和容器Frame框架\nimport java.awt.*;\n//GUI的第一个界面\npublic class TestFrame &#123;\n    public static void main(String[] args) &#123;\n        //看源码 选中+ctrl+左键\n        //看结构 alt+7\n        Frame frame = new Frame(&quot;我的第一个Java图形界面窗口&quot;);//Frame 是一个顶级窗口\n        //Frame的方法\n        //设置可见性\n        frame.setVisible(true);\n        //设置窗口大小\n        frame.setSize(400,400);\n        //设置背景颜色 Color\n        frame.setBackground(new Color(51, 158, 22));\n        //弹出的初始位置\n        frame.setLocation(200,200);\n        //设置大小固定\n        frame.setResizable(false);\n        //窗口无法关闭！！！最小化、最大化、窗口尺寸已经默认存在！\n    &#125;\n&#125;\n\nimport java.awt.*;\npublic class TestFrame2 &#123;\n    public static void main(String[] args) &#123;\n        //展示多个窗口\n        MyFrame myFrame1 = new MyFrame(100,100,200,200,Color.blue);\n        MyFrame myFrame2 = new MyFrame(300,100,200,200,Color.yellow);\n        MyFrame myFrame3 = new MyFrame(100,300,200,200,Color.red);\n        MyFrame myFrame4 = new MyFrame(300,300,200,200,Color.MAGENTA);\n    &#125;\n&#125;\nclass MyFrame extends Frame &#123;\n    static int id = 0;      //可能存在多个窗口，需要一个计数器\n    public MyFrame(int x,int y,int w,int h,Color color)&#123;\n        super(&quot;Myframe+&quot;+(++id));//继承\n        setBounds(x, y, w, h);//设置坐标\n        setBackground(color);//设置颜色\n        setVisible(true);//设置可见性\n    &#125;\n&#125;\n\n面板Panel\nimport java.awt.*;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\n//panel 可以看成是一个空间，但是不能单独存在\npublic class TestPanel &#123;\n    public static void main(String[] args)&#123;\n        Frame frame = new Frame();  //new 窗口\n        //布局的概念\n        Panel panel = new Panel();  //new 面板\n        Panel panel1 = new Panel();\n        //设置布局,不设置面板会置顶\n        frame.setLayout(null);\n        //窗口坐标和颜色\n        frame.setBounds(300,300,500,500);\n        frame.setBackground(new Color(140, 208, 212));\n        //panel 设置坐标，相对于frame\n        panel.setBounds(50,50,400,100);\n        panel.setBackground(new Color(181, 186, 54));\n        panel1.setBounds(50,200,400,250);\n        panel1.setBackground(new Color(165, 34, 101));\n        //将panel添加进frame\n        frame.add(panel1);//Panel 无法单独显示，必须添加到某个容器中\n        frame.add(panel);\n        frame.setVisible(true);\n        //监听时间，监听窗口关闭事件\n        //适配器模式(二十三种设计模式)\n        frame.addWindowListener(new WindowAdapter() &#123;\n            //窗口关闭要做的事情\n            @Override\n            public void windowClosing(WindowEvent e) &#123;\n                //结束程序\n                System.exit(0);\n            &#125;\n        &#125;);\n    &#125;\n&#125;\n\n2.3 布局管理器流式布局\nimport java.awt.*;\npublic class TestFlowLayout  &#123;\n    public static void main(String[] args) &#123;\n        Frame frame = new Frame();\n        //组件-按钮\n        Button button1 = new Button(&quot;button1&quot;);\n        Button button2 = new Button(&quot;button2&quot;);\n        Button button3 = new Button(&quot;button3&quot;);\n        //设置流式布局的位置\n        //frame.setLayout(new FlowLayout(0));\t0为左，1为中...\n        frame.setLayout(new FlowLayout(FlowLayout.LEFT));//两种方式\n        frame.setSize(200,200);\n        //把按钮添加上去\n        frame.add(button1);\n        frame.add(button2);\n        frame.add(button3);\n        frame.setVisible(true);\n    &#125;\n&#125;\n\n东西南北中布局\nimport java.awt.*;\npublic class TestBorderLayout &#123;\n    public static void main(String[] args) &#123;\n        Frame frame = new Frame(&quot;TestBorderLayout&quot;);\n        Button east = new Button(&quot;East&quot;);\n        Button west = new Button(&quot;West&quot;);\n        Button south = new Button(&quot;South&quot;);\n        Button north = new Button(&quot;North&quot;);\n        Button center = new Button(&quot;Center&quot;);\n        frame.setSize(400,400);\n        //不同布局的方位\n        frame.add(east,BorderLayout.EAST);\n        frame.add(west,BorderLayout.WEST);\n        frame.add(south,BorderLayout.SOUTH);\n        frame.add(north,BorderLayout.NORTH);\n        frame.add(center,BorderLayout.CENTER);\n        frame.setVisible(true);\n    &#125;\n&#125;\n\n栅格布局\nimport java.awt.*;\npublic class TestGridLayout &#123;\n    public static void main(String[] args) &#123;\n        Frame frame = new Frame(&quot;TestGridLayout&quot;);\n        Button btn1 = new Button(&quot;btn1&quot;);\n        Button btn2 = new Button(&quot;btn2&quot;);\n        Button btn3 = new Button(&quot;btn3&quot;);\n        Button btn4 = new Button(&quot;btn4&quot;);\n        Button btn5 = new Button(&quot;btn5&quot;);\n        Button btn6 = new Button(&quot;btn6&quot;);\n        frame.setLayout(new GridLayout(3,2));\n        frame.add(btn1);\n        frame.add(btn2);\n        frame.add(btn3);\n        frame.add(btn4);\n        frame.add(btn5);\n        frame.add(btn6);\n        frame.pack();//Java函数，自适应，用于优化大小；\n        // frame.setSize(400,400);\n        frame.setVisible(true);\n    &#125;\n&#125;\n\n2.4 事件监听ActionListener\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\npublic class TesActionEvent &#123;\n    public static void main(String[] args) &#123;\n        //按下按钮，触发一些事件\n        Frame frame = new Frame();\n        Button button = new Button();\n        /*按钮可以new一个接口，需要命名内部类，把他的实现类写下来。但一般不这么做\n        button.addActionListener(new AbstractAction() &#123;\n            @Override\n            public void actionPerformed(ActionEvent e) &#123;  &#125;  &#125;);*/\n        \n        //因为,addActionListener()需要一个ActionListener，所以我们需要构造一个ActionListener\n        //接口就写实现类，父类就继承\n        MyActionListener myActionListener = new MyActionListener();\n        button.addActionListener(myActionListener);\n        frame.add(button,BorderLayout.CENTER);\n        windowClose(frame);\n        frame.pack();\n        frame.setVisible(true);\n    &#125;\n    //关闭窗体的事件\n    private static void windowClose(Frame frame)&#123;\n        frame.addWindowListener(new WindowAdapter() &#123;\n            @Override\n            public void windowClosing(WindowEvent e) &#123;\n                System.exit(0);\n            &#125;\n        &#125;);\n    &#125;\n&#125;\nclass MyActionListener implements ActionListener&#123;\n    //事件监听\n    @Override\n    public void actionPerformed(ActionEvent e) &#123;\n        System.out.println(&quot;事件监听，您按下了按钮&quot;);\n    &#125;\n&#125;\n\n多按钮共享一个事件\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\npublic class TestActionTwo &#123;\n    public static void main(String[] args) &#123;\n        //两个按钮，实现同一个监听\n        //开始--停止\n        Frame frame = new Frame(&quot;开始-停止&quot;);\n        Button button1 = new Button(&quot;start&quot;);\n        Button button2 = new Button(&quot;stop&quot;);\n      // button2.setActionCommand(&quot;button2-stop&quot;);\n        MyMonitor myMonitor = new MyMonitor();\n        button1.addActionListener(myMonitor);\n        button2.addActionListener(myMonitor);\n        frame.add(button1,BorderLayout.NORTH);\n        frame.add(button2,BorderLayout.SOUTH);\n        frame.pack();\n        frame.setVisible(true);\n    &#125;\n&#125;\nclass MyMonitor implements ActionListener&#123;\n    @Override\n    public void actionPerformed(ActionEvent e) &#123;\n        /*e.getActionCommand() 获取按钮的信息\n        System.out.println(&quot;按钮被点击了：msg=&gt;&quot;+e.getActionCommand());\n        输出结果butoo2为&quot;按钮被点击了：msg=&gt;stop&quot;;可以显示的定义触发会返回的命令\n        butoo1为&quot;start&quot;。无显示定义，则会走默认的值。\n        */\n        //可以多个按钮只写一个监听类\n        if (e.getActionCommand().equals(&quot;start&quot;))&#123;//equals 等号\n            System.out.println(e.getActionCommand()+&quot;按钮被点击&quot;);\n        &#125; if (e.getActionCommand().equals(&quot;stop&quot;))&#123;\n            System.out.println(e.getActionCommand()+&quot;按钮被点击&quot;);\n        &#125;\n    &#125;\n&#125;\n\n输入框TextField监听\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\npublic class TestText01 &#123;\n    public static void main(String[] args) &#123;\n        //启动\n        new MyFrame();\n    &#125;\n&#125;\nclass MyFrame extends Frame&#123;\n    public MyFrame()&#123;\n        TextField textField = new TextField();//文本 TextArea文本域，可以写多行\n        add(textField);\n        //监听这个文本框输入的文字\n        MyActionListener2 myActionListener2 = new MyActionListener2();\n        //按下enter 就会触发这个输入框的事件\n        textField.addActionListener(myActionListener2);\n        //设置替换编码\n        textField.setEchoChar(&#39;*&#39;);\n        setVisible(true);\n        pack();\n    &#125;\n&#125;\nclass MyActionListener2 implements ActionListener&#123;//监听器\n    @Override\n    public void actionPerformed(ActionEvent e) &#123;\n        TextField field = (TextField)e.getSource();//获得一些资源,返回的一个对象\n        System.out.println(field.getText());//获得输入框的文本\n        field.setText(&quot;&quot;);//设置enter 后的状态\n    &#125;\n&#125;\n\n2.5 简易计算器import java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\n//简易计算器\npublic class TestCalc &#123;\n    public static void main(String[] args) &#123;\n        new Calculator();\n    &#125;\n&#125;\n//计算器类\nclass  Calculator extends Frame&#123;\n    public Calculator() &#123;\n        //三个文本框\n        TextField num1 = new TextField(10);//字符数\n        TextField num2 = new TextField(10);//字符数\n        TextField num3 = new TextField(20);//字符数\n        //一个按钮\n        Button button = new Button(&quot;=&quot;);\n        button.addActionListener(new MyCalculatorListener(num1,num2,num3));\n        //一个标签\n        Label label = new Label(&quot;+&quot;);\n        //布局\n        setLayout(new FlowLayout());\n        add(num1);\n        add(label);\n        add(num2);\n        add(button);\n        add(num3);\n        pack();\n        setVisible(true);\n    &#125;\n&#125;\n//监听器类\nclass MyCalculatorListener implements ActionListener&#123;\n    //获取三个变量\n    private TextField num1,num2,num3;\n\n    public MyCalculatorListener(TextField num1,TextField num2,TextField num3)&#123;\n        this.num1 = num1;\n        this.num2 = num2;\n        this.num3 = num3;\n    &#125;\n    @Override\n    public void actionPerformed(ActionEvent e) &#123;\n        //1.获得加数和被加数\n        int n1 = Integer.parseInt(num1.getText());\n        int n2 = Integer.parseInt(num2.getText());\n        //2.将这个值+法运算后，放到第三个框\n        num3.setText(&quot;&quot;+(n1+n2));\n        //3.清除前两个框\n        num1.setText(&quot;&quot;);\n        num2.setText(&quot;&quot;);\n    &#125;\n&#125;\n\n2.6 画笔import java.awt.*;\npublic class TestPaint &#123;\n    public static void main(String[] args) &#123;\n        new MyPaint().loadFrame();\n    &#125;\n&#125;\nclass MyPaint extends Frame &#123;\n    public void loadFrame()&#123;\n        setBounds(200,200,600,500);\n        setVisible(true);\n    &#125;\n    //画笔，颜色，可以画画\n   @Override\n    public void paint(Graphics g) &#123;\n       // super.paint(g);有些类里面有初始化操作，就无法删除\n       g.setColor(Color.red);\n       //g.drawOval(100,100,100,100);   //draw空心\n       g.fillOval(100,100,100,100);   //fill实心、填充的\n       g.setColor(Color.GREEN);\n       g.fillRect(200,200,200,200);\n       //养成习惯，画笔用完，将它还原到最初的颜色，不然你再画一个图会带上之前的颜色。\n    &#125;\n&#125;\n\n2.7 鼠标监听\nimport java.awt.*;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\n//鼠标监听事件\npublic class TestMouseListener &#123;\t\n    public static void main(String[] args) &#123;\n    new MyFrame(&quot;画图&quot;);\n    &#125;\n&#125;\n//自己的类\nclass MyFrame extends Frame&#123;\t\t\n    //画画需要画笔，需要监听鼠标当前的位置，需要集合来存储这个点\n    ArrayList points;\n\n    public MyFrame(String title) &#123;//--------框架\n        super(title);       //名字                                           \n        setBounds(200, 200, 400, 300);\n        //存标点击的点\n        points = new ArrayList&lt;&gt;();\n        //鼠标监听器，针对这个窗口\n        this.addMouseListener(new MyMouseListener());        //-监听鼠标\n\n        setVisible(true);\n    &#125;\n    @Override\t\t\t\t\n    public void paint(Graphics g) &#123; //画画                  //--------------画笔存储实施\n        //画画，需要监听鼠标的事件\n        Iterator iterator = points.iterator();              //-迭代器\n        while (iterator.hasNext())&#123;                         //检查序列中是否还有元素\n            Point point = (Point) iterator.next();\n            g.setColor(Color.BLUE);\n            g.fillOval(point.x,point.y,10,10);\n        &#125;\n    &#125;\n    //添加一个点到界面上，点集合\t\t\n    public void addPaint(Point point)&#123;\n        points.add(point);                  //将（点）传到迭代器里\n\n\n    &#125;\n\n    //适配器模式，就是别人已经写好的端口，不用全部重写内部类，直接继承更加方便。\n    private class MyMouseListener extends MouseAdapter&#123;      //----------监听器\n            //鼠标，按下，弹起，按下不放。\n            @Override\n            public void mousePressed(MouseEvent e) &#123;        //-鼠标按下\n               MyFrame frame = (MyFrame) e.getSource();     //-鼠标按下的来源\n                //这里我点击的时候，就会在界面上产生一个点\n                //这个点就是鼠标的点\n                frame.addPaint(new Point(e.getX(),e.getY()));//--将监控的（点的坐标）传到点集合\n                //每次点击鼠标都需要重写画一遍\n                frame.repaint();                             //再次刷漆\n            &#125;\n        &#125;\n&#125;            \n\n2.8 窗口监听import java.awt.*;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\n\npublic class TestWindow &#123;\n    public static void main(String[] args) &#123;\n        new WindowFrame(&quot;窗口监听&quot;);\n    &#125;\n&#125;\nclass WindowFrame extends Frame&#123;\n    public WindowFrame(String kk) &#123;\n        super(kk);\n        setBackground(Color.cyan);\n        setBounds(100,100,200,200);\n        setVisible(true);\n        //匿名内部类\n        this.addWindowListener(\n                new WindowAdapter() &#123;\n                    @Override\n                    public void windowOpened(WindowEvent e) &#123;\n                        System.out.println(&quot;窗口打开&quot;);\n                    &#125;\n                    @Override\n                    public void windowClosed(WindowEvent e) &#123;\n                        System.out.println(&quot;窗口关闭中&quot;);\n                    &#125;\n                    @Override\n                    public void windowActivated(WindowEvent e) &#123;\n                        System.out.println(&quot;窗口激活&quot;);\n                        WindowFrame source = (WindowFrame) e.getSource();       //获取框架信息\n                        source.setTitle(&quot;被激活了&quot;);\n                    &#125;\n                    @Override\n                    public void windowStateChanged(WindowEvent e) &#123;\n                        WindowFrame source = (WindowFrame) e.getSource();\n                        source.setTitle(&quot;状态改变了&quot;);\n                        System.out.println(&quot;窗口状态改变&quot;);\n                    &#125;\n                    @Override\n                    public void windowClosing(WindowEvent e) &#123;\n                        System.out.println(&quot;窗口关闭&quot;);\n                        System.exit(0);\n                    &#125;\n                &#125;\n        );\n    &#125;\n   /* 通过匿名内部类可以不用另外创建类\n   class MyWindowListener extends WindowAdapter&#123;\n        @Override\n        public void windowClosing(WindowEvent e) &#123;\n            setVisible(false);      //隐藏窗口，通过按钮点击事件\n            System.exit(0);         //0正常退出，1非正常退出\n        &#125;\n    &#125;*/\n&#125;\n\n2.9 键盘监听import java.awt.*;\nimport java.awt.event.KeyAdapter;\nimport java.awt.event.KeyEvent;\n//键盘\npublic class TestKeyListener &#123;\n    public static void main(String[] args) &#123;\n        new KeyFrame();\n    &#125;\n&#125;\nclass KeyFrame extends Frame&#123;\n    public KeyFrame() &#123;\n        setBounds(10,10,300,400);\n        setVisible(true);\n        this.addKeyListener(new KeyAdapter() &#123;\n            //键盘按下\n            @Override\n            public void keyPressed(KeyEvent e) &#123;\n                //获得当前键盘的码\n                int keyCode = e.getKeyCode();       //不需要去记录这个数值，直接使用静态属性VK_XXX\n                System.out.println(keyCode);\n                if (keyCode == KeyEvent.VK_UP)&#123;     //KeyEvent.VK 按键类\n                    System.out.println(&quot;你按下了上键！&quot;);\n                &#125;\n                //根据按下不同操作，产生不同结果。\n            &#125;\n        &#125;);\n    &#125;\n&#125;\n\n\n3、Swing3.1 窗口、面板import javax.swing.*;\nimport java.awt.*;\npublic class JFrameDemo &#123;\n    //init();初始化\n    public void init()&#123;\n        //顶级窗口\n        JFrame jf = new JFrame(&quot;这是一个JFrame窗口&quot;);\n        jf.setVisible(true);\n        //jf.setBackground(Color.cyan);     因为在容器中，直接颜色没效果，需要容器实例化\n        jf.setBounds(100,100,200,200);\n        JLabel jLabel = new JLabel(&quot;欢迎学习Java GUI&quot;);  //标签\n        jf.add(jLabel);\n        //让文本标签居中，设置水平对齐\n        jLabel.setHorizontalAlignment(SwingConstants.CENTER);\n        //需要容器实例化,颜色才能现象\n        Container contentPane = jf.getContentPane();\n        contentPane.setBackground(Color.cyan);\n        //关闭事件\n        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n    &#125;\n    public static void main(String[] args) &#123;\n        //建立一个窗口\n        new JFrameDemo().init();\n    &#125;\n&#125;\n\n3.2 弹窗import javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n//主窗口\npublic class DialogDemo extends JFrame &#123;\n    public DialogDemo() &#123;\n        this.setVisible(true);      //可见\n        this.setSize(700,500);          //尺寸\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);       //关闭事件\n        //JFrame 放东西，容器\n        Container container = this.getContentPane();\n        //绝对布局，会相对容器自动定位\n        container.setLayout(null);\n        //按钮\n        JButton button = new JButton(&quot;点击弹出一个对话框&quot;);      //创建\n        button.setBounds(30,30,200,50);\n        //点击这个按钮的时候，弹出一个弹窗\n        button.addActionListener(new ActionListener() &#123;           //监听器\n            @Override\n            public void actionPerformed(ActionEvent e) &#123;\n                //监听弹窗\n                new MyDialogDemo();\n            &#125;\n        &#125;);\n        container.add(button);      //将按钮放进容器中\n    &#125;\n    public static void main(String[] args) &#123;\n        new DialogDemo();\n    &#125;\n&#125;\n        //弹窗的窗口\nclass MyDialogDemo extends JDialog&#123;\n            public MyDialogDemo() &#123;\n                this.setVisible(true);\n                this.setBounds(100,100,500,500);\n           // this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);    弹窗可以被关掉，不需要额外添加事件\n                Container container = this.getContentPane();\n                container.setLayout(null);\n\n                container.add(new Label(&quot;Java弹窗&quot;));\n            &#125;\n        &#125;\n\n3.3 标签/*图标ICON*/\nimport javax.swing.*;\nimport java.awt.*;\n\n//图片，需要实现类，Frame 继承\npublic class IconDemo extends JFrame implements Icon &#123;\n\n    private int width;\n    private int height;\n\n    public IconDemo()&#123;&#125;\n\n    public IconDemo(int width,int height)&#123;\n        this.width = width;\n        this.height = height;\n    &#125;\n\n\n    public void init()&#123;     //图标\n        IconDemo iconDemo = new IconDemo(15,15);\n        //图标放在标签上，也可以放在按钮上!\n        //标签，图标，位置\n        JLabel label = new JLabel(&quot;icontest&quot;, iconDemo, SwingConstants.CENTER);\n\n        Container container = getContentPane();\n        container.add(label);\n\n        this.setVisible(true);\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n    &#125;\n    \n    public static void main(String[] args) &#123;\n        new IconDemo().init();\n    &#125;\n    @Override       //图标尺寸\n    public void paintIcon(Component c, Graphics g, int x, int y) &#123;\n        g.fillOval(x,y,width,height);\n    &#125;\n\n    @Override\n    public int getIconWidth() &#123;\n        return this.width;\n    &#125;\n\n    @Override\n    public int getIconHeight() &#123;\n        return this.height;\n    &#125;\n&#125;\n\n/* 图片 */\nimport javax.swing.*;\nimport java.awt.*;\nimport java.net.URL;\n\npublic class ImageIconDemo extends JFrame &#123;\n    public ImageIconDemo()  &#123;\n        //获取图片的地址\n        JLabel label = new JLabel(&quot;ImageIcon&quot;);\n        URL url = ImageIconDemo.class.getResource(&quot;xxx.jpg&quot;);//获取当前类以下的东西\n\n        ImageIcon imageIcon = new ImageIcon(url);//命名不要冲突\n        label.setIcon(imageIcon);\n        label.setHorizontalAlignment(SwingConstants.CENTER);\n\n        Container contentPane = getContentPane();\n        contentPane.add(label);\n\n        setVisible(true);\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        setBounds(100,100,300,500);\n    &#125;\n    public static void main(String[] args) &#123;\n        new ImageIconDemo();\n    &#125;\n&#125;\n\n3.4 面板import javax.swing.*;\nimport java.awt.*;\n\n\npublic class JPanelDemo extends JFrame &#123;\n    public JPanelDemo() &#123;\n        Container container = this.getContentPane();\n        //后面参数的意思，面板与面板的间距\n        container.setLayout(new GridLayout(2,1,10,10));\n\n        JPanel panel1 = new JPanel(new GridLayout(1, 3));   //GridLayout网格布局\n        JPanel panel2 = new JPanel(new GridLayout(2, 1));\n        JPanel panel3 = new JPanel(new GridLayout(2, 3));\n\n        panel1.add(new JButton(&quot;1&quot;));\n        panel1.add(new JButton(&quot;1&quot;));\n        panel1.add(new JButton(&quot;1&quot;));\n        panel2.add(new JButton(&quot;2&quot;));\n        panel2.add(new JButton(&quot;2&quot;));\n        panel3.add(new JButton(&quot;3&quot;));\n        panel3.add(new JButton(&quot;3&quot;));\n        panel3.add(new JButton(&quot;3&quot;));\n        panel3.add(new JButton(&quot;3&quot;));\n        panel3.add(new JButton(&quot;3&quot;));\n        panel3.add(new JButton(&quot;3&quot;));\n\n        container.add(panel1);\n        container.add(panel2);\n        container.add(panel3);\n\n        this.setVisible(true);\n        this.setSize(500,500);\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\n    &#125;\n    public static void main(String[] args) &#123;\n        new JPanelDemo();\n    &#125;\n&#125;\n\n3.5 边框、文本域import javax.swing.*;\nimport java.awt.*;\n\npublic class JScrollDemo extends JFrame &#123;\n    public JScrollDemo() &#123;\n        Container container = this.getContentPane();\n        //文本域\n        JTextArea textArea = new JTextArea(20, 50);\n        textArea.setText(&quot;边框、文本域&quot;);\n        //Scroll 面板\n        JScrollPane scrollPane = new JScrollPane(textArea);\n        container.add(scrollPane);\n\n        this.setBounds(100,100,300,350);\n        this.setVisible(true);\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        new JScrollDemo();\n    &#125;\n&#125;\n\n3.6 按钮图片按钮\nimport javax.swing.*;\nimport java.awt.*;\nimport java.net.URL;\n\npublic class JButtonDemo01 extends JFrame &#123;\n    public JButtonDemo01() &#123;\n        Container container = this.getContentPane();\n        //将一个图片变为图标\n        URL resource = JButtonDemo01.class.getResource(&quot;123.jpg&quot;);  //图片路径\n        ImageIcon icon = new ImageIcon(resource);       //转换为图标\n\n        //把这个图标放到按钮上\n        JButton button = new JButton();\n        button.setIcon(icon);\n        button.setToolTipText(&quot;图片按钮&quot;);      //图片按钮提示\n        //add\n        container.add(button);\n\n        this.setVisible(true);\n        this.setSize(500,300);\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\n    &#125;\n\n    public static void main(String[] args) &#123;\n        new JButtonDemo01();\n    &#125;\n&#125;\n\n单选按钮\nimport javax.swing.*;\nimport java.awt.*;\nimport java.net.URL;\n\npublic class JButtonDemo02 extends JFrame&#123;\n    public JButtonDemo02() &#123;\n        Container container = this.getContentPane();\n        //将一个图片变为图标\n        URL resource = JButtonDemo01.class.getResource(&quot;123.jpg&quot;);  //图片路径\n        ImageIcon icon = new ImageIcon(resource);       //转换为图标\n\n        //单选框\n        JRadioButton radioButton1 = new JRadioButton(&quot;JRadioButton01&quot;);\n        JRadioButton radioButton2 = new JRadioButton(&quot;JRadioButton02&quot;);\n        JRadioButton radioButton3 = new JRadioButton(&quot;JRadioButton03&quot;);\n        //由于单选框只能选择一个，可以将他们分组，一个组只能选一个。\n        ButtonGroup group = new ButtonGroup();      //组\n        group.add(radioButton1);                    \n        group.add(radioButton2);\n        group.add(radioButton3);\n\n        container.add(radioButton1,BorderLayout.CENTER);\n        container.add(radioButton2,BorderLayout.NORTH);\n        container.add(radioButton3,BorderLayout.SOUTH);\n\n\n        this.setVisible(true);\n        this.setSize(500,300);\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\n    &#125;\n\n    public static void main(String[] args) &#123;\n        new JButtonDemo02();\n    &#125;\n&#125;\n\n复选按钮\nimport javax.swing.*;\nimport java.awt.*;\nimport java.net.URL;\n\npublic class JButtonDemo03 extends JFrame &#123;\n    public JButtonDemo03() &#123;\n        Container container = this.getContentPane();\n        //将一个图片变为图标\n        URL resource = JButtonDemo01.class.getResource(&quot;123.jpg&quot;);  //图片路径\n        ImageIcon icon = new ImageIcon(resource);       //转换为图标\n\n        //多选框\n        JCheckBox checkBox01 = new JCheckBox(&quot;checkBox01&quot;);\n        JCheckBox checkBox02 = new JCheckBox(&quot;checkBox02&quot;);\n        \n        container.add(checkBox01,BorderLayout.NORTH);\n        container.add(checkBox02,BorderLayout.SOUTH);\n\n        this.setVisible(true);\n        this.setSize(500,300);\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\n    &#125;\n    public static void main(String[] args) &#123;\n        new JButtonDemo03();\n    &#125;\n&#125;\n\n3.7 列表下拉框\n/*选择地址或者一些单个选项（一到两个最好使用按钮，两个以上使用下拉框，节省内存布局）*/\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class TsetComboboxDemo01 extends JFrame &#123;\n    public TsetComboboxDemo01() &#123;\n        Container container = this.getContentPane();\n        JComboBox status = new JComboBox();\n        status.addItem(null);\n        status.addItem(&quot;正在上映&quot;);\n        status.addItem(&quot;已下架&quot;);\n        status.addItem(&quot;即将上映&quot;);\n\n        // status.addActionListener(); 监听获取值\n\n        container.add(status);\n\n        this.setVisible(true);\n        this.setSize(500,300);\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        new TsetComboboxDemo01();\n    &#125;\n&#125;\n\n列表框\n/*展示信息，一般是动态扩容。*/\nimport javax.swing.*;\nimport java.awt.*;\nimport java.util.Vector;\n\npublic class TsetComboboxDemo02 extends JFrame &#123;\n    public TsetComboboxDemo02() &#123;\n        Container container = this.getContentPane();\n        //生产列表的内容\n        //String[] contents = &#123;&quot;1&quot;,&quot;2&quot;,&quot;3&quot;&#125;;    静态数组\n\n        Vector contents = new Vector();\n\n        //列表中需要放入内容\n        JList jList = new JList(contents);      //列表\n\n        //动态数组\n        contents.add(&quot;zhangsan&quot;);\n        contents.add(&quot;lisi&quot;);\n        contents.add(&quot;wangwu&quot;);\n        \n        container.add(jList);\n\n        this.setVisible(true);\n        this.setSize(500,300);\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n    &#125;\n    public static void main(String[] args) &#123;\n        new TsetComboboxDemo02();\n    &#125;\n&#125;\n\n3.8 文本框文本框 TextField\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class TestTextDemo01 extends JFrame  &#123;\n    public TestTextDemo01() throws HeadlessException &#123;\n        Container container = this.getContentPane();\n\n\n        JTextField textField1 = new JTextField(&quot;hello&quot;,50);    //文本框+尺寸\n        JTextField textField2 = new JTextField(&quot;world&quot;);\n\n        container.add(textField1,BorderLayout.NORTH);\n        container.add(textField2,BorderLayout.SOUTH);\n\n\n        this.setVisible(true);\n        this.setSize(500,300);\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        new TestTextDemo01();\n    &#125;\n&#125;\n\n密码框 PasswordField\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class TestTextDemo02 extends JFrame &#123;\n    public TestTextDemo02() throws HeadlessException &#123;\n        Container container = this.getContentPane();\n\n        JPasswordField passwordField = new JPasswordField();    //密码框***\n        //passwordField.setEchoChar(&#39;*&#39;);                         //密码框显示符号\n\n        container.add(passwordField);\n\n\n        this.setVisible(true);\n        this.setSize(500,300);\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        new TestTextDemo02();\n    &#125;\n&#125;\n\n文本域 TextArea\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class JScrollDemo extends JFrame &#123;\n    public JScrollDemo() &#123;\n        Container container = this.getContentPane();\n        //文本域\n        JTextArea textArea = new JTextArea(20, 50);\n        textArea.setText(&quot;文本域 TextArea&quot;);\n        //Scroll 面板\n        JScrollPane scrollPane = new JScrollPane(textArea);\n        container.add(scrollPane);\n\n\n        this.setBounds(100,100,300,350);\n        this.setVisible(true);\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        new JScrollDemo();\n    &#125;\n&#125;\n\n\n4、常用类Frame;\t\t\t\t\t\t\t\t\t\t\t框架\nPanel;\t\t\t\t\t\t\t\t\t\t\t面板\nsetVisible;\t\t\t\t\t\t\t\t\t    可见性true\nsetSize(x,x);\t\t\t\t\t\t\t\t\t初始尺寸\nsetLocation(x,x);\t\t\t\t\t\t\t\t初始位置，x,y\nsetBounds(x,x,x,x);\t\t\t\t\t\t\t\t初始坐标+尺寸\nsetBackground（new color(x,x,x)）;   \t\t    颜色，三基色\nsetResizable;\t\t\t\t\t\t\t\t    大小是否可调，true,false\nsetLayout(new FlowLayout(FlowLayout.LEFT));\t\t流式布局\nframe.add(east,BorderLayout.EAST);\t\t\t\t方向布局\nframe.setLayout(new GridLayout(3,2));\t\t\t表格布局\nActionListener;\t\t\t\t\t\t\t\t\t监听器\nTextField;\t\t\t\t\t\t\t\t\t\t文本框\nTextArea;\t\t\t\t\t\t\t\t\t\t文本域\nPasswordField;\t\t\t\t\t\t\t\t\t密码框\nInteger.parseInt();\t\t\t\t\t\t\t\tString类转int类\npaint;\t\t\t\t\t\t\t\t\t\t\t画笔\nMouseAdapter;\t\t\t\t\t\t\t\t\t鼠标监听器\nWindowListener;\t\t\t\t\t\t\t\t\t窗口监听\nKeyListener;\t\t\t\t\t\t\t\t\t键盘监听\nDefaultCloseOperation(WindowConstants.);\t\t关闭事件(JFrame)\nContentPane;\t\t\t\t\t\t\t\t\t容器(JFrame)\nLayout;\t\t\t\t\t\t\t\t\t\t\t容器自动定位(JFrame)\nButton;\t\t\t\t\t\t\t\t\t\t\t按钮\nRadioButton;\t\t\t\t\t\t\t\t\t单选按钮\nButtonGroup;\t\t\t\t\t\t\t\t\t组\nCheckBox;\t\t\t\t\t\t\t\t\t\t多选按钮\nComboBox;\t\t\t\t\t\t\t\t\t\t下拉框\nList;\t\t\t\t\t\t\t\t\t\t\t列表框\nDialog;\t\t\t\t\t\t\t\t\t\t\t对话框\nLabel;\t\t\t\t\t\t\t\t\t\t\t标签\nIconDemo;\t\t\t\t\t\t\t\t\t\t图标\nImageIcon;\t\t\t\t\t\t\t\t\t\t图片\nScroll;\t\t\t\t\t\t\t\t\t\t\t滚动条\nTimer;\t\t\t\t\t\t\t\t\t\t\t定时器\n\n\n(部分内容参考【狂神说Java】GUI编程入门到游戏实战)\n","slug":"Java图形化基础 -- GUI编程","date":"2022-04-23T03:10:12.000Z","categories_index":"后端","tags_index":"Java","author_index":"会思想的苇草i"},{"id":"95d5eb05aae54932675ce4d24d2c2637","title":"Java程序设计--XML、设计模式","content":"\n1、XML1.1 XML概述&#x3D;&#x3D;XML是可扩展标记语言（eXtensible Markup Language)的缩写，它是是一种数据表示格式，可以描述非常复杂的数据结构，常用于传输和存储数据。&#x3D;&#x3D;\nXML的几个特点和使用场景\n\n一是纯文本，默认使用UTF-8编码;二是可嵌套\n如果把XML内容存为文件，那么它就是一个XML文件\nXML的使用场景:XML内容经常被当成消息进行网络传输，或者作为配置文件用于存储系统的信息\n\n1.2 XML的创建、语法规则XML的创建就是创建一个XML类型的文件，要求文件的后缀必须使用xml，如hello_world.xml\nXML语法规则\n\nXML文件的后缀名为: xml\n文档声明必须是第一行XML的标签(元素)规则\n标签由一对尖括号和合法标识符组成:&lt; name &gt;&lt; &#x2F;name &gt;，必须存在一个根标签，有且只能有一个。\n标签必须成对出现，有开始，有结束: &lt; name &gt;&lt; &#x2F;name &gt;\n特殊的标签可以不成对，但是必须有结束标记，如:&lt; br&#x2F;&gt;\n标签中可以定义属性，属性和标签名空格隔开,属性值必须用引号引起来&lt; student id &#x3D; “1” &gt;&lt; &#x2F;name &gt;\n标签需要正确的嵌套\n\nXML的其他组成\n\nXML文件中可以定义注释信息:&lt;！- -注释内容 - -&gt;\nXML文件中可以存在以下特殊字符\nXML文件中可以存在CDATA区:&lt;! [CDATA[ ..内容…]] &gt;\n\n1.3 XML文档约束文档约束:是用来限定xml文件中的标签以及属性应该怎么写。\nDTD约束\n\n编写DTD约束文档，后缀必须是.dtd\n\n在需要编写的XML文件中导入该DTD约束文档\n\n按照约束的规定编写XML文件的内容\n\n\n(&#x3D;&#x3D;不能约束具体的数据类型&#x3D;&#x3D;)\nschema\n\n&#x3D;&#x3D;schema可以约束具体的数据类型，约束能力上更强大&#x3D;&#x3D;。\nschema本身也是一个xml文件，本身也受到其他约束文件的要求，所以编写的更加严谨\n\n\n\n2、XML解析技术2.1 XML解析技术概述XML解析就是使用程序读取XML中的数据\n两种解析方式\n\nSAX解析\nDOM解析\n\nDom常见的解析工具\n\n\n\n名称\n说明\n\n\n\nJAXP\nSUN公司提供的一套XML的解析的API\n\n\nJDOM\nJDOM是一个开源项目，它基于树型结构，利用纯JAVA的技术对XML文档实现解析、生成、序列化以及多种操作。\n\n\ndom4j\n是JDOM的升级品，用来读写XML文件的。具有性能优异、功能强大和极其易使用的特点，它的性能超过sun公司官方的dom技术，同时它也是一个开放源代码的软件，Hibernate也用它来读写配置文件。\n\n\njsoup\n功能强大DOM方式的XML解析开发包，尤其对HTML解析更加方便\n\n\n\n2.2 Dom4J解析XML文件使用Dom4J把一个XML文件的数据进行解析\n\n下载Dom4j框架，官网下载\n在项目中创建一个文件夹:lib\n将dom4j-2.1.1.jar文件复制到lib文件夹\n在jar文件上点右键，选择Add as Library -&gt;点击OK\n在类中导包使用\n\nimport org.dom4j.Attribute;\nimport org.dom4j.Document;\nimport org.dom4j.DocumentException;\nimport org.dom4j.Element;\nimport org.dom4j.io.SAXReader;\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.util.List;\n\n/**\n   目标：学会使用dom4j解析XML文件中的数据。\n    1、导入dom4j框架。\n    2、准备一个XML文件。\n */\npublic class Dom4JHelloWorldDemo1 &#123;\n    @Test\n    public void parseXMLData() throws Exception &#123;\n        // 1、创建一个Dom4j的解析器对象，代表了整个dom4j框架\n        SAXReader saxReader = new SAXReader();\n\n        // 2、把XML文件加载到内存中成为一个Document文档对象\n        // Document document = saxReader.read(new File(&quot;xml-app\\\\src\\\\Contacts.xml&quot;)); // 需要通过模块名去定位\n        // Document document = saxReader.read(new FileInputStream(&quot;xml-app\\\\src\\\\Contacts.xml&quot;));\n\n        // 注意: getResourceAsStream中的/是直接去src下寻找的文件\n        InputStream is = Dom4JHelloWorldDemo1.class.getResourceAsStream(&quot;/Contacts.xml&quot;);\n        Document document = saxReader.read(is);\n\n        // 3、获取根元素对象\n        Element root = document.getRootElement();\n        System.out.println(root.getName());\n\n        // 4、拿根元素下的全部子元素对象(一级)\n        // List&lt;Element&gt; sonEles =  root.elements();\n        List&lt;Element&gt; sonEles =  root.elements(&quot;contact&quot;);\n        for (Element sonEle : sonEles) &#123;\n            System.out.println(sonEle.getName());\n        &#125;\n\n        // 拿某个子元素\n        Element userEle = root.element(&quot;user&quot;);\n        System.out.println(userEle.getName());\n\n        // 默认提取第一个子元素对象 (Java语言。)\n        Element contact = root.element(&quot;contact&quot;);\n        // 获取子元素文本\n        System.out.println(contact.elementText(&quot;name&quot;));\n        // 去掉前后空格\n        System.out.println(contact.elementTextTrim(&quot;name&quot;));\n        // 获取当前元素下的子元素对象\n        Element email = contact.element(&quot;email&quot;);\n        System.out.println(email.getText());\n        // 去掉前后空格\n        System.out.println(email.getTextTrim());\n\n        // 根据元素获取属性值\n        Attribute idAttr = contact.attribute(&quot;id&quot;);\n        System.out.println(idAttr.getName() + &quot;--&gt;&quot; + idAttr.getValue());\n        // 直接提取属性值\n        System.out.println(contact.attributeValue(&quot;id&quot;));\n        System.out.println(contact.attributeValue(&quot;vip&quot;));\n    &#125;\n&#125;\n\nDom4j解析XML-得到Document对象,从中获取元素对象和内容。\nSAXReader类\n\n\n\n构造器&#x2F;方法\n说明\n\n\n\npublic SAXReader()\n创建Dom4J的解析器对象\n\n\nDocument read(String url)\n加载XML文件成为Document对象\n\n\nDocument类\n\n\n\n方法名\n说明\n\n\n\nElement getRootElement()\n获得根元素对象\n\n\nDom4j解析XML的元素、属性、文本\n\n\n\n方法名\n说明\n\n\n\nList&lt; Element &gt; elements()\n得到当前元素下所有子元素\n\n\nList&lt; Element &gt; elements(String name)\n得到当前元素下指定名字的子元素返回集合\n\n\nElement element(String name)\n得到当前元素下指定名字的子元素,如果有很多名字相同的返回第一个\n\n\nString getName()\n得到元素名字\n\n\nString attributeValue(String name)\n通过属性名直接得到属性值\n\n\nString elementText(子元素名)\n得到指定名称的子元素的文本\n\n\nString getText()\n得到文本\n\n\n\n3、XML检索技术XPath介绍\n\nXPath在解析XML文档方面提供了一独树一帜的路径思想，更加优雅，高效\nXPath使用路径表达式来定位XML文档中的元素节点或属性节点。\n\n使用Xpath检索出XML文件\n\n导入jar包(dom4j和jaxen-1.1.2.jar)，Xpath技术依赖Dom4j技术\n通过dom4j的SAXReader获取Document对象\n利用XPath提供的API,结合XPath的语法完成选取XML文档元素节点进行解析操作。\nDocument中与Xpath相关的API如下:\n\n\n\n\n方法名\n说明\n\n\n\nNode selectSingleNode\n(“表达式”)获取符合表达式的唯一元素\n\n\nList&lt; Node &gt; selectNodes\n(“表达式”)获取符合表达式的元素集合\n\n\nXPath:绝对路径\n采用绝对路径获取从根节点开始逐层的查找&#x2F;contactList&#x2F;contact&#x2F;name节点列表并打印信息\n\n\n\n方法名\n说明\n\n\n\n&#x2F;根元素&#x2F;子元素&#x2F;孙元素\n从根元素开始，一级一级向下查找，不能跨级\n\n\nXPath:相对路径\n先得到根节点contactList,再采用相对路径获取下一级contact节点的name子节点并打印信息\n\n\n\n方法名\n说明\n\n\n\n.&#x2F;子元素&#x2F;孙元素\n从当前元素开始，一级一级向下查找，不能跨级\n\n\nXPath:全文搜索\n·直接全文搜索所有的name元素并打印\n\n\n\n方法名\n说明\n\n\n\n&#x2F;&#x2F;contact\n找contact元素，无论元素在哪里\n\n\n&#x2F;&#x2F;contact&#x2F;name\n找contact，无论在哪一级，但name一定是contact的子节点\n\n\n&#x2F;&#x2F;contact&#x2F;&#x2F;name\ncontact无论在哪一种，name只要是contact的子孙元素都可以找到\n\n\nXPath:属性查找\n在全文中搜索属性，或者带属性的元素\n\n\n\n方法名\n说明\n\n\n\n&#x2F;&#x2F;@属性名\n查找属性对象，无论是哪个元素，只要有这个属性即可。\n\n\n&#x2F;&#x2F;元素[@属性名]\n查找元素对象，全文搜索指定元素名和属性名。\n\n\n&#x2F;&#x2F;元素&#x2F;&#x2F;@属性名&#x3D;‘值’]\n查找元素对象，全文搜索指定元素名和属性名，并且属性值相等。\n\n\nimport org.dom4j.Attribute;\nimport org.dom4j.Document;\nimport org.dom4j.Element;\nimport org.dom4j.Node;\nimport org.dom4j.io.SAXReader;\nimport org.junit.Test;\n\nimport java.util.List;\n\npublic class XPathDemo &#123;\n    /**\n     1.绝对路径: /根元素/子元素/子元素。\n     */\n    @Test\n    public void parse01() throws Exception &#123;\n        // a、创建解析器对象\n        SAXReader saxReader = new SAXReader();\n        // b、把XML加载成Document文档对象\n        Document document =\n                saxReader.read(XPathDemo.class.getResourceAsStream(&quot;/Contacts2.xml&quot;));\n        // c、检索全部的名称\n        List&lt;Node&gt; nameNodes = document.selectNodes(&quot;/contactList/contact/name&quot;);\n        for (Node nameNode : nameNodes) &#123;\n            Element  nameEle = (Element) nameNode;\n            System.out.println(nameEle.getTextTrim());\n        &#125;\n    &#125;\n\n    /**\n     2.相对路径： ./子元素/子元素。 (.代表了当前元素)\n     */\n    @Test\n    public void parse02() throws Exception &#123;\n        // a、创建解析器对象\n        SAXReader saxReader = new SAXReader();\n        // b、把XML加载成Document文档对象\n        Document document =\n                saxReader.read(XPathDemo.class.getResourceAsStream(&quot;/Contacts2.xml&quot;));\n        Element root = document.getRootElement();\n        // c、检索全部的名称\n        List&lt;Node&gt; nameNodes = root.selectNodes(&quot;./contact/name&quot;);\n        for (Node nameNode : nameNodes) &#123;\n            Element  nameEle = (Element) nameNode;\n            System.out.println(nameEle.getTextTrim());\n        &#125;\n    &#125;\n\n    /**\n     3.全文搜索：\n     //元素  在全文找这个元素\n     //元素1/元素2  在全文找元素1下面的一级元素2\n     //元素1//元素2  在全文找元素1下面的全部元素2\n     */\n    @Test\n    public void parse03() throws Exception &#123;\n        // a、创建解析器对象\n        SAXReader saxReader = new SAXReader();\n        // b、把XML加载成Document文档对象\n        Document document =\n                saxReader.read(XPathDemo.class.getResourceAsStream(&quot;/Contacts2.xml&quot;));\n        // c、检索数据\n        //List&lt;Node&gt; nameNodes = document.selectNodes(&quot;//name&quot;);\n        // List&lt;Node&gt; nameNodes = document.selectNodes(&quot;//contact/name&quot;);\n        List&lt;Node&gt; nameNodes = document.selectNodes(&quot;//contact//name&quot;);\n        for (Node nameNode : nameNodes) &#123;\n            Element  nameEle = (Element) nameNode;\n            System.out.println(nameEle.getTextTrim());\n        &#125;\n    &#125;\n\n    /**\n     4.属性查找。\n     //@属性名称  在全文检索属性对象。\n     //元素[@属性名称]  在全文检索包含该属性的元素对象。\n     //元素[@属性名称=值]  在全文检索包含该属性的元素且属性值为该值的元素对象。\n     */\n    @Test\n    public void parse04() throws Exception &#123;\n        // a、创建解析器对象\n        SAXReader saxReader = new SAXReader();\n        // b、把XML加载成Document文档对象\n        Document document =\n                saxReader.read(XPathDemo.class.getResourceAsStream(&quot;/Contacts2.xml&quot;));\n        // c、检索数据\n        List&lt;Node&gt; nodes = document.selectNodes(&quot;//@id&quot;);\n        for (Node node : nodes) &#123;\n            Attribute attr = (Attribute) node;\n            System.out.println(attr.getName() + &quot;===&gt;&quot; + attr.getValue());\n        &#125;\n\n        // 查询name元素（包含id属性的）\n//      Node node = document.selectSingleNode(&quot;//name[@id]&quot;);\n        Node node = document.selectSingleNode(&quot;//name[@id=888]&quot;);\n        Element ele = (Element) node;\n        System.out.println(ele.getTextTrim());\n    &#125;\n&#125;\n\n\n4、设计模式4.1 工厂模式&#x3D;&#x3D;工厂模式(Factory Pattern)是Java 中最常用的设计模式之一，这种类型的设计模式属于创建型模式，它提供了一种获取对象的方式。&#x3D;&#x3D;\n工厂设计模式的作用:\n\n工厂的方法可以封装对象的创建细节，比如:为该对象进行加工和数据注入。\n可以实现类与类之间的解耦操作（核心思想)。\n\npublic abstract class Computer &#123;\n    private String name;\n    private double price;\n\n    public abstract void start();\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public double getPrice() &#123;\n        return price;\n    &#125;\n\n    public void setPrice(double price) &#123;\n        this.price = price;\n    &#125;\n&#125;\n\n\npublic class Huawei extends Computer&#123;\n    @Override\n    public void start() &#123;\n        System.out.println(getName() + &quot;开机了，展示了华为的菊花图标~~~~&quot;);\n    &#125;\n&#125;\n\npublic class Mac extends Computer&#123;\n    @Override\n    public void start() &#123;\n        System.out.println(getName() + &quot;以非常优雅的方法启动了，展示了一个苹果logo&quot;);\n    &#125;\n&#125;\n\npublic class FactoryPattern &#123;\n    /**\n       定义一个方法，创建对象返回\n     */\n    public static Computer createComputer(String info)&#123;\n        switch (info)&#123;\n            case &quot;huawei&quot;:\n                Computer c = new Huawei();\n                c.setName(&quot;huawei pro 16&quot;);\n                c.setPrice(5999);\n                return c;\n            case &quot;mac&quot;:\n                Computer c2 = new Mac();\n                c2.setName(&quot;MacBook pro&quot;);\n                c2.setPrice(11999);\n                return c2;\n            default:\n                return null;\n        &#125;\n    &#125;\n&#125;\n\npublic class FactoryDemo &#123;\n    public static void main(String[] args) &#123;\n        Computer c1 = FactoryPattern.createComputer(&quot;huawei&quot;);\n        c1.start();\n\n        Computer c2 = FactoryPattern.createComputer(&quot;mac&quot;);\n        c2.start();\n    &#125;\n&#125;\n\n4.2 装饰模式&#x3D;&#x3D;装饰设计模式是创建一个新类，包装原始类，从而在新类中提升原来类的功能。&#x3D;&#x3D;\n装饰设计模式的作用:\n作用:装饰模式指的是在不改变原类的基础上，动态地扩展─个类的功能。\n\n定义父类\n定义原始类，继承父类，定义功能。\n定义装饰类，继承父类，包装原始类，增强功能!!\n\n/**\n   共同父类\n */\npublic abstract class InputStream &#123;\n    public abstract int read();\n    public abstract int read(byte[] buffer);\n&#125;\n\nimport java.util.Arrays;\n\n/**\n   原始类\n */\npublic class FileInputStream extends InputStream&#123;\n    @Override\n    public int read() &#123;\n        System.out.println(&quot;低性能的方式读取了一个字节a&quot;);\n        return 97;\n    &#125;\n\n    @Override\n    public int read(byte[] buffer) &#123;\n        buffer[0] = 97;\n        buffer[1] = 98;\n        buffer[2] = 99;\n        System.out.println(&quot;低性能的方式读取了一个字节数组：&quot; + Arrays.toString(buffer));\n        return 3;\n    &#125;\n&#125;\n\n/**\n   装饰类：继承InputStream 拓展原始类的功能\n */\npublic class BufferedInputStream extends InputStream&#123;\n    private InputStream is;\n    public BufferedInputStream(InputStream is)&#123;\n        this.is = is;\n    &#125;\n    @Override\n    public int read() &#123;\n        System.out.println(&quot;提供8KB的缓冲区，提高读数据性能~~~~&quot;);\n        return is.read();\n    &#125;\n\n    @Override\n    public int read(byte[] buffer) &#123;\n        System.out.println(&quot;提供8KB的缓冲区，提高读数据性能~~~~&quot;);\n        return is.read(buffer);\n    &#125;\n&#125;\n\n/**\n  装饰模式\n\n    定义父类：InputStream\n    定义实现类：FileInputStream 继续父类 定义功能\n    定义装饰实现类：BufferedInputStream 继承父类 定义功能 包装原始类，增强功能。\n */\npublic class DecoratorPattern &#123;\n    public static void main(String[] args) &#123;\n        InputStream is = new BufferedInputStream(new FileInputStream());\n        System.out.println(is.read());\n        System.out.println(is.read(new byte[3]));\n    &#125;\n&#125;\n\n\n\n","slug":"Java程序设计 -- XML、设计模式（二十一）","date":"2022-04-19T12:38:36.000Z","categories_index":"后端","tags_index":"Java","author_index":"会思想的苇草i"},{"id":"bec3c05a6e5145a0f9bf9077827e54de","title":"Java程序设计--Java高级技术","content":"\n1、单元测试1.1 单元测试概述单元测试就是针对最小的功能单元编写测试代码，Java程序最小的功能单元是方法，因此，单元测试就是针对Java方法的测试，进而检查方法的正确性。\n目前测试方法\n\n只有一个main方法，如果一个方法的测试失败了，其他方法测试会受到影响。\n无法得到测试的结果报告，需要程序员自己去观察测试是否成功。\n无法实现自动化测试。\n\nJunit单元测试框架\n\nJUnit是使用Java语言实现的单元测试框架，它是开源的，Java开发者都应当学习并使用JUnit编写单元测试。\n此外，几乎所有的IDE工具都集成了JUnit，这样我们就可以直接在IDE中编写并运行JUnit测试，JUnit目前最新版本是5。\n\nJUnit优点\n\n&#x3D;&#x3D;JUnit可以灵活的选择执行哪些测试方法，可以一键执行全部测试方法。&#x3D;&#x3D;\n&#x3D;&#x3D;Junit可以生成全部方法的测试报告，测试良好则是绿色，测试失败则是红色。&#x3D;&#x3D;\n&#x3D;&#x3D;单元测试中的某个方法测试失败了，不会影响其他测试方法的测试。&#x3D;&#x3D;\n\n1.2 单元测试快速入门需求:使用单元测试进行业务方法预期结果、正确性测试的快速入门\n分析:\n\n将JUnit的jar包导入到项目中- IDEA通常整合好了Junit框架，一般不需要导入。- 如果IDEA没有整合好，需要自己手工导入如下2个JUnit的jar包到模块- \n\n编写测试方法:该测试方法必须是公共的无参数无返回值的非静态方法。\n\n在测试方法上使用@Test注解:标注该方法是一个测试方法\n\n在测试方法中完成被测试方法的预期正确性测试。\n\n选中测试方法，选择“JUnit运行”，如果测试良好则是绿色;如果测试失败，则是红色\n\n\n1.3 单元测试常用注解Junit常用注解(Junit 5.xxxx版本)\n\n\n\n注解\n说明\n\n\n\n@Test\n测试方法\n\n\n@BeforeEach\n用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。\n\n\n@AfterEach\n用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。\n\n\n@BeforeAll\n用来静态修饰方法，该方法会在所有测试方法之前只执行一次。\n\n\n@AfterAll\n用来静态修饰方法，该方法会在所有测试方法之后只执行一次。\n\n\n\n开始执行的方法:初始化资源。\n执行完之后的方法:释放资源。\n\n/**\n   业务方法\n */\npublic class UserService &#123;\n    public String loginName(String loginName , String passWord)&#123;\n        if(&quot;admin&quot;.equals(loginName) &amp;&amp; &quot;123456&quot;.equals(passWord))&#123;\n            return &quot;登录成功&quot;;\n        &#125;else &#123;\n            return &quot;用户名或者密码有问题&quot;;\n        &#125;\n    &#125;\n\n    public void selectNames()&#123;\n        System.out.println(10/2);\n        System.out.println(&quot;查询全部用户名称成功~~&quot;);\n    &#125;\n&#125;\n\nimport org.junit.*;\n\n/**\n   测试类\n */\npublic class TestUserService &#123;\n\n    // 修饰实例方法的\n    @Before\n    public void before()&#123;\n        System.out.println(&quot;===before方法执行一次===&quot;);\n    &#125;\n\n    @After\n    public void after()&#123;\n        System.out.println(&quot;===after方法执行一次===&quot;);\n    &#125;\n\n    // 修饰静态方法\n    @BeforeClass\n    public static void beforeClass()&#123;\n        System.out.println(&quot;===beforeClass方法执行一次===&quot;);\n    &#125;\n\n    @AfterClass\n    public static void afterClass()&#123;\n        System.out.println(&quot;===afterClass方法执行一次===&quot;);\n    &#125;\n\n\n    /**\n       测试方法\n       注意点：\n            1、必须是公开的，无参数 无返回值的方法\n            2、测试方法必须使用@Test注解标记。\n     */\n    @Test\n    public void testLoginName()&#123;\n        UserService userService = new UserService();\n        String rs = userService.loginName(&quot;admin&quot;,&quot;123456&quot;);\n\n        // 进行预期结果的正确性测试：断言。\n        Assert.assertEquals(&quot;您的登录业务可能出现问题&quot;, &quot;登录成功&quot;, rs );\n    &#125;\n\n    @Test\n    public void testSelectNames()&#123;\n        UserService userService = new UserService();\n        userService.selectNames();\n    &#125;\n\n&#125;\n\n\n2、反射2.1 反射概述\n&#x3D;&#x3D;反射是指对于任何一个Class类，在”运行的时候”都可以直接得到这个类全部成分。&#x3D;&#x3D;\n在运行时,可以直接得到这个类的构造器对象:Constructor\n在运行时,可以直接得到这个类的成员变量对象:Field\n在运行时,可以直接得到这个类的成员方法对象:Method\n这种运行时动态获取类信息以及动态调用类中成分的能力称为Java语言的反射机制。\n\n反射的关键:\n反射的第一步都是先得到编译后的Class类对象，然后就可以得到Class的全部成分。\n\n2.2 反射获取对象反射获取类对象\n\n\npublic class Student &#123;\n&#125;\n\n/**\n   反射的第一步：获取Class对象\n */\npublic class Test &#123;\n    public static void main(String[] args) throws Exception &#123;\n        // 1、Class类中的一个静态方法：forName(全限名：包名 + 类名)\n        Class c = Class.forName(&quot;com.itheima.d2_reflect_class.Student&quot;);\n        System.out.println(c); // Student.class\n\n        // 2、类名.class\n        Class c1 = Student.class;\n        System.out.println(c1);\n\n        // 3、对象.getClass() 获取对象对应类的Class对象。\n        Student s = new Student();\n        Class c2 = s.getClass();\n        System.out.println(c2);\n    &#125;\n&#125;\n\n反射获取构造器对象\n使用反射技术获取构造器对象并使用\n\n反射的第一步是先得到类对象，然后从类对象中获取类的成分对象。\nClass类中用于获取构造器的方法\n\n\n\n\n方法\n说明\n\n\n\nConstructor&lt;?&gt;[] getConstructors()\n返回所有构造器对象的数组(只能拿public的)\n\n\nConstructor&lt;?&gt;[ ] getDeclaredConstructors()\n返回所有构造器对象的数组，存在就能拿到\n\n\nConstructor&lt; T &gt; getConstructor(class&lt;?&gt;… parameterTypes)\n返回单个构造器对象(只能拿public的)\n\n\nConstructor&lt; T &gt; getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)\n返回单个构造器对象，存在就能拿到\n\n\nConstructor类中用于创建对象的方法\n\n\n\n符号\n说明\n\n\n\nT newInstance(Object.. initargs)\n根据指定的构造器创建对象\n\n\npublic void setAccessible(boolean flag)\n设置为true,表示取消访问检查，进行暴力反射\n\n\n如果是非public的构造器，需要打开权限（暴力反射)，然后再创建对象，setAccessible(boolean)，反射可以破坏封装性，私有的也可以执行了。\npublic class Student &#123;\n    private String name;\n    private int age;\n\n    private Student()&#123;\n        System.out.println(&quot;无参数构造器执行！&quot;);\n    &#125;\n\n    public Student(String name, int age) &#123;\n        System.out.println(&quot;有参数构造器执行！&quot;);\n        this.name = name;\n        this.age = age;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Student&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, age=&quot; + age +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n\nimport org.junit.Test;\n\nimport java.lang.reflect.Constructor;\n\npublic class TestStudent01 &#123;\n    // 1. getConstructors:\n    // 获取全部的构造器：只能获取public修饰的构造器。\n    // Constructor[] getConstructors()\n    @Test\n    public void getConstructors()&#123;\n        // a.第一步：获取类对象\n        Class c = Student.class;\n        // b.提取类中的全部的构造器对象(这里只能拿public修饰)\n        Constructor[] constructors = c.getConstructors();\n        // c.遍历构造器\n        for (Constructor constructor : constructors) &#123;\n            System.out.println(constructor.getName() + &quot;===&gt;&quot; + constructor.getParameterCount());\n        &#125;\n    &#125;\n\n\n    // 2.getDeclaredConstructors():\n    // 获取全部的构造器：只要你敢写，这里就能拿到，无所谓权限是否可及。\n    @Test\n    public void getDeclaredConstructors()&#123;\n        // a.第一步：获取类对象\n        Class c = Student.class;\n        // b.提取类中的全部的构造器对象\n        Constructor[] constructors = c.getDeclaredConstructors();\n        // c.遍历构造器\n        for (Constructor constructor : constructors) &#123;\n            System.out.println(constructor.getName() + &quot;===&gt;&quot; + constructor.getParameterCount());\n        &#125;\n    &#125;\n\n    // 3.getConstructor(Class... parameterTypes)\n    // 获取某个构造器：只能拿public修饰的某个构造器\n    @Test\n    public void getConstructor() throws Exception &#123;\n        // a.第一步：获取类对象\n        Class c = Student.class;\n        // b.定位单个构造器对象 (按照参数定位无参数构造器 只能拿public修饰的某个构造器)\n        Constructor cons = c.getConstructor();\n        System.out.println(cons.getName() + &quot;===&gt;&quot; + cons.getParameterCount());\n    &#125;\n\n\n    // 4.getConstructor(Class... parameterTypes)\n    // 获取某个构造器：只要你敢写，这里就能拿到，无所谓权限是否可及。\n    @Test\n    public void getDeclaredConstructor() throws Exception &#123;\n        // a.第一步：获取类对象\n        Class c = Student.class;\n        // b.定位单个构造器对象 (按照参数定位无参数构造器)\n        Constructor cons = c.getDeclaredConstructor();\n        System.out.println(cons.getName() + &quot;===&gt;&quot; + cons.getParameterCount());\n\n        // c.定位某个有参构造器\n        Constructor cons1 = c.getDeclaredConstructor(String.class, int.class);\n        System.out.println(cons1.getName() + &quot;===&gt;&quot; + cons1.getParameterCount());\n\n    &#125;\n\n&#125;\n\n反射获取成员变量对象使用反射技术获取成员变量对象并使用\n\n反射的第一步是先得到类对象，然后从类对象中获取类的成分对象。\nClass类中用于获取成员变量的方法。\n\n\n\n\n方法\n说明\n\n\n\nField [ ] getFields()\n返回所有成员变量对象的数组(只能拿public的)\n\n\nField[ ] getDeclaredFields()\n返回所有成员变量对象的数组，存在就能拿到\n\n\nField getField(String name)\n返回单个成员变量对象(只能拿public的)\n\n\nField getDeclaredField(String name)\n返回单个成员变量对象，存在就能拿到\n\n\n获取成员变量的作用依然是在某个对象中取值、赋值\nField类中用于取值、赋值的方法\n\n\n\n符号\n说明\n\n\n\nvoid set(Object obj, Object value):\n赋值\n\n\nObject get(Object obj)\n获取值\n\n\npublic class Student &#123;\n    private String name;\n    private int age;\n    public static String schoolName;\n    public static final String  COUNTTRY = &quot;中国&quot;;\n\n    public Student()&#123;\n        System.out.println(&quot;无参数构造器执行！&quot;);\n    &#125;\n\n    public Student(String name, int age) &#123;\n        System.out.println(&quot;有参数构造器执行！&quot;);\n        this.name = name;\n        this.age = age;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Student&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, age=&quot; + age +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.lang.reflect.Field;\n\npublic class FieldDemo01 &#123;\n    /**\n     * 1.获取全部的成员变量。\n     * Field[] getDeclaredFields();\n     *  获得所有的成员变量对应的Field对象，只要申明了就可以得到\n     */\n    @Test\n    public void getDeclaredFields()&#123;\n        // a.定位Class对象\n        Class c = Student.class;\n        // b.定位全部成员变量\n        Field[] fields = c.getDeclaredFields();\n        // c.遍历一下\n        for (Field field : fields) &#123;\n            System.out.println(field.getName() + &quot;==&gt;&quot; + field.getType());\n        &#125;\n    &#125;\n\n    /**\n        2.获取某个成员变量对象 Field getDeclaredField(String name);\n     */\n    @Test\n    public void getDeclaredField() throws Exception &#123;\n        // a.定位Class对象\n        Class c = Student.class;\n        // b.根据名称定位某个成员变量\n        Field f = c.getDeclaredField(&quot;age&quot;);\n        System.out.println(f.getName() +&quot;===&gt;&quot; + f.getType());\n    &#125;\n\n&#125;\n\n\n反射获取对象方法使用反射技术获取方法对象并使用\n\n反射的第一步是先得到类对象，然后从类对象中获取类的成分对象。\nClass类中用于获取成员方法的方法\n\n\n\n\n方法\n说明\n\n\n\nMethod[ ] getMethods()\n返回所有成员方法对象的数组(只能拿public的)\n\n\nMethod[ ] getDeclaredMethods()\n返回所有成员方法对象的数组，存在就能拿到\n\n\nMethod getMethod(String name，Class&lt;?&gt;… parameterTypes)\n返回单个成员方法对象(只能拿public的)\n\n\nMethod getDeclaredNethod(String name，Class&lt;?&gt;… parameterTypes)\n返回单个成员方法对象，存在就能拿到\n\n\n获取成员方法的作用依然是在某个对象中进行执行此方法Method类中用于触发执行的方法\n\n\n\n符号\n说明\n\n\n\nobject invoke(0bject obj，object. . . args)\n运行方法\\参数一:用obj对象调用该方法\\参数二:调用方法的传递的参数(如果没有就不写)返回值:方法的返回值(如果没有就不写)\n\n\npublic class Dog &#123;\n    private String name ;\n    public Dog()&#123;\n    &#125;\n\n    public Dog(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public void run()&#123;\n        System.out.println(&quot;狗跑的贼快~~&quot;);\n    &#125;\n\n    private void eat()&#123;\n        System.out.println(&quot;狗吃骨头&quot;);\n    &#125;\n\n    private String eat(String name)&#123;\n        System.out.println(&quot;狗吃&quot; + name);\n        return &quot;吃的很开心！&quot;;\n    &#125;\n\n    public static void inAddr()&#123;\n        System.out.println(&quot;在学习Java!&quot;);\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n&#125;\n\nimport org.junit.Test;\n\nimport java.lang.reflect.Method;\n\npublic class MethodDemo01 &#123;\n    /**\n     * 1.获得类中的所有成员方法对象\n     */\n    @Test\n    public void getDeclaredMethods()&#123;\n        // a.获取类对象\n        Class c = Dog.class;\n        // b.提取全部方法；包括私有的\n        Method[] methods = c.getDeclaredMethods();\n        // c.遍历全部方法\n        for (Method method : methods) &#123;\n            System.out.println(method.getName() +&quot; 返回值类型：&quot; + method.getReturnType() + &quot; 参数个数：&quot; + method.getParameterCount());\n        &#125;\n    &#125;\n\n    /**\n     * 2. 获取某个方法对象\n     */\n    @Test\n    public void getDeclardMethod() throws Exception &#123;\n        // a.获取类对象\n        Class c = Dog.class;\n        // b.提取单个方法对象\n        Method m = c.getDeclaredMethod(&quot;eat&quot;);\n        Method m2 = c.getDeclaredMethod(&quot;eat&quot;, String.class);\n\n        // 暴力打开权限了\n        m.setAccessible(true);\n        m2.setAccessible(true);\n\n        // c.触发方法的执行\n        Dog d = new Dog();\n        // 注意：方法如果是没有结果回来的，那么返回的是null.\n        Object result = m.invoke(d);\n        System.out.println(result);\n\n        Object result2 = m2.invoke(d, &quot;骨头&quot;);\n        System.out.println(result2);\n    &#125;\n&#125;\n\n2.3 反射的作用反射的作用-绕过编译阶段为集合添加数据\n反射是作用在运行时的技术，此时集合的泛型将不能产生约束了，此时是可以为集合存入其他任意类型的元素的。\nArrayList&lt; Integer &gt; list = new ArrayList&lt;&gt;();\nlist.add(100);\n// list.add(“黑马&quot;);//报错\nlist.add(99);\n\n&#x3D;&#x3D;泛型只是在编译阶段可以约束集合只能操作某种数据类型，在编译成Class文件进入运行阶段的时候，其真实类型都是ArrayList了，泛型相当于被擦除了。反射是作用在运行时的技术，此时已经不存在泛型了。&#x3D;&#x3D;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\n\npublic class ReflectDemo &#123;\n    public static void main(String[] args) throws Exception &#123;\n        // 需求：反射实现泛型擦除后，加入其他类型的元素\n        ArrayList&lt;String&gt; lists1 = new ArrayList&lt;&gt;();\n        ArrayList&lt;Integer&gt; lists2 = new ArrayList&lt;&gt;();\n\n        System.out.println(lists1.getClass());\n        System.out.println(lists2.getClass());\n\n        System.out.println(lists1.getClass() ==  lists2.getClass());  // ArrayList.class\n\n        System.out.println(&quot;---------------------------&quot;);\n        ArrayList&lt;Integer&gt; lists3 = new ArrayList&lt;&gt;();\n        lists3.add(23);\n        lists3.add(22);\n        // lists3.add(&quot;33&quot;);\n\n        Class c = lists3.getClass(); // ArrayList.class  ===&gt; public boolean add(E e)\n        // 定位c类中的add方法\n        Method add = c.getDeclaredMethod(&quot;add&quot;, Object.class);\n        boolean rs = (boolean) add.invoke(lists3, &quot;33&quot;);\n        System.out.println(rs);\n\n        System.out.println(lists3);\n\n        ArrayList list4 = lists3;\n        list4.add(&quot;44&quot;);\n        list4.add(false);\n        System.out.println(lists3);\n    &#125;\n&#125;\n\n反射做通用框架\n\n可以在运行时得到一个类的全部成分然后操作。\n可以破坏封装性。(很突出)\n也可以破坏泛型的约束性。(很突出)\n更重要的用途是适合:做Java高级框架。\n基本上主流框架都会基于反射设计一些通用技术功能。\n\n\n3、注解3.1 注解概述&#x3D;&#x3D;Java注解(Annotation）又称Java标注，是JDK5.0引入的一种注释机制。Java语言中的类、构造器、方法、成员变量、参数等都可以被注解进行标注。&#x3D;&#x3D;\n\n注解的作用：&#x3D;&#x3D;对Java中类、方法、成员变量做标记，然后进行特殊处理，至于到底做何种处理由业务需求来决定。&#x3D;&#x3D;例如:JUnit框架中，标记了注解@Test的方法就可以被当成测试方法执行，而没有标记的就不能当成测试方法执行。\n3.2  自定义注解&#x3D;&#x3D;自定义注解就是自己做一个注解来使用。&#x3D;&#x3D;\npublic @interface 注解名称&#123;\n    public 属性名称 属性名()default 默认值;\n&#125;\n\n特殊属性\n\nvalue属性，如果只有一个value属性的情况下，使用value属性的时候可以省略value名称不写!!\n但是如果有多个属性，且多个属性没有默认值，那么value名称是不能省略的。\n\n/**\n   学会自定义注解。掌握其定义格式和语法。\n */\n@MyBook(name=&quot;《精通JavaSE》&quot;,authors = &#123;&quot;佚名&quot;, &quot;dlei&quot;&#125; , price = 199.5)\n//@Book(value = &quot;/delete&quot;)\n// @Book(&quot;/delete&quot;)\n@Book(value = &quot;/delete&quot;, price = 23.5)\n//@Book(&quot;/delete&quot;)\npublic class AnnotationDemo1 &#123;\n\n    @MyBook(name=&quot;《精通JavaSE2》&quot;,authors = &#123;&quot;佚名&quot;, &quot;dlei&quot;&#125; , price = 199.5)\n    private AnnotationDemo1()&#123;\n\n    &#125;\n\n    @MyBook(name=&quot;《精通JavaSE1》&quot;,authors = &#123;&quot;佚名&quot;, &quot;dlei&quot;&#125; , price = 199.5)\n    public static void main(String[] args) &#123;\n        @MyBook(name=&quot;《精通JavaSE2》&quot;,authors = &#123;&quot;佚名&quot;, &quot;dlei&quot;&#125; , price = 199.5)\n        int age = 21;\n    &#125;\n&#125;\n\n3.3 元注解元注解&#x3D;&#x3D;元注解:就是注解注解的注解。&#x3D;&#x3D;\n元注解有两个:\n\n@Target:约束自定义注解只能在哪些地方使用\n@Retention:申明注解的生命周期\n\n@Target中可使用的值定义在ElementType枚举类中，常用值如下\n\nTYPE，类，接口\nFIELD,成员变量\nMETHOD,成员方法\nPARAMETER,方法参数\nCONSTRUCTOR,构造器\nLOCAL_VARIABLE，局部变量\n\n@Retention中可使用的值定义在RetentionPolicy枚举类中，常用值如下\n\nSOURCE:注解只作用在源码阶段，生成的字节码文件中不存在\nCLASS:注解作用在源码阶段，字节码文件阶段，运行阶段不存在，默认值\nRUNTIME:注解作用在源码阶段，字节码文件阶段，运行阶段(开发常用)\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(&#123;ElementType.METHOD,ElementType.FIELD&#125;) // 元注解\n@Retention(RetentionPolicy.RUNTIME) // 一直活着，在运行阶段这个注解也不消失\npublic @interface MyTest &#123;\n&#125;\n\n3.4 注解解析注解的解析\n&#x3D;&#x3D;注解的操作中经常需要进行解析，注解的解析就是判断是否存在注解，存在注解就解析出内容。&#x3D;&#x3D;\n与注解解析相关的接口\n\nAnnotation:注解的顶级接口，注解都是Annotation类型的对象\nAnnotatedElement:该接口定义了与注解解析相关的解析方法\n\n\n\n\n方法\n说明\n\n\n\nAnnotationl]getDeclaredAnnotations()\n获得当前对象上使用的所有注解，返回注解数组。\n\n\nT getDeclaredAnnotation(Class&lt; T &gt; annotationClass)\n根据注解类型获得对应注解对象\n\n\nboolean isAnnotationPresent(Class&lt; Annotation &gt; annotationClass)\n判断当前对象是否使用了指定的注解如果使用了则返回true，否则false\n\n\n所有的类成分Class, Method ,Field , Constructor，都实现了AnnotatedElement接口他们都拥有解析注解的能力\npublic @interface Book &#123;\n    String value(); // 特殊属性\n    double price() ;\n    //double price() default 9.9;\n&#125;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Bookk &#123;\n    String value();\n    double price() default 100;\n    String[] author();\n&#125;\n\nimport org.junit.Test;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\n\n/**\n   目标：完成注解的解析\n */\npublic class AnnotationDemo3 &#123;\n    @Test\n    public void parseClass()&#123;\n        // a.先得到类对象\n        Class c = BookStore.class;\n        // b.判断这个类上面是否存在这个注解\n        if(c.isAnnotationPresent(Bookk.class))&#123;\n            //c.直接获取该注解对象\n            Bookk book = (Bookk) c.getDeclaredAnnotation(Bookk.class);\n            System.out.println(book.value());\n            System.out.println(book.price());\n            System.out.println(Arrays.toString(book.author()));\n        &#125;\n    &#125;\n\n    @Test\n    public void parseMethod() throws NoSuchMethodException &#123;\n        // a.先得到类对象\n        Class c = BookStore.class;\n\n        Method m = c.getDeclaredMethod(&quot;test&quot;);\n\n        // b.判断这个类上面是否存在这个注解\n        if(m.isAnnotationPresent(Bookk.class))&#123;\n            //c.直接获取该注解对象\n            Bookk book = (Bookk) m.getDeclaredAnnotation(Bookk.class);\n            System.out.println(book.value());\n            System.out.println(book.price());\n            System.out.println(Arrays.toString(book.author()));\n        &#125;\n    &#125;\n&#125;\n\n@Bookk(value = &quot;《情深深雨濛濛》&quot;, price = 99.9, author = &#123;&quot;琼瑶&quot;, &quot;dlei&quot;&#125;)\nclass BookStore&#123;\n\n    @Bookk(value = &quot;《三少爷的剑》&quot;, price = 399.9, author = &#123;&quot;古龙&quot;, &quot;熊耀华&quot;&#125;)\n    public void test()&#123;\n    &#125;\n&#125;\n\n解析注解的技巧\n\n注解在哪个成分上，我们就先拿哪个成分对象。\n比如注解作用成员方法，则要获得该成员方法对应的Method对象，再来拿上面的注解\n比如注解作用在类上，则要该类的Class对象，再来拿上面的注解\n比如注解作用在成员变量上，则要获得该成员变量对应的Field对象，再来拿上面的注解\n\n\n4、动态代理模拟企业业务功能开发，并完成每个功能的性能统计\n需求\n模拟某企业用户管理业务，需包含用户登录，用户删除，用户查询功能，并要统计每个功能的耗时\n分析\n\n定义一个UserService表示用户业务接口，规定必须完成用户登录，用户删除，用户查询功能。\n定义一个实现类UserServicelmpl实现UserService，并完成相关功能，且统计每个功能的耗时。\n定义测试类，创建实现类对象，调用方法。\n\npublic class UserServiceImpl implements UserService&#123;\n    @Override\n    public String login(String loginName, String passWord)  &#123;\n        try &#123;\n            Thread.sleep(1000);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n        if(&quot;admin&quot;.equals(loginName) &amp;&amp; &quot;1234&quot;.equals(passWord)) &#123;\n            return &quot;success&quot;;\n        &#125;\n        return &quot;登录名和密码可能有毛病&quot;;\n\n    &#125;\n\n    @Override\n    public void selectUsers() &#123;\n        System.out.println(&quot;查询了100个用户数据！&quot;);\n        try &#123;\n            Thread.sleep(2000);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n    @Override\n    public boolean deleteUsers() &#123;\n        try &#123;\n            System.out.println(&quot;删除100个用户数据！&quot;);\n            Thread.sleep(500);\n            return true;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n            return false;\n        &#125;\n    &#125;\n\n    @Override\n    public void updateUsers() &#123;\n        try &#123;\n            System.out.println(&quot;修改100个用户数据！&quot;);\n            Thread.sleep(2500);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n/**\n   模拟用户业务功能\n */\npublic interface UserService &#123;\n    String login(String loginName , String passWord) ;\n    void selectUsers();\n    boolean deleteUsers();\n    void updateUsers();\n&#125;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        // 1、把业务对象，直接做成一个代理对象返回，代理对象的类型也是 UserService类型\n        UserService userService = ProxyUtil.getProxy(new UserServiceImpl());\n        System.out.println(userService.login(&quot;admin&quot;, &quot;1234&quot;));\n        System.out.println(userService.deleteUsers());\n        userService.selectUsers();\n        userService.updateUsers(); // 走代理\n    &#125;\n&#125;\n\n此案例中业务对象的每个方法都要进行性能统计，存在大量重复的代码。\n动态代理\n代理就是被代理者没有能力或者不愿意去完成某件事情，需要找个人代替自己去完成这件事，动态代理就是用来对业务功能（方法）进行代理的。\n关键步骤\n\n必须有接口，实现类要实现接口（代理通常是基于接口实现的)。\n创建一个实现类的对象，该对象为业务对象，紧接着为业务对象做一个代理对象。\n\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n/**\n    public static Object newProxyInstance(ClassLoader loader,  Class&lt;?&gt;[] interfaces, InvocationHandler h)\n    参数一：类加载器，负责加载代理类到内存中使用。\n    参数二：获取被代理对象实现的全部接口。代理要为全部接口的全部方法进行代理\n    参数三：代理的核心处理逻辑\n */\npublic class ProxyUtil &#123;\n    /**\n      生成业务对象的代理对象。\n     * @param obj\n     * @return\n     */\n    public static &lt;T&gt; T  getProxy(T obj) &#123;\n        // 返回了一个代理对象了\n        return (T)Proxy.newProxyInstance(obj.getClass().getClassLoader(),\n                obj.getClass().getInterfaces(),\n                new InvocationHandler() &#123;\n                    @Override\n                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n                        // 参数一：代理对象本身。一般不管\n                        // 参数二：正在被代理的方法\n                        // 参数三：被代理方法，应该传入的参数\n                       long startTimer = System .currentTimeMillis();\n                        // 马上触发方法的真正执行。(触发真正的业务功能)\n                        Object result = method.invoke(obj, args);\n\n                        long endTimer = System.currentTimeMillis();\n                        System.out.println(method.getName() + &quot;方法耗时：&quot; + (endTimer - startTimer) / 1000.0 + &quot;s&quot;);\n\n                        // 把业务功能方法执行的结果返回给调用者\n                        return result;\n                    &#125;\n                &#125;);\n    &#125;\n&#125;\n\n动态代理的优点\n\n非常的灵活，支持任意接口类型的实现类对象做代理，也可以直接为接本身做代理。\n可以为被代理对象的所有方法做代理。\n可以在不改变方法源码的情况下，实现对方法功能的增强。\n不仅简化了编程工作、提高了软件系统的可扩展性，同时也提高了开发效率。\n\n\n","slug":"Java程序设计 -- Java高级技术（二十）","date":"2022-04-17T08:21:11.000Z","categories_index":"后端","tags_index":"Java","author_index":"会思想的苇草i"},{"id":"fcaa2443e4f23837ea39b8c51bbe3746","title":"Java程序设计--网络编程","content":"\n1、网络通信三要素\n&#x3D;&#x3D;IP地址:设备在网络中的地址，是唯一的标识。&#x3D;&#x3D;\n&#x3D;&#x3D;端口:应用程序在设备中唯一的标识。&#x3D;&#x3D;\n&#x3D;&#x3D;协议:数据在网络中传输的规则，常见的协议有UDP协议和TCP协议。&#x3D;&#x3D;\n\n\n1.1 IP地址 lP (Internet Protocol) ︰全称”互联网协议地址”，是分配给上网设备的唯一标志。\n常见的IP分类为:IPv4和IPv6。\n\n\nIP地址形式:\n\n公网地址、和私有地址(局域网使用)。\n192.168.开头的就是常见的局域网地址，范围即为192.168.0.0 - - 192.168.255.255，专门为组织机构内部使用。\n\nIP常用命令:\n\n&#x3D;&#x3D;ipconfig:查看本机IP地址&#x3D;&#x3D;\n&#x3D;&#x3D;ping lP地址:检查网络是否连通&#x3D;&#x3D;\n\n特殊IP地址:\n\n本机IP:127.0.0.1或者localhost:称为回送地址也可称本地回环地址，只会寻找当前所在本机。\nIP地址操作类- - InetAddress\n\nInetAddress的使用\n\n此类表示Internet协议(IP）地址。\n\nlnetAddress API如下\n\n\n\n名称\n说明\n\n\n\npublic static InetAddress getLocalHost()\n返回本主机的地址对象\n\n\npublic static InetAddress getByName( String host)\n得到指定主机的IP地址对象，参数是域名或者IP地址\n\n\npublic String getHostName()\n获取此IP地址的主机名\n\n\npublic string getHostAddress()\n返回IP地址字符串\n\n\npublic boolean isReachable(int timeout)\n在指定毫秒内连通该IP地址对应的主机，连通返回true\n\n\npublic class InetAddressDemo01 &#123;\n    public static void main(String[] args) throws Exception &#123;\n        // 1.获取本机地址对象。\n        InetAddress ip1 = InetAddress.getLocalHost();\n        System.out.println(ip1.getHostName());\n        System.out.println(ip1.getHostAddress());\n\n        // 2.获取域名ip对象\n        InetAddress ip2 = InetAddress.getByName(&quot;www.baidu.com&quot;);\n        System.out.println(ip2.getHostName());\n        System.out.println(ip2.getHostAddress());\n\n        // 3.获取公网IP对象。\n        InetAddress ip3 = InetAddress.getByName(&quot;112.80.248.76&quot;);\n        System.out.println(ip3.getHostName());\n        System.out.println(ip3.getHostAddress());\n\n        // 4.判断是否能通： ping  5s之前测试是否可通\n        System.out.println(ip3.isReachable(5000));\n    &#125;\n&#125;\n\n1.2 端口号 端口号:标识正在计算机设备上运行的进程（程序)，被规定为一个16位的二进制，范围是0~65535\n端口类型\n\n周知端口:0~1023，被预先定义的知名应用占用(如:HTTP占用80，FTP占用21)\n注册端口:1024~49151，分配给用户进程或某些应用程序。(如: Tomcat占用8080，MySQL占用3306)\n动态端口:49152到65535，之所以称为动态端口，是因为它一般不固定分配某种进程，而是动态分配\n\n注意:我们自己开发的程序选择注册端口，且一个设备中不能出现两个程序的端口号一样，否则出错。\n1.3 通信协议连接和通信数据的规则被称为网络通信协议。\n网络通信协议有两套参考模型\n\nOSI参考模型:世界互联协议标准，全球通信规范，由于此模型过于理想化，未能在因特网上进行广泛推广\nTCP&#x2F;IP参考模型(或TCP&#x2F;IP协议):事实上的国际标准\n\n\n\n\nOSI参考模型\nTCP&#x2F;IP参考模型\n各层对应\n面向操作\n\n\n\n应用层\n应用层\nHTTP、FTP、DNS、SMTP…\n应用程序需要关注的：浏览器，邮箱、程序员一般在这一层开发\n\n\n表示层\n应用层\nHTTP、FTP、DNS、SMTP…\n应用程序需要关注的：浏览器，邮箱、程序员一般在这一层开发\n\n\n会话层\n应用层\nHTTP、FTP、DNS、SMTP…\n应用程序需要关注的：浏览器，邮箱、程序员一般在这一层开发\n\n\n传输层\n传输层\nTCP、UDP…\n选择使用的TCP、UDP协议\n\n\n网络层\n网络层\nIP、ICMP…\n封装源和目标IP，进行路径选择\n\n\n数据链路层\n数据链路层+物理\n物理寻址\n物理设备中传输\n\n\n物理层\n数据链路层+物理\n物理寻址\n物理设备中传输\n\n\n传输层的2个常见协议\n\nTCP(Transmission Control Protocol)︰传输控制协议\nUDP(User Datagram Protocol):用户数据报协议\n\nTCP协议特点\n\n使用TCP协议，必须双方先建立连接，它是一种面向连接的可靠通信协议。\n传输前，采用“三次握手”方式建立连接，所以是可靠的。\n在连接中可进行大数据量的传输。\n连接、发送数据都需要确认，且传输完毕后，还需释放已建立的连接，通信效率较低。\n\nTCP协议通信场景\n\n对信息安全要求较高的场景，例如:文件下载、金融等数据通信。\n\n\n\nUDP协议:\n\nUDP是一种无连接、不可靠传输的协议\n将数据源IP、目的地IP和端口封装成数据包，不需要建立连接\n每个数据包的大小限制在64KB内\n发送不管对方是否准备好，接收方收到也不确认，故是不可靠的\n可以广播发送，发送数据结束时无需释放资源，开销小，速度快\n\nUDP协议通信场景\n\n语音通话，视频会话等。\n\n\n2、UDP通信2.1 UDP通信 - - 快速入门UDP协议的特点\n\nUDP是一种无连接、不可靠传输的协议。\n将数据源IP、目的地IP和端口以及数据封装成数据包，大小限制在64KB内，直接发送出去即可。\n\nDatagramPacket:数据包对象  \n\n\n\n构造器\n说明\n\n\n\npublic DatagramPacket(byte[ ] buf, int length，InetAddress address,int port)\n创建发送端数据包对象buf:要发送的内容，字节数组length:要发送内容的字节长度address:接收端的IP地址对象port:接收端的端口号\n\n\npublic DatagramPacket(byte[] buf， int length)\n创建接收端的数据包对象buf:用来存储接收的内容length:能够接收内容的长度\n\n\nDatagramPacket常用方法\n\n\n\n方法\n说明\n\n\n\npublic int getLength()\n获得实际接收到的字节个数\n\n\nDatagramSocket:发送端和接收端对象\n\n\n\n构造器\n说明\n\n\n\npublic DatagramSocket()\n创建发送端的Socket对象，系统会随机分配一个端口号。\n\n\npublic DatagramSocket(int port)\n创建接收端的Socket对象并指定端口号\n\n\nDatagramSocket类成员方法\n\n\n\n方法\n说明\n\n\n\npublic void send(DatagramPacket dp)\n发送数据包\n\n\npublic void receive(DatagramPacket p)\n接收数据包\n\n\n使用UDP通信实现：发送消息、接受消息\n\n\n\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\n\n/**\n  发送端  一发 一收\n */\npublic class ClientDemo1 &#123;\n    public static void main(String[] args) throws Exception &#123;\n        System.out.println(&quot;=====客户端启动======&quot;);\n\n        // 1、创建发送端对象：发送端自带默认的端口号（人）\n        DatagramSocket socket = new DatagramSocket(6666);\n        // 2、创建一个数据包对象封装数据（韭菜盘子）\n        byte[] buffer = &quot;我是一颗快乐的韭菜，你愿意吃吗？&quot;.getBytes();\n        DatagramPacket packet = new DatagramPacket( buffer, buffer.length,\n                InetAddress.getLocalHost() , 8888);\n\n        // 3、发送数据出去\n        socket.send(packet);\n\n        socket.close();\n    &#125;\n&#125;\n\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketException;\n\n/**\n  接收端\n */\npublic class ServerDemo2 &#123;\n    public static void main(String[] args) throws Exception &#123;\n        System.out.println(&quot;=====服务端启动======&quot;);\n        // 1、创建接收端对象：注册端口（人）\n        DatagramSocket socket = new DatagramSocket(8888);\n        // 2、创建一个数据包对象接收数据（韭菜盘子）\n        byte[] buffer = new byte[1024 * 64];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        // 3、等待接收数据。\n        socket.receive(packet);\n        // 4、取出数据即可\n        // 读取多少倒出多少\n        int len = packet.getLength();\n        String rs = new String(buffer,0, len);\n        System.out.println(&quot;收到了：&quot; + rs);\n        // 获取发送端的ip和端口\n        String ip  =packet.getSocketAddress().toString();\n        System.out.println(&quot;对方地址：&quot; + ip);\n\n        int port  = packet.getPort();\n        System.out.println(&quot;对方端口：&quot; + port);\n\n        socket.close();\n    &#125;\n&#125;\n\n使用UDP通信实现：多发多收消息\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.MulticastSocket;\nimport java.util.Scanner;\n\n/**\n  发送端  多发 多收\n */\npublic class ClientDemo1 &#123;\n    public static void main(String[] args) throws Exception &#123;\n        System.out.println(&quot;=====客户端启动======&quot;);\n\n        // 1、创建发送端对象：发送端自带默认的端口号（人）\n        DatagramSocket socket = new DatagramSocket(7777);\n        \n\n        Scanner sc = new Scanner(System.in);\n        while (true) &#123;\n            System.out.println(&quot;请说：&quot;);\n            String msg = sc.nextLine();\n\n            if(&quot;exit&quot;.equals(msg))&#123;\n                System.out.println(&quot;离线成功！&quot;);\n                socket.close();\n                break;\n            &#125;\n\n            // 2、创建一个数据包对象封装数据（韭菜盘子）\n            byte[] buffer = msg.getBytes();\n            DatagramPacket packet = new DatagramPacket( buffer, buffer.length,\n                    InetAddress.getLocalHost() , 8888);\n\n            // 3、发送数据出去\n            socket.send(packet);\n        &#125;\n\n    &#125;\n&#125;\n\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\n\n/**\n  接收端\n */\npublic class ServerDemo2 &#123;\n    public static void main(String[] args) throws Exception &#123;\n        System.out.println(&quot;=====服务端启动======&quot;);\n        // 1、创建接收端对象：注册端口（人）\n        DatagramSocket socket = new DatagramSocket(8888);\n\n        // 2、创建一个数据包对象接收数据（韭菜盘子）\n        byte[] buffer = new byte[1024 * 64];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n\n        while (true) &#123;\n            // 3、等待接收数据。\n            socket.receive(packet);\n            // 4、取出数据即可\n            // 读取多少倒出多少\n            int len = packet.getLength();\n            String rs = new String(buffer,0, len);\n            System.out.println(&quot;收到了来自：&quot; + packet.getAddress() +&quot;, 对方端口是&quot; + packet.getPort() +&quot;的消息：&quot; + rs);\n        &#125;\n    &#125;\n&#125;\n\n2.2 UDP通信 - - 广播、组播UDP的三种通信方式:\n\n单播:单台主机与单台主机之间的通信。\n广播:当前主机与所在网络中的所有主机通信。\n组播:当前主机与选定的一组主机的通信。\n\nUDP如何实现广播\n\n使用广播地址:255.255.255.255\n具体操作: - 发送端发送的数据包的目的地写的是广播地址、且指定端口。(255.255.255.255,9999) - 本机所在网段的其他主机的程序只要注册对应端口就可以收到消息了。(9999)\n\nUDP如何实现组播\n\n使用组播地址:224.0.0.0 ~239.255.255.255\n具体操作:  - 发送端的数据包的目的地是组播IP（例如:224.0.1.1，端口:9999)  - 接收端必须绑定该组播IP(224.0.1.1)，端口还要注册发送端的目的端口9999，这样即可接收该组播消息。  - DatagramSocket的子类MulticastSocket可以在接收端绑定组播IP。\n\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.util.Scanner;\n\n/**\n  发送端  多发 多收\n */\npublic class ClientDemo1 &#123;\n    public static void main(String[] args) throws Exception &#123;\n        System.out.println(&quot;=====客户端启动======&quot;);\n\n        // 1、创建发送端对象：发送端自带默认的端口号（人）\n        DatagramSocket socket = new DatagramSocket();\n        \n\n        Scanner sc = new Scanner(System.in);\n        while (true) &#123;\n            System.out.println(&quot;请说：&quot;);\n            String msg = sc.nextLine();\n\n            if(&quot;exit&quot;.equals(msg))&#123;\n                System.out.println(&quot;离线成功！&quot;);\n                socket.close();\n                break;\n            &#125;\n\n            // 2、创建一个数据包对象封装数据（韭菜盘子）\n            byte[] buffer = msg.getBytes();\n            // 注意：只要目的地IP是 255.255.255.255 这个消息将以广播的形式对外发送\n//            DatagramPacket packet = new DatagramPacket( buffer, buffer.length,\n//                    InetAddress.getByName(&quot;255.255.255.255&quot;) , 8888);\n\n            DatagramPacket packet = new DatagramPacket( buffer, buffer.length,\n                    InetAddress.getByName(&quot;224.0.1.1&quot;) , 9898);\n\n                    // 3、发送数据出去\n            socket.send(packet);\n        &#125;\n\n    &#125;\n&#125;\n\nimport java.net.*;\n\n/**\n  接收端\n */\npublic class ServerDemo2 &#123;\n    public static void main(String[] args) throws Exception &#123;\n        System.out.println(&quot;=====服务端启动======&quot;);\n        // 1、创建接收端对象：注册端口（人）\n        MulticastSocket socket = new MulticastSocket(9898);\n\n        // 注意：绑定组播地址（加群）\n        socket.joinGroup(new InetSocketAddress(InetAddress.getByName(&quot;224.0.1.1&quot;) , 9898),\n                NetworkInterface.getByInetAddress(InetAddress.getLocalHost()));\n\n        // 2、创建一个数据包对象接收数据（韭菜盘子）\n        byte[] buffer = new byte[1024 * 64];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n\n\n        while (true) &#123;\n            // 3、等待接收数据。\n            socket.receive(packet);\n            // 4、取出数据即可\n            // 读取多少倒出多少\n            int len = packet.getLength();\n            String rs = new String(buffer,0, len);\n            System.out.println(&quot;收到了来自：&quot; + packet.getAddress() +&quot;, 对方端口是&quot; + packet.getPort() +&quot;的消息：&quot; + rs);\n        &#125;\n    &#125;\n&#125;\n\n\n3、TCP通信3.1 TCP通信 - - 快速入门\n注意:在java中只要是使用java.net.Socket类实现通信，底层即是使用了TCP协议\n编写客户端代码\nSocket\n\n\n\n构造器\n说明\n\n\n\npublic Socket(String host , int port)\n创建发送端的Socket对象与服务端连接，参数为服务端程序的ip和端口。\n\n\nSocket类成员方法\n\n\n\n方法\n说明\n\n\n:-:\n:-:\n\n\noutputStream getoutputstream()\n获得字节输出流对象\n\n\nInputStream getInputstream()\n获得字节输入流对象\n\n\n客户端发送消息\n需求:客户端实现步骤\n\n创建客户端的Socket对象，请求与服务端的连接。\n使用socket对象调用getOutputStream()方法得到字节输出流。\n使用字节输出流完成数据的发送。\n释放资源:关闭socket管道。\n\n编写服务端代码\nServerSocket(服务端)\n\n\n\n构造器\n说明\n\n\n\npublic ServerSocket(int port)\n注册服务端端口。\n\n\nServerSocket类成员方法\n\n\n\n方法\n说明\n\n\n\npublic Socket accept()\n等待接收客户端的socket通信连接。连接成功返回socket对象与客户端建立端到端通信。\n\n\n服务端实现接收消息\n需求:服务端实现步骤\n\n创建ServerSocket对象，注册服务端端口。\n调用ServerSocket对象的accept()方法，等待客户端的连接，并得到Socket管道对象。\n通过Socket对象调用getlnputStream()方法得到字节输入流、完成数据的接收。\n释放资源:关闭socket管道\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.net.Socket;\n\n/**\n   目标：完成Socket网络编程入门案例的客户端开发，实现1发1收。\n */\npublic class ClientDemo1 &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            System.out.println(&quot;====客户端启动===&quot;);\n            // 1、创建Socket通信管道请求有服务端的连接\n            // public Socket(String host, int port)\n            // 参数一：服务端的IP地址\n            // 参数二：服务端的端口\n            Socket socket = new Socket(&quot;127.0.0.1&quot;, 7777);\n\n            // 2、从socket通信管道中得到一个字节输出流 负责发送数据\n            OutputStream os = socket.getOutputStream();\n\n            // 3、把低级的字节流包装成打印流\n            PrintStream ps = new PrintStream(os);\n\n            // 4、发送消息\n            ps.println(&quot;我是TCP的客户端，我已经与你对接，并发出邀请：约吗？&quot;);\n            ps.flush();\n\n            // 关闭资源。\n            // socket.close();\n\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\n/**\n   目标：开发Socket网络编程入门代码的服务端，实现接收消息\n */\npublic class ServerDemo2 &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            System.out.println(&quot;===服务端启动成功===&quot;);\n            // 1、注册端口\n            ServerSocket serverSocket = new ServerSocket(7777);\n            // 2、必须调用accept方法：等待接收客户端的Socket连接请求，建立Socket通信管道\n            Socket socket = serverSocket.accept();\n            // 3、从socket通信管道中得到一个字节输入流\n            InputStream is = socket.getInputStream();\n            // 4、把字节输入流包装成缓冲字符输入流进行消息的接收\n            BufferedReader br = new BufferedReader(new InputStreamReader(is));\n            // 5、按照行读取消息\n            String msg;\n            if ((msg = br.readLine()) != null)&#123;\n                System.out.println(socket.getRemoteSocketAddress() + &quot;说了：: &quot; + msg);\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n3.2 TCP通信 - - 多发多收需求:使用TCP通信方式实现:多发多收消息。\n具体要求:\n\n可以使用死循环控制服务端收完消息继续等待接收下一个消息。\n客户端也可以使用死循环等待用户不断输入消息。\n客户端一旦输入了exit，则关闭客户端程序，并释放资源。\n\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.net.Socket;\nimport java.util.Scanner;\n\n/**\n   目标：实现多发和多收\n */\npublic class ClientDemo1 &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            System.out.println(&quot;====客户端启动===&quot;);\n            // 1、创建Socket通信管道请求有服务端的连接\n            // public Socket(String host, int port)\n            // 参数一：服务端的IP地址\n            // 参数二：服务端的端口\n            Socket socket = new Socket(&quot;127.0.0.1&quot;, 7777);\n\n            // 2、从socket通信管道中得到一个字节输出流 负责发送数据\n            OutputStream os = socket.getOutputStream();\n\n            // 3、把低级的字节流包装成打印流\n            PrintStream ps = new PrintStream(os);\n\n            Scanner sc =  new Scanner(System.in);\n            while (true) &#123;\n                System.out.println(&quot;请说：&quot;);\n                String msg = sc.nextLine();\n                // 4、发送消息\n                ps.println(msg);\n                ps.flush();\n            &#125;\n\n            // 关闭资源。\n            // socket.close();\n\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\n/**\n   目标：开发Socket网络编程入门代码的服务端，实现接收消息\n */\npublic class ServerDemo2 &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            System.out.println(&quot;===服务端启动成功===&quot;);\n            // 1、注册端口\n            ServerSocket serverSocket = new ServerSocket(7777);\n            while (true) &#123;\n                // 2、必须调用accept方法：等待接收客户端的Socket连接请求，建立Socket通信管道\n                Socket socket = serverSocket.accept();\n                // 3、从socket通信管道中得到一个字节输入流\n                InputStream is = socket.getInputStream();\n                // 4、把字节输入流包装成缓冲字符输入流进行消息的接收\n                BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                // 5、按照行读取消息\n                String msg;\n                while ((msg = br.readLine()) != null)&#123;\n                    System.out.println(socket.getRemoteSocketAddress() + &quot;说了：: &quot; + msg);\n                &#125;\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n本例实现了多发多收（客户端循环反复地发送消息，服务端循环反复地接收消息），但是不能同时接受多个客户端的消息，因为服务端现在只有一个线程，只能与一个客户端进行通信。\n3.3 TCP通信 - - 多接受引入多线程可以让服务端处理多个客户端的通信需求\n\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.net.Socket;\nimport java.util.Scanner;\n\n/**\n    目标：实现服务端可以同时处理多个客户端的消息。\n */\npublic class ClientDemo1 &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            System.out.println(&quot;====客户端启动===&quot;);\n            // 1、创建Socket通信管道请求有服务端的连接\n            // public Socket(String host, int port)\n            // 参数一：服务端的IP地址\n            // 参数二：服务端的端口\n            Socket socket = new Socket(&quot;127.0.0.1&quot;, 7777);\n\n            // 2、从socket通信管道中得到一个字节输出流 负责发送数据\n            OutputStream os = socket.getOutputStream();\n\n            // 3、把低级的字节流包装成打印流\n            PrintStream ps = new PrintStream(os);\n\n            Scanner sc =  new Scanner(System.in);\n            while (true) &#123;\n                System.out.println(&quot;请说：&quot;);\n                String msg = sc.nextLine();\n                // 4、发送消息\n                ps.println(msg);\n                ps.flush();\n            &#125;\n\n            // 关闭资源。\n            // socket.close();\n\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\n/**\n   目标：实现服务端可以同时处理多个客户端的消息。\n */\npublic class ServerDemo2 &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            System.out.println(&quot;===服务端启动成功===&quot;);\n            // 1、注册端口\n            ServerSocket serverSocket = new ServerSocket(7777);\n            // a.定义一个死循环由主线程负责不断的接收客户端的Socket管道连接。\n            while (true) &#123;\n                // 2、每接收到一个客户端的Socket管道，交给一个独立的子线程负责读取消息\n                Socket socket = serverSocket.accept();\n                System.out.println(socket.getRemoteSocketAddress()+ &quot;它来了，上线了！&quot;);\n                // 3、开始创建独立线程处理socket\n                new ServerReaderThread(socket).start();\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.Socket;\n\npublic class ServerReaderThread extends Thread&#123;\n    private Socket socket;\n    public ServerReaderThread(Socket socket)&#123;\n        this.socket = socket;\n    &#125;\n    @Override\n    public void run() &#123;\n        try &#123;\n            // 3、从socket通信管道中得到一个字节输入流\n            InputStream is = socket.getInputStream();\n            // 4、把字节输入流包装成缓冲字符输入流进行消息的接收\n            BufferedReader br = new BufferedReader(new InputStreamReader(is));\n            // 5、按照行读取消息\n            String msg;\n            while ((msg = br.readLine()) != null)&#123;\n                System.out.println(socket.getRemoteSocketAddress() + &quot;说了：: &quot; + msg);\n            &#125;\n        &#125; catch (Exception e) &#123;\n            System.out.println(socket.getRemoteSocketAddress() + &quot;下线了！！！&quot;);\n        &#125;\n    &#125;\n&#125;\n\n3.4 TCP通信 - - 使用线程池优化多接受客户端与服务端的线程模型是：N-N的关系，客户端并发越多，系统瘫痪的越快。\n\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.net.Socket;\nimport java.util.Scanner;\n\n/**\n    拓展：使用线程池优化：实现通信。\n */\npublic class ClientDemo1 &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            System.out.println(&quot;====客户端启动===&quot;);\n            // 1、创建Socket通信管道请求有服务端的连接\n            // public Socket(String host, int port)\n            // 参数一：服务端的IP地址\n            // 参数二：服务端的端口\n            Socket socket = new Socket(&quot;127.0.0.1&quot;, 6666);\n\n            // 2、从socket通信管道中得到一个字节输出流 负责发送数据\n            OutputStream os = socket.getOutputStream();\n\n            // 3、把低级的字节流包装成打印流\n            PrintStream ps = new PrintStream(os);\n\n            Scanner sc =  new Scanner(System.in);\n            while (true) &#123;\n                System.out.println(&quot;请说：&quot;);\n                String msg = sc.nextLine();\n                // 4、发送消息\n                ps.println(msg);\n                ps.flush();\n            &#125;\n            // 关闭资源。\n            // socket.close();\n\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\nimport demo.ServerReaderThread;\n\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.*;\n\n/**\n   目标：实现服务端可以同时处理多个客户端的消息。\n */\npublic class ServerDemo2 &#123;\n\n    // 使用静态变量记住一个线程池对象\n    private static ExecutorService pool = new ThreadPoolExecutor(300,\n            1500, 6, TimeUnit.SECONDS,\n            new ArrayBlockingQueue&lt;&gt;(2)\n    , Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy());\n\n    public static void main(String[] args) &#123;\n        try &#123;\n            System.out.println(&quot;===服务端启动成功===&quot;);\n            // 1、注册端口\n            ServerSocket serverSocket = new ServerSocket(6666);\n            // a.定义一个死循环由主线程负责不断的接收客户端的Socket管道连接。\n            while (true) &#123;\n                // 2、每接收到一个客户端的Socket管道，\n                Socket socket = serverSocket.accept();\n                System.out.println(socket.getRemoteSocketAddress()+ &quot;它来了，上线了！&quot;);\n\n                // 任务对象负责读取消息。\n                Runnable target = new ServerReaderRunnable(socket);\n                pool.execute(target);\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.Socket;\n\npublic class ServerReaderRunnable implements Runnable&#123;\n    private Socket socket;\n    public ServerReaderRunnable(Socket socket)&#123;\n        this.socket = socket;\n    &#125;\n    @Override\n    public void run() &#123;\n        try &#123;\n            // 3、从socket通信管道中得到一个字节输入流\n            InputStream is = socket.getInputStream();\n            // 4、把字节输入流包装成缓冲字符输入流进行消息的接收\n            BufferedReader br = new BufferedReader(new InputStreamReader(is));\n            // 5、按照行读取消息\n            String msg;\n            while ((msg = br.readLine()) != null)&#123;\n                System.out.println(socket.getRemoteSocketAddress() + &quot;说了：: &quot; + msg);\n            &#125;\n        &#125; catch (Exception e) &#123;\n            System.out.println(socket.getRemoteSocketAddress() + &quot;下线了！！！&quot;);\n        &#125;\n    &#125;\n&#125;\n\n服务端可以复用线程处理多个客户端，可以避免系统瘫痪。适合客户端通信时长较短的场景。\n3.5 TCP通信 - - 即时通信即时通信，是指一个客户端的消息发出去，其他客户端可以接收到。之前我们的消息都是发给服务端的。即时通信需要进行端口转发的设计思想。服务端需要把在线的Socket管道存储起来，一旦收到一个消息要推送给其他管道。\n\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.net.Socket;\nimport java.util.Scanner;\n\n/**\n    拓展：即时通信\n\n    客户端：发消息的同时，随时有人发消息过来。\n    服务端：接收消息后，推送给其他所有的在线socket\n */\npublic class ClientDemo1 &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            System.out.println(&quot;====客户端启动===&quot;);\n            // 1、创建Socket通信管道请求有服务端的连接\n            // public Socket(String host, int port)\n            // 参数一：服务端的IP地址\n            // 参数二：服务端的端口\n            Socket socket = new Socket(&quot;127.0.0.1&quot;, 6868);\n\n            // 马上为客户端分配一个独立的线程负责读取它收到的消息\n            new ClientReaderThread(socket).start();\n\n            // 2、从socket通信管道中得到一个字节输出流 负责发送数据\n            OutputStream os = socket.getOutputStream();\n\n            // 3、把低级的字节流包装成打印流\n            PrintStream ps = new PrintStream(os);\n\n            Scanner sc =  new Scanner(System.in);\n            while (true) &#123;\n                System.out.println(&quot;请说：&quot;);\n                String msg = sc.nextLine();\n                // 4、发送消息\n                ps.println(msg);\n                ps.flush();\n            &#125;\n            // 关闭资源。\n            // socket.close();\n\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.net.Socket;\n\npublic class ClientReaderThread extends Thread&#123;\n    private Socket socket;\n    public ClientReaderThread(Socket socket)&#123;\n        this.socket = socket;\n    &#125;\n    @Override\n    public void run() &#123;\n        try &#123;\n            // 3、从socket通信管道中得到一个字节输入流\n            InputStream is = socket.getInputStream();\n            // 4、把字节输入流包装成缓冲字符输入流进行消息的接收\n            BufferedReader br = new BufferedReader(new InputStreamReader(is));\n            // 5、按照行读取消息\n            String msg;\n            while ((msg = br.readLine()) != null)&#123;\n                System.out.println(socket.getRemoteSocketAddress() + &quot;收到了: &quot; + msg);\n            &#125;\n        &#125; catch (Exception e) &#123;\n            System.out.println(&quot;服务端把你踢出去了~~&quot;);\n        &#125;\n    &#125;\n\n&#125;\n\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n   目标: 即时通信\n */\npublic class ServerDemo2 &#123;\n\n    public static List&lt;Socket&gt; onLineSockets = new ArrayList&lt;&gt;();\n\n    public static void main(String[] args) &#123;\n        try &#123;\n            System.out.println(&quot;===服务端启动成功===&quot;);\n            // 1、注册端口\n            ServerSocket serverSocket = new ServerSocket(6868);\n            // a.定义一个死循环由主线程负责不断的接收客户端的Socket管道连接。\n            while (true) &#123;\n                // 2、每接收到一个客户端的Socket管道，交给一个独立的子线程负责读取消息\n                Socket socket = serverSocket.accept();\n                System.out.println(socket.getRemoteSocketAddress()+ &quot;它来了，上线了！&quot;);\n                // 把当前客户端管道Socket加入到在线集合中去\n                onLineSockets.add(socket);\n\n                // 3、开始创建独立线程处理socket\n                new ServerReaderThread(socket).start();\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\nimport java.io.*;\nimport java.net.Socket;\n\npublic class ServerReaderThread extends Thread&#123;\n    private Socket socket;\n    public ServerReaderThread(Socket socket)&#123;\n        this.socket = socket;\n    &#125;\n    @Override\n    public void run() &#123;\n        try &#123;\n            // 3、从socket通信管道中得到一个字节输入流\n            InputStream is = socket.getInputStream();\n            // 4、把字节输入流包装成缓冲字符输入流进行消息的接收\n            BufferedReader br = new BufferedReader(new InputStreamReader(is));\n            // 5、按照行读取消息\n            String msg;\n            while ((msg = br.readLine()) != null)&#123;\n                System.out.println(socket.getRemoteSocketAddress() + &quot;说了：: &quot; + msg);\n                // 把这个消息发给当前所有在线socket\n                sendMsgToAll(msg);\n            &#125;\n        &#125; catch (Exception e) &#123;\n            System.out.println(socket.getRemoteSocketAddress() + &quot;下线了！！！&quot;);\n            // 从在线集合中抹掉本客户端socket\n            ServerDemo2.onLineSockets.remove(socket);\n        &#125;\n    &#125;\n\n    private void sendMsgToAll(String msg) &#123;\n        try &#123;\n            // 遍历全部的在线 socket给他们发消息\n            for (Socket onLineSocket : ServerDemo2.onLineSockets) &#123;\n                // 除了自己的socket，其他socket我都发！！\n                if(onLineSocket != socket)&#123;\n                    PrintStream ps = new PrintStream(socket.getOutputStream());\n                    ps.println(msg);\n                    ps.flush();\n                &#125;\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n3.6 TCP通信 - - 模拟BS系统之前的客户端都是CS结构，客户端需要我们自己开发实现。BS结构是浏览器访问服务端，不需要开发客户端。\n\nimport java.io.PrintStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.*;\n\npublic class BSserverDemo &#123;\n    // 使用静态变量记住一个线程池对象\n    private static ExecutorService pool = new ThreadPoolExecutor(3,\n            5, 6, TimeUnit.SECONDS,\n            new ArrayBlockingQueue&lt;&gt;(2)\n            , Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy());\n\n    public static void main(String[] args) &#123;\n        try &#123;\n            // 1.注册端口\n            ServerSocket ss = new ServerSocket(8080);\n            // 2.创建一个循环接收多个客户端的请求。\n            while(true)&#123;\n                Socket socket = ss.accept();\n                // 3.交给一个独立的线程来处理！\n                pool.execute(new ServerReaderRunnable(socket));\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.net.Socket;\n\npublic class ServerReaderRunnable implements Runnable&#123;\n    private Socket socket;\n    public ServerReaderRunnable(Socket socket)&#123;\n        this.socket = socket;\n    &#125;\n    @Override\n    public void run() &#123;\n        try &#123;\n            // 浏览器 已经与本线程建立了Socket管道\n            // 响应消息给浏览器显示\n            PrintStream ps = new PrintStream(socket.getOutputStream());\n            // 必须响应HTTP协议格式数据，否则浏览器不认识消息\n            ps.println(&quot;HTTP/1.1 200 OK&quot;); // 协议类型和版本 响应成功的消息！\n            ps.println(&quot;Content-Type:text/html;charset=UTF-8&quot;); // 响应的数据类型：文本/网页\n\n            ps.println(); // 必须发送一个空行\n\n            // 才可以响应数据回去给浏览器\n            ps.println(&quot;&lt;span style=&#39;color:red;font-size:90px&#39;&gt;《最牛的149期》 &lt;/span&gt;&quot;);\n            ps.close();\n        &#125; catch (Exception e) &#123;\n            System.out.println(socket.getRemoteSocketAddress() + &quot;下线了！！！&quot;);\n        &#125;\n    &#125;\n&#125;\n\n注意:服务器必须给浏览器响应HTTP协议格式的数据，否则浏览器不识别。\n\n\n","slug":"Java程序设计 -- 网络编程（十九）","date":"2022-04-15T02:39:59.000Z","categories_index":"后端","tags_index":"Java","author_index":"会思想的苇草i"},{"id":"4efd1e259b597b69971ef5e65a102b02","title":"Java程序设计--多线程","content":"\n1、多线程的创建线程(thread)是一个程序内部的一条执行路径。\n我们之前启动程序执行后，main方法的执行其实就是一条单独的执行路径。\npublic static void main(String] args) &#123;\n//代码...\nfor (int i = 0; i &lt; 10; i++)&#123;System.out.println(i);\n//代码..\n&#125;\n\n程序中如果只有一条执行路径，那么这个程序就是单线程的程序。\n&#x3D;&#x3D;多线程是指从软硬件上实现多条执行流程的技术。&#x3D;&#x3D;\n1.1 创建方式一 - - 继承Thread类Java是通过java.lang.Thread类来代表线程的。\n按照面向对象的思想，Thread类应该提供了实现多线程的方式。\n步骤：\n\n定义一个子类MyThread继承线程类java.lang.Thread，重写run()方法\n创建MyThread类的对象\n调用线程对象的start()方法启动线程（启动后还是执行run方法的)\n\npublic class ThreadDemo1 &#123;\n    public static void main(String[] args) &#123;\n        // 3、new一个新线程对象\n        Thread t = new MyThread();\n        // 4、调用start方法启动线程（执行的还是run方法）\n        t.start();\n\n        for (int i = 0; i &lt; 5; i++) &#123;\n            System.out.println(&quot;主线程执行输出：&quot; + i);\n        &#125;\n\n    &#125;\n&#125;\n\n/**\n   1、定义一个线程类继承Thread类\n */\nclass MyThread extends Thread&#123;\n    /**\n       2、重写run方法，里面是定义线程以后要干啥\n     */\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 5; i++) &#123;\n            System.out.println(&quot;子线程执行输出：&quot; + i);\n        &#125;\n    &#125;\n&#125;\n\n优缺点：\n\n优点:编码简单。\n缺点:线程类已经继承Thread，无法继承其他类，不利于扩展。\n\n1.2 创建方式二 - - 实现Runnable接口步骤：\n\n定义一个线程任务类MyRunnable实现Runnable接口，重写run()方法创建\nMyRunnable任务对象\n把MyRunnable任务对象交给Thread处理\n调用线程对象的start()方法启动线程\n\nThread的构造器\n\n\n\n构造器\n说明\n\n\n\npublic Thread(String name)\n可以为当前线程指定名称\n\n\npublic Thread(Runnable target)\n封装Runnable对象成为线程对象\n\n\npublic Thread(Runnable target ,String name )\n封装Runnable对象成为线程对象，并指定线程名称\n\n\npublic class ThreadDemo2 &#123;\n    public static void main(String[] args) &#123;\n        // 3、创建一个任务对象\n        Runnable target = new MyRunnable();\n        // 4、把任务对象交给Thread处理\n        Thread t = new Thread(target);\n        // Thread t = new Thread(target, &quot;1号&quot;);\n        // 5、启动线程\n        t.start();\n\n        for (int i = 0; i &lt; 10; i++) &#123;\n            System.out.println(&quot;主线程执行输出：&quot; + i);\n        &#125;\n    &#125;\n&#125;\n\n/**\n   1、定义一个线程任务类 实现Runnable接口\n */\nclass MyRunnable  implements Runnable &#123;\n    /**\n       2、重写run方法，定义线程的执行任务的\n     */\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 10; i++) &#123;\n            System.out.println(&quot;子线程执行输出：&quot; + i);\n        &#125;\n    &#125;\n&#125;\n\n优缺点：\n\n优点:线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强。\n缺点:编程多一层对象包装，如果线程有执行结果是不可以直接返回的。\n\n1.3 创建方式三 - - 实现Callable接口前2种线程创建方式都存在一个问题:他们重写的run方法均不能直接返回结果。不适合需要返回线程执行结果的业务场景。\nJDK 5.0提供了Callable和FutureTask来实现。\n这种方式的优点是:可以得到线程执行的结果。\n\n得到任务对象-\t1．定义类实现Callable接口，重写call方法，封装要做的事情。-\t2.用FutureTask把Callable对象封装成线程任务对象。\n把线程任务对象交给Thread处理\n调用Thread的start方法启动线程，执行任务\n线程执行完毕后、通过FutureTask的get方法去获取任务执行的结果\n\nFutureTask的API\n\n\n\n方法名称\n说明\n\n\n\npublic FutureTask&lt;&gt;(Callable call)\n把Callable对象封装成FutureTask对象。\n\n\npublic V get() throws Exception\n获取线程执行call方法返回的结果。\n\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.FutureTask;\n\npublic class ThreadDemo3 &#123;\n    public static void main(String[] args) &#123;\n        // 3、创建Callable任务对象\n        Callable&lt;String&gt; call = new MyCallable(100);\n        // 4、把Callable任务对象 交给 FutureTask 对象\n        //  FutureTask对象的作用1： 是Runnable的对象（实现了Runnable接口），可以交给Thread了\n        //  FutureTask对象的作用2： 可以在线程执行完毕之后通过调用其get方法得到线程执行完成的结果\n        FutureTask&lt;String&gt; f1 = new FutureTask&lt;&gt;(call);\n        // 5、交给线程处理\n        Thread t1 = new Thread(f1);\n        // 6、启动线程\n        t1.start();\n\n\n        Callable&lt;String&gt; call2 = new MyCallable(200);\n        FutureTask&lt;String&gt; f2 = new FutureTask&lt;&gt;(call2);\n        Thread t2 = new Thread(f2);\n        t2.start();\n\n        try &#123;\n            // 如果f1任务没有执行完毕，这里的代码会等待，直到线程1跑完才提取结果。\n            String rs1 = f1.get();\n            System.out.println(&quot;第一个结果：&quot; + rs1);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        try &#123;\n            // 如果f2任务没有执行完毕，这里的代码会等待，直到线程2跑完才提取结果。\n            String rs2 = f2.get();\n            System.out.println(&quot;第二个结果：&quot; + rs2);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n/**\n    1、定义一个任务类 实现Callable接口  应该申明线程任务执行完毕后的结果的数据类型\n */\nclass MyCallable implements Callable&lt;String&gt;&#123;\n    private int n;\n    public MyCallable(int n) &#123;\n        this.n = n;\n    &#125;\n\n    /**\n       2、重写call方法（任务方法）\n     */\n    @Override\n    public String call() throws Exception &#123;\n        int sum = 0;\n        for (int i = 1; i &lt;= n ; i++) &#123;\n            sum += i;\n        &#125;\n        return &quot;子线程执行的结果是：&quot; + sum;\n    &#125;\n&#125;\n\n优缺点:\n\n优点:线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强。可以在线程执行完毕后去获取线程执行的结果。\n缺点:编码复杂一点。\n\n\n2、Thread的常用方法Thread常见构造器\n\n\n\n构造器\n说明\n\n\n\npublic Thread(String name)\n可以为当前线程指定名称\n\n\npublic Thread(Runnable target)\n把Runnable对象交给线程对象\n\n\npublic Thread(Runnable target ,String name )\n把Runnable对象交给线程对象，并指定线程名称\n\n\nThread常见方法\n\n\n\n方法名称\n说明\n\n\n\nString getName()\n获取当前线程的名称，默认线程名称是Thread-索引\n\n\nvoid setName( String name)\n设置线程名称\n\n\npublic static Thread currentThread( ) :\n返回对当前正在执行的线程对象的引用\n\n\npublic static void sleep(long time)\n让线程休眠指定的时间，单位为毫秒。\n\n\npublic void run()\n线程任务方法\n\n\npublic void start()\n线程启动方法\n\n\npublic class MyThread extends Thread&#123;\n    public MyThread() &#123;\n    &#125;\n\n    public MyThread(String name) &#123;\n        // 为当前线程对象设置名称，送给父类的有参数构造器初始化名称\n        super(name);\n    &#125;\n\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 5; i++) &#123;\n            System.out.println( Thread.currentThread().getName() + &quot;输出：&quot; + i);\n        &#125;\n    &#125;\n&#125;\n\npublic class ThreadDemo01 &#123;\n    // main方法是由主线程负责调度的\n    public static void main(String[] args) &#123;\n        Thread t1 = new MyThread(&quot;1号&quot;);\n        // t1.setName(&quot;1号&quot;);\n        t1.start();\n        System.out.println(t1.getName());\n\n        Thread t2 = new MyThread(&quot;2号&quot;);\n        // t2.setName(&quot;2号&quot;);\n        t2.start();\n        System.out.println(t2.getName());\n\n        // 哪个线程执行它，它就得到哪个线程对象（当前线程对象）\n        // 主线程的名称就叫main\n        Thread m = Thread.currentThread();\n        System.out.println(m.getName());\n        m.setName(&quot;最牛的线程&quot;);\n\n        for (int i = 0; i &lt; 5; i++) &#123;\n            System.out.println( m.getName() + &quot;输出：&quot; + i);\n        &#125;\n    &#125;\n&#125;\n\npublic class ThreadDemo02 &#123;\n    // main方法是由主线程负责调度的\n    public static void main(String[] args) throws Exception &#123;\n        for (int i = 1; i &lt;= 5; i++) &#123;\n            System.out.println(&quot;输出：&quot; + i);\n            if(i == 3)&#123;\n                // 让当前线程进入休眠状态\n                // 段子：项目经理让我加上这行代码，如果用户愿意交钱，我就注释掉。\n                Thread.sleep(3000);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\n3、线程安全多个线程同时操作同一个共享资源的时候可能会出现业务安全问题，称为线程安全问题。\n线程安全问题出现的原因：\n\n&#x3D;&#x3D;存在多线程并发&#x3D;&#x3D;\n&#x3D;&#x3D;同时访问共享资源&#x3D;&#x3D;\n&#x3D;&#x3D;存在修改共享资源&#x3D;&#x3D;\n\n\n4、线程同步&#x3D;&#x3D;线程同步是为了解决线程安全问题。&#x3D;&#x3D;\n线程同步的核心思想\n&#x3D;&#x3D;加锁，把共享资源进行上锁，每次只能一个线程进入访问完毕以后解锁，然后其他线程才能进来。&#x3D;&#x3D;\n4.1 方式一 - - 同步代码块\n&#x3D;&#x3D;作用:把出现线程安全问题的核心代码给上锁。&#x3D;&#x3D;\n原理:每次只能一个线程进入，执行完毕后自动解锁，其他线程才可以进来执行。\n\nsynchronized(同步锁对象)&#123;\n    操作共享资源的代码(核心代码)\n&#125;\n\n&#x3D;&#x3D;锁对象要求：理论上锁对象只要对于当前同时执行的线程来说是同一个对象即可。&#x3D;&#x3D;\n\n规范上:建议使用共享资源作为锁对象。\n对于实例方法建议使用this作为锁对象。\n对于静态方法建议使用字节码(类名.class)对象作为锁对象。\n\npublic class Account &#123;\n    private String cardId;\n    private double money; // 余额 关键信息\n\n    public Account() &#123;\n    &#125;\n\n    public Account(String cardId, double money) &#123;\n        this.cardId = cardId;\n        this.money = money;\n    &#125;\n\n    public String getCardId() &#123;\n        return cardId;\n    &#125;\n\n    public void setCardId(String cardId) &#123;\n        this.cardId = cardId;\n    &#125;\n\n    public double getMoney() &#123;\n        return money;\n    &#125;\n\n    public void setMoney(double money) &#123;\n        this.money = money;\n    &#125;\n\n    public void drawMoney(double money) &#123;\n        // 1、拿到是谁来取钱\n        String name = Thread.currentThread().getName();\n        // 同步代码块\n        // 小明 小红\n        // this == acc 共享账户\n        synchronized (this) &#123;\n            // 2、判断余额是否足够\n            if(this.money &gt;= money)&#123;\n                // 钱够了\n                System.out.println(name+&quot;来取钱，吐出：&quot; + money);\n                // 更新余额\n                this.money -= money;\n                System.out.println(name+&quot;取钱后，余额剩余：&quot; + this.money);\n            &#125;else&#123;\n                // 3、余额不足\n                System.out.println(name+&quot;来取钱，余额不足！&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\npublic class DrawThread extends Thread&#123;\n    private Account acc;\n    public DrawThread(Account acc, String name)&#123;\n        super(name);\n        this.acc = acc;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        // 小明 小红  ： acc\n        acc.drawMoney(100000);\n    &#125;\n&#125;\n\npublic class TestSafeDemo &#123;\n    public static void main(String[] args) &#123;\n        // 测试线程安全问题\n        // 1、创建一个共享的账户对象。\n        Account acc = new Account(&quot;ICBC-111&quot; , 100000);\n\n        // 2、创建2个线程对象，操作同一个账户对象\n        new DrawThread(acc, &quot;小明&quot;).start();\n        new DrawThread(acc,&quot;小红&quot;).start();\n\n    &#125;\n&#125;\n\n4.2 方式二 - - 同步方法\n&#x3D;&#x3D;作用:把出现线程安全问题的核心方法给上锁。&#x3D;&#x3D;\n原理:每次只能一个线程进入，执行完毕以后自动解锁，其他线程才可以进来执行。\n\n修饰符 synchronized 返回值类型 方法名称(形参列表)&#123;\n    操作共享资源的代码\n&#125;\n\npublic synchronized void drawMoney(double money) &#123;\n        // 1、拿到是谁来取钱\n        String name = Thread.currentThread().getName();\n        // 2、判断余额是否足够\n        // 小明  小红\n        if(this.money &gt;= money)&#123;\n            // 钱够了\n            System.out.println(name+&quot;来取钱，吐出：&quot; + money);\n            // 更新余额\n            this.money -= money;\n            System.out.println(name+&quot;取钱后，余额剩余：&quot; + this.money);\n        &#125;else&#123;\n            // 3、余额不足\n            System.out.println(name+&quot;来取钱，余额不足！&quot;);\n        &#125;\n    &#125;\n\n同步方法底层原理\n\n同步方法其实底层也是有隐式锁对象的，只是锁的范围是整个方法代码。（相对于同步代码块锁范围更大）\n如果方法是实例方法:同步方法默认用this作为的锁对象。但是代码要高度面向对象!\n如果方法是静态方法:同步方法默认用类名.class作为的锁对象。\n\n4.3 方式三 - - Lock锁\n为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock，更加灵活、方便。\nLock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作。\nLock是接口不能直接实例化，这里采用它的实现类ReentrantLock来构建Lock锁对象。\n\n\n\n\n方法名称\n说明\n\n\n\npublic ReentrantLock()\n获得Lock锁的实现类对象\n\n\nLock的API\n\n\n\n方法名称\n说明\n\n\n\nvoid lock()\n获得锁\n\n\nvoid unlock()\n释放锁\n\n\npublic void drawMoney(double money) &#123;\n        // 1、拿到是谁来取钱\n        String name = Thread.currentThread().getName();\n        // 2、判断余额是否足够\n        // 小明  小红\n        lock.lock(); // 上锁\n        try &#123;\n            if(this.money &gt;= money)&#123;\n                // 钱够了\n                System.out.println(name+&quot;来取钱，吐出：&quot; + money);\n                // 更新余额\n                this.money -= money;\n                System.out.println(name+&quot;取钱后，余额剩余：&quot; + this.money);\n            &#125;else&#123;\n                // 3、余额不足\n                System.out.println(name+&quot;来取钱，余额不足！&quot;);\n            &#125;\n        &#125; finally &#123;\n            lock.unlock(); // 解锁\n        &#125;\n\n    &#125;\n\n\n5、线程通信所谓线程通信就是线程间相互发送数据，线程间共享一个资源即可实现线程通信。\n线程通信常见形式\n\n通过共享一个数据的方式实现。\n根据共享数据的情况决定自己该怎么做，以及通知其他线程怎么做。\n\n线程通信实际应用场景\n\n生产者与消费者模型:生产者线程负责生产数据，消费者线程负责消费生产者产生的数据。\n要求:生产者线程生产完数据后唤醒消费者，然后等待自己，消费者消费完该数据后唤醒生产者，然后等待自己。\n\nObject类的等待和唤醒方法:\n\n\n\n方法名称\n说明\n\n\n\nvoid wait()\n让当前线程等待并释放所占锁，直到另一个线程调用notify()方法或notifyAll()\n\n\nvoid notify()\n唤醒正在等待的单个线程\n\n\nvoid notifyAll()\n唤醒正在等待的所有线程\n\n\n注意：上述方法应该使用当前同步锁对象进行调用。\n\n\n\n\n6、线程池6.1 线程池概述&#x3D;&#x3D;线程池就是一个可以复用线程的技术。&#x3D;&#x3D;\n不使用线程池，如果用户每发起一个请求，后台就创建一个新线程来处理，下次新任务来了又要创建新线程，而创建新线程的开销是很大的，这样会严重影响系统的性能。\n6.2 线程池相关APIJDK 5.0起提供了代表线程池的接口: ExecutorService\n如何得到线程池对象\n\n方式一:使用ExecutorService的实现类ThreadPoolExecutor自创建一个线程池对象\n方式二:使用Executors（线程池的工具类）调用方法返回不同特点的线程池对象\n\n\npublic class ThreadPoolDemo1 &#123;\n    public static void main(String[] args) &#123;\n        // 1、创建线程池对象\n        ExecutorService pool = new ThreadPoolExecutor(3, 5 ,\n                6, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(5) , Executors.defaultThreadFactory(),\n               new ThreadPoolExecutor.AbortPolicy() );\n\n        // 2、给任务线程池处理。\n        Runnable target = new MyRunnable();\n        pool.execute(target);\n        pool.execute(target);\n        pool.execute(target);\n\n        pool.execute(target);\n        pool.execute(target);\n        pool.execute(target);\n        pool.execute(target);\n        pool.execute(target);\n\n        // 创建临时线程\n        pool.execute(target);\n        pool.execute(target);\n//        // 不创建，拒绝策略被触发！！！\n//        pool.execute(target);\n\n        // 关闭线程池（开发中一般不会使用）。\n        // pool.shutdownNow(); // 立即关闭，即使任务没有完成，会丢失任务的！\n        pool.shutdown(); // 会等待全部任务执行完毕之后再关闭（建议使用的）\n    &#125;\n&#125;\n\n&#x3D;&#x3D;新任务提交时发现核心线程都在忙，任务队列也满了，并且还可以创建临时线程，此时才会创建临时线程。&#x3D;&#x3D;\n&#x3D;&#x3D;核心线程和临时线程都在忙，任务队列也满了，新的任务过来的时候才会开始任务拒绝。&#x3D;&#x3D;\n6.3 线程池处理任务ExecutorService的常用方法\n\n\n\n方法名称\n说明\n\n\n\nvoid execute(Runnable command)\n执行任务&#x2F;命令，没有返回值，一般用来执行 Runnable 任务\n\n\nFuture&lt; T &gt; submit(Callable&lt; T &gt; task)\n执行任务，返回未来任务对象获取线程结果，一般拿来执行callable任务\n\n\nvoid shutdown()\n等任务执行完毕后关闭线程池\n\n\nList&lt; Runnable &gt; shutdownNow()\n立刻关闭，停止正在执行的任务，并返回队列中未执行的任务\n\n\n新任务拒绝策略\n\n\n\n策略\n详解\n\n\n\nThreadPoolExecutor.AbortPolicy\n丢弃任务并抛出RejectedExecutionException异常。是默认的策略\n\n\nThreadPoolExecutor.DiscardPolicy:\n丢弃任务，但是不抛出异常这是不推荐的做法\n\n\nThreadPoolExecutor.DiscardOldestpolicy\n抛弃队列中等待最久的任务然后把当前任务加入队列中\n\n\nThreadPoolExecutor.callerRunsPolicy\n由主线程负责调用任务的run()方法从而绕过线程池直接执行\n\n\n线程池处理Runnable任务\n\n\n\npublic class MyRunnable implements Runnable&#123;\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 5; i++) &#123;\n            System.out.println(Thread.currentThread().getName() + &quot;输出了：HelloWorld ==&gt; &quot;  + i);\n        &#125;\n        try &#123;\n            System.out.println(Thread.currentThread().getName() + &quot;本任务与线程绑定了，线程进入休眠了~~~&quot;);\n            Thread.sleep(10000000);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n线程池处理Callable任务\nimport java.util.concurrent.Callable;\n\n/**\n    1、定义一个任务类 实现Callable接口  应该申明线程任务执行完毕后的结果的数据类型\n */\npublic class MyCallable implements Callable&lt;String&gt;&#123;\n    private int n;\n    public MyCallable(int n) &#123;\n        this.n = n;\n    &#125;\n\n    /**\n       2、重写call方法（任务方法）\n     */\n    @Override\n    public String call() throws Exception &#123;\n        int sum = 0;\n        for (int i = 1; i &lt;= n ; i++) &#123;\n            sum += i;\n        &#125;\n        return Thread.currentThread().getName()\n                + &quot;执行 1-&quot; + n+ &quot;的和，结果是：&quot; + sum;\n    &#125;\n&#125;\n\n6.4 Executors工具类实现线程池Executors得到线程池对象的常用方法\nExecutors:线程池的工具类通过调用方法返回不同类型的线程池对象。\n\n\n\n方法名称\n说明\n\n\n\npublic static ExecutorService newCachedThreadPool()\n线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了一段时间则会被回收掉。\n\n\npublic static ExecutorService newFixedThreadPool(int nThreads)\n创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程替代它。\n\n\npublic static Executorservice newSingleThreadExecutor ()\n创建只有一个线程的线程池对象，如果该线程出现异常而结束，那么线程池会补充一个新线程。\n\n\npublic static ScheduledExecutorService newScheduledThreadPool(intcorePoolSize)\n创建一个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务。\n\n\n注意:Executors的底层其实也是基于线程池的实现类ThreadPoolExecutor创建线程池对象的。\nExecutors使用可能存在的陷阱大型并发系统环境中使用Executors如果不注意可能会出现系统风险。\n\n\n\n方法名称\n存在问题\n\n\n\npublic static ExecutorService newFixedThreadPool(int nThreads) \\\\ public static ExecutorService newSingleThreadExecutor()\n允许请求的任务队列长度是Integer.MAX_VALUE，可能出现OOM错误( java.lang.OutOfMemoryError )\n\n\npublic static ExecutorService newCachedThreadPool() \\\\ public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)\n创建的线程数量最大上限是Integer.MAX_VALUE,线程数可能会随着任务1:1增长，也可能出现OOM错误( java.lang.OutOfMemoryError）\n\n\n\n7、定时器\n定时器是一种控制任务延时调用，或者周期调用的技术。\n作用:闹钟、定时邮件发送。\n\n定时器的实现方式\n\n方式一: Timer\n方式二: ScheduledExecutorService\n\nTimer定时器\n\n\n\n构造\n说明\n\n\n\npublic Timer()\n创建Timer定时器对象\n\n\n\n\n\n方法\n说明\n\n\n\npublic void schedule(TimerTask task，long delay,long period)\n开启一个定时器,按照计划处理TimerTask任务\n\n\nimport java.util.Date;\nimport java.util.Timer;\nimport java.util.TimerTask;\n\n\npublic class TimerDemo1 &#123;\n    public static void main(String[] args) &#123;\n        // 1、创建Timer定时器\n        Timer timer = new Timer();  // 定时器本身就是一个单线程。\n        // 2、调用方法，处理定时任务\n        timer.schedule(new TimerTask() &#123;\n            @Override\n            public void run() &#123;\n                System.out.println(Thread.currentThread().getName() + &quot;执行AAA~~~&quot; + new Date());\n            &#125;\n        &#125;, 0, 2000);\n\n        timer.schedule(new TimerTask() &#123;\n            @Override\n            public void run() &#123;\n                System.out.println(Thread.currentThread().getName() + &quot;执行BB~~~&quot;+ new Date());\n                System.out.println(10/0);\n            &#125;\n        &#125;, 0, 2000);\n\n        timer.schedule(new TimerTask() &#123;\n            @Override\n            public void run() &#123;\n                System.out.println(Thread.currentThread().getName() + &quot;执行CCC~~~&quot;+ new Date());\n            &#125;\n        &#125;, 0, 3000);\n    &#125;\n&#125;\n\nTimer定时器的特点和存在的问题\n\nTimer是单线程，处理多个任务按照顺序执行，存在延时与设置定时器的时间有出入。\n可能因为其中的某个任务的异常使Timer线程死掉，从而影响后续任务执行。\n\nScheduledExecutorService定时器\nScheduledExecutorService是jdk1.5中引入了并发包，目的是为了弥补Timer的缺陷, ScheduledExecutorService内部为线程池。\n\n\n\nExecutors的方法\n说明\n\n\n\npublic static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)\n得到线程池对象\n\n\n\n\n\nScheduledExecutorService的方法\n说明\n\n\n\npublic ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command，long initialDelay， long period,TimeUnit unit)\n周期调度方法\n\n\nimport java.util.Date;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\n/**\n    目标：Timer定时器的使用和了解。\n */\npublic class TimerDemo2 &#123;\n    public static void main(String[] args) &#123;\n        // 1、创建ScheduledExecutorService线程池，做定时器\n        ScheduledExecutorService pool = Executors.newScheduledThreadPool(3);\n\n        // 2、开启定时任务\n        pool.scheduleAtFixedRate(new TimerTask() &#123;\n            @Override\n            public void run() &#123;\n                System.out.println(Thread.currentThread().getName() + &quot;执行输出：AAA  ==》 &quot; + new Date());\n                try &#123;\n                    Thread.sleep(100000);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;, 0, 2, TimeUnit.SECONDS);\n\n\n        pool.scheduleAtFixedRate(new TimerTask() &#123;\n            @Override\n            public void run() &#123;\n                System.out.println(Thread.currentThread().getName() + &quot;执行输出：BBB  ==》 &quot; + new Date());\n                System.out.println(10 / 0);\n            &#125;\n        &#125;, 0, 2, TimeUnit.SECONDS);\n\n\n        pool.scheduleAtFixedRate(new TimerTask() &#123;\n            @Override\n            public void run() &#123;\n                System.out.println(Thread.currentThread().getName() + &quot;执行输出：CCC  ==》 &quot; + new Date());\n            &#125;\n        &#125;, 0, 2, TimeUnit.SECONDS);\n\n    &#125;\n&#125;\n\nScheduledExecutorService的优点\n\n基于线程池，某个任务的执行情况不会影响其他定时任务的执行。\n\n\n8、并发、并行并发与并行\n\n正在运行的程序（软件）就是一个独立的进程，线程是属于进程的，多个线程其实是并发与并行同时进行的。\n\n并发的理解:\n\n&#x3D;&#x3D;CPU同时处理线程的数量有限。&#x3D;&#x3D;\n&#x3D;&#x3D;CPU会轮询为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发。【CPU分时轮询的执行过程】&#x3D;&#x3D;\n\n并行的理解:\n\n&#x3D;&#x3D;在同一个时刻上，同时有多个线程在被CPU处理并执行。【同一时刻同时在执行】&#x3D;&#x3D;\n\n\n\n9、线程的生命周期线程的状态:也就是线程从生到死的过程，以及中间经历的各种状态及状态转换。理解线程的状态有利于提升并发编程的理解能力。\n线程的6种状态总结\n\n\n\n线程状态\n描述\n\n\n\nNEW(新建)\n线程刚被创建，但是并未启动。\n\n\nRunnable(可运行)\n线程已经调用了start()等待CPU调度\n\n\nBlocked(锁阻塞)\n线程在执行的时候未竞争到锁对象，则该线程进入Blocked状态。\n\n\nWaiting(无限等待)\n一个线程进入Waiting状态，另一个线程调用notify或者notifyAll方法才能够唤醒\n\n\nTimed Waiting(计时等待)\n同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。带有超时参数的常用方法有Thread.sleep 、 Object.wait。\n\n\nTeminated(被终止)\n因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡\n\n\n\n","slug":"Java程序设计 -- 多线程基础（十八）","date":"2022-04-12T14:02:36.000Z","categories_index":"后端","tags_index":"Java","author_index":"会思想的苇草i"},{"id":"5dfd375e1addf174b025352719cc8bb2","title":"Java程序设计--输入输出流(下)","content":"\n1、缓冲流1.1 缓冲流概述\n缓冲流也称为高效流、或者高级流。之前学习的字节流可以称为原始流。\n&#x3D;&#x3D;作用:缓冲流自带缓冲区、可以提高原始字节流、字符流读写数据的性能。&#x3D;&#x3D;\n\n\n1.2 字节缓冲流字节缓冲流性能优化原理:\n\n字节缓冲输入流自带了8KB缓冲池，以后我们直接从缓冲池读取数据，所以性能较好。\n字节缓冲输出流自带了8KB缓冲池，数据就直接写入到缓冲池中去，写数据性能极高了。\n\n字节缓冲流\n\n字节缓冲输入流: BufferedInputStream，提高字节输入流读取数据的性能，读写功能上并无变化。\n字节缓冲输出流: BufferedOutputStream，提高字节输出流读取数据的性能，读写功能上并无变化。\n\n\n\n\n构造器\n说明\n\n\n\npublic BufferedInputStream(InputStream is)\n可以把低级的字节输入流包装成一个高级的缓冲字节输入流管道，从而提高字节输入流读数据的性能\n\n\npublic BufferedOutputStream(OutputStream os)\n可以把低级的字节输出流包装成一个高级的缓冲字节输出流，从而提高写数据的性能\n\n\nimport java.io.*;\n\n/**\n    使用字节缓冲流完成数据的读写操作。\n */\npublic class ByteBufferDemo &#123;\n    public static void main(String[] args) &#123;\n\n        try (\n                // 这里面只能放置资源对象，用完会自动关闭：自动调用资源对象的close方法关闭资源（即使出现异常也会做关闭操作）\n                // 1、创建一个字节输入流管道与原视频接通\n                InputStream is = new FileInputStream(&quot;D:\\\\resources\\\\demo.jpeg&quot;);\n                // a.把原始的字节输入流包装成高级的缓冲字节输入流\n                InputStream bis = new BufferedInputStream(is);\n                // 2、创建一个字节输出流管道与目标文件接通\n                OutputStream os = new FileOutputStream(&quot;D:\\\\resources\\\\demo222.jpeg&quot;);\n                // b.把字节输出流管道包装成高级的缓冲字节输出流管道\n                OutputStream bos = new BufferedOutputStream(os);\n\n        ) &#123;\n\n            // 3、定义一个字节数组转移数据\n            byte[] buffer = new byte[1024];\n            int len; // 记录每次读取的字节数。\n            while ((len = bis.read(buffer)) != -1)&#123;\n                bos.write(buffer, 0 , len);\n            &#125;\n            System.out.println(&quot;复制完成了！&quot;);\n\n        &#125; catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;\n\n    &#125;\n&#125;\n\n1.3 字符缓冲流概述字符缓冲输入流:BufferedReader。\n\n作用:提高字符输入流读取数据的性能，除此之外多了按照行读取数据的功能。\n\n\n\n\n构造器\n说明\n\n\n\npublic BufferedReader( Reader r)\n可以把低级的字符输入流包装成一个高级的缓冲字符输入流管道，从而提高字符输入流读数据的性能\n\n\n字符缓冲输入流新增功能\n\n\n\n方法\n说明\n\n\n\npublic String readLine()\n读取一行数据返回，如果读取没有完毕，无行可读返回null\n\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.Reader;\n\n/**\n    学会使用缓冲字符输入流提高字符输入流的性能，新增了按照行读取的方法(经典代码)\n */\npublic class BufferedReaderDemo1 &#123;\n    public static void main(String[] args) &#123;\n        try (\n                // 1、创建一个文件字符输入流与源文件接通。\n                Reader fr = new FileReader(&quot;io-app2/src/data01.txt&quot;);\n                // a、把低级的字符输入流包装成高级的缓冲字符输入流。\n                BufferedReader br = new BufferedReader(fr);\n                )&#123;\n              String line;\n              while ((line = br.readLine()) != null)&#123;\n                  System.out.println(line);\n              &#125;\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n字符缓冲输出流:BufferedWriter。\n\n作用:提高字符输出流写取数据的性能，除此之外多了换行功能\n\n\n\n\n构造器\n说明\n\n\n\npublic BufferedWriter(Writer w)\n可以把低级的字符输出流包装成一个高级的缓冲字符输出流管道，从而提高字符输出流写数据的性能\n\n\n字符缓冲输出流新增功能\n\n\n\n方法\n说明\n\n\n:-:\n:-:\n\n\npublic void newLine()\n换行操作\n\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.Writer;\n\n/**\n        缓冲字符输出流的使用，学会它多出来的一个功能：newLine();\n */\npublic class BufferedWriterDemo2 &#123;\n    public static void main(String[] args) throws Exception &#123;\n        // 1、创建一个字符输出流管道与目标文件接通\n        Writer fw = new FileWriter(&quot;io-app2/src/out02.txt&quot;); // 覆盖管道，每次启动都会清空文件之前的数据\n       //Writer fw = new FileWriter(&quot;io-app2/src/out02.txt&quot;, true); // 追加数据\n        BufferedWriter bw = new BufferedWriter(fw);\n\n//      a.public void write(int c):写一个字符出去\n        bw.write(98);\n        bw.write(&#39;a&#39;);\n        bw.write(&#39;徐&#39;); // 不会出问题了\n        bw.newLine(); // bw.write(&quot;\\r\\n&quot;); // 换行\n\n//       b.public void write(String c)写一个字符串出去\n        bw.write(&quot;abc我是中国人&quot;);\n        bw.newLine(); // bw.write(&quot;\\r\\n&quot;); // 换行\n\n\n//       c.public void write(char[] buffer):写一个字符数组出去\n        char[] chars = &quot;abc我是中国人&quot;.toCharArray();\n        bw.write(chars);\n        bw.newLine(); // bw.write(&quot;\\r\\n&quot;); // 换行\n\n\n//       d.public void write(String c ,int pos ,int len):写字符串的一部分出去\n        bw.write(&quot;abc我是中国人&quot;, 0, 5);\n        bw.newLine(); // bw.write(&quot;\\r\\n&quot;); // 换行\n\n//       e.public void write(char[] buffer ,int pos ,int len):写字符数组的一部分出去\n        bw.write(chars, 3, 5);\n        bw.newLine(); // bw.write(&quot;\\r\\n&quot;); // 换行\n\n\n        // fw.flush();// 刷新后流可以继续使用\n        bw.close(); // 关闭包含刷线，关闭后流不能使用\n\n    &#125;\n&#125;\n\n\n2、转换流2.1 字符输入转换流字符输入转换流: InputStreamReader，可以把原始的字节流按照指定编码转换成字符输入流。&#x3D;&#x3D;可以解决字符流读取不同编码乱码问题。&#x3D;&#x3D;\n\n\n\n构造器\n说明\n\n\n\npublic InputStreamReader(InputStream is)\n可以把原始的字节流按照代码默认编码转换成字符输入流。几乎不用，与默认的FileReader—样。\n\n\npublic InputStreamReader(InputStream is , String charset)\n可以把原始的字节流按照指定编码转换成字符输入流，这样字符流中的字符就不乱码了(重点)\n\n\nimport java.io.*;\n\npublic class InputStreamReaderDemo &#123;\n    public static void main(String[] args) throws Exception &#123;\n        // 代码UTF-8   文件 GBK  &quot;D:\\\\resources\\\\data.txt&quot;\n        // 1、提取GBK文件的原始字节流。   abc 我\n        //                            ooo oo\n        InputStream is = new FileInputStream(&quot;D:\\\\resources\\\\data.txt&quot;);\n        // 2、把原始字节流转换成字符输入流\n        // Reader isr = new InputStreamReader(is); // 默认以UTF-8的方式转换成字符流。 还是会乱码的  跟直接使用FileReader是一样的\n        Reader isr = new InputStreamReader(is , &quot;GBK&quot;); // 以指定的GBK编码转换成字符输入流  完美的解决了乱码问题\n\n        BufferedReader br = new BufferedReader(isr);\n        String line;\n        while ((line = br.readLine()) != null)&#123;\n            System.out.println(line);\n        &#125;\n    &#125;\n&#125;\n\n2.2 字符输出转换流字符输入转换流:OutputStreamWriter，可以把字节输出流按照指定编码转换成字符输出流。\n\n\n\n构造器\n说明\n\n\n\npublic OutputStreamWriter(OutputStream os)\n可以把原始的字节输出流按照代码默\n\n\npublic OutputStreamWriter(OutputStream os，String charset)\n可以把原始的字节输出流按照指定编码转换成字符输出流(重点)\n\n\nimport java.io.*;\nimport java.nio.Buffer;\n\npublic class OutputStreamWriterDemo &#123;\n    public static void main(String[] args) throws Exception &#123;\n        // 1、定义一个字节输出流\n        OutputStream os = new FileOutputStream(&quot;io-app2/src/out03.txt&quot;);\n\n        // 2、把原始的字节输出流转换成字符输出流\n        // Writer osw = new OutputStreamWriter(os); // 以默认的UTF-8写字符出去 跟直接写FileWriter一样\n        Writer osw = new OutputStreamWriter(os , &quot;GBK&quot;); // 指定GBK的方式写字符出去\n\n        // 3、把低级的字符输出流包装成高级的缓冲字符输出流。\n        BufferedWriter bw = new BufferedWriter(osw);\n\n        bw.write(&quot;我爱中国1~~&quot;);\n        bw.write(&quot;我爱中国2~~&quot;);\n        bw.write(&quot;我爱中国3~~&quot;);\n\n        bw.close();\n    &#125;\n&#125;\n\n\n3、序列化对象3.1 对象序列化\n对象序列化:\n\n作用:以内存为基准，把内存中的对象存储到磁盘文件中去，称为对象序列化(对象必须实现序列化接口)。\n使用到的流是对象字节输出流:ObjectOutputStream\n\n\n使用到的流是对象字节输出流:ObjectOutputStream\n\n\n\n构造器\n说明\n\n\n\npublic ObjectOutputstream(Outputstream out)\n把低级字节输出流包装成高级的对象字节输出流\n\n\nObjectOutputStream序列化方法\n\n\n\n方法名称\n说明\n\n\n:-:\n:-:\n\n\npublic final void writeObject(object obj)\n把对象写出去到对象序列化流的文件中去\n\n\nimport java.io.Serializable;\n\n/**\n  对象如果要序列化，必须实现Serializable序列化接口。\n */\npublic class Student implements Serializable &#123;\n    // 申明序列化的版本号码\n    // 序列化的版本号与反序列化的版本号必须一致才不会出错！\n    private static final long serialVersionUID = 1;\n    private String name;\n    private String loginName;\n    // transient修饰的成员变量不参与序列化了\n    private transient String passWord;\n    private int age ;\n\n    public Student()&#123;\n    &#125;\n\n    public Student(String name, String loginName, String passWord, int age) &#123;\n        this.name = name;\n        this.loginName = loginName;\n        this.passWord = passWord;\n        this.age = age;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public String getLoginName() &#123;\n        return loginName;\n    &#125;\n\n    public void setLoginName(String loginName) &#123;\n        this.loginName = loginName;\n    &#125;\n\n    public String getPassWord() &#123;\n        return passWord;\n    &#125;\n\n    public void setPassWord(String passWord) &#123;\n        this.passWord = passWord;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Student&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, loginName=&#39;&quot; + loginName + &#39;\\&#39;&#39; +\n                &quot;, passWord=&#39;&quot; + passWord + &#39;\\&#39;&#39; +\n                &quot;, age=&quot; + age +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n\nimport java.io.FileOutputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.PrintStream;\n\npublic class ObjectOutputStreamDemo &#123;\n    public static void main(String[] args) throws Exception &#123;\n        // 1、创建学生对象\n        Student s = new Student(&quot;陈磊&quot;, &quot;chenlei&quot;,&quot;1314520&quot;, 21);\n\n        // 2、对象序列化：使用对象字节输出流包装字节输出流管道\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;io-app2/src/obj.txt&quot;));\n\n        // 3、直接调用序列化方法\n        oos.writeObject(s);\n\n        // 4、释放资源\n        oos.close();\n        System.out.println(&quot;序列化完成了~~&quot;);\n\n    &#125;\n&#125;\n\n3.2对象反序列化对象反序列化:\n\n使用到的流是对象字节输入流:ObjectlnputStream\n作用:以内存为基准，把存储到磁盘文件中去的对象数据恢复成内存中的对象，称为对象反序列化。\n\n\n\n\n构造器\n说明\n\n\n\npublic objectInputstream(Inputstream out)\n把低级字节输如流包装成高级的对象字节输入流\n\n\nobjectInputStream序列化方法\n\n\n\n方法名称\n说明\n\n\n\npublic Obiect readObiect()\n把存储到磁盘文件中去的对象数据恢复成内存中的对象返回\n\n\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.ObjectInputStream;\n\n/**\n    目标：学会进行对象反序列化：使用对象字节输入流把文件中的对象数据恢复成内存中的Java对象。\n */\npublic class ObjectInputStreamDemo &#123;\n    public static void main(String[] args) throws Exception &#123;\n        // 1、创建对象字节输入流管道包装低级的字节输入流管道\n        ObjectInputStream is = new ObjectInputStream(new FileInputStream(&quot;io-app2/src/obj.txt&quot;));\n\n        // 2、调用对象字节输入流的反序列化方法\n        Student s = (Student) is.readObject();\n\n        System.out.println(s);\n    &#125;\n&#125;\n\n\n4、打印流4.1 PrintStream、PrintWriter\n打印流\n\n作用: &#x3D;&#x3D;打印流可以实现方便、高效的打印数据到文件中去。&#x3D;&#x3D; 打印流一般是指: PrintStream，PrintWriter两个类。\n可以实现打印什么数据就是什么数据，例如打印整数97写出去就是97，打印boolean的true，写出去就是true。\n\nPrintStream\n\n\n\n构造器\n说明\n\n\n\npublic PrintStream(OutputStream os)\n打印流直接通向字节输出流管道\n\n\npublic printStream(File f)\n打印流直接通向文件对象\n\n\npublic PrintStream(String filepath)\n打印流直接通向文件路径\n\n\n\n\n\n方法\n说明\n\n\n\npublic void print(Xxx xx)\n打印任意类型的数据出去\n\n\nPrintWriter\n\n\n\n构造器\n说明\n\n\n\npublic Printwriter(OutputStream os)\n打印流直接通向字节输出流管道\n\n\npublic printwriter (Writer w)\n打印流直接通向字符输出流管道\n\n\npublic Printwriter (File f)\n打印流直接通向文件对象\n\n\npublic Printwriter (String filepath)\n打印流直接通向文件路径\n\n\n\n\n\n方法\n说明\n\n\n\npublic void print(Xxx xx)\n打印任意类型的数据出去\n\n\nPrintStream和PrintWriter的区别\n\n打印数据功能上是一模一样的，都是使用方便，性能高效（核心优势)\nPrintStream继承自字节输出流OutputStream，支持写字节数据的方法。\nPrintWriter继承自字符输出流Writer，支持写字符数据出去。\n\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\n\n/**\n    学会使用打印流 高效  方便写数据到文件。\n */\npublic class PrintDemo &#123;\n    public static void main(String[] args) throws Exception &#123;\n        PrintWriter ps = new PrintWriter(&quot;io-app2/src/ps.txt&quot;); // 打印功能上与PrintStream的使用没有区别\n\n        ps.println(97);\n        ps.println(&#39;a&#39;);\n        ps.println(23.3);\n        ps.println(true);\n        ps.println(&quot;我是打印流输出的，我是啥就打印啥&quot;);\n\n        ps.close();\n    &#125;\n&#125;\n\n4.2 输出语句的重定向属于打印流的一种应用，可以把输出语句的打印位置改到文件。\nimport java.io.FileOutputStream;\nimport java.io.PrintStream;\n\n/**\n    目标：了解改变输出语句的位置到文件\n */\npublic class PrintDemo2 &#123;\n    public static void main(String[] args) throws Exception &#123;\n        System.out.println(&quot;锦瑟无端五十弦&quot;);\n        System.out.println(&quot;一弦一柱思华年&quot;);\n\n        // 改变输出语句的位置（重定向）\n        PrintStream ps = new PrintStream(&quot;io-app2/src/log.txt&quot;);\n        System.setOut(ps); // 把系统打印流改成我们自己的打印流\n\n        System.out.println(&quot;庄生晓梦迷蝴蝶&quot;);\n        System.out.println(&quot;望帝春心托杜鹃&quot;);\n    &#125;\n&#125;\n\n\n5、Properties\nProperties属性集对象\n\n其实就是一个Map集合，但是我们一般不会当集合使用，因为HashMap更好用。\n\nProperties核心作用:\n\nProperties代表的是一个属性文件，可以把自己对象中的键值对信息存入到一个属性文件中去。\n属性文件:后缀是.properties结尾的文件,里面的内容都是key&#x3D;value，后续做系统配置信息的。\n\nProperties的API:\nProperties和IO流结合的方法:\n\n\n\n构造器\n说明\n\n\n\nvoid load(InputStream inStream)\n从输入字节流读取属性列表(键和元素对)\n\n\nvoid load(Reader reader)\n从输入字符流读取属性列表（键和元素对)\n\n\nvoid store(OutputStream out，String comments)\n将此属性列表（键和元素对)写入此 Properties表中，以适合于使用load(InputStream)\n\n\nvoid store(Writer writer,String comments)\n将此属性列表（键和元素对)写入此 Properties表中以适合使用load(Reader)方法的格式写入输出字符流\n\n\npublic object setProperty(String key，String value)\n保存键值对(put)\n\n\npublic object setProperty(String key)\n使用此属性列表中指定的键搜索属性值(get)\n\n\npublic Set&lt; string &gt; stringPropertyNames()\n所有键的名称的集合(keySet())\n\n\nimport java.io.FileWriter;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Scanner;\n\n\npublic class PropertiesDemo &#123;\n    public static void main(String[] args) throws Exception &#123;\n        // 需求：使用Properties把键值对信息存入到属性文件中去。\n        Properties properties = new Properties();\n        properties.setProperty(&quot;admin&quot;, &quot;123456&quot;);\n        properties.setProperty(&quot;dlei&quot;, &quot;003197&quot;);\n        properties.setProperty(&quot;heima&quot;, &quot;itcast&quot;);\n        System.out.println(properties);\n\n        /**\n           参数一：保存管道 字符输出流管道\n           参数二：保存心得\n         */\n        properties.store(new FileWriter(&quot;io-app2/src/users.properties&quot;)\n                , &quot;this is users!! i am very happy! give me 100!&quot;);\n\n    &#125;\n&#125;\n\n\n6、IO框架commons-io概述\n\ncommons-io是apache开源基金组织提供的一组有关IO操作的类库，可以提高IO功能开发的效率。\ncommons-io工具包提供了很多有关io操作的类。有两个主要的类FileUtils, IOUtils\n\nFileUtils主要有如下方法:\n\n\n\n方法名\n说明\n\n\n\nString readFileToString(File file，string encoding)\n读取文件中的数据,返回字符串。\n\n\nvoid copyFile(File srcFile，File destFile)\n复制文件。\n\n\nvoid copyDirectoryToDirectory(File srcDir，File destDir)\n复制文件夹。\n\n\n\n","slug":"Java程序设计 -- 输入输出流（下）（十七）","date":"2022-04-04T07:22:51.000Z","categories_index":"后端","tags_index":"Java","author_index":"会思想的苇草i"},{"id":"b7639bc085f01665e0869b23fc927b0f","title":"Java程序设计--输入输出流(上)","content":"\n1、字符集1.1 常见字符集介绍字符集基础知识:\n计算机底层不可以直接存储字符的。计算机中底层只能存储二进制(0、1)二进制是可以转换成十进制的。\n计算机底层可以表示十进制编号。计算机可以给人类字符进行编号存储，这套编号规则就是字符集。\nASCII字符集:\n\nASCII(American Standard Code for Information Interchange，美国信息交换标准代码):包括了数字、英文、符号。\n&#x3D;&#x3D;ASCII使用1个字节存储一个字符，一个字节是8位&#x3D;&#x3D;，总共可以表示128个字符信息，对于英文，数字来说是够用的。\n\nGBK:   \n\nwindow系统默认的码表。兼容ASCII码表，也包含了几万个汉字，并支持繁体汉字以及部分日韩文字。\n注意:GBK是中国的码表，&#x3D;&#x3D;一个中文以两个字节的形式存储&#x3D;&#x3D;。但不包含世界上所有国家的文字。\n\nUnicode码表:\n\nunicode (又称统一码、万国码、单一码）是计算机科学领域里的一项业界字符编码标准。容纳世界上大多数国家的所有常见文字和符号，&#x3D;&#x3D;一个中文一般以三个字节的形式存储&#x3D;&#x3D; 。\n由于Unicode会先通过UTF-8，UTF-16，以及UTF-32的编码成二进制后再存储到计算机，其中最为常见的就是UTF-8。\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.Arrays;\n\n/**\n    学会自己进行文字的编码和解码，为以后可能用到的场景做准备。\n */\npublic class Test &#123;\n    public static void main(String[] args) throws Exception &#123;\n        // 1、编码：把文字转换成字节（使用指定的编码）\n        String name = &quot;abc我爱你中国&quot;;\n        // byte[] bytes = name.getBytes(); // 以当前代码默认字符集进行编码 （UTF-8）\n        byte[] bytes = name.getBytes(&quot;GBK&quot;); // 指定编码\n        System.out.println(bytes.length);\n        System.out.println(Arrays.toString(bytes));\n\n        // 2、解码：把字节转换成对应的中文形式（编码前 和 编码后的字符集必须一致，否则乱码 ）\n        // String rs = new String(bytes); // 默认的UTF-8\n        String rs = new String(bytes, &quot;GBK&quot;); // 指定GBK解码\n        System.out.println(rs);\n    &#125;\n&#125;\n\n1.2 字符集的编码、解码操作String编码\n\n\n\n方法名称\n说明\n\n\n\nbyte[ ] getBytes()\n使用平台的默认字符集将该String编码为一系列字节，将结果存储到新的字节数组中\n\n\nbyte[ ] getBytes(String charsetName)\n使用指定的字符集将该String编码为一系列字节，将结果存储到新的字节数组中\n\n\nString解码\n\n\n\n构造器\n说明\n\n\n\nString(byte[ ] bytes)\n通过使用平台的默认字符集解码指定的字节数组来构造新的String\n\n\nString(byte[ ] bytes，string charsetName)\n通过指定的字符集解码指定的字节数组来构造新的String\n\n\n\n2、IO流概述IO也称为输入、输出流，就是用来读写数据的。\n\n&#x3D;&#x3D;I表示intput，是数据从硬盘文件读入到内存的过程，称之输入，负责读。&#x3D;&#x3D;\n&#x3D;&#x3D;O表示output，是内存程序的数据从内存到写出到硬盘文件的过程，称之输出，负责写。&#x3D;&#x3D;\n\nIO流的分类\n\n\n总结流的四大类:\n\n字节输入流: 以内存为基准，来自磁盘文件&#x2F;网络中的数据以字节的形式读入到内存中去的流称为字节输入流。\n字节输出流: 以内存为基准，把内存中的数据以字节写出到磁盘文件或者网络中去的流称为字节输出流。\n字符输入流: 以内存为基准，来自磁盘文件&#x2F;网络中的数据以字符的形式读入到内存中去的流称为字符输入流。\n字符输出流: 以内存为基准，把内存中的数据以字符写出到磁盘文件或者网络介质中去的流称为字符输出流。\n\n\n\n3、字节流的使用3.1 文字字节输入流\n文件字节输入流:FilelnputStream\n作用:以内存为基准，把磁盘文件中的数据以字节的形式读取到内存中去。\n\n\n\n构造器\n说明\n\n\n\npublic FileInputStream(File file)创建字节\n输入流管道与源文件对象接通\n\n\npublic FileInputStream(String pathname)\n创建字节输入流管道与源文件路径接通\n\n\n\n\n\n方法名称\n说明\n\n\n\npublic int read()\n每次读取一个字节返回，如果字节已经没有可读的返回-1\n\n\npublic int read(byte[] buffer)\n每次读取一个字节数组返回，如果字节已经没有可读的返回-1\n\n\n读取一个字节，性能较慢，读取中文字符输出无法避免乱码问题。\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\n\npublic class FileInputStreamDemo01 &#123;\n    public static void main(String[] args) throws Exception &#123;\n        // 创建一个文件字节输入流管道与源文件接通。\n        InputStream is = new FileInputStream(&quot;file-io-app\\\\src\\\\data.txt&quot;);\n        int b;\n        while (( b = is.read() ) != -1)&#123;\n            System.out.print((char) b);\n        &#125;\n    &#125;\n&#125;\n\n读取一个字节数组读取性能得到了提升，读取中文字符输出无法避免乱码问题。\nimport java.io.FileInputStream;\nimport java.io.InputStream;\n\npublic class FileInputStreamDemo02 &#123;\n    public static void main(String[] args) throws Exception &#123;\n        // 创建一个文件字节输入流管道与源文件接通\n        InputStream is = new FileInputStream(&quot;file-io-app/src/data02.txt&quot;);\n        \n        byte[] buffer = new byte[3];\n        int len; // 记录每次读取的字节数。\n        while ((len = is.read(buffer)) != -1) &#123;\n            // 读取多少倒出多少\n            System.out.print(new String(buffer, 0 , len));\n        &#125;\n    &#125;\n&#125;\n\n为了实现使用字节输入流读取中文内容不乱码，定义一个与文件一样大的字节数组，一次性读取完文件的全部字节。如果文件过大，字节数组可能引起内存溢出。\n方式一\n自己定义一个字节数组与文件的大小一样大，然后使用读取字节数组的方法，一次性读取完成。\n\n\n\n方法名称\n说明\n\n\n\npublic int read(byte[] buffer)\n每次读取一个字节数组返回，如果字节已经没有可读的返回-1\n\n\n方式二\n官方为字节输入流InputStream提供了如下API可以直接把文件的全部数据读取到一个字节数组中。\n\n\n\n方法名称\n说明\n\n\n\npublic byte[]readAllBytes() throws IOException\n直接将当前字节输入流对应的文件对象的字节数据装到一个字节数组返回\n\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\n\n/**\n   使用文件字节输入流一次读完文件的全部字节。可以解决乱码问题。\n */\npublic class FileInputStreamDemo03 &#123;\n    public static void main(String[] args) throws Exception &#123;\n        //创建一个文件字节输入流管道与源文件接通\n        File f = new File(&quot;file-io-app/src/data03.txt&quot;);\n        InputStream is = new FileInputStream(f);\n\n        // 读取全部字节数组\n        byte[] buffer = is.readAllBytes();\n        System.out.println(new String(buffer));\n\n    &#125;\n&#125;\n\n3.2 文件字节输出流\n作用:以内存为基准，把内存中的数据以字节的形式写出到磁盘文件中去的流。\n\n\n\n构造器\n说明\n\n\n\npublic FileoutputStream(File file)\n创建字节输出流管道与源文件对象接通\n\n\npublic FileOutputStream(File file, boolean append)\n创建字节输出流管道与源文件对象接通，可追加数据\n\n\npublic Fileoutputstream(String filepath)\n创建字节输出流管道与源文件路径接通\n\n\npublic FileOutputstream(String filepath, boolean append)\n创建字节输出流管道与源文件路径接通，可追加数据\n\n\n文件字节输出流(FileOutputStream)写数据出去的API\n\n\n\n方法名称\n说明\n\n\n\npublic void write(int a)\n写一个字节出去\n\n\npublic void write(byte[ ] buffer)\n写一个字节数组出去\n\n\npublic void write(byte[ ] buffer , int pos , int len)\n写一个字节数组的一部分出去\n\n\n流的关闭与刷新\n\n\n\n方法\n说明\n\n\n\nflush()\n刷新流，还可以继续写数据\n\n\nclose()\n关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据\n\n\n字节输出流实现写出去的数据能换行：os.write(“\\r\\n” .getBytes())\n让写出去的数据能成功生效：\n\n&#x3D;&#x3D;flush()刷新数据&#x3D;&#x3D;\n&#x3D;&#x3D;close()方法是关闭流，关闭包含刷新，关闭后流不可以继续使用了&#x3D;&#x3D;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.OutputStream;\n\npublic class OutputStreamDemo &#123;\n    public static void main(String[] args) throws Exception &#123;\n        // 1、创建一个文件字节输出流管道与目标文件接通\n        OutputStream os = new FileOutputStream(&quot;file-io-app/src/out04.txt&quot; , true); // 追加数据管道\n//        OutputStream os = new FileOutputStream(&quot;file-io-app/src/out04.txt&quot;); // 先清空之前的数据，写新数据进入\n\n        // 2、写数据出去\n        // a.public void write(int a):写一个字节出去\n        os.write(&#39;a&#39;);\n        os.write(98);\n        os.write(&quot;\\r\\n&quot;.getBytes()); // 换行\n        // os.write(&#39;徐&#39;); // [ooo]\n\n        // b.public void write(byte[] buffer):写一个字节数组出去。\n        byte[] buffer = &#123;&#39;a&#39; , 97, 98, 99&#125;;\n        os.write(buffer);\n        os.write(&quot;\\r\\n&quot;.getBytes()); // 换行\n\n        byte[] buffer2 = &quot;我是中国人&quot;.getBytes();\n//        byte[] buffer2 = &quot;我是中国人&quot;.getBytes(&quot;GBK&quot;);\n        os.write(buffer2);\n        os.write(&quot;\\r\\n&quot;.getBytes()); // 换行\n\n\n        // c. public void write(byte[] buffer , int pos , int len):写一个字节数组的一部分出去。\n        byte[] buffer3 = &#123;&#39;a&#39;,97, 98, 99&#125;;\n        os.write(buffer3, 0 , 3);\n        os.write(&quot;\\r\\n&quot;.getBytes()); // 换行\n\n        // os.flush(); // 写数据必须，刷新数据 可以继续使用流\n        os.close(); // 释放资源，包含了刷新的！关闭后流不可以使用了\n    &#125;\n&#125;\n\n3.3 文件拷贝需求:\n把某个视频复制到其他目录下的“b.avi”\n思路:\n\n根据数据源创建字节输入流对象\n根据目的地创建字节输出流对象\n读写数据，复制视频\n释放资源\n\n\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\n/**\n *   学会使用字节流完成文件的复制（支持一切文件类型的复制）\n */\npublic class CopyDemo &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            // 1、创建一个字节输入流管道与原视频接通\n            InputStream is = new FileInputStream(&quot;file-io-app/src/out04.txt&quot;);\n\n            // 2、创建一个字节输出流管道与目标文件接通\n            OutputStream os = new FileOutputStream(&quot;file-io-app/src/out05.txt&quot;);\n\n            // 3、定义一个字节数组转移数据\n            byte[] buffer = new byte[1024];\n            int len; // 记录每次读取的字节数。\n            while ((len = is.read(buffer)) != -1)&#123;\n                os.write(buffer, 0 , len);\n            &#125;\n            System.out.println(&quot;复制完成了！&quot;);\n\n            // 4、关闭流。\n            os.close();\n            is.close();\n        &#125; catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n\n4、资源释放的方式4.1 try-catch-finally\nfinally:在异常处理时提供finally块来执行所有清除操作，比如说IO流中的释放资源\n特点:被finally控制的语句最终一定会执行，除非JVM退出\n异常处理标准格式: try….catch…finally\n\ntry &#123;\n    FileOutputStream fos = new FileOutputStream( &quot;a.txt&quot;);\n    fos.write(97);\n    fos.close();\n&#125;catch ( IOException e) &#123;\n    e.printStackTrace();\n&#125;finally&#123;\n\n&#125;\n\nimport java.io.*;\n\n/**\n *   学会使用finally释放资源。\n */\npublic class TryCatchFinallyDemo1 &#123;\n    public static void main(String[] args) &#123;\n        InputStream is = null;\n        OutputStream os = null;\n        try &#123;\n\n            // System.out.println(10/ 0);\n\n            // 1、创建一个字节输入流管道与原视频接通\n             is = new FileInputStream(&quot;file-io-app/src/out04.txt&quot;);\n\n            // 2、创建一个字节输出流管道与目标文件接通\n             os = new FileOutputStream(&quot;file-io-app/src/out05.txt&quot;);\n\n            // 3、定义一个字节数组转移数据\n            byte[] buffer = new byte[1024];\n            int len; // 记录每次读取的字节数。\n            while ((len = is.read(buffer)) != -1)&#123;\n                os.write(buffer, 0 , len);\n            &#125;\n            System.out.println(&quot;复制完成了！&quot;);\n\n         //   System.out.println( 10 / 0);\n\n        &#125; catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            // 无论代码是正常结束，还是出现异常都要最后执行这里\n            System.out.println(&quot;========finally=========&quot;);\n            try &#123;\n                // 4、关闭流。\n                if(os!=null)os.close();\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n            try &#123;\n                if(is != null) is.close();\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n\n        System.out.println(test(10, 2));\n    &#125;\n\n    public static int test(int a , int b)&#123;\n        try &#123;\n            int c = a / b;\n            return c;\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n            return -111111; // 计算出现bug.\n        &#125;finally &#123;\n            System.out.println(&quot;--finally--&quot;);\n            // 哪怕上面有return语句执行，也必须先执行完这里才可以！\n            // 开发中不建议在这里加return ，如果加了，返回的永远是这里的数据了，这样会出问题！\n            return 100;\n        &#125;\n    &#125;\n&#125;\n\n4.2 try-with-resourceJDK7和JDK9中都简化了资源释放操作\n\n5、字符流的使用5.1 文件字符输入流\n文件字符输入流: Reader\n作用:以内存为基准，把磁盘文件中的数据以字符的形式读取到内存中去。\n\n\n\n构造器\n说明\n\n\n\npublic FileReader(File file)\n创建字符输入流管道与源文件对象接通\n\n\npublic FileReader(String pathname)\n创建字符输入流管道与源文件路径接通\n\n\n\n\n\n方法名称\n说明\n\n\n\npublic int read()\n每次读取一个字符返回，如果字符已经没有可读的返回-1\n\n\npublic int read(char[] buffer)\n每次读取一个字符数组，返回读取的字符个数，如果字符已经没有可读的返回-1\n\n\n每次读取一个字符：读取中文字符不会出现乱码（如果代码文件编码一致)；性能较慢。\n\n\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.Reader;\n\n\npublic class FileReaderDemo01 &#123;\n    public static void main(String[] args) throws Exception &#123;\n        // 目标：每次读取一个字符。\n        // 创建一个字符输入流管道与源文件接通\n        Reader fr = new FileReader(&quot;file-io-app\\\\src\\\\data06.txt&quot;);\n\n        int code;\n        while ((code = fr.read()) != -1)&#123;\n            System.out.print((char) code);\n        &#125;\n    &#125;\n&#125;\n\n每次读取一个字符数组：读取的性能得到了提升，读取中文字符输出不会乱码。\nimport java.io.FileReader;\nimport java.io.Reader;\n\n\npublic class FileReaderDemo02 &#123;\n    public static void main(String[] args) throws Exception &#123;\n        // 1、创建一个文件字符输入流与源文件接通\n        Reader fr = new FileReader(&quot;file-io-app/src/data07.txt&quot;);\n\n        // 2、用循环，每次读取一个字符数组的数据。  1024 + 1024 + 8\n        char[] buffer = new char[1024]; // 1K字符\n        int len;\n        while ((len = fr.read(buffer)) != -1) &#123;\n            String rs = new String(buffer, 0, len);\n            System.out.print(rs);\n        &#125;\n\n    &#125;\n&#125;\n\n5.2 文件字符输出流文件字符输出流:FileWriter\n作用:以内存为基准，把内存中的数据以字符的形式写出到磁盘文件中去的流。\n\n\n\n构造器\n说明\n\n\n\npublic Filewriter(File file)\n创建字符输出流管道与源文件对象接通\n\n\npublic Filewriter(File file, boolean append)\n创建字符输出流管道与源文件对象接通，可追加数据\n\n\npublic Filewriter(string filepath)\n创建字符输出流管道与源文件路径接通\n\n\npublic Filewriter(String filepath，boolean append)\n创建字符输出流管道与源文件路径接通，可追加数据\n\n\n文件字符输出流(FileWriter)写数据出去的API\n\n\n\n方法名称\n说明\n\n\n\nvoid write(int c)\n写一个字符\n\n\nvoid write(char[] cbuf)\n写入一个字符数组\n\n\nvoid write(char[]cbuf, int off, int len)\n写入字符数组的一部分\n\n\nvoid write(String str)\n写一个字符串\n\n\nvoid write(String str, int off, int len)\n写一个字符串的一部分\n\n\nvoid write(int c)\n写一个字符\n\n\n流的关闭与刷新\n\n\n\n方法\n说明\n\n\n:-:\n:-:\n\n\nflush()\n刷新流，还可以继续写数据\n\n\nclose()\n关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据\n\n\n字符输出流实现写出去的数据能换行:fw.write(“\\r\\n”)\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.Writer;\n\npublic class FileWriterDemo03 &#123;\n    public static void main(String[] args) throws Exception &#123;\n        // 1、创建一个字符输出流管道与目标文件接通\n        // Writer fw = new FileWriter(&quot;file-io-app/src/out08.txt&quot;); // 覆盖管道，每次启动都会清空文件之前的数据\n        Writer fw = new FileWriter(&quot;file-io-app/src/out08.txt&quot;, true); // 覆盖管道，每次启动都会清空文件之前的数据\n\n//      a.public void write(int c):写一个字符出去\n        fw.write(98);\n        fw.write(&#39;a&#39;);\n        fw.write(&#39;徐&#39;); // 不会出问题了\n        fw.write(&quot;\\r\\n&quot;); // 换行\n\n//       b.public void write(String c)写一个字符串出去\n        fw.write(&quot;abc我是中国人&quot;);\n        fw.write(&quot;\\r\\n&quot;); // 换行\n\n\n//       c.public void write(char[] buffer):写一个字符数组出去\n        char[] chars = &quot;abc我是中国人&quot;.toCharArray();\n        fw.write(chars);\n        fw.write(&quot;\\r\\n&quot;); // 换行\n\n\n//       d.public void write(String c ,int pos ,int len):写字符串的一部分出去\n        fw.write(&quot;abc我是中国人&quot;, 0, 5);\n        fw.write(&quot;\\r\\n&quot;); // 换行\n\n\n//       e.public void write(char[] buffer ,int pos ,int len):写字符数组的一部分出去\n        fw.write(chars, 3, 5);\n        fw.write(&quot;\\r\\n&quot;); // 换行\n\n\n        // fw.flush();// 刷新后流可以继续使用\n        fw.close(); // 关闭包含刷线，关闭后流不能使用\n\n    &#125;\n&#125;\n\n\n","slug":"Java程序设计 -- 输入输出流（上）（十六）","date":"2022-04-02T01:35:33.000Z","categories_index":"后端","tags_index":"Java","author_index":"会思想的苇草i"},{"id":"74587a5637a9c21548b605cd59260ff7","title":"前端开发利器 - - PxCook（像素大厨）","content":"\n1、PxCook简述前端开发软件：\n\nPS（Photoshop）收费、占用磁盘空间大\nPxCook本地免费，轻量，高效\n\nPxCook\n&#x3D;&#x3D;高效易用的自动标注工具, 生成前端代码, 设计研发协作利器&#x3D;&#x3D;\nPxCook功能\n\n代码生成：包括 CSS, XML, Objective-C, Swift, ReactNative…\n自动标注：在开发模式下，可直接查看设计稿中元素的内容，间距，尺寸和样式等。同时会根据当前所选择的元素，在右侧属性栏中生成对应的样式代码。\n智能标注：支持智能标注出设计稿中，需要特殊注意的地方，以便加快工程师的开发效率。\n单位换算：支持 iOS, Android 和 H5 平台的不同单位类型和分辨率换算。\n切图协作：支持 iOS, Android 和 H5 三种平台的 切图协作 。导入到PxCook中的切图种类和命名，会根据当前的设备类型，自动进行换算。\n主流设计工具跨平台支持：支持 Photoshop，Sketch 和 Adobe XD 等设计工具，支持 macOS 和 Windows 两个操作系统。\n项目制管理设计稿：支持项目制管理您的设计稿中的每一个画板，同时支持对画板进行分组。\n协作项目的支持：支持云端协作项目，可以自由邀请项目的参与者到该项目中。\n本地项目的支持： 支持本地项目，所有项目数据可以以 pxcp 文件格式保存到本地，隐私保护更加有效。\n\n\n2、PxCook安装下载地址：PxCook - 高效易用的自动标注工具)\n\n\n\n3、PxCook基本操作3.1 通过软件打开设计图打开软件\n创建web项目\n拖拽入设计图，png用设计模式 psd用开发模式\n\n3.2 常用快捷键放大设计图：ctrl + +\n缩小设计图：ctrl - - \n移动设计图：空格按住不放，鼠标拖动\n3.3 常用工具\n量尺寸\n\n吸颜色\n\n\n3.4 从psd文件中直接获取数据切换到开发界面，直接点击获取数据\n\n\n","slug":"前端--PxCook（像素大厨）","date":"2022-03-30T13:51:02.000Z","categories_index":"前端","tags_index":"工具","author_index":"会思想的苇草i"},{"id":"414614a1c2fb25b2cf7d59eca8c59b48","title":"Java程序设计--日志框架、File、递归","content":"\n1、日志框架1.1 日志技术概述\n生活中的日志:生活中的日志就好比日记，可以记录你生活的点点滴滴。\n程序中的日志:程序中的日志可以用来记录程序运行过程中的信息，并可以进行永久存储。\n\n日志技术具备的优势\n\n可以将系统执行的信息选择性的记录到指定的位置(控制台、文件中、数据库中)。\n可以随时以开关的形式控制是否记录日志，无需修改源代码。\n\n日志技术体系结构\n1.2 Logback概述Logback日志框架\nLogback是由log4j创始人设计的另一个开源日志组件，性能比log4j要好\n官方网站:https://logback.qos.ch/index.html\nLogback是基于slf4j的日志规范实现的框架。\nLogback主要分为三个技术模块:\n\nlogback-core: logback-core模块为其他两个模块奠定了基础，必须有。\nlogback-classic:它是log4j的一个改良版本，同时它完整实现了slf4j API。\nlogback-access模块与Tomcat和Jetty等Servlet容器集成，以提供 HTTP访问日志功能\n\n1.3 Logback快速入门导入Logback日志技术到项目中\n\n在项目下新建文件夹lib，导入Logback的相关jar包到该文件夹下，并添加到项目依赖库中去。\n\n&#x3D;&#x3D;将Logback的核心配置文件logback.xml直接拷贝到src目录下（必须是src下)。&#x3D;&#x3D;\n\n在代码中获取日志的对象\n\n\npublic static final Logger LOGGER = loggerFactory.getLogger(&quot;类对象&quot;);\n\n\n使用日志对象LOGGER调用其方法输出日志信息\n\n1.4 Logback配置详解Logback日志系统的特性都是通过核心配置文件logback.xml控制的。\nLogback日志输出位置、格式设置:\n\n通过logback.xml中的标签可以设置输出位置和日志信息的详细格式。\n通常可以设置2个日志输出位置:一个是控制台、一个是系统文件中\n\n输出到控制台的配置标志\n&lt; appender name=&quot;CONSOLE&quot;  class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;\n\n输出到系统文件的配置标志\n&lt; appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;\n\n可以通过设置日志的输出级别来控制哪些日志信息输出或者不输出。\n\n级别程度依次是:&#x3D;&#x3D;TRACE&lt; DEBUG&lt;INFO&lt;WARN&lt;ERROR;默认级别是debug(忽略大小写)，对应其方法。&#x3D;&#x3D;\n作用:用于控制系统中哪些日志级别是可以输出的，只输出级别不低于设定级别的日志信息。\nA&#x3D;&#x3D;LL和OFF分别是打开全部日志信息，及关闭全部日志信息。&#x3D;&#x3D;\n\n&lt;root level=INFO&quot;&gt;\n    &lt; appender-ref ref=&quot;CONSOLE&quot;/&gt;\n    &lt; appender-ref ref=&quot;FILE”/&gt;\n&lt; / root&gt;\n\n\n2、File类2.1 File类的概述File类在包java.io.File下、代表操作系统的文件对象（文件、文件夹)。\nFile类提供了诸如:定位文件，获取文件本身的信息、删除文件、创建文件(文件夹)等功能。\nFile类创建对象\n\n\n\n方法名称\n说明\n\n\n\npublic File(string pathname)\n根据文件路径创建文件对象\n\n\npublic File(string parent,string child)\n从父路径名字符串和子路径名字符串创建文件对象\n\n\npublic File(File parent，string child)\n根据父路径对应文件对象和子路径名字符串创建文件对象\n\n\n\nFile对象可以定位文件和文件夹\nFile封装的对象仅仅是一个路径名，这个路径可以是存在的，也可以是不存在的。\n\n绝对路径和相对路径\n绝对路径:从盘符开始\nFile file1 = new File(“D: \\\\software\\\\a.txt”);\n\n相对路径:不带盘符，默认直接到当前工程下的目录寻找文件。\nFile file3 = new File(“模块名\\la.txt”);\n\nimport java.io.File;\n\npublic class FileDemo &#123;\n    public static void main(String[] args) &#123;\n        // 1、创建File对象（指定了文件的路径）\n        // 路径写法： D:\\resources\\xueshan.jpeg\n        //          D:/resources/xueshan.jpeg\n        //          File.separator\n//        File f = new File(&quot;D:\\\\resources\\\\xueshan.jpeg&quot;);\n//        File f = new File(&quot;D:/resources/xueshan.jpeg&quot;);\n        File f = new File(&quot;D:&quot; + File.separator+&quot;resources&quot;+ File.separator +&quot;xueshan.jpeg&quot;);\n        long size = f.length(); // 是文件的字节大小\n        System.out.println(size);\n\n        // 2、File创建对象，支持绝对路径 支持相对路径（重点）\n        File f1 = new File(&quot;D:\\\\resources\\\\beauty.jpeg&quot;); // 绝对路径\n        System.out.println(f1.length());\n\n        // 相对路径：一般定位模块中的文件的。 相对到工程下！！\n        File f2 = new File(&quot;file-io-app/src/data.txt&quot;);\n        System.out.println(f2.length());\n\n        // 3、File创建对象 ，可以是文件也可以是文件夹\n  \n\n2.2 File类常用APIFile类的判断文件类型、获取文件信息功能\n\n\n\n方法名称\n说明\n\n\n\npublic boolean isDirectory()\n测试此抽象路径名表示的File是否为文件夹\n\n\npublic boolean isFile()\n测试此抽象路径名表示的File是否为文件\n\n\npublic boolean exists()\n测试此抽象路径名表示的File是否存在\n\n\npublic string getAbsolutePath()\n返回此抽象路径名的绝对路径名字符串\n\n\npublic string getPath()\n将此抽象路径名转换为路径名字符串\n\n\npublic string getName()\n返回由此抽象路径名表示的文件或文件夹的名称\n\n\npublic long lastModified()\n返回文件最后修改的时间毫秒值\n\n\nimport java.io.File;\nimport java.text.SimpleDateFormat;\n\npublic class FileDemo &#123;\n    public static void main(String[] args) &#123;\n        // 1.绝对路径创建一个文件对象\n        File f1 = new File(&quot;D:/resources/xueshan.jpeg&quot;);\n        // a.获取它的绝对路径。\n        System.out.println(f1.getAbsolutePath());\n        // b.获取文件定义的时候使用的路径。\n        System.out.println(f1.getPath());\n        // c.获取文件的名称：带后缀。\n        System.out.println(f1.getName());\n        // d.获取文件的大小：字节个数。\n        System.out.println(f1.length()); // 字节大小\n        // e.获取文件的最后修改时间\n        long time = f1.lastModified();\n        System.out.println(&quot;最后修改时间：&quot; + new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;).format(time));\n        // f、判断文件是文件还是文件夹\n        System.out.println(f1.isFile()); // true\n        System.out.println(f1.isDirectory()); // false\n\n        System.out.println(&quot;-------------------------&quot;);\n\n        File f2 = new File(&quot;file-io-app\\\\src\\\\data.txt&quot;);\n        // a.获取它的绝对路径。\n        System.out.println(f2.getAbsolutePath());\n        // b.获取文件定义的时候使用的路径。\n        System.out.println(f2.getPath());\n        // c.获取文件的名称：带后缀。\n        System.out.println(f2.getName());\n        // d.获取文件的大小：字节个数。\n        System.out.println(f2.length()); // 字节大小\n        // e.获取文件的最后修改时间\n        long time1 = f2.lastModified();\n        System.out.println(&quot;最后修改时间：&quot; + new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;).format(time1));\n        // f、判断文件是文件还是文件夹\n        System.out.println(f2.isFile()); // true\n        System.out.println(f2.isDirectory()); // false\n        System.out.println(f2.exists()); // true\n\n        File file = new File(&quot;D:/&quot;);\n        System.out.println(file.isFile()); // false\n        System.out.println(file.isDirectory()); // true\n        System.out.println(file.exists()); // true\n\n        File file1 = new File(&quot;D:/aaa&quot;);\n        System.out.println(file1.isFile()); // false\n        System.out.println(file1.isDirectory()); // false\n        System.out.println(file1.exists()); // false\n\n    &#125;\n&#125;\n\nFile类创建文件的功能\n\n\n\n方法名称\n说明\n\n\n\npublic boolean createNewFile()\n创建一个新的空的文件\n\n\npublic boolean mkdir()\n只能创建一级文件夹\n\n\npublic boolean mkdirs()\n可以创建多级文件夹\n\n\nFile类删除文件的功能\n\n\n\n方法名称\n说明\n\n\n\npublic boolean delete()\n删除由此抽象路径名表示的文件或空文件夹\n\n\n\ndelete方法默认只能删除文件和空文件夹。\ndelete方法直接删除不走回收站。\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo&#123;\n    public static void main(String[] args) throws IOException &#123;\n        File f = new File(&quot;file-io-app\\\\src\\\\data.txt&quot;);\n        // a.创建新文件，创建成功返回true ,反之 ,不需要这个，以后文件写出去的时候都会自动创建\n        System.out.println(f.createNewFile());\n        File f1 = new File(&quot;file-io-app\\\\src\\\\data02.txt&quot;);\n        System.out.println(f1.createNewFile()); // （几乎不用的，因为以后文件都是自动创建的！）\n\n        // b.mkdir创建一级目录\n        File f2 = new File(&quot;D:/resources/aaa&quot;);\n        System.out.println(f2.mkdir());\n\n        // c.mkdirs创建多级目录(重点)\n        File f3 = new File(&quot;D:/resources/ccc/ddd/eee/ffff&quot;);\n//        System.out.println(f3.mkdir());\n        System.out.println(f3.mkdirs()); // 支持多级创建\n\n        // d.删除文件或者空文件夹\n        System.out.println(f1.delete());\n        File f4 = new File(&quot;D:/resources/xueshan.jpeg&quot;);\n        System.out.println(f4.delete()); // 占用一样可以删除\n\n        // 只能删除空文件夹,不能删除非空文件夹.\n        File f5 = new File(&quot;D:/resources/aaa&quot;);\n        System.out.println(f5.delete());\n    &#125;\n&#125;\n\nFile类的遍历功能\n\n\n\n方法名称\n说明\n\n\n\npublic string[ ] list()\n获取当前目录下所有的”一级文件名称”到一个字符串数组中去返回\n\n\npublic File[] listFiles()(常用)\n获取当前目录下所有的”一级文件对象”到一个文件对象数组中去返回(重点)\n\n\nlistFiles方法注意事项:\n\n\n\n\n当调用者不存在时，返回null\n当调用者是一个文件时，返回null\n当调用者是一个空文件夹时，返回一个长度为0的数组\n当调用者是一个有内容的文件夹时，将里面所有文件和文件夹的路径放在File数组中返回\n当调用者是一个有隐藏文件的文件夹时，将里面所有文件和文件夹的路径放在File数组中返回，包含隐藏内容\n当调用者是一个需要权限才能进入的文件夹时，返回null\n\nimport java.io.File;\nimport java.util.Arrays;\n\npublic class FileDemo&#123;\n    public static void main(String[] args) &#123;\n        // 1、定位一个目录\n        File f1 = new File(&quot;D:/resources&quot;);\n        String[] names = f1.list();\n        for (String name : names) &#123;\n            System.out.println(name);\n        &#125;\n\n        // 2.一级文件对象\n        // 获取当前目录下所有的&quot;一级文件对象&quot;到一个文件对象数组中去返回（重点）\n        File[] files = f1.listFiles();\n        for (File f : files) &#123;\n            System.out.println(f.getAbsolutePath());\n        &#125;\n\n        // 注意事项\n        File dir = new File(&quot;D:/resources/ddd&quot;);\n        File[] files1 = dir.listFiles();\n        System.out.println(Arrays.toString(files1));\n    &#125;\n&#125;\n\n\n3、方法递归3.1 递归的形式和特点&#x3D;&#x3D;方法直接调用自己或者间接调用自己的形式称为方法递归( recursion)。&#x3D;&#x3D;\n递归做为一种算法在程序设计语言中广泛应用。\n递归的形式\n&#x3D;&#x3D;直接递归:方法自己调用自己。&#x3D;&#x3D;\n&#x3D;&#x3D;间接递归:方法调用其他方法，其他方法又回调方法自己。&#x3D;&#x3D;\n&#x3D;&#x3D;递归如果没有控制好终止，会出现递归死循环，导致栈内存溢出现象。&#x3D;&#x3D;\npublic class RecursionDemo &#123;\n    public static void main(String[] args) &#123;\n        test2();\n    &#125;\n\n    public static void test()&#123;\n        System.out.println(&quot;=======test被执行========&quot;);\n        test(); // 方法递归 直接递归形式\n    &#125;\n\n    public static void test2()&#123;\n        System.out.println(&quot;=======test2被执行========&quot;);\n        test3(); // 方法递归 间接递归\n    &#125;\n\n    private static void test3() &#123;\n        System.out.println(&quot;=======test3被执行========&quot;);\n        test2();\n    &#125;\n&#125;\n\n递归解决问题的思路:\n把一个复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。\n3.2 递归案例计算1—-n的和\n需求:计算1-n的和的结果，使用递归思想解决。\npublic class RecursionDemo &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(f(5));\n    &#125;\n\n    public static int f(int n)&#123;\n        if(n == 1)&#123;\n            return 1;\n        &#125;else &#123;\n            return f(n - 1)  + n;\n        &#125;\n    &#125;\n&#125;\n\n猴子吃桃问题\n猴子第一天摘下若干桃子，当即吃了一半，觉得好不过瘾，于是又多吃了一个第二天又吃了前天剩余桃子数量的一半，觉得好不过瘾，于是又多吃了一个以后每天都是吃前天剩余桃子数量的一半，觉得好不过瘾，又多吃了一个等到第10天的时候发现桃子只有1个了。\n需求:请问猴子第—天摘了多少个桃子?\n/**\n    猴子吃桃。\n    公式（合理的）： f(x) - f(x)/2 - 1 = f(x+1)\n        2f(x) - f(x) - 2 = 2f(x + 1)\n        f(x) = 2f(x + 1) + 2\n    求f(1) = ?\n    终结点： f（10） = 1\n */\npublic class RecursionDemo &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(f(1));\n        System.out.println(f(2));\n        System.out.println(f(3));\n    &#125;\n\n    public static int f(int n)&#123;\n        if(n == 10)&#123;\n            return 1;\n        &#125;else &#123;\n            return 2 * f(n + 1) + 2;\n        &#125;\n    &#125;\n&#125;\n\n3.3 非规律化递归案例非递归化问题需要流程化的编程思想。\n文件搜索\n需求:文件搜索、从C:盘中，搜索出某个文件名称并输出绝对路径。\nimport java.io.File;\nimport java.io.IOException;\n\n/**\n    去D判断搜索 eDiary.exe文件\n */\npublic class RecursionDemo&#123;\n    public static void main(String[] args) &#123;\n        // 2、传入目录 和  文件名称\n        searchFile(new File(&quot;D:/&quot;) , &quot;eDiary.exe&quot;);\n    &#125;\n\n    /**\n     * 1、搜索某个目录下的全部文件，找到我们想要的文件。\n     * @param dir  被搜索的源目录\n     * @param fileName 被搜索的文件名称\n     */\n    public static void searchFile(File dir,String fileName)&#123;\n        // 3、判断dir是否是目录\n        if(dir != null &amp;&amp; dir.isDirectory())&#123;\n            // 可以找了\n            // 4、提取当前目录下的一级文件对象\n            File[] files = dir.listFiles(); // null  []\n            // 5、判断是否存在一级文件对象，存在才可以遍历\n            if(files != null &amp;&amp; files.length &gt; 0) &#123;\n                for (File file : files) &#123;\n                    // 6、判断当前遍历的一级文件对象是文件 还是 目录\n                    if(file.isFile())&#123;\n                        // 7、是不是咱们要找的，是把其路径输出即可\n                        if(file.getName().contains(fileName))&#123;\n                            System.out.println(&quot;找到了：&quot; + file.getAbsolutePath());\n                            // 启动它。\n                            try &#123;\n                                Runtime r = Runtime.getRuntime();\n                                r.exec(file.getAbsolutePath());\n                            &#125; catch (IOException e) &#123;\n                                e.printStackTrace();\n                            &#125;\n                        &#125;\n                    &#125;else &#123;\n                        // 8、是文件夹，需要继续递归寻找\n                        searchFile(file, fileName);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;else &#123;\n            System.out.println(&quot;对不起，当前搜索的位置不是文件夹！&quot;);\n        &#125;\n    &#125;\n&#125;\n\n啤酒问题\n需求:啤酒2元1瓶，4个盖子可以换一瓶，2个空瓶可以换一瓶，请问10元钱可以喝多少瓶酒，剩余多少空瓶和盖子。\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Arrays;\n\npublic class RecursionDemo&#123;\n\n    // 定义一个静态的成员变量用于存储可以买的酒数量\n    public static int totalNumber; // 总数量\n    public static int lastBottleNumber; // 记录每次剩余的瓶子个数\n    public static int lastCoverNumber; // 记录每次剩余的盖子个数\n\n\n    public static void main(String[] args) &#123;\n        // 1、拿钱买酒\n        buy(10);\n        System.out.println(&quot;总数：&quot; + totalNumber);\n        System.out.println(&quot;剩余盖子数：&quot; + lastCoverNumber);\n        System.out.println(&quot;剩余瓶子数：&quot; + lastBottleNumber);\n    &#125;\n\n    public static void buy(int money)&#123;\n        // 2、看可以立马买多少瓶\n        int buyNumber = money / 2; // 5\n        totalNumber += buyNumber;\n\n        // 3、把盖子 和瓶子换算成钱\n        // 统计本轮总的盖子数  和 瓶子数\n        int coverNumber = lastCoverNumber + buyNumber;\n        int bottleNumber = lastBottleNumber + buyNumber;\n\n        // 统计可以换算的钱\n        int allMoney = 0;\n        if(coverNumber &gt;= 4)&#123;\n            allMoney += (coverNumber / 4) * 2;\n        &#125;\n        lastCoverNumber = coverNumber % 4;\n\n        if(bottleNumber &gt;= 2)&#123;\n            allMoney += (bottleNumber / 2) * 2;\n        &#125;\n        lastBottleNumber = bottleNumber % 2;\n\n        if(allMoney &gt;= 2)&#123;\n            buy(allMoney);\n        &#125;\n\n        Integer[] arr2 = new Integer[]&#123;11, 22, 33&#125;;\n        Arrays.sort(arr2);\n    &#125;\n&#125;\n\n\n","slug":"Java程序设计 -- 日志框架、File、递归（十五）","date":"2022-03-29T10:02:05.000Z","categories_index":"后端","tags_index":"Java","author_index":"会思想的苇草i"},{"id":"0b9a635cc4d74b69a28063082e6467ef","title":"Java程序设计--Stream流、异常","content":"\n1、Stream流1.1 Stream流的概述&#x3D;&#x3D;用于简化集合和数组操作的API。&#x3D;&#x3D;\nStream流式思想的核心:\n\n先得到集合或者数组的Stream流(就是一根传送带)\n把元素放上去\n然后就用这个Stream流简化的API来方便的操作元素。\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        List&lt;String&gt; names = new ArrayList&lt;&gt;();\n        Collections.addAll(names, &quot;张三丰&quot;,&quot;张无忌&quot;,&quot;周芷若&quot;,&quot;赵敏&quot;,&quot;张强&quot;);\n        System.out.println(names);\n        // 使用Stream实现的\n        names.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).filter(s -&gt; s.length() == 3).forEach(s -&gt; System.out.println(s));\n    &#125;\n&#125;\n\n1.2 Stream流的获取获取Stream流\n创建─条流水线，并把数据放到流水线上准备进行操作\n中间方法\n流水线上的操作。一次操作完毕之后，还可以继续进行其他操作\n终结方法\n一个Stream流只能有一个终结方法，是流水线上的最后一个操作\nStream操作集合或者数组的第一步是先得到Stream流，然后才能使用流的功能。\n集合获取Stream流的方式\n可以使用Collection接口中的默认方法stream()生成流\n\n\n\n名称\n说明\n\n\n\ndefault Stream&lt; E &gt; stream()\n获取当前集合对象的Stream流\n\n\n数组获取Stream流的方式\n\n\n\n\n\n\n名称\n说明\n\n\n\npublic static &lt; T&gt; Stream&lt; T&gt; stream(T[ ] array)\n获取当前数组的Stream流\n\n\npublic static&lt; T&gt; stream&lt; T&gt; of(T… values)\n获取当前数组&#x2F;可变数据的Stream流\n\n\nimport java.util.*;\nimport java.util.stream.Stream;\n\npublic class StreamDemo02 &#123;\n    public static void main(String[] args) &#123;\n        /** --------------------Collection集合获取流-------------------------------   */\n        Collection&lt;String&gt; list = new ArrayList&lt;&gt;();\n        Stream&lt;String&gt; s =  list.stream();\n\n        /** --------------------Map集合获取流-------------------------------   */\n        Map&lt;String, Integer&gt; maps = new HashMap&lt;&gt;();\n        // 键流\n        Stream&lt;String&gt; keyStream = maps.keySet().stream();\n        // 值流\n        Stream&lt;Integer&gt; valueStream = maps.values().stream();\n        // 键值对流（拿整体）\n        Stream&lt;Map.Entry&lt;String,Integer&gt;&gt; keyAndValueStream =  maps.entrySet().stream();\n\n        /** ---------------------数组获取流------------------------------   */\n        String[] names = &#123;&quot;赵敏&quot;,&quot;小昭&quot;,&quot;灭绝&quot;,&quot;周芷若&quot;&#125;;\n        Stream&lt;String&gt; nameStream = Arrays.stream(names);\n        Stream&lt;String&gt; nameStream2 = Stream.of(names);\n    &#125;\n&#125;\n\n1.3 Stream流的常用APIStream流的常用API(中间操作方法)\n\n\n\n名称\n说明\n\n\n\nstream&lt; T&gt; filter(Predicate&lt;? super T&gt; predicate)\n用于对流中的数据进行过滤。\n\n\nstream&lt; T&gt; limit(long maxsize)\n获取前几个元素\n\n\nstream&lt; T&gt; skip(long n)\n跳过前几个元素\n\n\nstream&lt; T&gt; distinct()\n去除流中重复的元素。依赖(hashCode和eqluals方法)\n\n\nstatic &lt; T&gt; stream&lt; T&gt; concat(stream a,stream b)\n合并a和b两个流为一个流\n\n\n注意:\n\n\n\n\n中间方法也称为非终结方法，调用完成后返回新的Stream流可以继续使用，支持链式编程。\n在Stream流中无法直接修改集合、数组中的数据。\n\nStream流的常见终结操作方法\n\n\n\n名称\n说明\n\n\n\nvoid forEach(Consumer action)\n对此流的每个元素执行遍历操作\n\n\nlong count()\n返回此流中的元素数\n\n\n注意:终结操作方法，调用完成后流就无法继续使用了，原因是不会返回Stream了。\n\n\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\n\npublic class StreamDemo03 &#123;\n    public static void main(String[] args) &#123;\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n        list.add(&quot;张无忌&quot;);\n        list.add(&quot;周芷若&quot;);\n        list.add(&quot;赵敏&quot;);\n        list.add(&quot;张强&quot;);\n        list.add(&quot;张三丰&quot;);\n        list.add(&quot;张三丰&quot;);\n\n        // Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)\n        list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).forEach(s -&gt; System.out.println(s));\n\n        long size = list.stream().filter(s -&gt; s.length() == 3).count();\n        System.out.println(size);\n\n       // list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).limit(2).forEach(s -&gt; System.out.println(s));\n        list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).limit(2).forEach(System.out::println);\n\n        list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).skip(2).forEach(System.out::println);\n\n        // map加工方法: 第一个参数原材料  -&gt; 第二个参数是加工后的结果。\n        // 给集合元素的前面都加上一个：黑马的：\n        list.stream().map(s -&gt; &quot;黑马的：&quot; + s).forEach(a -&gt; System.out.println(a));\n\n        // 需求：把所有的名称 都加工成一个学生对象。\n         list.stream().map(s -&gt; new Student(s)).forEach(s -&gt; System.out.println(s));\n//        list.stream().map(Student::new).forEach(System.out::println); // 构造器引用  方法引用\n\n        // 合并流。\n        Stream&lt;String&gt; s1 = list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;));\n        Stream&lt;String&gt; s2 = Stream.of(&quot;java1&quot;, &quot;java2&quot;);\n        // public static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)\n        Stream&lt;String&gt; s3 = Stream.concat(s1 , s2);\n        s3.distinct().forEach(s -&gt; System.out.println(s));\n    &#125;\n&#125;\n\n1.4 Stream流的收集操作\n收集Stream流的含义:就是把Stream流操作后的结果数据转回到集合或者数组中去。\n\nStream流:方便操作集合&#x2F;数组的手段。\n\n集合&#x2F;数组:才是开发中的目的。\n\n\nStream流的收集方法\n\n\n\n名称\n说明\n\n\n\nR collect(collector collector)\n开始收集Stream流，指定收集器\n\n\nCollectors工具类提供了具体的收集方式\n\n\n\n名称\n说明\n\n\n:-:\n:-:\n\n\npublic static  Collector toList()\n把元素收集到List集合中\n\n\npublic static  collector toSet()\n把元素收集到Set集合中\n\n\npublic static collector toMap(Function keyMapper , Function valueMapper)\n把元素收集到Map集合中\n\n\nimport java.util.*;\nimport java.util.function.IntFunction;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class StreamDemo05 &#123;\n    public static void main(String[] args) &#123;\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n        list.add(&quot;张无忌&quot;);\n        list.add(&quot;周芷若&quot;);\n        list.add(&quot;赵敏&quot;);\n        list.add(&quot;张强&quot;);\n        list.add(&quot;张三丰&quot;);\n        list.add(&quot;张三丰&quot;);\n\n        Stream&lt;String&gt; s1 = list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;));\n        List&lt;String&gt; zhangList = s1.collect(Collectors.toList()); // 可变集合\n        zhangList.add(&quot;java1&quot;);\n        System.out.println(zhangList);\n\n        // 注意注意注意：“流只能使用一次”\n        Stream&lt;String&gt; s2 = list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;));\n        Set&lt;String&gt; zhangSet = s2.collect(Collectors.toSet());\n        System.out.println(zhangSet);\n\n        Stream&lt;String&gt; s3 = list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;));\n//         Object[] arrs = s3.toArray();\n        String[] arrs = s3.toArray(String[]::new); // 可以不管，拓展一下思维！！\n        System.out.println(&quot;Arrays数组内容：&quot; + Arrays.toString(arrs));\n\n    &#125;\n&#125;\n\n\n2、异常处理2.1 异常概述异常是程序在”编译”或者”执行”的过程中可能出现的问题，注意:语法错误不算在异常体系中。比如:数组索引越界、空指针异常、日期格式化异常，等…\n异常一旦出现了，如果没有提前处理，程序就会退出JVM虚拟机而终止。研究异常并且避免异常，然后提前处理异常，体现的是程序的安全，健壮性。\nError:\n\n&#x3D;&#x3D;系统级别问题、JVM退出等，代码无法控制。&#x3D;&#x3D;\n\nException: java.lang包下，称为异常类，它表示程序本身可以处理的问题\n\n&#x3D;&#x3D;RuntimeException及其子类:运行时异常，编译阶段不会报错。(空指针异常，数组索引越界异常)&#x3D;&#x3D;\n\n&#x3D;&#x3D;除RuntimeException之外所有的异常:编译时异常，编译期必须处理的，否则程序不能通过编译。(日期格式化异常)。&#x3D;&#x3D;\n\n\n\n编译时异常就是在编译的时候出现的异常，运行时异常就是在运行时出现的异常。\n2.2 常见运行时异常直接继承自RuntimeException或者其子类，编译阶段不会报错，运行时可能出现的错误。\n运行时异常示例\n\n\n\n中文\n英文\n\n\n\n数组索引越界异常\nArraylndexOutOfBoundsException\n\n\n空指针异常\nNullPointerException，直接输出没有问题，但是调用空指针H的变量的\n\n\n数学操作异常\nArithmeticException\n\n\n类型转换异常\nClassCastException\n\n\n数字转换异常\nNumberFormatException\n\n\n运行时异常:一般是程序员业务没有考虑好或者是编程逻辑不严谨引起的程序错误，自己的水平有问题!\npublic class ExceptionDemo &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(&quot;程序开始。。。。。。&quot;);\n        /** 1.数组索引越界异常: ArrayIndexOutOfBoundsException。*/\n        int[] arr = &#123;1, 2, 3&#125;;\n        System.out.println(arr[2]);\n        // System.out.println(arr[3]); // 运行出错，程序终止\n\n        /** 2.空指针异常 : NullPointerException。直接输出没有问题。但是调用空指针的变量的功能就会报错！！ */\n        String name = null;\n        System.out.println(name); // null\n        // System.out.println(name.length()); // 运行出错，程序终止\n\n        /** 3.类型转换异常：ClassCastException。 */\n        Object o = 23;\n        // String s = (String) o;  // 运行出错，程序终止\n\n        /** 5.数学操作异常：ArithmeticException。 */\n        //int c = 10 / 0;\n\n        /** 6.数字转换异常： NumberFormatException。 */\n        //String number = &quot;23&quot;;\n        String number = &quot;23aabbc&quot;;\n        Integer it = Integer.valueOf(number); // 运行出错，程序终止\n        System.out.println(it + 1);\n\n        System.out.println(&quot;程序结束。。。。。&quot;);\n    &#125;\n&#125;\n\n2.3 常见编译时异常不是RuntimeException或者其子类的异常，编译阶段就报错，必须处理，否则代码不通过。\n编译时异常的作用是担心程序员的技术不行，在编译阶段就爆出一个错误,目的在于提醒不要出错!编译时异常是可遇不可求。遇到了就遇到了呗。\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class ExceptionDemo &#123;\n    public static void main(String[] args) throws ParseException &#123;\n        String date = &quot;2015-01-12 10:23:21&quot;;\n        // 创建一个简单日期格式化类：\n        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM-dd HH:mm:ss&quot;);\n        // 解析字符串时间成为日期对象\n        Date d = sdf.parse(date);\n        //\n        System.out.println(d);\n    &#125;\n&#125;\n\n2.4 异常默认处理机制\n默认会在出现异常的代码那里自动的创建一个异常对象:ArithmeticException。\n异常会从方法中出现的点这里抛出给调用者，调用者最终抛出给JVM虚拟机。\n虚拟机接收到异常对象后，先在控制台直接输出异常栈信息数据。\n直接从当前执行的异常点干掉当前程序。\n后续代码没有机会执行了，因为程序已经死亡。\n\n2.5 编译时异常的处理机制编译时异常是编译阶段就出错的，所以必须处理，否则代码根本无法通过。\n编译时异常的处理形式有三种:\n\n出现异常直接抛出去给调用者，调用者也继续抛出去。\n出现异常自己捕获处理，不麻烦别人。\n前两者结合，出现异常直接抛出去给调用者，调用者捕获处理。\n\n异常处理方式1——throws\n&#x3D;&#x3D;throws:用在方法上，可以将方法内部出现的异常抛出去给本方法的调用者处理。&#x3D;&#x3D;\n这种方式并不好，发生异常的方法自己不处理异常，如果异常最终抛出去给虚拟机将引起程序死亡。\n//抛出异常格式\n方法 throws 异常1,异常2,异常3..&#123;\n&#125;\n//规范做法\n方法 throws Exception&#123;\n&#125;\n//（代表可以抛出一切异常）\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class ExceptionDemo01 &#123;\n    public static void main(String[] args) throws Exception &#123;\n        System.out.println(&quot;程序开始。。。。。&quot;);\n        parseTime(&quot;2011-11-11 11:11:11&quot;);\n        System.out.println(&quot;程序结束。。。。。&quot;);\n    &#125;\n\n    public static void parseTime(String date) throws Exception &#123;\n        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);\n        Date d = sdf.parse(date);\n        System.out.println(d);\n    &#125;\n&#125;\n\n异常处理方式2—— try…catch…\n&#x3D;&#x3D;监视捕获异常，用在方法内部，可以将方法内部出现的异常直接捕获处理。&#x3D;&#x3D;\n这种方式还可以，发生异常的方法自己独立完成异常的处理，程序可以继续往下执行。\n//格式:\ntry&#123;\n    //监视可能出现异常的代码!\n&#125;catch(异常类型1变量)&#123;\n    //处理异常\n&#125;catch(异常类型2变量)&#123;\n    //处理异常\n&#125;...\n\n\n//建议格式:\ntry&#123;\n    //可能出现异常的代码！\n&#125;catch(Exception e)&#123;\n    e.printStackTrace();\n&#125;\n//Exception可以捕获一切异常类型\n\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.InputStream;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class ExceptionDemo02 &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(&quot;程序开始。。。。&quot;);\n        parseTime(&quot;2011-11-11 11:11:11&quot;);\n        System.out.println(&quot;程序结束。。。。&quot;);\n    &#125;\n\n    public static void parseTime(String date) &#123;\n        try &#123;\n            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM-dd HH:mm:ss&quot;);\n            Date d = sdf.parse(date);\n            System.out.println(d);\n\n            InputStream is = new FileInputStream(&quot;E:/meinv.jpg&quot;);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace(); // 打印异常栈信息\n        &#125;\n    &#125;\n&#125;\n\n异常处理方式3——前两者结合\n\n&#x3D;&#x3D;方法直接将异通过throws抛出去给调用者&#x3D;&#x3D;\n&#x3D;&#x3D;调用者收到异常后直接捕获处理&#x3D;&#x3D;\n\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class ExceptionDemo03 &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(&quot;程序开始。。。。&quot;);\n        try &#123;\n            parseTime(&quot;2011-11-11 11:11:11&quot;);\n            System.out.println(&quot;功能操作成功~~~&quot;);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n            System.out.println(&quot;功能操作失败~~~&quot;);\n        &#125;\n        System.out.println(&quot;程序结束。。。。&quot;);\n    &#125;\n\n    public static void parseTime(String date) throws Exception &#123;\n        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy、MM-dd HH:mm:ss&quot;);\n        Date d = sdf.parse(date);\n        System.out.println(d);\n\n        InputStream is = new FileInputStream(&quot;D:/meinv.jpg&quot;);\n    &#125;\n\n&#125;\n\n在开发中按照规范来说第三种方式是最好的:底层的异常抛出去给最外层，最外层集中捕获处理。\n实际应用中，只要代码能够编译通过，并且功能能完成，那么每一种异常处理方式似乎也都是可以的。\n2.6 运行时异常的处理机制运行时异常编译阶段不会出错，是运行时才可能出错的，所以编译阶段不处理也可以。\n按照规范建议还是处理:建议在最外层调用处集中捕获处理即可。\n2.7 自定义异常自定义异常的必要?\n\nJava无法为这个世界上全部的问题提供异常类。\n如果企业想通过异常的方式来管理自己的某个业务问题，就需要自定义异常类了。\n\n自定义异常的好处:\n\n可以使用异常的机制管理业务问题，如提醒程序员注意。\n同时一旦出现bug，可以用异常的形式清晰的指出出错的地方。\n\n自定义异常的分类\n1、自定义编译时异常\n\n定义一个异常类继承Exception\n重写构造器\n在出现异常的地方用throw new自定义对象抛出\n\n作用:编译时异常是编译阶段就报错，提醒更加强烈，一定需要处理!!\n2、自定义运行时异常\n\n定义一个异常类继承RuntimeException\n重写构造器\n在出现异常的地方用throw new自定义对象抛出\n\n作用:提醒不强烈，编译阶段不报错!!运行时才可能出现!!\n/**\n    自定义的编译时异常\n      1、继承Exception\n      2、重写构造器\n */\npublic class ItheimaAgeIlleagalException extends Exception&#123;\n    public ItheimaAgeIlleagalException() &#123;\n    &#125;\n\n    public ItheimaAgeIlleagalException(String message) &#123;\n        super(message);\n    &#125;\n&#125;\n\n/**\n    自定义的编译时异常\n      1、继承RuntimeException\n      2、重写构造器\n */\npublic class ItheimaAgeIlleagalRuntimeException extends RuntimeException&#123;\n    public ItheimaAgeIlleagalRuntimeException() &#123;\n    &#125;\n\n    public ItheimaAgeIlleagalRuntimeException(String message) &#123;\n        super(message);\n    &#125;\n&#125;\n\npublic class ExceptionDemo &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            checkAge2(-23);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n    public static void checkAge2(int age)  &#123;\n        if(age &lt; 0 || age &gt; 200)&#123;\n            // 抛出去一个异常对象给调用者\n            // throw ：在方法内部直接创建一个异常对象，并从此点抛出\n            // throws : 用在方法申明上的，抛出方法内部的异常\n            throw new ItheimaAgeIlleagalRuntimeException(age + &quot; is illeagal!&quot;);\n        &#125;else &#123;\n            System.out.println(&quot;年龄合法：推荐商品给其购买~~&quot;);\n        &#125;\n    &#125;\n\n    public static void checkAge(int age) throws ItheimaAgeIlleagalException &#123;\n        if(age &lt; 0 || age &gt; 200)&#123;\n            // 抛出去一个异常对象给调用者\n            // throw ：在方法内部直接创建一个异常对象，并从此点抛出\n            // throws : 用在方法申明上的，抛出方法内部的异常\n            throw new ItheimaAgeIlleagalException(age + &quot; is illeagal!&quot;);\n        &#125;else &#123;\n            System.out.println(&quot;年龄合法：推荐商品给其购买~~&quot;);\n        &#125;\n    &#125;\n&#125;\n\n\n","slug":"Java程序设计 -- Stream流、异常（十四）","date":"2022-03-28T08:27:03.000Z","categories_index":"后端","tags_index":"Java","author_index":"会思想的苇草i"},{"id":"d48d7238235ebfe7d1b58dbbcb25bc7c","title":"Java程序设计--集合(下)","content":"\n1、Set系列集合1.1 Set系列集合概述Set系列集合特点\n\n无序: 存取顺序不一致\n不重复: 可以去除重复\n无索引: 没有带索引的方法，所以不能使用普通for循环遍历，也不能通过索弓|来获取元素。\n\nSet集合实现类特点\n\nHashSet :&#x3D;&#x3D;无序&#x3D;&#x3D;、不重复、无索引。\nLinkedHashSet: &#x3D;&#x3D;有序&#x3D;&#x3D;、不重复、无索引。\nTreeSet: &#x3D;&#x3D;可排序&#x3D;&#x3D;、不重复、无索引。\n\nimport java.util.HashSet;\nimport java.util.Set;\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        // 看看Set系列集合的特点： HashSet LinkedHashSet TreeSet\n        //\n        Set&lt;String&gt; sets = new HashSet&lt;&gt;(); // 一行经典代码  无序不重复，无索引\n        // Set&lt;String&gt; sets = new LinkedHashSet&lt;&gt;(); // 有序  不重复 无索引\n        sets.add(&quot;MySQL&quot;);\n        sets.add(&quot;MySQL&quot;);\n        sets.add(&quot;Java&quot;);\n        sets.add(&quot;Java&quot;);\n        sets.add(&quot;HTML&quot;);\n        sets.add(&quot;HTML&quot;);\n        sets.add(&quot;SpringBoot&quot;);\n        sets.add(&quot;SpringBoot&quot;);\n        System.out.println(sets);\n    &#125;\n&#125;\n\n1.2 HashSet元素无序的底层原理HashSet集合底层采取哈希表存储的数据。\n哈希表是一种对于增删改查数据性能都较好的结构。\n哈希值- -是JDK根据对象的地址，按照某种规则算出来的int类型的数值。\nObject类的API\n\npublic int hashCode():返回对象的哈希值\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        // 目标：学会获取对象的哈希值，并确认一下\n        String name = &quot;haut&quot;;\n        System.out.println(name.hashCode());\n        System.out.println(name.hashCode());\n\n        String name1 = &quot;haut1&quot;;\n        System.out.println(name1.hashCode());\n        System.out.println(name1.hashCode());\n    &#125;\n&#125;\n\n对象的哈希值特点\n\n同一个对象多次调用hashCode()方法返回的哈希值是相同的\n默认情况下，不同对象的哈希值是不同的。\n\nHashSet1.7版本原理解析（数组+链表）\n\n创建一个默认长度1 6的数组，数组名table\n根据元素的哈希值跟数组的长度求余计算出应存入的位置(哈希算法)\n判断当前位置是否为null,如果是null直接存入\n如果位置不为null,表示有元素，则调用equals方法比较\n如果一样，则不存，如果不一样，则存入数组,\nJDK 7新元素占老元素位置，指向老元素\nJDK 8中新元素挂在老元素下面\n\n\n\nJDK1. .8版本HashSet原理解析（数组+链表+红黑树）\n底层结构:哈希表(数组、链表、红黑树的结合体)当挂在元素下面的数据过多时,查询性能降低，从JDK8开始后，当链表长度超过8的时候，自动转换为红黑树。\n\n1.3 HashSet元素去重复的底层原理\n\n创建一个默认长度16的数组, 数组名table\n根据元素的哈希值跟数组的长度求余计算出应存入的位置(哈希算法)\n判断当前位置是否为nll,如果是nulI直接存入\n如果位置不为null,表示有元素,则调用equals方法比较\n如果一样,则不存,如果不一样, 则存入数组\n\n结论:如果希望Set集合认为2个内容一样的对象是重复的,必须重写对象的hashCode()和equals(方法\n1.4 实现类：LinkedHashSetLinkedHashSet集合概述和特点\n\n有序、不重复、无索引。\n这里的有序指的是保证存储和取出的元素顺序一致。\n原理:底层数据结构是依然哈希表,只是每个元素又额外的多了一个双链表的机制记录存储的顺序。\n\n\n1.5 实现类：TreeSetTreeSet集合概述和特点\n\n&#x3D;&#x3D;不重复、 无索引、可排序。&#x3D;&#x3D;\n&#x3D;&#x3D;可排序: 按照元素的大小默认升序(有小到大)排序。&#x3D;&#x3D;\nTreeSet集合底层是基 于红黑树的数据结构实现排序的，增删改查性能都较好。\n\n注意: TreeSet集合是一定要排序的，可以将元素按照指定的规则进行排序。\nTreeSet集合默认的规则\n\n&#x3D;&#x3D;对于数值类型: Integer , Double,官方默认按照大小进行升序排序。&#x3D;&#x3D;\n&#x3D;&#x3D;对于字符串类型: 默认按照首字符的编号升序排序。&#x3D;&#x3D;\n&#x3D;&#x3D;对于自定义类型如Student对象, TreeSet无法直接排序。&#x3D;&#x3D;\n\n结论:想要使用TreeSet存储自定义类型，需要制定排序规则\n自定义排序规则\nTreeSet集合存储对象的的时候有2种方式可以设计自定义比较规则\n方式一\n\n让自定义的类实现Comparable接口重写里面的compareTo方法来定制比较规则。\n\n方式二\n\nTreeSet集合有参数构造器， 可以设置Comparator接口对应的比较器对象,来定制比较规则。\n\n两种方式中，关于返回值的规则:\n\n如果认为第一 个元素大于第二个元素返回正整数即可。\n如果认为第一 个元素小于第二个元素返回负整数即可。\n如果认为第一 个元素等于第二个元素返回0即可，此时Treeset集合只会保留一个元素,认为两者重复。\n\n&#x3D;&#x3D;注意:如果TreeSet集合存储的对象有实现比较规则，集合也自带比较器，默认使用集合自带的比较器排序。&#x3D;&#x3D;\n\n2、Collection体系的特点、总结\n如果希望元素可以重复，又有索引，索引查询要快 - - 用ArrayList集合,基于数组的。(用的最多)\n如果希望元素可以重复，又有索引，增删首尾操作快 - - 用LinkedList集合, 基于链表的。\n如果希望增删改查都快，但是元素不重复无序无索引 - - 用HashSe集合,基于哈希表的。\n如果希望增删改查都快，但是元素不重复有序、无索引 - - 用LinkedHashSe集合, 基于哈希表和双链表。\n如果要对对象进行排序 - - 用TeeSet集合,基于红黑树。后续也可以用Lis集合实现排序。\n\n\n3、可变参数可变参数\n\n可变参数用在形参中可以接收多个数据。\n&#x3D;&#x3D;可变参数的格式:数据类型..参数名称&#x3D;&#x3D;\n\n可变参数的作用\n\n传输参数非常灵活，方便。可以不传输参数,可以传输1个或者多个，也可以传输一个数组\n可变参数在方法内部本质上就是一个数组。\n\nimport java.util.Arrays;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n\n        sum(); // 1、不传参数\n        sum(10); // 2、可以传输一个参数\n        sum(10, 20, 30); // 3、可以传输多个参数\n        sum(new int[]&#123;10, 20, 30, 40, 50&#125;); // 4、可以传输一个数组\n    &#125;\n\n    /**\n     注意：一个形参列表中只能有一个可变参数,可变参数必须放在形参列表的最后面\n     * @param nums\n     */\n    public static void sum(  int...nums)&#123;\n        // 注意：可变参数在方法内部其实就是一个数组。 nums\n        System.out.println(&quot;元素个数：&quot; + nums.length);\n        System.out.println(&quot;元素内容：&quot; + Arrays.toString(nums));\n    &#125;\n&#125;\n\n可变参数的注意事项\n\n一个形参列表中可变参数只能有一个\n可变参数必须放在形参列表的最后面\n\n\n4、集合工具类Collections集合工具类\njava.utils.Collections:是集合工具类作用: Collections并不属于集合， 是用来操作集合的工具类。\nCollections常用的API\n\n\n\n方法名称\n说明\n\n\n\npublic static  boolean addAll(Collection&lt;? super T&gt; C, T… elements)\n给集合对象批量添加元素\n\n\npublic static void shuffle(List&lt;?&gt; list)\n打乱List集合元素的顺序\n\n\nCollections排序相关API\n使用范围:只能对于List集合的排序。\n排序方式1:\n\n\n\n方法名称\n说明\n\n\n\npublic static  void sort(List list)\n将集合中元素按照默认规则排序\n\n\n注意:本方式不可以直接对自定义类型的List集合排序,除非自定义类型实现了比较规则Comparable接口。\n排序方式2:\n\n\n\n方法名称\n说明\n\n\n\npublic static  void sort(List list, Comparator&lt;? super T&gt; c)\n将集合中元素按照指定规则排序\n\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        List&lt;String&gt; names = new ArrayList&lt;&gt;();\n        //names.add(&quot;楚留香&quot;);\n        //names.add(&quot;胡铁花&quot;);\n        //names.add(&quot;张无忌&quot;);\n        //names.add(&quot;陆小凤&quot;);\n        Collections.addAll(names, &quot;楚留香&quot;,&quot;胡铁花&quot;, &quot;张无忌&quot;,&quot;陆小凤&quot;);\n        System.out.println(names);\n\n        // 2、public static void shuffle(List&lt;?&gt; list) :打乱集合顺序。\n        Collections.shuffle(names);\n        System.out.println(names);\n\n        // 3、 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 （排值特性的元素）\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n        Collections.addAll(list, 12, 23, 2, 4);\n        System.out.println(list);\n        Collections.sort(list);\n        System.out.println(list);\n    &#125;\n&#125;\n\n\n5、Map集合体系5.1 Map集合的概述及特点Map集合概述和使用\n\nMap集合是一种双列集合， 每个元素包含两个数据。\nMap集合的每个元素的格式: key&#x3D;value(键值对元素)。\nMap集合也被称为”键值对集合”。\n\nMap集合整体格式\n\nCollection集合的格式: [元素1,元素2,元素3..]\nMap集合的完整格式: {key1 &#x3D;value1 , key2&#x3D;value2 , key3&#x3D;value3 …}\n\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        // 1、创建一个Map集合对象\n        // Map&lt;String, Integer&gt; maps = new HashMap&lt;&gt;(); // 一行经典代码\n        Map&lt;String, Integer&gt; maps = new LinkedHashMap&lt;&gt;();\n        maps.put(&quot;鸿星尔克&quot;, 3);\n        maps.put(&quot;Java&quot;, 1);\n        maps.put(&quot;枸杞&quot;, 100);\n        maps.put(&quot;Java&quot;, 100); // 覆盖前面的数据\n        maps.put(null, null);\n        System.out.println(maps);\n\n    &#125;\n&#125;\n\n\n\nMap集合体系特点\n\nMap集合的特点都是由键决定的。\nMap集合的键是无序,不重复的,无索引的,值不做要求(可以重复)。\nMap集合后面重复的键对应的值会覆盖前面重复键的值。\nMap集合的键值对都可以为null。\n\nMap集合实现类特点\n\nHashMap:元素按照键是无序, 不重复,无索引，值不做要求。(与Map体系一致)\nLinkedHashMap:元素按照键是有序, 不重复,无索引,值不做要求。\nTreeMap: 元素按照建是排序,不重复,无索引的,值不做要求。\n\n5.2 Map集合常用APIMap集合\nMap是双列集合的祖宗接口，它的功能是全部双列集合都可以继承使用的。\nMap API如下:\n\n\n\n方法名称\n说明\n\n\n\nV put(K key,V value)\n添加元素\n\n\nV remove(0bject key)\n根据键删除键值对元素\n\n\nvoid clear( )\n移除所有的键值对元素\n\n\nboolean containsKey(object key)\n判断集合是否包含指定的键\n\n\nboolean containsValue(0bject value )\n判断集合是否包含指定的值\n\n\nboolean isEmpty()\n判断集合是否为空\n\n\nint size()\n集合的长度，也就是集合中键值对的个数\n\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        // 1.添加元素: 无序，不重复，无索引。\n        Map&lt;String , Integer&gt; maps = new HashMap&lt;&gt;();\n        maps.put(&quot;iphoneX&quot;,10);\n        maps.put(&quot;娃娃&quot;,20);\n        maps.put(&quot;iphoneX&quot;,100);//  Map集合后面重复的键对应的元素会覆盖前面重复的整个元素！\n        maps.put(&quot;huawei&quot;,100);\n        maps.put(&quot;生活用品&quot;,10);\n        maps.put(&quot;手表&quot;,10);\n        // &#123;huawei=100, 手表=10, 生活用品=10, iphoneX=100, 娃娃=20&#125;\n        System.out.println(maps);\n\n        // 2.清空集合\n//        maps.clear();\n//        System.out.println(maps);\n\n        // 3.判断集合是否为空，为空返回true ,反之！\n        System.out.println(maps.isEmpty());\n\n        // 4.根据键获取对应值:public V get(Object key)\n        Integer key = maps.get(&quot;huawei&quot;);\n        System.out.println(key);\n        System.out.println(maps.get(&quot;生活用品&quot;)); // 10\n        System.out.println(maps.get(&quot;生活用品2&quot;)); // null\n\n        // 5.根据键删除整个元素。(删除键会返回键的值)\n        System.out.println(maps.remove(&quot;iphoneX&quot;));\n        System.out.println(maps);\n\n        // 6.判断是否包含某个键 ，包含返回true ,反之\n        System.out.println(maps.containsKey(&quot;娃娃&quot;));  // true\n        System.out.println(maps.containsKey(&quot;娃娃2&quot;));  // false\n        System.out.println(maps.containsKey(&quot;iphoneX&quot;)); // false\n\n        // 7.判断是否包含某个值。\n        System.out.println(maps.containsValue(100));  //\n        System.out.println(maps.containsValue(10));  //\n        System.out.println(maps.containsValue(22)); //\n\n        // &#123;huawei=100, 手表=10, 生活用品=10, 娃娃=20&#125;\n        // 8.获取全部键的集合：public Set&lt;K&gt; keySet()\n        Set&lt;String&gt; keys = maps.keySet();\n        System.out.println(keys);\n\n        System.out.println(&quot;------------------------------&quot;);\n        // 9.获取全部值的集合：Collection&lt;V&gt; values();\n        Collection&lt;Integer&gt; values = maps.values();\n        System.out.println(values);\n\n        // 10.集合的大小\n        System.out.println(maps.size()); // 4\n\n        // 11.合并其他Map集合。(拓展)\n        Map&lt;String , Integer&gt; map1 = new HashMap&lt;&gt;();\n        map1.put(&quot;java1&quot;, 1);\n        map1.put(&quot;java2&quot;, 100);\n        Map&lt;String , Integer&gt; map2 = new HashMap&lt;&gt;();\n        map2.put(&quot;java2&quot;, 1);\n        map2.put(&quot;java3&quot;, 100);\n        map1.putAll(map2); // 把集合map2的元素拷贝一份到map1中去\n        System.out.println(map1);\n        System.out.println(map2);\n    &#125;\n&#125;\n\n5.3 Map集合的遍历方式方式一 - - 键找值\n\n先获取Map集合的全部键的Set集合。\n遍历键的Set集合,然后通过键提取对应值。\n\n\n键找值涉及到的API:\n\n\n\n方法名称\n说明\n\n\n\nSet keySet()\n获取所有键的集合\n\n\nV get(Object key)\n根据键获取值\n\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        Map&lt;String , Integer&gt; maps = new HashMap&lt;&gt;();\n        // 1.添加元素: 无序，不重复，无索引。\n        maps.put(&quot;娃娃&quot;,30);\n        maps.put(&quot;iphoneX&quot;,100);\n        maps.put(&quot;huawei&quot;,1000);\n        maps.put(&quot;生活用品&quot;,10);\n        maps.put(&quot;手表&quot;,10);\n        System.out.println(maps);\n        // maps = &#123;huawei=1000, 手表=10, 生活用品=10, iphoneX=100, 娃娃=30&#125;\n\n        // 1、键找值：第一步：先拿到集合的全部键。\n        Set&lt;String&gt; keys = maps.keySet();\n        // 2、第二步：遍历每个键，根据键提取值\n        for (String key : keys) &#123;\n            int value = maps.get(key);\n            System.out.println(key + &quot;===&gt;&quot; + value);\n        &#125;\n\n    &#125;\n&#125;\n\n方式二 – 键值对\n\n先把Map集合转换成Set集合，Set集合中每 个元素都是键值对实体类型了。\n遍历Set集合，然后提取键以及提取值。\n\n\n键值对涉及到的API:\n\n\n\n方法名称\n说明\n\n\n\nSet&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()\n获取所有键值对对象的集合\n\n\nK getKey()\n获得键\n\n\nV getValue()\n获取值\n\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        Map&lt;String , Integer&gt; maps = new HashMap&lt;&gt;();\n        // 1.添加元素: 无序，不重复，无索引。\n        maps.put(&quot;娃娃&quot;,30);\n        maps.put(&quot;iphoneX&quot;,100);\n        maps.put(&quot;huawei&quot;,1000);\n        maps.put(&quot;生活用品&quot;,10);\n        maps.put(&quot;手表&quot;,10);\n        System.out.println(maps);\n        // maps = &#123;huawei=1000, 手表=10, 生活用品=10, iphoneX=100, 娃娃=30&#125;\n        // 1、把Map集合转换成Set集合\n        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = maps.entrySet();\n        // 2、开始遍历\n        for(Map.Entry&lt;String, Integer&gt; entry : entries)&#123;\n            String key = entry.getKey();\n            int value = entry.getValue();\n            System.out.println(key + &quot;====&gt;&quot; + value);\n        &#125;\n    &#125;\n&#125;\n\n方式三 – lambda表达式\n得益于JDK 8开始的新技术Lambda表达式，提供了一种更简单、更直接的遍历集合的方式。\nMap结合Lambda遍历的API\n\n\n\n方法名称\n说明\n\n\n\ndefault void forEach(Biconsumer&lt;? super K, ? super v&gt; action)\n结合lambda遍历Map集合\n\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.BiConsumer;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        Map&lt;String , Integer&gt; maps = new HashMap&lt;&gt;();\n        // 1.添加元素: 无序，不重复，无索引。\n        maps.put(&quot;娃娃&quot;,30);\n        maps.put(&quot;iphoneX&quot;,100);//  Map集合后面重复的键对应的元素会覆盖前面重复的整个元素！\n        maps.put(&quot;huawei&quot;,1000);\n        maps.put(&quot;生活用品&quot;,10);\n        maps.put(&quot;手表&quot;,10);\n        System.out.println(maps);\n\n        maps.forEach((k, v) -&gt; &#123;\n            System.out.println(k + &quot;---&gt;&quot; + v);\n        &#125;);\n\n    &#125;\n&#125;\n\n5.4 Map集合的实现类HashMap\n\nHashMap是Map里面的一个实现类。特点都是由键决定的:无序、不重复、无索引\n可直接使用Map里面的方法\nHashMap跟HashSet底层原理是一模一样的，都是哈希表结构，HashMap的每个元素包含两个值\n\n（实际上:Set系列集合的底层就是Map实现的，只是Set集合中的元素只要键数据，不要值数据而已。）\nimport com.itheima.d1_collection_set.Student;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class HashMapDemo &#123;\n    public static void main(String[] args) &#123;\n         // Map集合是根据键去除重复元素\n        Map&lt;Student, String&gt; maps = new HashMap&lt;&gt;();\n\n        Student s1 = new Student(&quot;无恙&quot;, 20, &#39;男&#39;);\n        Student s2 = new Student(&quot;无恙&quot;, 20, &#39;男&#39;);\n        Student s3 = new Student(&quot;周雄&quot;, 21, &#39;男&#39;);\n\n        maps.put(s1, &quot;北京&quot;);\n        maps.put(s2, &quot;上海&quot;);\n        maps.put(s3, &quot;广州&quot;);\n\n        System.out.println(maps);\n    &#125;\n&#125;\n\nLinkenHashMap\n\n由键决定:有序、不重复、无索引\n这里的有序指的是保证存储和取出的元素顺序─致\n底层数据结构是依然哈希表，只是每个键值对元素又额外的多了一个双链表的机制记录存储的顺序。\n\n\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.TreeSet;\n\n/**\n    目标：认识Map体系的特点：按照键无序，不重复，无索引。值不做要求。\n */\npublic class LinkedHashMapDemo &#123;\n    public static void main(String[] args) &#123;\n        // 1、创建一个Map集合对象\n        Map&lt;String, Integer&gt; maps = new LinkedHashMap&lt;&gt;();\n        maps.put(&quot;鸿星尔克&quot;, 3);\n        maps.put(&quot;Java&quot;, 1);\n        maps.put(&quot;枸杞&quot;, 100);\n        maps.put(&quot;Java&quot;, 100); // 覆盖前面的数据\n        maps.put(null, null);\n        System.out.println(maps);\n\n    &#125;\n&#125;\n\nTreeMap\n\n由键决定特性:不重复、无索引、可排序。\n可排序:按照键数据的大小默认升序(有小到大)排序。只能对键排序。\n注意:TreeMap集合是一定要排序的，可以默认排序，也可以将键按照指定的规则进行排序。\nTreeMap跟TreeSet—样底层原理是一样的。\n\nTreeMap集合自定义排序规则有2种\n\n类实现Comparable接口，重写比较规则。\n集合自定义Comparator比较器对象，重写比较规则。\n\npublic class Apple implements Comparable&lt;Apple&gt;&#123;\n    private String name;\n    private String color;\n    private double price;\n    private int weight;\n\n    public Apple() &#123;\n    &#125;\n\n    public Apple(String name, String color, double price, int weight) &#123;\n        this.name = name;\n        this.color = color;\n        this.price = price;\n        this.weight = weight;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public String getColor() &#123;\n        return color;\n    &#125;\n\n    public void setColor(String color) &#123;\n        this.color = color;\n    &#125;\n\n    public double getPrice() &#123;\n        return price;\n    &#125;\n\n    public void setPrice(double price) &#123;\n        this.price = price;\n    &#125;\n\n    public int getWeight() &#123;\n        return weight;\n    &#125;\n\n    public void setWeight(int weight) &#123;\n        this.weight = weight;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Apple&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, color=&#39;&quot; + color + &#39;\\&#39;&#39; +\n                &quot;, price=&quot; + price +\n                &quot;, weight=&quot; + weight +\n                &#39;&#125;&#39;;\n    &#125;\n\n    /**\n      方式一：类自定义比较规则\n      o1.compareTo(o2)\n     * @param o\n     * @return\n     */\n    @Override\n    public int compareTo(Apple o) &#123;\n        // 按照重量进行比较的\n        return this.weight - o.weight ; // 去重重量重复的元素\n        // return this.weight - o.weight &gt;= 0 ? 1 : -1; // 保留重量重复的元素\n    &#125;\n&#125;\n\nimport java.util.Comparator;\nimport java.util.Map;\nimport java.util.TreeMap;\n\npublic class TreeMapDemo3 &#123;\n    public static void main(String[] args) &#123;\n        Map&lt;Integer, String&gt; maps1 = new TreeMap&lt;&gt;();\n        maps1.put(13 , &quot;王麻子&quot;);\n        maps1.put(1 , &quot;张三&quot;);\n        maps1.put(3 , &quot;县长&quot;);\n        System.out.println(maps1);\n\n        // TreeMap集合自带排序。  可排序 不重复（只要大小规则一样就认为重复）  无索引\n        Map&lt;Apple, String&gt; maps2 = new TreeMap&lt;&gt;(new Comparator&lt;Apple&gt;() &#123;\n            @Override\n            public int compare(Apple o1, Apple o2) &#123;\n                return Double.compare(o2.getPrice() , o1.getPrice()); // 按照价格降序排序！\n            &#125;\n        &#125;);\n        maps2.put(new Apple(&quot;红富士&quot;, &quot;红色&quot;, 9.9, 500), &quot;山东&quot; );\n        maps2.put(new Apple(&quot;青苹果&quot;, &quot;绿色&quot;, 15.9, 300), &quot;广州&quot;);\n        maps2.put(new Apple(&quot;绿苹果&quot;, &quot;青色&quot;, 29.9, 400), &quot;江西&quot;);\n        maps2.put(new Apple(&quot;黄苹果&quot;, &quot;黄色&quot;, 9.8, 500), &quot;湖北&quot;);\n\n        System.out.println(maps2);\n    &#125;\n&#125;\n\n5.5 集合的嵌套需求\n\n某个班级多名学生，现在需要组成秋游活动，班长提供了四个景点依次是(A、B、C、D),每个学生可以选择多个景点，请统计出最终哪个景点想去的人数最多。\n\n分析\n\n将80个学生选择的数据拿到程序中去，需要记住每个学生选择的情况。\n定义Map集合用于存储最终统计的结果。\n\nimport java.util.*;\n\npublic class MapTest4 &#123;\n    public static void main(String[] args) &#123;\n        // 1、要求程序记录每个学生选择的情况。\n        // 使用一个Map集合存储。\n        Map&lt;String, List&lt;String&gt;&gt; data = new HashMap&lt;&gt;();\n\n        // 2、把学生选择的数据存入进去。\n        List&lt;String&gt; selects = new ArrayList&lt;&gt;();\n        Collections.addAll(selects, &quot;A&quot;, &quot;C&quot;);\n        data.put(&quot;罗勇&quot;, selects);\n\n        List&lt;String&gt; selects1 = new ArrayList&lt;&gt;();\n        Collections.addAll(selects1, &quot;B&quot;, &quot;C&quot; , &quot;D&quot;);\n        data.put(&quot;胡涛&quot;, selects1);\n\n        List&lt;String&gt; selects2 = new ArrayList&lt;&gt;();\n        Collections.addAll(selects2 , &quot;A&quot;,  &quot;B&quot;, &quot;C&quot; , &quot;D&quot;);\n        data.put(&quot;刘军&quot;, selects2);\n\n        System.out.println(data);\n\n        // 3、统计每个景点选择的人数。\n        Map&lt;String, Integer&gt; infos = new HashMap&lt;&gt;(); // &#123;&#125;\n\n        // 4、提取所有人选择的景点的信息。\n        Collection&lt;List&lt;String&gt;&gt; values = data.values();\n        System.out.println(values);\n        // values = [[A, B, C, D], [B, C, D], [A, C]]\n        //             value\n\n        for (List&lt;String&gt; value : values) &#123;\n            for (String s : value) &#123;\n                // 有没有包含这个景点\n                if(infos.containsKey(s))&#123;\n                    infos.put(s, infos.get(s) + 1);\n                &#125;else &#123;\n                    infos.put(s , 1);\n                &#125;\n            &#125;\n        &#125;\n\n        System.out.println(infos);\n    &#125;\n&#125;\n\n\n6、不可变集合&#x3D;&#x3D;不可变集合，就是不可被修改的集合。集合的数据项在创建的时候提供，并且在整个生命周期中都不可改变。否则报错。&#x3D;&#x3D;\n如果某个数据不能被修改，把它防御性地拷贝到不可变集合中是个很好的实践。或者当集合对象被不可信的库调用时，不可变形式是安全的。\n在List、Set、Map接口中，都存在of方法，可以创建一个不可变的集合。\n\n\n\n方法名称\n说明\n\n\n\nstatic  List of(E..elements)\n创建一个具有指定元素的List集合对象\n\n\nstatic  Set of(E…elements)\n创建一个具有指定元素的Set集合对象\n\n\nstatic &lt;K,V&gt; Map&lt;K,V&gt; of(…elements)\n创建一个具有指定元素的Map集合对象\n\n\n这个集合不能添加，不能删除，不能修改。\n\n\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class CollectionDemo &#123;\n    public static void main(String[] args) &#123;\n        // 1、不可变的List集合\n        List&lt;Double&gt; lists = List.of(569.5, 700.5, 523.0,  570.5);\n        // lists.add(689.0);\n        // lists.set(2, 698.5);\n        // System.out.println(lists);\n        double score = lists.get(1);\n        System.out.println(score);\n\n        // 2、不可变的Set集合\n        Set&lt;String&gt; names = Set.of(&quot;迪丽热巴&quot;, &quot;迪丽热九&quot;, &quot;马尔扎哈&quot;, &quot;卡尔眨巴&quot; );\n        // names.add(&quot;三少爷&quot;);\n        System.out.println(names);\n\n        // 3、不可变的Map集合\n        Map&lt;String, Integer&gt; maps = Map.of(&quot;huawei&quot;,2, &quot;Java开发&quot;, 1 , &quot;手表&quot;, 1);\n        // maps.put(&quot;衣服&quot;, 3);\n        System.out.println(maps);\n    &#125;\n&#125;\n\n\n","slug":"Java程序设计 -- 集合(下)（十三）","date":"2022-03-24T10:16:55.000Z","categories_index":"后端","tags_index":"Java","author_index":"会思想的苇草i"},{"id":"84c5c7d3318822a7a4ef1ba96214ecd0","title":"Java程序设计--集合(上)","content":"\n1、集合的概述集合和数组都是容器\n\n数组定义完成并启动后，类型确定、长度固定。\n\n数组可以&#x3D;&#x3D;存储基本类型和引用类型的数据。&#x3D;&#x3D;\n\n适合元素的个数和类型确定的业务场景，不适合做需要增删数据操作。\n\n集合的大小不固定，启动后可以动态变化，类型也可以选择不固定。\n\n集合只能&#x3D;&#x3D;存储引用数据类型的数据。&#x3D;&#x3D;\n\n集合非常适合做元素的增删操作。\n\n\n\n2、集合的体系\n&#x3D;&#x3D;List系列集合:添加的元素是有序、可重复、有索引。&#x3D;&#x3D;\n\n&#x3D;&#x3D;ArrayList、LinekdList :有序、可重复、有索引。&#x3D;&#x3D;\n\n&#x3D;&#x3D;Set系列集合:添加的元素是无序、不重复、无索引。&#x3D;&#x3D;\n\n&#x3D;&#x3D;HashSet:无序、不重复、无索引;&#x3D;&#x3D;\n&#x3D;&#x3D;LinkedHashSet:有序、不重复、无索引。&#x3D;&#x3D;\n&#x3D;&#x3D;TreeSet:按照大小默认升序排序、不重复、无索引。&#x3D;&#x3D;\n\n集合都是支持泛型的，可以在编译阶段约束集合只能操作某种数据类型。\n\n3、Collection的常用方法Collection是单列集合的祖宗接口，它的功能是全部单列集合都可以继承使用的。\n\n\n\n方法名\n称说明\n\n\n\npublic boolean add(E e)\n把给定的对象添加到当前集合中\n\n\npublic void clear()\n清空集合中所有的元素\n\n\npublic boolean remove(E e)\n把给定的对象在当前集合中删除\n\n\npublic boolean contains(Object obj)\n判断当前集合中是否包含给定的对象\n\n\npublic boolean isEmpty()\n判断当前集合是否为空\n\n\npublic int size()\n返回集合中元素的个数\n\n\npublic Object[] toArray()\n把集合中的元素，存储到数组中\n\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\n\npublic class CollectionDemo &#123;\n    public static void main(String[] args) &#123;\n        // HashSet:添加的元素是无序，不重复，无索引。\n        Collection&lt;String&gt; c = new ArrayList&lt;&gt;();\n        // 1.添加元素, 添加成功返回true。\n        c.add(&quot;Java&quot;);\n        c.add(&quot;HTML&quot;);\n        System.out.println(c.add(&quot;HTML&quot;));\n        c.add(&quot;MySQL&quot;);\n        c.add(&quot;Java&quot;);\n        System.out.println(c.add(&quot;后端&quot;));\n        System.out.println(c); // [Java, HTML, HTML, MySQL, Java, 后端]\n\n        // 2.清空集合的元素。\n        // c.clear();\n        // System.out.println(c);\n\n        // 3.判断集合是否为空 是空返回true,反之。\n        // System.out.println(c.isEmpty());\n\n        // 4.获取集合的大小。\n        System.out.println(c.size());\n\n        // 5.判断集合中是否包含某个元素。\n        System.out.println(c.contains(&quot;Java&quot;));  // true\n        System.out.println(c.contains(&quot;java&quot;)); // false\n        System.out.println(c.contains(&quot;后端&quot;)); // true\n\n        // 6.删除某个元素:如果有多个重复元素默认删除前面的第一个！\n        System.out.println(c.remove(&quot;java&quot;)); // false\n        System.out.println(c);\n        System.out.println(c.remove(&quot;Java&quot;)); // true\n        System.out.println(c);\n\n        // 7.把集合转换成数组  [HTML, HTML, MySQL, Java, 后端]\n        Object[] arrs = c.toArray();\n        System.out.println(&quot;数组：&quot; + Arrays.toString(arrs));\n\n        System.out.println(&quot;----------------------拓展----------------------&quot;);\n        Collection&lt;String&gt; c1 = new ArrayList&lt;&gt;();\n        c1.add(&quot;java1&quot;);\n        c1.add(&quot;java2&quot;);\n        Collection&lt;String&gt; c2 = new ArrayList&lt;&gt;();\n        c2.add(&quot;赵敏&quot;);\n        c2.add(&quot;殷素素&quot;);\n        // addAll把c2集合的元素全部倒入到c1中去。\n        c1.addAll(c2);\n        System.out.println(c1);\n        System.out.println(c2);\n    &#125;\n&#125;\n\n\n4、集合的遍历方式4.1 方式一：迭代器遍历就是一个一个的把容器中的元素访问一遍。\n&#x3D;&#x3D;迭代器在Java中的代表是lterator，迭代器是集合的专用遍历方式。&#x3D;&#x3D;\nCollection集合获取迭代器\n\n\n\n方法名称\n说明\n\n\n\nIterator iterator()\n返回集合中的迭代器对象，该迭代器对象默认指向当前集合的O索引\n\n\nlterator中的常用方法\n\n\n\n方法名称\n说明\n\n\n\nboolean hasNext()\n询问当前位置是否有元素存在，存在返回true ,不存在返回false\n\n\nE next()\n获取当前位置的元素，并同时将迭代器对象移向下一个位置，注意防止取出越界\n\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        ArrayList&lt;String&gt; lists = new ArrayList&lt;&gt;();\n        lists.add(&quot;赵敏&quot;);\n        lists.add(&quot;小昭&quot;);\n        lists.add(&quot;素素&quot;);\n        lists.add(&quot;灭绝&quot;);\n        System.out.println(lists);\n        // [赵敏, 小昭, 素素, 灭绝]\n\n        // 1、得到当前集合的迭代器对象。\n        Iterator&lt;String&gt; it = lists.iterator();\n\n        // 2、定义while循环\n        while (it.hasNext())&#123;\n            String ele = it.next();\n            System.out.println(ele);\n        &#125;\n        System.out.println(&quot;-----------------------------&quot;);\n    &#125;\n&#125;\n\n\n4.2 方式二：foreach&#x2F;增强for循环&#x3D;&#x3D;增强for循环，既可以遍历集合也可以遍历数组。&#x3D;&#x3D;\nfor(元素数据类型 变量名:数组或者Collection集合)&#123;\n    //在此处使用变量即可，该变量就是元素\n&#125;\n\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        Collection&lt;String&gt; lists = new ArrayList&lt;&gt;();\n        lists.add(&quot;赵敏&quot;);\n        lists.add(&quot;小昭&quot;);\n        lists.add(&quot;殷素素&quot;);\n        lists.add(&quot;周芷若&quot;);\n        System.out.println(lists);\n        // [赵敏, 小昭, 殷素素, 周芷若]\n        //  ele\n\n        for (String ele : lists) &#123;\n            System.out.println(ele);\n        &#125;\n\n        System.out.println(&quot;------------------&quot;);\n        double[] scores = &#123;100, 99.5 , 59.5&#125;;\n        for (double score : scores) &#123;\n            System.out.println(score);\n//            if(score == 59.5)&#123;\n//                score = 100.0; // 修改无意义，不会影响数组的元素值。\n//            &#125;\n        &#125;\n        System.out.println(Arrays.toString(scores));\n    &#125;\n&#125;\n\n4.3 方式三：lambda表达式得益于JDK 8开始的新技术Lambda表达式，提供了一种更简单、更直接的遍历集合的方式。\nCollection结合Lambda遍历的APl\n\n\n\n方法名称\n说明\n\n\n\ndefault void forEach(consumer&lt; ?super T&gt; action):\n结合lambda遍历集合\n\n\n\n\n\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.function.Consumer;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        Collection&lt;String&gt; lists = new ArrayList&lt;&gt;();\n        lists.add(&quot;赵敏&quot;);\n        lists.add(&quot;小昭&quot;);\n        lists.add(&quot;殷素素&quot;);\n        lists.add(&quot;周芷若&quot;);\n        System.out.println(lists);\n        // [赵敏, 小昭, 殷素素, 周芷若]\n        //  s\n        lists.forEach(new Consumer&lt;String&gt;() &#123;\n            @Override\n            public void accept(String s) &#123;\n                System.out.println(s);\n            &#125;\n        &#125;);\n\n//        lists.forEach(s -&gt; &#123;\n//                System.out.println(s);\n//        &#125;);\n\n        // lists.forEach(s -&gt;  System.out.println(s) );\n\n        lists.forEach(System.out::println );\n\n    &#125;\n&#125;\n\n\n5、 集合存储自定义类型的对象public class Movie &#123;\n    private String name;\n    private double score;\n    private String actor;\n\n    public Movie() &#123;\n    &#125;\n\n    public Movie(String name, double score, String actor) &#123;\n        this.name = name;\n        this.score = score;\n        this.actor = actor;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public double getScore() &#123;\n        return score;\n    &#125;\n\n    public void setScore(double score) &#123;\n        this.score = score;\n    &#125;\n\n    public String getActor() &#123;\n        return actor;\n    &#125;\n\n    public void setActor(String actor) &#123;\n        this.actor = actor;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Movie&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, score=&quot; + score +\n                &quot;, actor=&#39;&quot; + actor + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\n\npublic class TestDemo &#123;\n    public static void main(String[] args) &#123;\n        // 1、定义一个电影类\n        // 2、定义一个集合对象存储3部电影对象\n        Collection&lt;Movie&gt; movies = new ArrayList&lt;&gt;();\n        movies.add(new Movie(&quot;《你好，李焕英》&quot;, 9.5, &quot;张小斐,贾玲,沈腾,陈赫&quot;));\n        movies.add(new Movie(&quot;《唐人街探案》&quot;, 8.5, &quot;王宝强,刘昊然,美女&quot;));\n        movies.add(new Movie(&quot;《刺杀小说家》&quot;,8.6, &quot;雷佳音,杨幂&quot;));\n\n        System.out.println(movies);\n\n        // 3、遍历集合容器中的每个电影对象\n        for (Movie movie : movies) &#123;\n            System.out.println(&quot;片名：&quot; + movie.getName());\n            System.out.println(&quot;得分：&quot; + movie.getScore());\n            System.out.println(&quot;主演：&quot; + movie.getActor());\n        &#125;\n\n    &#125;\n&#125;\n\n集合中存储的是元素对象的地址。\n\n6、常见的数据结构参见数据结构系列博客    数据结构笔记。\n\n7、List系列集合7.1 List集合特点&#x3D;&#x3D;ArrayList、 LinekdList :有序，可重复，有索引。&#x3D;&#x3D;\n\n有序:存储和取出的元素顺序一致\n有索引:可以通过索引操作元素\n可重复: 存储的元素可以重复\n\n&#x3D;&#x3D;ArrayList底层是基于数组实现的,根据查询元素快,增删相对慢。&#x3D;&#x3D;&#x3D;&#x3D;LinkedList底层基于双链表实现的，查询元素慢,增删首尾元素是非常快的。&#x3D;&#x3D;\nList集合特有方法\nList集合因为支持索引， 所以多了很多索弓|操作的独特api,其他Collection的功能List也都继承了。\n\n\n\n方法名称\n说明\n\n\n\nvoid add(int index,E element)\n在此集合中的指定位置插入指定的元素\n\n\nE remove(int index)\n删除指定索引处的元素，返回被删除的元素\n\n\nE set(int index,E element)\n修改指定索引处的元素，返回被修改的元素\n\n\nE get(int index)\n返回指定索引\n\n\nimport java.util.ArrayList;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        // 1.创建一个ArrayList集合对象：\n        // List:有序，可重复，有索引的。\n        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); // 一行经典代码！\n        list.add(&quot;Java&quot;);\n        list.add(&quot;Java&quot;);\n        list.add(&quot;HTML&quot;);\n        list.add(&quot;HTML&quot;);\n        list.add(&quot;MySQL&quot;);\n        list.add(&quot;MySQL&quot;);\n\n        // 2.在某个索引位置插入元素。\n        list.add(2, &quot;后端&quot;);\n        System.out.println(list);\n\n        // 3.根据索引删除元素,返回被删除元素\n        System.out.println(list.remove(1));\n        System.out.println(list);\n\n        // 4.根据索引获取元素:public E get(int index):返回集合中指定位置的元素。\n        System.out.println(list.get(1));\n\n        // 5.修改索引位置处的元素: public E set(int index, E element)\n        System.out.println(list.set(1, &quot;前端&quot;));\n        System.out.println(list);\n    &#125;\n&#125;\n\n7.2 List集合遍历\n迭代器\n增强for循环\nLambda表达式\nfor循环(因为List集合存在索引)\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class Test&#123;\n    public static void main(String[] args) &#123;\n        List&lt;String&gt; lists = new ArrayList&lt;&gt;();\n        lists.add(&quot;java1&quot;);\n        lists.add(&quot;java2&quot;);\n        lists.add(&quot;java3&quot;);\n\n        /* （1）for循环。 */\n        System.out.println(&quot;-----------------------&quot;);\n\n        for (int i = 0; i &lt; lists.size(); i++) &#123;\n            String ele = lists.get(i);\n            System.out.println(ele);\n        &#125;\n\n\n        /* （2）迭代器。 */\n        System.out.println(&quot;-----------------------&quot;);\n        Iterator&lt;String&gt; it = lists.iterator();\n        while (it.hasNext())&#123;\n            String ele = it.next();\n            System.out.println(ele);\n        &#125;\n\n        /* （3）foreach */\n        System.out.println(&quot;-----------------------&quot;);\n        for (String ele : lists) &#123;\n            System.out.println(ele);\n        &#125;\n\n        /* （4）JDK 1.8开始之后的Lambda表达式  */\n        System.out.println(&quot;-----------------------&quot;);\n        lists.forEach(s -&gt; &#123;\n            System.out.println(s);\n        &#125;);\n\n    &#125;\n&#125;\n\n7.3 ArrayList集合的底层原理\nAraylist底层是基于数组实现的:根据索引定位元素快，增删需要做元素的移位操作。\n第一次创建集合并添加第一个元素的时候， 在底层创建一个默认长度为10的数组。\n\n\n\n7.4 LinkedList集合的底层原理底层数据结构是双链表，查询慢，首尾操作的速度是极快的，所以多了很多首尾操作的特有API。\nLinkedList集合的特有功能\n\n\n\n方法名称\n说明\n\n\n\npublic void adFirst(E e)\n在该列表开头插入指定的元素\n\n\npublic void addLast(E e)\n将指定的元素追加到此列表的末尾\n\n\npublic E getFirst()\n返回此列表中的第一个元素\n\n\npublic E getLast()\n返回此列表中的最后一个元素\n\n\npublic E removeFirst()\n从此列表中删除并返回第一个元素\n\n\npublic E removeLast()\n从此列表中删除并返回最后一个元素\n\n\n\n\n\n\n\n8、集合的并发修改异常问题当我们从集合中找出某个元素并删除的时候可能出现一 种并发修改异常问题。\n哪些遍历存在问题?\n\n迭代器遍历集合且直接用集合删除元素的时候可能出现。\n增强for循环遍历集合且直接用集合删除元素的时候可能出现。\n\n哪种遍历且删除元素不出问题\n\n迭代器遍历集合但是用迭代器自己的删除方法操作可以解决。\n使用for循环遍历并删除元素不会存在这个问题。\n\n\n9、泛型深入9.1 泛型的概述和优势泛型概述\n\n泛型:是JDK5中引入的特性,可以在编译阶段约束操作的数据类型，并进行检查。\n泛型的格式: &lt;数据类型&gt;; 注意:泛型只能支持引|用数据类型。\n集合体系的全部接口和实现类都是支持泛型的使用的。\n\n泛型的好处:\n\n统一数据类型。\n把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为编译阶段类型就能确定下来。\n\n\n9.2 自定义泛型类泛型类的概述\n\n定义类时同时定义了泛型的类就是泛型类。\n泛型类的格式:修饰符class类名&lt;泛型变量&gt;{ }\n\n范例: public class MyArrayList&lt;T&gt; &#123; &#125;\n\n此处泛型变量T可以随便写为任意标识, 常见的如E、T、K、V等。\n作用:编译阶段可以指定数据类型，类似于集合的作用。\n模拟ArrayList集合自定义一 个集合MyArrayList集合,完成添加和删除功能的泛型设计即可。\nimport java.util.ArrayList;\n\npublic class MyArrayList&lt;E&gt; &#123;\n    private ArrayList lists = new ArrayList();\n\n    public void add(E e)&#123;\n        lists.add(e);\n    &#125;\n\n    public void remove(E e)&#123;\n        lists.remove(e);\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return lists.toString();\n    &#125;\n&#125;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        MyArrayList&lt;String&gt; list = new MyArrayList&lt;&gt;();\n        list.add(&quot;Java&quot;);\n        list.add(&quot;Java&quot;);\n        list.add(&quot;MySQL&quot;);\n        list.remove(&quot;MySQL&quot;);\n        System.out.println(list);\n\n        MyArrayList&lt;Integer&gt; list2 = new MyArrayList&lt;&gt;();\n        list2.add(23);\n        list2.add(24);\n        list2.add(25);\n        list2.remove(25);\n        System.out.println(list2);\n    &#125;\n&#125;\n\n泛型类的原理:\n把出现泛型变量的地方全部替换成传输的真实数据类型。\n9.3 自定义泛型方法泛型方法的概述\n\n定义方法时同时定义了泛型的方法就是泛型方法。\n泛型方法的格式:修饰符&lt;泛型变量&gt;方法返回值方法名称(形参列表){}\n\n范例: public &lt;T&gt; void show(T t)&#123; &#125;\n\n作用:方法中可以使用泛型接收一切实际类型的参数，方法更具备通用性。\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        String[] names = &#123;&quot;小璐&quot;, &quot;蓉容&quot;, &quot;小何&quot;&#125;;\n        printArray(names);\n\n        Integer[] ages = &#123;10, 20, 30&#125;;\n        printArray(ages);\n\n        Integer[] ages2 = getArr(ages);\n        String[]  names2 = getArr(names);\n    &#125;\n\n    public static &lt;T&gt; T[] getArr(T[] arr)&#123;\n        return arr;\n    &#125;\n\n    public static &lt;T&gt; void printArray(T[] arr)&#123;\n        if(arr != null)&#123;\n            StringBuilder sb = new StringBuilder(&quot;[&quot;);\n            for (int i = 0; i &lt; arr.length; i++) &#123;\n                sb.append(arr[i]).append(i == arr.length - 1 ? &quot;&quot; : &quot;, &quot;);\n            &#125;\n            sb.append(&quot;]&quot;);\n            System.out.println(sb);\n        &#125;else &#123;\n            System.out.println(arr);\n        &#125;\n    &#125;\n&#125;\n\n给你任何一个类型的数组，都能返回它的内容。也就是实现Arrays.toString(数组)的功能! \n泛型方法的原理:\n把出现泛型变量的地方全部替换成传输的真实数据类型。\n9.4 自定义泛型接口泛型接口的概述\n\n使用了泛型定义的接口就是泛型接口。\n泛型接口的格式:修饰符interface 接口名称&lt;泛型变量&gt;{}\n\n范例: public interface Data&lt;E&gt;&#123;&#125;\n\n作用:泛型接口可以让实现类选择当前功能需要操作的数据类型\n泛型接口的原理:\n实现类可以在实现接口的时候传入自己操作的数据类型,这样重写的方法都将是针对于该类型的操作。\n9.5 泛型通配符、上下限通配符:?\n\n?可以在“使用泛型”的时候代表一切类型。\nET KV是在定义泛型的时候使用的。\n\n开发一个极品飞车的游戏,所有的汽车都能一 起参与比赛。\nimport java.util.ArrayList;\n\npublic class GenericDemo &#123;\n    public static void main(String[] args) &#123;\n        ArrayList&lt;BMW&gt; bmws = new ArrayList&lt;&gt;();\n        bmws.add(new BMW());\n        bmws.add(new BMW());\n        bmws.add(new BMW());\n        go(bmws);\n\n        ArrayList&lt;BENZ&gt; benzs = new ArrayList&lt;&gt;();\n        benzs.add(new BENZ());\n        benzs.add(new BENZ());\n        benzs.add(new BENZ());\n        go(benzs);\n\n        ArrayList&lt;Dog&gt; dogs = new ArrayList&lt;&gt;();\n        dogs.add(new Dog());\n        dogs.add(new Dog());\n        dogs.add(new Dog());\n        // go(dogs);\n    &#125;\n\n    /**\n       所有车比赛\n     */\n    public static void go(ArrayList&lt;? extends Car&gt; cars)&#123;\n    &#125;\n&#125;\n\nclass Dog&#123;\n\n&#125;\n\nclass BENZ extends Car&#123;\n&#125;\n\nclass BMW extends Car&#123;\n&#125;\n\n// 父类\nclass Car&#123;\n&#125;\n\n注意:●虽然BMW和BENZ都继承了Car但是ArrayList &lt; BMW&gt;和ArrayList与ArrayList没有关系的! !\n泛型的上下限: .\n\n? extends Car: ?必须是Car或者其子类泛型上限\n? super Car : ?必须是Car或者其父类 泛型下限\n\n\n","slug":"Java程序设计 -- 集合(上)（十二）","date":"2022-03-22T13:26:15.000Z","categories_index":"后端","tags_index":"Java","author_index":"会思想的苇草i"},{"id":"65aeac242f4186aad4881b96128bffa6","title":"Java程序设计--常用API(下)","content":"\n1、日期与时间1.1 DateDate 类代表当前所在系统的日期时间信息。\nDate 的构造器\n\n\n\n名称\n说明\n\n\n\npublic Date()\n创建一个 Date 对象，代表的是系统当前此刻日期时间。\n\n\nDate 的常用方法\n\n\n\n名称\n说明\n\n\n\npublic long getTime()\n返回从 1970 年 1 月 1 日 00:00:00 走到此刻的总的毫秒数\n\n\n时间毫秒值-&gt;日期对象\n\n\n\n构造器\n说明\n\n\n\npublic Date(long time)\n把时间毫秒值转换成 Date 日期对象。\n\n\n\n\n\nDate\n方法说明\n\n\n\npublic void setTime(long time)\n设置日期对象的时间为当前时间毫秒值对应的时间\n\n\nimport java.time.Instant;\nimport java.time.ZoneId;\nimport java.util.Date;\n\n/**\n    目标：学会使用Date类处理时间，获取时间的信息\n */\npublic class DateDemo &#123;\n    public static void main(String[] args) &#123;\n        // 1、创建一个Date类的对象：代表系统此刻日期时间对象\n        Date d = new Date();\n        System.out.println(d);\n\n        // 2、获取时间毫秒值\n        long time = d.getTime();\n        System.out.println(time);\n//        long time1 = System.currentTimeMillis();\n//        System.out.println(time1);\n\n        System.out.println(&quot;----------------------------&quot;);\n        // 1、得到当前时间\n        Date d1 = new Date();\n        System.out.println(d1);\n\n        // 2、当前时间往后走 1小时  121s\n        long time2 = System.currentTimeMillis();\n        time2 += (60 * 60 + 121) * 1000;\n\n        // 3、把时间毫秒值转换成对应的日期对象。\n        // Date d2 = new Date(time2);\n        // System.out.println(d2);\n\n        Date d3 = new Date();\n        d3.setTime(time2);\n        System.out.println(d3);\n\n    &#125;\n&#125;\n\n1.2 SimpleDateFormat可以去完成日期时间的格式化操作格式化\n构造器\n\n\n\n构造器\n说明\n\n\n\npublic SimpleDateFormat(String pattern)\n构造一个 SimpleDateFormat，使用指定的格式\n\n\n格式化方法\n\n\n\n格式化方法\n说明\n\n\n\npublic final String format(Date date)\n将日期格式化成日期&#x2F;时间字符串\n\n\npublic final String format(Object time)\n将时间毫秒值式化成日期&#x2F;时间字符串\n\n\n格式化的时间形式的常用的模式对应关系：\nimport javax.xml.crypto.Data;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class SimpleDateFormatDemo&#123;\n    public static void main(String[] args) throws ParseException &#123;\n        // 目标: 学会使用SimpleDateFormat解析字符串时间成为日期对象。\n        // 有一个时间 2021年08月06日 11:11:11 往后 2天 14小时 49分 06秒后的时间是多少。\n        // 1、把字符串时间拿到程序中来\n        String dateStr = &quot;2021年08月06日 11:11:11&quot;;\n\n        // 2、把字符串时间解析成日期对象（本节的重点）:形式必须与被解析时间的形式完全一样，否则运行时解析报错！\n        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);\n        Date d = sdf.parse(dateStr);\n\n        // 3、往后走2天 14小时 49分 06秒\n        long time = d.getTime() + (2L*24*60*60 + 14*60*60 + 49*60 + 6) * 1000;\n\n        // 4、格式化这个时间毫秒值就是结果\n        System.out.println(sdf.format(time));\n    &#125;\n&#125;\n\n1.3 CalendarCalendar 代表了系统此刻日期对应的日历对象。\nCalendar 是一个抽象类，&#x3D;&#x3D;不能直接创建对象。&#x3D;&#x3D;\nCalendar 日历类创建日历对象的方法\n\n\n\n方法名\n说明\n\n\n\npublic static calendar getInstance()\n获取当前日历对象\n\n\nCalendar 常用方法\n\n\n\n方法名\n说明\n\n\n\npublic int get(int field)\n取日期中的某个字段信息。\n\n\npublic void set(int field,int value)\n修改日历的某个字段信息。\n\n\npublic void add(int field,int amount)\n为某个字段增加&#x2F;减少指定的值\n\n\npublic final Date getTime()\n拿到此刻日期对象。\n\n\npublic long getTimeInMillis()\n拿到此刻时间毫秒值\n\n\n注意:calendar 是可变日期对象，一旦修改后其对象本身表示的时间将产生变化。\nimport javax.xml.crypto.Data;\nimport java.util.Calendar;\nimport java.util.Date;\n\n/**\n    目标：日历类Calendar的使用,可以得到更加丰富的信息。\n */\npublic class CalendarDemo&#123;\n    public static void main(String[] args) &#123;\n        // 1、拿到系统此刻日历对象\n        Calendar cal = Calendar.getInstance();\n        System.out.println(cal);\n\n        // 2、获取日历的信息:public int get(int field)：取日期中的某个字段信息。\n        int year = cal.get(Calendar.YEAR);\n        System.out.println(year);\n\n        int mm = cal.get(Calendar.MONTH) + 1;\n        System.out.println(mm);\n\n        int days = cal.get(Calendar.DAY_OF_YEAR) ;\n        System.out.println(days);\n\n        // 3、public void set(int field,int value)：修改日历的某个字段信息。\n        // cal.set(Calendar.HOUR , 12);\n        // System.out.println(cal);\n\n        // 4.public void add(int field,int amount)：为某个字段增加/减少指定的值\n        // 请问64天后是什么时间\n        cal.add(Calendar.DAY_OF_YEAR , 64);\n        cal.add(Calendar.MINUTE , 59);\n\n        //  5.public final Date getTime(): 拿到此刻日期对象。\n        Date d = cal.getTime();\n        System.out.println(d);\n\n        //  6.public long getTimeInMillis(): 拿到此刻时间毫秒值\n        long time = cal.getTimeInMillis();\n        System.out.println(time);\n\n    &#125;\n&#125;\n\n1.4 LocalDate、LocalTime、LocalDateTime从 Java 8 开始，java.time 包提供了新的日期和时间 API\nLocalDate、LocalTime、LocalDateTim 他们分别表示日期，时间，日期时间对象，他们的类的实例是不可变的对象。他们三者构建对象和 API 都是通用的。\n构建对象的方式如下\n\n\n\n方法名\n说明\n\n\n\n\npublic static Xxxx now();\n静态方法，根据当前时间创建对象\nLocaDate localDate &#x3D; LocalDate.now();LocalTime localTime &#x3D; LocalTime.now();LocalDateTime localDateTime &#x3D; LocalDateTime.now();\n\n\npublic static Xxox of(…);\n静态方法，指定日期&#x2F;时间创建对象\nLocalDate localDate1 &#x3D;LocalDate.of(2099,11,11);LocalTime localTime1 &#x3D; LocalTime.of(11,11,11);LocalDateTime localDateTime1 &#x3D; LocalDateTime.of(2020,10,6,13,23,43);\n\n\nLocalDate、LocalTime、LocalDateTime 获取信息的 API\n\n\n\n方法名\n说明\n\n\n\npublic int geYear()\n获取年\n\n\npublic int getMonthValue()\n获取月份(1-12)\n\n\nPublic int getDayOfMonth()\n获取月中第几天乘法\n\n\nPublic int getDayOfYear()\n获取年中第几天\n\n\nPublic DayOfWeek getDayOfWeek()\n获取星期\n\n\nLocalDateTime 的转换 API\n\n\n\n方法名\n说明\n\n\n\npublic LocalDate toLocalDate()\n转换成一个 LocalDate 对象\n\n\npublic LocalTime toLocalTime()\n转换成一个 LocalTime 对象\n\n\n修改相关的 API\n这些方法返回的是一个新的实例引用，因为 LocalDateTime 、LocaIDate 、LocalTime 都是不可变的\n\n\n\n方法名\n说明\n\n\n\nplusDays, plusWeeks, plusMonths, plusYears\n向当前 LocalDate 对象添加几天、几周、几个月、几年\n\n\nminusDays, minusWeeks, minusMonths, minusYears\n从当前 LocalDate 对象减去几天、几周、几个月、几年\n\n\nwithDayOfMonth, withDayOfYear, withMonth, withYear\n将月份天数、年份天数、月份、年份修改为指定的值并返回新的 LocalDate 对象\n\n\nisBefore, isAfter\n比较两个 LocalDate\n\n\nimport java.time.LocalDate;\nimport java.time.Month;\n\npublic class Demo01LocalDate &#123;\n    public static void main(String[] args) &#123;\n        // 1、获取本地日期对象。\n        LocalDate nowDate = LocalDate.now();\n        System.out.println(&quot;今天的日期：&quot; + nowDate);//今天的日期：\n\n        int year = nowDate.getYear();\n        System.out.println(&quot;year：&quot; + year);\n\n\n        int month = nowDate.getMonthValue();\n        System.out.println(&quot;month：&quot; + month);\n\n        int day = nowDate.getDayOfMonth();\n        System.out.println(&quot;day：&quot; + day);\n\n        //当年的第几天\n        int dayOfYear = nowDate.getDayOfYear();\n        System.out.println(&quot;dayOfYear：&quot; + dayOfYear);\n\n        //星期\n        System.out.println(nowDate.getDayOfWeek());\n        System.out.println(nowDate.getDayOfWeek().getValue());\n\n        //月份\n        System.out.println(nowDate.getMonth());//AUGUST\n        System.out.println(nowDate.getMonth().getValue());//8\n\n        System.out.println(&quot;------------------------&quot;);\n        LocalDate bt = LocalDate.of(1991, 11, 11);\n        System.out.println(bt);//直接传入对应的年月日\n        System.out.println(LocalDate.of(1991, Month.NOVEMBER, 11));//相对上面只是把月换成了枚举\n    &#125;\n&#125;\n\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.time.Month;\n\npublic class Demo02LocalTime &#123;\n    public static void main(String[] args) &#123;\n        // 1、获取本地时间对象。\n        LocalTime nowTime = LocalTime.now();\n        System.out.println(&quot;今天的时间：&quot; + nowTime);//今天的时间：\n\n        int hour = nowTime.getHour();//时\n        System.out.println(&quot;hour：&quot; + hour);//hour：\n\n        int minute = nowTime.getMinute();//分\n        System.out.println(&quot;minute：&quot; + minute);//minute：\n\n        int second = nowTime.getSecond();//秒\n        System.out.println(&quot;second：&quot; + second);//second：\n\n        int nano = nowTime.getNano();//纳秒\n        System.out.println(&quot;nano：&quot; + nano);//nano：\n\n        System.out.println(&quot;-----&quot;);\n        System.out.println(LocalTime.of(8, 20));//时分\n        System.out.println(LocalTime.of(8, 20, 30));//时分秒\n        System.out.println(LocalTime.of(8, 20, 30, 150));//时分秒纳秒\n        LocalTime mTime = LocalTime.of(8, 20, 30, 150);\n\n        System.out.println(&quot;---------------&quot;);\n        System.out.println(LocalDateTime.of(1991, 11, 11, 8, 20));\n        System.out.println(LocalDateTime.of(1991, Month.NOVEMBER, 11, 8, 20));\n        System.out.println(LocalDateTime.of(1991, 11, 11, 8, 20, 30));\n        System.out.println(LocalDateTime.of(1991, Month.NOVEMBER, 11, 8, 20, 30));\n        System.out.println(LocalDateTime.of(1991, 11, 11, 8, 20, 30, 150));\n        System.out.println(LocalDateTime.of(1991, Month.NOVEMBER, 11, 8, 20, 30, 150));\n    &#125;\n&#125;\n\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\n\npublic class Demo03LocalDateTime &#123;\n    public static void main(String[] args) &#123;\n        // 日期 时间\n        LocalDateTime nowDateTime = LocalDateTime.now();\n        System.out.println(&quot;今天是：&quot; + nowDateTime);//今天是：\n        System.out.println(nowDateTime.getYear());//年\n        System.out.println(nowDateTime.getMonthValue());//月\n        System.out.println(nowDateTime.getDayOfMonth());//日\n        System.out.println(nowDateTime.getHour());//时\n        System.out.println(nowDateTime.getMinute());//分\n        System.out.println(nowDateTime.getSecond());//秒\n        System.out.println(nowDateTime.getNano());//纳秒\n        //日：当年的第几天\n        System.out.println(&quot;dayOfYear：&quot; + nowDateTime.getDayOfYear());//dayOfYear：249\n        //星期\n        System.out.println(nowDateTime.getDayOfWeek());//THURSDAY\n        System.out.println(nowDateTime.getDayOfWeek().getValue());//4\n        //月份\n        System.out.println(nowDateTime.getMonth());//SEPTEMBER\n        System.out.println(nowDateTime.getMonth().getValue());//9\n\n\n        LocalDate ld = nowDateTime.toLocalDate();\n        System.out.println(ld);\n\n        LocalTime lt = nowDateTime.toLocalTime();\n        System.out.println(lt.getHour());\n        System.out.println(lt.getMinute());\n        System.out.println(lt.getSecond());\n    &#125;\n&#125;\n\n1.5 InstantJDK8 获取时间戳特别简单，且功能更丰富。Instant 类由一个静态的工厂方法 now()可以返回当前时间戳。\nimport java.time.Instant;\nimport java.time.LocalDate;\nimport java.time.ZoneId;\nimport java.util.Date;\n\npublic class InstantDemo &#123;\n    public static void main(String[] args) &#123;\n        // 1、得到一个Instant时间戳对象\n        Instant instant = Instant.now();\n        System.out.println(instant);\n\n        // 2、系统此刻的时间戳怎么办？\n        Instant instant1 = Instant.now();\n        System.out.println(instant1.atZone(ZoneId.systemDefault()));\n\n        // 3、如何去返回Date对象\n        Date date = Date.from(instant);\n        System.out.println(date);\n\n        Instant i2 = date.toInstant();\n        System.out.println(i2);\n    &#125;\n&#125;\n\n时间戳是包含日期和时间的，与 java.util.Date 很类似，事实上 Instant 就是类似 JDK8 以前的 Date.lnstant 和 Date 这两个类可以进行转换。\n1.6 DateTimeFormatter在 JDK8 中，引入了一个全新的日期与时间格式器 DateTimeFormatter。正反都能调用 format 方法。\nimport java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\n\npublic class DateTimeFormatDemo &#123;\n    public static void main(String[] args) &#123;\n        // 本地此刻  日期时间 对象\n        LocalDateTime ldt = LocalDateTime.now();\n        System.out.println(ldt);\n\n        // 解析/格式化器\n        DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss EEE a&quot;);\n        // 正向格式化\n        System.out.println(dtf.format(ldt));\n        // 逆向格式化\n        System.out.println(ldt.format(dtf));\n\n        // 解析字符串时间\n        DateTimeFormatter dtf1 = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);\n        // 解析当前字符串时间成为本地日期时间对象\n        LocalDateTime ldt1 = LocalDateTime.parse(&quot;2019-11-11 11:11:11&quot; ,  dtf1);\n        System.out.println(ldt1);\n        System.out.println(ldt1.getDayOfYear());\n    &#125;\n&#125;\n\n1.7 Period&#x2F;DurationPeriod\n在 Java8 中，我们可以使用以下类来计算曰期间隔差异: java.time.Period\n主要是 Period 类方法 getYears()， getMonths()和 getDays()来计算,只能精确到年月日。用于计算两个“时间”间隔。用于 LocalDate 之间的比较。\nimport java.time.LocalDate;\nimport java.time.Period;\n\npublic class PeriodDemo &#123;\n    public static void main(String[] args) &#123;\n        // 当前本地 年月日\n        LocalDate today = LocalDate.now();\n        System.out.println(today);//\n\n        // 生日的 年月日\n        LocalDate birthDate = LocalDate.of(1998, 10, 13);\n        System.out.println(birthDate);\n\n        Period period = Period.between(birthDate, today);//第二个参数减第一个参数\n\n        System.out.println(period.getYears());\n        System.out.println(period.getMonths());\n        System.out.println(period.getDays());\n    &#125;\n&#125;\n\nDuration\n在 Java8 中，我们可以使用以下类来计算时间间隔差异: java.time.Duration 提供了使用基于时间的值测量时间量的方法。用于计算两个“日期”间隔。\n用于 LocalDateTime 之间的比较。也可用于 Instant 之间的比较。\nimport java.time.Duration;\nimport java.time.LocalDateTime;\n\npublic class DurationDemo &#123;\n    public static void main(String[] args) &#123;\n        // 本地日期时间对象。\n        LocalDateTime today = LocalDateTime.now();\n        System.out.println(today);\n\n        // 出生的日期时间对象\n        LocalDateTime birthDate = LocalDateTime.of(2021,8\n                ,06,01,00,00);\n\n        System.out.println(birthDate);\n\n        Duration duration = Duration.between(  today , birthDate);//第二个参数减第一个参数\n\n        System.out.println(duration.toDays());//两个时间差的天数\n        System.out.println(duration.toHours());//两个时间差的小时数\n        System.out.println(duration.toMinutes());//两个时间差的分钟数\n        System.out.println(duration.toMillis());//两个时间差的毫秒数\n        System.out.println(duration.toNanos());//两个时间差的纳秒数\n    &#125;\n&#125;\n\n1.8 ChronoUnitjava.time.temporal.ChronoUnit\nChronoUnit 类可用于在单个时间单位内测量一段时间，这个工具类是最全的了，可以用于比较所有的时间单位\nimport java.time.LocalDateTime;\nimport java.time.temporal.ChronoUnit;\n\npublic class ChronoUnitDemo &#123;\n    public static void main(String[] args) &#123;\n        // 本地日期时间对象：此刻的\n        LocalDateTime today = LocalDateTime.now();\n        System.out.println(today);\n\n        // 生日时间\n        LocalDateTime birthDate = LocalDateTime.of(1990,10,1,\n                10,50,59);\n        System.out.println(birthDate);\n\n        System.out.println(&quot;相差的年数：&quot; + ChronoUnit.YEARS.between(birthDate, today));\n        System.out.println(&quot;相差的月数：&quot; + ChronoUnit.MONTHS.between(birthDate, today));\n        System.out.println(&quot;相差的周数：&quot; + ChronoUnit.WEEKS.between(birthDate, today));\n        System.out.println(&quot;相差的天数：&quot; + ChronoUnit.DAYS.between(birthDate, today));\n        System.out.println(&quot;相差的时数：&quot; + ChronoUnit.HOURS.between(birthDate, today));\n        System.out.println(&quot;相差的分数：&quot; + ChronoUnit.MINUTES.between(birthDate, today));\n        System.out.println(&quot;相差的秒数：&quot; + ChronoUnit.SECONDS.between(birthDate, today));\n        System.out.println(&quot;相差的毫秒数：&quot; + ChronoUnit.MILLIS.between(birthDate, today));\n        System.out.println(&quot;相差的微秒数：&quot; + ChronoUnit.MICROS.between(birthDate, today));\n        System.out.println(&quot;相差的纳秒数：&quot; + ChronoUnit.NANOS.between(birthDate, today));\n        System.out.println(&quot;相差的半天数：&quot; + ChronoUnit.HALF_DAYS.between(birthDate, today));\n        System.out.println(&quot;相差的十年数：&quot; + ChronoUnit.DECADES.between(birthDate, today));\n        System.out.println(&quot;相差的世纪（百年）数：&quot; + ChronoUnit.CENTURIES.between(birthDate, today));\n        System.out.println(&quot;相差的千年数：&quot; + ChronoUnit.MILLENNIA.between(birthDate, today));\n        System.out.println(&quot;相差的纪元数：&quot; + ChronoUnit.ERAS.between(birthDate, today));\n    &#125;\n&#125;\n\n\n2、包装类包装类就是 8 种基本数据类型对应的引用类型。\n\n\n\n基本数据类型\n引用数据类型\n\n\n\nbyte\nByte\n\n\nshort\nShort\n\n\nint\nInteger\n\n\nlong\nLong\n\n\nchar\nCharacter\n\n\nfloat\nFloat\n\n\ndouble\nDouble\n\n\nboolean\nBoolean\n\n\nJava 为了实现一切皆对象，为 8 种基本类型提供了对应的引用类型。集合和泛型其实也只能支持包装类型，不支持基本数据类型。\n自动装箱:基本类型的数据和变量可以直接赋值给包装类型的变量。\n自动拆箱:包装类型的变量可以直接赋值给基本数据类型的变量。\n包装类的特有功能\n包装类的变量的默认值可以是 null，容错率更高。\n&#x3D;&#x3D;可以把基本类型的数据转换成字符串类型&#x3D;&#x3D;\n调用toString()方法得到字符串结果。\n调用lnteger.toString(基本类型的数据)。\n\n&#x3D;&#x3D;可以把字符串类型的数值转换成真实的数据类型&#x3D;&#x3D;\nInteger.parselnt(“字符串类型的整数”)\nDouble.parseDouble(“字符串类型的小数”)。\n\n/**\n    明白包装类的概念，并使用。\n */\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        int a = 10;\n        Integer a1 = 11;\n        Integer a2 = a; // 自动装箱\n        System.out.println(a);\n        System.out.println(a1);\n\n        Integer it = 100;\n        int it1 = it; // 自动拆箱\n        System.out.println(it1);\n\n        double db = 99.5;\n        Double db2 = db; // 自动装箱了\n        double db3 = db2; // 自动拆箱\n        System.out.println(db3);\n\n        // int age = null; // 报错了！\n        Integer age1 = null;\n        Integer age2 = 0;\n\n        System.out.println(&quot;-----------------&quot;);\n        // 1、包装类可以把基本类型的数据转换成字符串形式。\n        Integer i3 = 23;\n        String rs = i3.toString();\n        System.out.println(rs + 1);\n\n        String rs1 = Integer.toString(i3);\n        System.out.println(rs1 + 1);\n\n        // 可以直接+字符串得到字符串类型\n        String rs2 = i3 + &quot;&quot;;\n        System.out.println(rs2 + 1);\n\n        System.out.println(&quot;-----------------&quot;);\n\n        String number = &quot;23&quot;;\n        //转换成整数\n        // int age = Integer.parseInt(number);\n        int age = Integer.valueOf(number);\n        System.out.println(age + 1);\n\n        String number1 = &quot;99.9&quot;;\n        //转换成小数\n//        double score = Double.parseDouble(number1);\n        double score = Double.valueOf(number1);\n        System.out.println(score + 0.1);\n    &#125;\n&#125;\n\n\n3、正则表达式3.1 正则表达式概述、初体验正则表示：正则表达式可以用一些规定的字符来制定规则，并用来校验数据格式的合法性。\n正则表达式初体验\n需求:假如现在要求校验一个 qq 号码是否正确，6 位及 20 位之内，必须全部是数字。先使用目前所学知识完成校验需求;然后体验—下正则表达式检验。\npublic class RegexDemo1 &#123;\n    public static void main(String[] args) &#123;\n        // 需求：校验qq号码，必须全部数字 6 - 20位\n        System.out.println(checkQQ(&quot;251425998&quot;));\n        System.out.println(checkQQ(&quot;2514259a98&quot;));\n        System.out.println(checkQQ(null));\n        System.out.println(checkQQ(&quot;2344&quot;));\n\n        System.out.println(&quot;-------------------------&quot;);\n        // 正则表达式的初体验：\n        System.out.println(checkQQ2(&quot;251425998&quot;));\n        System.out.println(checkQQ2(&quot;2514259a98&quot;));\n        System.out.println(checkQQ2(null));\n        System.out.println(checkQQ2(&quot;2344&quot;));\n\n    &#125;\n\n    public static boolean checkQQ2(String qq)&#123;\n        return qq != null &amp;&amp; qq.matches(&quot;\\\\d&#123;6,20&#125;&quot;);\n    &#125;\n\n\n    public static boolean checkQQ(String qq)&#123;\n        // 1、判断qq号码的长度是否满足要求\n        if(qq == null || qq.length() &lt; 6 || qq.length() &gt; 20 ) &#123;\n            return false;\n        &#125;\n\n        // 2、判断qq中是否全部是数字，不是返回false\n        //  251425a87\n        for (int i = 0; i &lt; qq.length(); i++) &#123;\n            // 获取每位字符\n            char ch = qq.charAt(i);\n            // 判断这个字符是否不是数字，不是数字直接返回false\n            if(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n                return false;\n            &#125;\n        &#125;\n\n        return true; // 肯定合法了！\n    &#125;\n&#125;\n\n3.2 正则表达式的匹配规则字符串对象提供了匹配正则表达式的方法\n\n字符类(默认匹配一个字符)\n\n预定义的字符类(默认匹配一个字符)\n\n贪婪的量词(配合匹配多个字符)\n需求\n\n请编写程序模拟用户输入手机号码、验证格式正确，并给出提示，直到格式输入正确为止。\n请编写程序模拟用户输入邮箱号码、验证格式正确，并给出提示，直到格式输入正确为止。\n请编写程序模拟用户输入电话号码、验证格式正确，并给出提示，直到格式输入正确为止。\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class RegexTest3 &#123;\n    public static void main(String[] args) &#123;\n        // 目标：校验 手机号码 邮箱  电话号码\n         checkPhone();\n         checkEmail();\n         checkTel();\n    &#125;\n\n    public static void checkTel()&#123;\n        Scanner sc = new Scanner(System.in);\n        while (true) &#123;\n            System.out.println(&quot;请您输入您的电话号码：&quot;);\n            String tel = sc.next();\n            // 判断邮箱格式是否正确   027-3572457  0273572457\n            if(tel.matches(&quot;0\\\\d&#123;2,6&#125;-?\\\\d&#123;5,20&#125;&quot;))&#123;\n                System.out.println(&quot;格式正确，注册完成！&quot;);\n                break;\n            &#125;else &#123;\n                System.out.println(&quot;格式有误！&quot;);\n            &#125;\n        &#125;\n    &#125;\n\n    public static void checkEmail()&#123;\n        Scanner sc = new Scanner(System.in);\n        while (true) &#123;\n            System.out.println(&quot;请您输入您的注册邮箱：&quot;);\n            String email = sc.next();\n            // 判断邮箱格式是否正确   3268847878@qq.com\n            // 判断邮箱格式是否正确   3268847dsda878@163.com\n            // 判断邮箱格式是否正确   3268847dsda878@pci.com.cn\n            if(email.matches(&quot;\\\\w&#123;1,30&#125;@[a-zA-Z0-9]&#123;2,20&#125;(\\\\.[a-zA-Z0-9]&#123;2,20&#125;)&#123;1,2&#125;&quot;))&#123;\n                System.out.println(&quot;邮箱格式正确，注册完成！&quot;);\n                break;\n            &#125;else &#123;\n                System.out.println(&quot;格式有误！&quot;);\n            &#125;\n        &#125;\n    &#125;\n\n    public static void checkPhone()&#123;\n        Scanner sc = new Scanner(System.in);\n        while (true) &#123;\n            System.out.println(&quot;请您输入您的注册手机号码：&quot;);\n            String phone = sc.next();\n            // 判断手机号码的格式是否正确\n            if(phone.matches(&quot;1[3-9]\\\\d&#123;9&#125;&quot;))&#123;\n                System.out.println(&quot;手机号码格式正确，注册完成！&quot;);\n                break;\n            &#125;else &#123;\n                System.out.println(&quot;格式有误！&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n3.3 正则表达式的应用\n\n\n方法名\n说明\n\n\n\npublic String replaceAll(String regex,String newStr)\n按照正则表达式匹配的内容进行替换\n\n\npublic String] split(String regex):\n按照正则表达式匹配的内容进行分割字符串，反回一个字符串数组。\n\n\npublic class RegexDemo04 &#123;\n    public static void main(String[] args) &#123;\n        String names = &quot;小路dhdfhdf342蓉儿43fdffdfbjdfaf小何&quot;;\n\n        String[] arrs = names.split(&quot;\\\\w+&quot;);\n        for (int i = 0; i &lt; arrs.length; i++) &#123;\n            System.out.println(arrs[i]);\n        &#125;\n\n        String names2 = names.replaceAll(&quot;\\\\w+&quot;, &quot;  &quot;);\n        System.out.println(names2);\n    &#125;\n&#125;\n\n3.4 正则表达式爬取信息/**\n    拓展：正则表达式爬取信息中的内容。(了解)\n */\npublic class RegexDemo05 &#123;\n    public static void main(String[] args) &#123;\n        String rs = &quot;学习Java,电话020-43422424，或者联系邮箱&quot; +\n                &quot;itcast@itcast.cn,电话18762832633，0203232323&quot; +\n                &quot;邮箱bozai@itcast.cn，400-100-3233 ，4001003232&quot;;\n\n        // 需求：从上面的内容中爬取出 电话号码和邮箱。\n        // 1、定义爬取规则，字符串形式\n        String regex = &quot;(\\\\w&#123;1,30&#125;@[a-zA-Z0-9]&#123;2,20&#125;(\\\\.[a-zA-Z0-9]&#123;2,20&#125;)&#123;1,2&#125;)|(1[3-9]\\\\d&#123;9&#125;)&quot; +\n                &quot;|(0\\\\d&#123;2,6&#125;-?\\\\d&#123;5,20&#125;)|(400-?\\\\d&#123;3,9&#125;-?\\\\d&#123;3,9&#125;)&quot;;\n\n        // 2、把这个爬取规则编译成匹配对象。\n        Pattern pattern = Pattern.compile(regex);\n\n        // 3、得到一个内容匹配器对象\n        Matcher matcher = pattern.matcher(rs);\n\n        // 4、开始找了\n        while (matcher.find()) &#123;\n            String rs1 = matcher.group();\n            System.out.println(rs1);\n        &#125;\n\n    &#125;\n&#125;\n\n\n4、Arrays 类4.1 Arrays 类概述，常用功能演示数组操作工具类,专门用于操作数组元素的。\nArrays 类的常用 API\n\n\n\n方法名\n说明\n\n\n\npublic static String tostring(类型[] a)\n返回数组的内容（字符串形式)\n\n\npublic static void sort(类型[] a)\n对数组进行默认升序排序\n\n\npublic static  void sort(类型[] a, Comparator&lt;? superT&gt; c)\n使用比较器对象自定义排序\n\n\npublic static int binarySearch(int[] a, int key)\n二分搜索数组中的数据,存在返回索引,不存在返回-1\n\n\n\nimport java.util.Arrays;\n\npublic class ArraysDemo1 &#123;\n    public static void main(String[] args) &#123;\n        // 目标：学会使用Arrays类的常用API ,并理解其原理\n        int[] arr = &#123;10, 2, 55, 23, 24, 100&#125;;\n        System.out.println(arr);\n\n        // 1、返回数组内容的 toString(数组)\n//        String rs = Arrays.toString(arr);\n//        System.out.println(rs);\n\n        System.out.println(Arrays.toString(arr));\n\n        // 2、排序的API(默认自动对数组元素进行升序排序)\n        Arrays.sort(arr);\n        System.out.println(Arrays.toString(arr));\n\n        // 3、二分搜索技术（前提数组必须排好序才支持，否则出bug）\n        int index = Arrays.binarySearch(arr, 55);\n        System.out.println(index);\n\n        // 返回不存在元素的规律： - （应该插入的位置索引 + 1）\n        int index2 = Arrays.binarySearch(arr, 22);\n        System.out.println(index2);\n\n\n        // 注意：数组如果没有排好序，可能会找不到存在的元素，从而出现bug!!\n        int[] arr2 = &#123;12, 36, 34, 25 , 13,  24,  234, 100&#125;;\n        System.out.println(Arrays.binarySearch(arr2 , 36));\n    &#125;\n\n&#125;\n\n4.2 Arrays 类对于 Comparator 比较器的支持Arrays 类的排序方法\n\n\n\n方法名\n说明\n\n\n\npublic static void sort(类型 a)\n对数组进行默认升序排序\n\n\npublic static  void sort(类型 a, Comparator&lt; ? super T&gt; c)\n使用比较器对象自定义排序\n\n\n自定义排序规则\n设置 Comparator 接口对应的比较器对象，来定制比较规则。\n\n如果认为左边数据大于右边数据返回正整数\n如果认为左边数据小于右边数据返回负整数\n如果认为左边数据等于右边数据返回 0\n\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class ArraysDemo2 &#123;\n    public static void main(String[] args) &#123;\n        // 目标：自定义数组的排序规则：Comparator比较器对象。\n        // 1、Arrays的sort方法对于有值特性的数组是默认升序排序\n        int[] ages = &#123;34, 12, 42, 23&#125;;\n        Arrays.sort(ages);\n        System.out.println(Arrays.toString(ages));\n\n        // 2、需求：降序排序！(自定义比较器对象，只能支持引用类型的排序！！)\n        Integer[] ages1 = &#123;34, 12, 42, 23&#125;;\n        /**\n           参数一：被排序的数组 必须是引用类型的元素\n           参数二：匿名内部类对象，代表了一个比较器对象。\n         */\n        Arrays.sort(ages1, new Comparator&lt;Integer&gt;() &#123;\n            @Override\n            public int compare(Integer o1, Integer o2) &#123;\n                // 指定比较规则。\n//                if(o1 &gt; o2)&#123;\n//                    return 1;\n//                &#125;else if(o1 &lt; o2)&#123;\n//                    return -1;\n//                &#125;\n//                return 0;\n                // return o1 - o2; // 默认升序\n                return o2 - o1; //  降序\n            &#125;\n        &#125;);\n        System.out.println(Arrays.toString(ages1));\n\n        System.out.println(&quot;-------------------------&quot;);\n        Student[] students = new Student[3];\n        students[0] = new Student(&quot;吴磊&quot;,23 , 175.5);\n        students[1] = new Student(&quot;谢鑫&quot;,18 , 185.5);\n        students[2] = new Student(&quot;王亮&quot;,20 , 195.5);\n        System.out.println(Arrays.toString(students));\n\n        // Arrays.sort(students);  // 直接运行奔溃\n        Arrays.sort(students, new Comparator&lt;Student&gt;() &#123;\n            @Override\n            public int compare(Student o1, Student o2) &#123;\n                // 自己指定比较规则\n                // return o1.getAge() - o2.getAge(); // 按照年龄升序排序！\n                // return o2.getAge() - o1.getAge(); // 按照年龄降序排序！！\n                // return Double.compare(o1.getHeight(), o2.getHeight()); // 比较浮点型可以这样写 升序\n                return Double.compare(o2.getHeight(), o1.getHeight()); // 比较浮点型可以这样写  降序\n            &#125;\n        &#125;);\n        System.out.println(Arrays.toString(students));\n\n\n    &#125;\n&#125;\n\n\n5、常见算法参见数据结构系列博客 数据结构笔记。\n\n6、Lambda 表达式6.1 Lambda 概述Lambda 表达式是 JDK 8 开始后的一种新语法形式。\n作用:简化匿名内部类的代码写法。\nLambda 表达式的简化格式\n(匿名内部类被重写方法的形参列表)-&gt;&#123;\n    被重写方法的方法体代码。\n&#125;\n注:-&gt;是语法形式。无实际含义\n\npublic class LambdaDemo1 &#123;\n    public static void main(String[] args) &#123;\n        // 目标：学会使用Lambda的标准格式简化匿名内部类的代码形式\n        Animal a = new Animal() &#123;\n            @Override\n            public void run() &#123;\n                System.out.println(&quot;乌龟跑的很慢~~~~~&quot;);\n            &#125;\n        &#125;;\n        a.run();\n\n        // 注意：lambda并不是可以简化所有匿名匿名内部类形式！！\n//        Animal a1 = () -&gt; &#123;\n//            System.out.println(&quot;乌龟跑的很慢~~~~~&quot;);\n//        &#125;;\n//        a1.run();\n    &#125;\n&#125;\n\n\n\nabstract class Animal&#123;\n    public abstract void run();\n&#125;\n\n\n注意:Lambda 表达式只能简化 &#x3D;&#x3D;函数式接口（首先必须是接口、其次接口中有且仅有一个抽象方法的形式）&#x3D;&#x3D; 的匿名内部类的写法形式\n6.2 Lambda 应用public class LambdaDemo2 &#123;\n    public static void main(String[] args) &#123;\n        // 目标：学会使用Lambda的标准格式简化匿名内部类的代码形式\n        // 注意：Lambda只能简化接口中只有一个抽象方法的匿名内部类形式（函数式接口）\n//        Swimming s1 = new Swimming() &#123;\n//            @Override\n//            public void swim() &#123;\n//                System.out.println(&quot;老师游泳贼溜~~~~~&quot;);\n//            &#125;\n//        &#125;;\n\n//        Swimming s1 = () -&gt; &#123;\n//            System.out.println(&quot;老师游泳贼溜~~~~~&quot;);\n//        &#125;;\n\n        Swimming s1 = () -&gt; System.out.println(&quot;老师游泳贼溜~~~~~&quot;);\n        go(s1);\n\n        System.out.println(&quot;---------------------&quot;);\n//        go(new Swimming() &#123;\n//            @Override\n//            public void swim() &#123;\n//                System.out.println(&quot;学生游泳很开心~~~&quot;);\n//            &#125;\n//        &#125;);\n\n//        go(() -&gt;&#123;\n//                System.out.println(&quot;学生游泳很开心~~~&quot;);\n//        &#125;);\n\n        go(() -&gt; System.out.println(&quot;学生游泳很开心~~~&quot;));\n\n\n    &#125;\n\n    public static void go(Swimming s)&#123;\n        System.out.println(&quot;开始。。。&quot;);\n        s.swim();\n        System.out.println(&quot;结束。。。&quot;);\n    &#125;\n&#125;\n\n@FunctionalInterface // 一旦加上这个注解必须是函数式接口，里面只能有一个抽象方法\ninterface Swimming&#123;\n    void swim();\n&#125;\n\n6.3 Lambda 表达式的省略规则Lambda 表达式的省略写法(进—步在 Lambda 表达式的基础上继续简化)\n\n参数类型可以省略不写。\n如果只有一个参数，参数类型可以省略，同时()也可以省略。\n如果 Lambda 表达式的方法体代码只有一行代码。可以省略大括号不写,同时要省略分号!\n如果 Lambda 表达式的方法体代码只有一行代码。可以省略大括号不写。此时，如果这行代码是 return 语句，必须省略 return 不写，同时也必须省略”;”不写\n\n\n","slug":"Java程序设计 -- 常用API(下)（十一）","date":"2022-03-22T11:19:57.000Z","categories_index":"后端","tags_index":"Java","author_index":"会思想的苇草i"},{"id":"14d6bcd214a7a0ca6551995e61aaab69","title":"Java程序设计--常用API(中)","content":"\n1、Object1.1 toString方法Object类的方法是一切子类对象都可以直接使用的，所以我们要学习Object类的方法。&#x3D;&#x3D;一个类要么默认继承了Object类，要么间接继承了Object类，Object类是Java中的祖宗类。&#x3D;&#x3D;\nobject类的常用方法:\n\n\n\n方法名\n说明\n\n\n\npublic String toString()\n默认是返回当前对象在堆内存中的地址信息:类的全限名@内存地址\n\n\npublic boolean equals(Object o)\n默认是比较当前对象与另一个对象的地址是否相同，相同返回true，不同返回false\n\n\nimport java.util.Objects;\n\npublic class Student &#123; //extends Object&#123;\n    private String name;\n    private char sex;\n    private int age;\n\n    public Student() &#123;\n    &#125;\n\n    public Student(String name, char sex, int age) &#123;\n        this.name = name;\n        this.sex = sex;\n        this.age = age;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public char getSex() &#123;\n        return sex;\n    &#125;\n\n    public void setSex(char sex) &#123;\n        this.sex = sex;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n\n\n    @Override\n    public boolean equals(Object o) &#123;\n        // 1、判断是否是同一个对象比较，如果是返回true。\n        if (this == o) return true;\n        // 2、如果o是null返回false  如果o不是学生类型返回false  ...Student !=  ..Pig\n        if (o == null || this.getClass() != o.getClass()) return false;\n        // 3、说明o一定是学生类型而且不为null\n        Student student = (Student) o;\n        return sex == student.sex &amp;&amp; age == student.age &amp;&amp; Objects.equals(name, student.name);\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Student&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, sex=&quot; + sex +\n                &quot;, age=&quot; + age +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n\n/**\n    目标：掌握Object类中toString方法的使用。\n */\npublic class Test1 &#123;\n    public static void main(String[] args) &#123;\n        Student s = new Student(&quot;周雄&quot;, &#39;男&#39;, 19);\n        // String rs = s.toString();\n        // System.out.println(rs);\n\n        // System.out.println(s.toString());\n\n        // 直接输出对象变量，默认可以省略toString调用不写的\n        System.out.println(s);\n    &#125;\n&#125;\n\nobject的toString方法:\n\n\n\n方法名\n说明\n\n\n\npublic String toString()\n默认是返回当前对象在堆内存中的地址信息:类的全限名@内存地址\n\n\n\n开发中直接输出对象，默认输出对象的地址其实是毫无意义的。\n开发中输出对象变量，更多的时候是希望看到对象的内容数据而不是对象的地址信息。\n\ntoString存在的意义：\n父类toString()方法存在的意义就是为了被子类重写，以便返回对象的内容信息，而不是地址信息!\n1.2 equals方法object的equals方法:\n\n\n\n方法名\n说明\n\n\n\npublic boolean equals(Object o)\n默认是比较当前对象与另一个对象的地址是否相同，相同返回true，不同返回false\n\n\n直接比较两个对象的地址是否相同完全可以用“&#x3D;&#x3D;”替代equals。\nequals存在的意义：\n父类equals方法存在的意义就是为了被子类重写，以便子类自己来定制比较规则。\nimport java.util.Objects;\n\n/**\n    目标：掌握Object类中equals方法的使用。\n */\npublic class Test2 &#123;\n    public static void main(String[] args) &#123;\n        Student s1 = new Student(&quot;周雄&quot;, &#39;男&#39;, 19);\n        Student s2 = new Student(&quot;周雄&quot;, &#39;男&#39;, 19);\n        // equals默认是比较2个对象的地址是否相同，子类重写后会调用子类重写的来比较内容是否相同。\n        System.out.println(s1.equals(s2));\n        System.out.println(s1 == s2);\n\n        System.out.println(Objects.equals(s1, s2));\n    &#125;\n&#125;\n\n\n2、ObjectsObjects是一个工具类，提供了一些方法去完成一些功能。\n官方在进行字符串比较时，没有用字符串对象的的equals方法，而是选择了Objects的equals方法来比较。\n&#x3D;&#x3D;使用Objects的equals方法在进行对象的比较会更加安全&#x3D;&#x3D;\nobjects的常见方法:\n\n\n\n方法名\n说明\n\n\n\npublic static boolean equals(object a，object b)\n比较两个对象的，底层会先进行非空判断，从而可以避免空指针异常。再进行equals比较\n\n\npublic static boolean isNull(0bject obj)\n判断变量是否为null ,为null返回true ,反之\n\n\nimport java.util.Objects;\n\n/**\n    目标：掌握objects类的常用方法:equals\n */\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        String s1 = null;\n        String s2 = new String(&quot;itheima&quot;);\n\n        // System.out.println(s1.equals(s2));   // 留下了隐患，可能出现空指针异常。\n\n        System.out.println(Objects.equals(s1, s2)); // 更安全，结果也是对的！\n\n\n\n        System.out.println(Objects.isNull(s1)); // true\n        System.out.println(s1 == null); // true\n\n        System.out.println(Objects.isNull(s2)); // false\n        System.out.println(s2 == null); // false\n\n    &#125;\n&#125;\n\n\n3、StringBuilderStringBuilder是一个可变的字符串类，我们可以把它看成是一个对象容器。\n作用:提高字符串的操作效率，如拼接、修改等。\nStringBuilder构造器\n\n\n\n名称\n说明\n\n\n\npublic StringBuilder()\n创建一个空白的可变的字符串对象，不包含任何内容\n\n\npublic StringBuilder(String str)\n创建一个指定字符串内容的可变字符串对象\n\n\nStringBuilder常用方法\n\n\n\n方法名称\n说明\n\n\n\npublic StringBuilder append(任意类型)\n添加数据并返回StringBuilder对象本身\n\n\npublic StringBuilder reverse()\n将对象的内容反转\n\n\npublic int length()\n返回对象内容长度\n\n\npublic String toString()\n通过toString()就可以实现把StringBuilder转换为String\n\n\n/**\n    目标：学会使用StringBuilder操作字符串,最终还需要知道它性能好的原因\n */\npublic class StringBuilderDemo1 &#123;\n    public static void main(String[] args) &#123;\n        StringBuilder sb = new StringBuilder(); // &quot;&quot;\n        sb.append(&quot;a&quot;);\n        sb.append(&quot;b&quot;);\n        sb.append(&quot;c&quot;);\n        sb.append(1);\n        sb.append(false);\n        sb.append(3.3);\n        sb.append(&quot;abc&quot;);\n        System.out.println(sb);\n\n        StringBuilder sb1 = new StringBuilder();\n        // 支持链式编程\n        sb1.append(&quot;a&quot;).append(&quot;b&quot;).append(&quot;c&quot;).append(&quot;我爱你中国&quot;);\n        System.out.println(sb1);\n\n        // 反转\n        sb1.reverse().append(&quot;110&quot;);\n        System.out.println(sb1);\n\n        System.out.println(sb1.length());\n\n        // 注意：StringBuilder只是拼接字符串的手段：效率好。\n        // 最终的目的还是要恢复成String类型。\n        StringBuilder sb2 = new StringBuilder();\n        sb2.append(&quot;123&quot;).append(&quot;456&quot;);\n        // 恢复成String类型\n        String rs = sb2.toString();\n        check(rs);\n    &#125;\n\n    public static void check(String data)&#123;\n        System.out.println(data);\n    &#125;\n&#125;\n\n\n\n4、Math包含执行基本数字运算的方法，Math类没有提供公开的构造器。\n使用类中的成员，看类的成员是否都是静态的，如果是，通过类名就可以直接调用。\nMath类的常用方法\n\n\n\n方法名\n说明\n\n\n\npublic static int abs(int a)\n获取参数绝对值\n\n\npublic static double ceil( double a)\n向上取整\n\n\npublic static double floor( double a)\n向下取整\n\n\npublic static int round(float a)\n四舍五入\n\n\npublic static int max(int a,int b)\n获取两个int值中的较大值\n\n\npublic static double pow( double a, double b)\n返回a的b次幂的值\n\n\npublic static double random()\n返回值为double的随机值，范围[0.0,1.0)\n\n\n/**\n    目标：Math类的使用。\n */\npublic class MathDemo &#123;\n    public static void main(String[] args) &#123;\n        // 1.取绝对值:返回正数\n        System.out.println(Math.abs(10)); // 10\n        System.out.println(Math.abs(-10.3)); // 10.3\n\n        // 2.向上取整: 5\n        System.out.println(Math.ceil(4.00000001)); // 5.0\n        System.out.println(Math.ceil(4.0)); // 4.0\n        // 3.向下取整：4\n        System.out.println(Math.floor(4.99999999)); // 4.0\n        System.out.println(Math.floor(4.0)); // 4.0\n\n        // 4.求指数次方\n        System.out.println(Math.pow(2 , 3)); // 2^3 = 8.0\n        // 5.四舍五入 10\n        System.out.println(Math.round(4.49999)); // 4\n        System.out.println(Math.round(4.500001)); // 5\n\n        System.out.println(Math.random());  // 0.0 - 1.0 （包前不包后）\n\n        // 拓展： 3 - 9 之间的随机数  （0 - 6） + 3\n        //  [0 - 6] + 3\n        int data =  (int)(Math.random() * 7) + 3;\n        System.out.println(data);\n\n\n    &#125;\n&#125;\n\n\n5、SystemSystem也是一个工具类，代表了当前系统，提供了一些与系统相关的方法。\nSystem类的常用方法\n\n\n\n方法名\n说明\n\n\n\npublic static void exit(int status)\n终止当前运行的Java 虚拟机，非零表示异常终止\n\n\npublic static long currentTimeMillis()\n返回当前系统的时间毫秒值形式\n\n\npublic static void arraycopy(数据源数组,起始索引目的地数组,起始索引,拷贝个数)\n数组拷贝\n\n\nimport java.math.BigDecimal;\nimport java.math.RoundingMode;\nimport java.text.SimpleDateFormat;\nimport java.util.Arrays;\n\n/**\n    目标：System系统类的使用。\n    System代表当前系统。（虚拟机系统）\n */\npublic class SystemDemo &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(&quot;程序开始。。。&quot;);\n\n        // System.exit(0); // JVM终止！\n\n        // 2、计算机认为时间有起源：返回1970-1-1 00：00：00 走到此刻的总的毫秒值：时间毫秒值。\n        long time = System.currentTimeMillis();\n        System.out.println(time);\n\n        long startTime = System.currentTimeMillis();\n        // 进行时间的计算：性能分析\n        for (int i = 0; i &lt; 100000; i++) &#123;\n            System.out.println(&quot;输出：&quot; + i);\n        &#125;\n        long endTime = System.currentTimeMillis();\n        System.out.println((endTime - startTime)/1000.0 + &quot;s&quot;);\n\n\n        // 3、做数组拷贝（了解）\n\n        int[] arr1 = &#123;10, 20, 30, 40, 50, 60, 70&#125;;\n        int[] arr2 = new int[6]; // [0, 0, 0, 0, 0, 0] ==&gt;  [0, 0, 40, 50, 60, 0]\n        System.arraycopy(arr1, 3, arr2, 2, 3);\n        System.out.println(Arrays.toString(arr2));\n\n        System.out.println(&quot;-------------------&quot;);\n        double i = 10.0;\n        double j = 3.0;\n\n//\n//        System.out.println(k1);\n\n        System.out.println(&quot;程序结束。。。。&quot;);\n    &#125;\n&#125;\n\n\n6、BigDecimal用于解决浮点型运算精度失真的问题\npublic static BigDecimal valueof(double val):包装浮点数成为BigDecimal对象。\n\nBigDecima常用API\n\n\n\n方法名\n说明\n\n\n\npublic BigDecimal add(BigDecimal b)\n加法\n\n\npublic BigDecimal subtract(BigDecimal b)\n减法\n\n\npublic BigDecimal multiply(BigDecimal b)\n乘法\n\n\npublic BigDecimal divide(BigDecimal b)\n除法\n\n\npublic BigDecimal divide(另一个BigDecimal对象，精确几位，舍入模式)\n除法\n\n\nimport java.math.BigDecimal;\nimport java.math.RoundingMode;\nimport java.text.NumberFormat;\n\n/**\n    目标：BigDecimal大数据类。\n */\npublic class BigDecimalDemo &#123;\n    public static void main(String[] args) &#123;\n        // 浮点型运算的时候直接+  * / 可能会出现数据失真（精度问题）。\n        System.out.println(0.09 + 0.01);\n        System.out.println(1.0 - 0.32);\n        System.out.println(1.015 * 100);\n        System.out.println(1.301 / 100);\n\n        System.out.println(&quot;-------------------------&quot;);\n        double a = 0.1;\n        double b = 0.2;\n        double c = a + b;\n        System.out.println(c);\n        System.out.println(&quot;--------------------------&quot;);\n        // 包装浮点型数据成为大数据对象 BigDeciaml\n        BigDecimal a1 = BigDecimal.valueOf(a);\n        BigDecimal b1 = BigDecimal.valueOf(b);\n        BigDecimal c1 = a1.add(b1);\n        // BigDecimal c1 = a1.subtract(b1);\n        // BigDecimal c1 = a1.multiply(b1);\n        // BigDecimal c1 = a1.divide(b1);\n        System.out.println(c1);\n\n        // 目的：double\n        double rs = c1.doubleValue();\n        System.out.println(rs);\n\n        // 注意事项：BigDecimal是一定要精度运算的\n        BigDecimal a11 = BigDecimal.valueOf(10.0);\n        BigDecimal b11 = BigDecimal.valueOf(3.0);\n        /**\n           参数一：除数 参数二：保留小数位数  参数三：舍入模式\n         */\n        BigDecimal c11 = a11.divide(b11, 2, RoundingMode.HALF_UP); // 3.3333333333\n        System.out.println(c11);\n\n\n        System.out.println(&quot;-------------------&quot;);\n    &#125;\n&#125;\n\n\n","slug":"Java程序设计 -- 常用API(中)（十）","date":"2022-03-21T14:44:56.000Z","categories_index":"后端","tags_index":"Java","author_index":"会思想的苇草i"},{"id":"b96805334df48e1df4b0636b2d6744aa","title":"Java程序设计--常用API(上)","content":"\n1、String1.1 String类概述java.lang.String 类代表字符串，String类定义的变量可以用于指向字符串对象，然后操作该字符串。\nJava程序中的所有字符串文字（例如“abc”）都为此类的对象。\n&#x3D;&#x3D;String其实常被称为不可变字符串类型，它的对象在创建后不能被更改。&#x3D;&#x3D;\n字符串对象以 “” 方式给出的字符串对象，在字符串常量池中存储。\n1.2 String创建对象\n直接使用“”定义。（推荐方式)\n通过String类的构造器创建对象。\n\n\n\n\n构造器\n说明\n\n\n\npublic String()\n创建一个空白字符串对象，不含有任何内容\n\n\npublic String(String original)\n根据传入的字符串对象，来创建字符串对象\n\n\npublic String(char[] chs)\n根据字符数组的内容，来创建字符串对象\n\n\npublic String(byte[] chs)\n根据字节数组的内容，来创建字符串对象\n\n\npublic class StringDemo &#123;\n    public static void main(String[] args) &#123;\n        // 方式一：直接使用双引号得到字符串对象\n        String name = &quot;我爱你中国&quot;;\n        System.out.println(name);\n\n        // 方式二：\n        // 1、public String(): 创建一个空白字符串对象，不含有任何内容 （几乎不用）\n        String s1 = new String(); // s1 = &quot;&quot;\n        System.out.println(s1);\n\n        // 2、public String(String): 根据传入的字符串内容，来创建字符串对象（几乎不用）\n        String s2 = new String(&quot;我是中国人&quot;);\n        System.out.println(s2);\n\n        // 3、public String(char[] c): 根据字符数组的内容，来创建字符串对象\n        char[] chars = &#123;&#39;a&#39; , &#39;b&#39; , &#39;中&#39;, &#39;国&#39;&#125;;\n        String s3 = new String(chars);\n        System.out.println(s3);\n\n        // 4、public String(byte[] b):  根据字节数组的内容，来创建字符串对象\n        byte[] bytes = &#123;97, 98, 99, 65, 66, 67&#125;;\n        String s4 = new String(bytes);\n        System.out.println(s4);\n\n        System.out.println(&quot;---------------------------------------&quot;);\n        String ss1 = &quot;abc&quot;;//内容\n        String ss2 = &quot;abc&quot;;\n        System.out.println(ss1 == ss2);\n\n        char[] chars1 = &#123;&#39;a&#39; , &#39;b&#39; , &#39;c&#39;&#125;;\n        String ss3 = new String(chars1);//地址\n        String ss4 = new String(chars1);\n        System.out.println(ss3 == ss4);\n    &#125;\n&#125;\n\n&#x3D;&#x3D;以“”方式给出的字符串对象，在字符串常量池中存储，而且相同内容只会在其中存储一份。&#x3D;&#x3D;\n\n&#x3D;&#x3D;通过构造器new对象，每new一次都会产生一个新对象，放在堆内存中。&#x3D;&#x3D;\n\n1.3 常用API字符串内容比较\n推荐使用String类提供的“equals”比较:只关心内容一样即可\n\n\n\n方法名\n说明\n\n\n\npublic boolean equals (Object anObject)\n将此字符串与指定对象进行比较。&#x3D;&#x3D;只关心字符内容是否一致!&#x3D;&#x3D;\n\n\npublic boolean equalsIgnoreCase (string anotherString)\n将此字符串与指定对象进行比较，&#x3D;&#x3D;忽略大小写比较字符串。只关心字符内容是否一致!&#x3D;&#x3D;\n\n\nimport java.util.Scanner;\n\npublic class StringAPIEqualsDemo &#123;\n    public static void main(String[] args) &#123;\n        // 1、正确登录名和密码\n        String okName = &quot;admin&quot;;\n        String okPassword = &quot;123456&quot;;\n\n        // 2、请您输入登录名称和密码\n        Scanner sc = new Scanner(System.in);\n        System.out.println(&quot;登录名称：&quot;);\n        String name = sc.next();\n        System.out.println(&quot;登录密码：&quot;);\n        String password = sc.next();\n\n        // 3、判断用户输入的登录名称和密码与正确的内容是否相等。\n        if(okName.equals(name ) &amp;&amp; okPassword.equals(password))&#123;\n            System.out.println(&quot;登录成功！&quot;);\n        &#125;else &#123;\n            System.out.println(&quot;用户名或者密码错误了！&quot;);\n        &#125;\n\n        // 4、忽略大小写比较内容的Api: 一般用于比较验证码这样的业务逻辑\n        String sysCode = &quot;23AdFh&quot;;\n        String code1 = &quot;23aDfH&quot;;\n        System.out.println(sysCode.equals(code1)); // false\n        System.out.println(sysCode.equalsIgnoreCase(code1)); // true\n    &#125;\n&#125;\n\nString类常用API\n\n\n\n方法名\n说明\n\n\n\npublic int length()\n返回此字符串的长度\n\n\npublic char charAt(int index)\n获取某个索引位置处的字符\n\n\npublic char[] toCharArray() :\n将当前字符串转换成字符数组返回\n\n\npublic sString substring(int beginIndex， int endIndex)\n根据开始和结束索引进行截取，得到新的字符串（包前不包后)\n\n\npublic string substring(int beginIndex)\n从传入的索引处截取，截取到末尾，得到新的字符串\n\n\npublic string replace(CharSequence target,CharSequence replacement)\n使用新值，将字符串中的旧值替换，得到新的字符串\n\n\npublic string[ ] split(String regex)\n根据传入的规则切割字符串，得到字符串数组返回\n\n\n/**\n    String常用的其他API。\n */\npublic class StringAPIOtherDemo&#123;\n    public static void main(String[] args) &#123;\n        // 1、public int length(): 获取字符串的长度\n        String name = &quot;我爱你中国love&quot;;\n        System.out.println(name.length());\n\n        // 2、public char charAt(int index): 获取某个索引位置处的字符\n        char c = name.charAt(1);\n        System.out.println(c);\n\n        System.out.println(&quot;------------遍历字符串中的每个字符--------------&quot;);\n        for (int i = 0; i &lt; name.length(); i++) &#123;\n            char ch = name.charAt(i);\n            System.out.println(ch);\n        &#125;\n        // 3、public char[] toCharArray()：: 把字符串转换成字符数组\n        char[] chars = name.toCharArray();\n        for (int i = 0; i &lt; chars.length; i++) &#123;\n            char ch = chars[i];\n            System.out.println(ch);\n        &#125;\n\n        // 4、public String substring(int beginIndex, int endIndex) ：截取内容，(包前不包后的)\n        String name2 = &quot;Java是最厉害的编程语言！&quot;;\n        //              01234567   89\n        String rs = name2.substring(0, 9);\n        System.out.println(rs);\n        String rs1 = name2.substring(4, 9);\n        System.out.println(rs1);\n\n        // 5、public String substring(int beginIndex):从当前索引一直截取到末尾\n        String rs2 = name2.substring(4);\n        System.out.println(rs2);\n\n        // 6、public String replace(CharSequence target, CharSequence replacement)\n        String name3 = &quot;金三胖是最厉害的80后，金三胖棒棒的！我好爱金三胖&quot;;\n        String rs3 = name3.replace(&quot;金三胖&quot;, &quot;***&quot;);\n        System.out.println(rs3);\n\n        // 7、public boolean contains(CharSequence s)\n        System.out.println(name3.contains(&quot;金三胖&quot;)); // true\n        System.out.println(name3.contains(&quot;金二胖&quot;)); // false\n\n        // 8、public boolean startsWith(String prefix)\n        System.out.println(name3.startsWith(&quot;金三胖&quot;));\n        System.out.println(name3.startsWith(&quot;金三胖是最厉害的&quot;));\n        System.out.println(name3.startsWith(&quot;金三胖是最厉害的2&quot;));\n\n        // 9、public String[] split(String s): 按照某个内容把字符串分割成字符串数组返回。\n        String name4 = &quot;王宝强,贾乃亮,陈羽凡&quot;;\n        String[] names = name4.split(&quot;,&quot;);\n        for (int i = 0; i &lt; names.length; i++) &#123;\n            System.out.println(&quot;选择了：&quot; + names[i]);\n        &#125;\n    &#125;\n&#125;\n\n\n2、Arraylist2.1 Arraylist概述集合是与数组类似，也是一种容器，用于装数据的。\n\n&#x3D;&#x3D;数组定义完成并启动后，类型确定、长度固定。&#x3D;&#x3D;\n在个数不能确定，且要进行增删数据操作的时候，数组是不太合适的\n\n\n集合的大小不固定，启动后可以动态变化，类型也可以选择不固定。\n集合非常适合做元素个数不确定，且要进行增删操作的业务场景。\n集合的提供了许多丰富、好用的功能，而数组的功能很单一。\n\nArrayList是集合中的一种，它支持索引。\nArrayList集合的对象获取\n\n\n\n构造器\n说明\n\n\n\npublic ArrayList()\n创建一个空的集合对象\n\n\nArrayList集合添加元素的方法\n\n\n\n方法名\n说明\n\n\n\npublic boolean add(E e)\n将指定的元素追加到此集合的末尾\n\n\npublic void add(int index,E element)\n在此集合中的指定位置插入指定的元素\n\n\n/**\n      创建ArrayList对象，代表集合容器，往里面添加元素。\n */\npublic class ArrayListDemo1 &#123;\n    public static void main(String[] args) &#123;\n        // 1、创建ArrayList集合的对象\n        ArrayList list = new ArrayList();\n\n        // 2、添加数据\n        list.add(&quot;Java&quot;);\n        list.add(&quot;Java&quot;);\n        list.add(&quot;MySQL&quot;);\n        list.add(&quot;程序员&quot;);\n        list.add(23);\n        list.add(23.5);\n        list.add(false);\n        System.out.println(list.add(&#39;中&#39;));\n        System.out.println(list);\n\n        // 3、给指定索引位置插入元素\n        list.add(1, &quot;赵敏&quot;);\n        System.out.println(list);\n    &#125;\n&#125;\n\n2.2 Arraylist与泛型&#x3D;&#x3D;ArrayList︰其实就是一个泛型类，可以在编译阶段约束集合对象只能操作某种数据类型&#x3D;&#x3D;\n举例:\n\nArrayList &lt; String &gt; :此集合只能操作字符串类型的元素。\nArrayList &lt; lnteger &gt;:此集合只能操作整数类型的元素。\n\n注意:集合中只能存储引用类型，不支持基本数据类型。\n/**\n      能够使用泛型约束ArrayList集合操作的数据类型\n */\npublic class ArrayListDemo2 &#123;\n    public static void main(String[] args) &#123;\n        // ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();\n        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); // JDK 1.7开始，泛型后面的类型申明可以不写\n        list.add(&quot;Java&quot;);\n        list.add(&quot;MySQL&quot;);\n//        list.add(23);\n//        list.add(23.5);\n\n        ArrayList&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();\n        list2.add(23);\n        list2.add(100);\n        // list2.add(&quot;Java&quot;);\n\n\n    &#125;\n&#125;\n\n2.3 Arraylist常用API\n\n\n方法名\n说明\n\n\n\npublic boolean   remove(Object o)\n删除指定的元素，返回删除是否成功\n\n\npublic E   remove(int   index)\n删除指定索引处的元素，返回被删除的元素\n\n\npublic E   set(int index,E   element)\n修改指定索引处的元素，返回被修改的元素\n\n\npublic E   get(int   index)\n返回指定索引处的元素\n\n\npublic int   size()\n返回集合中的元素的个数\n\n\npublic boolean   add(E e)\n将指定的元素追加到此集合的末尾\n\n\npublic void   add(int index,E   element)\n在此集合中的指定位置插入指定的元素\n\n\n/**\n    目标：掌握ArrayList集合的常用API\n */\npublic class ArrayListDemo3 &#123;\n    public static void main(String[] args) &#123;\n        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();\n        list.add(&quot;Java&quot;);\n        list.add(&quot;Java&quot;);\n        list.add(&quot;MySQL&quot;);\n        list.add(&quot;MyBatis&quot;);\n        list.add(&quot;HTML&quot;);\n\n        // 1、public E get(int index)：获取某个索引位置处的元素值\n        String e = list.get(3);\n        System.out.println(e);\n\n        // 2、public int size()：获取集合的大小（元素个数）\n        System.out.println(list.size());\n\n        // 3、完成集合的遍历\n        for (int i = 0; i &lt; list.size(); i++) &#123;\n            System.out.println(list.get(i));\n        &#125;\n\n        // 4、public E remove(int index)：删除某个索引位置处的元素值,并返回被删除的元素值\n        System.out.println(list); // [Java, Java, MySQL, MyBatis, HTML]\n        String e2 = list.remove(2);\n        System.out.println(e2);\n        System.out.println(list);\n\n        // 5、public boolean remove(Object o):直接删除元素值，删除成功返回true，删除失败返回false\n        System.out.println(list.remove(&quot;MyBatis&quot;));\n        System.out.println(list);\n\n        ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;();\n        list1.add(&quot;Java&quot;);\n        list1.add(&quot;王宝强&quot;);\n        list1.add(&quot;Java&quot;);\n        list1.add(&quot;MySQL&quot;);\n        System.out.println(list1);\n        // 只会删除第一次出现的这个元素值，后面的不删除\n        System.out.println(list1.remove(&quot;Java&quot;));\n        System.out.println(list1);\n\n\n        // 6、public E set(int index,E element)：修改某个索引位置处的元素值。\n        String e3 = list1.set(0 , &quot;贾乃亮&quot;);\n        System.out.println(e3);\n        System.out.println(list1);\n\n\n    &#125;\n&#125;\n\n案例：\n遍历并删除元素值\n需求:某个班级的考试在系统上进行，成绩大致为:98，77，66，89，79，50，100现在需要先把成绩低于80分以下的数据去掉。\n/**\n   案例：从集合中遍历元素且删除。\n */\npublic class ArrayListTest&#123;\n    public static void main(String[] args) &#123;\n        // 1、创建集合对象：存入学生成绩(98,77,66,89,79,50,100)\n        ArrayList&lt;Integer&gt; scores = new ArrayList&lt;&gt;();\n        scores.add(98);\n        scores.add(77);\n        scores.add(66);\n        scores.add(89);\n        scores.add(79);\n        scores.add(50);\n        scores.add(100);\n        System.out.println(scores);\n\n        for (int i = scores.size() - 1; i &gt;= 0 ; i--) &#123;\n            int score = scores.get(i);\n            // 2、判断这个分数是否低于80分，如果低于则从集合中删除它\n            if(score &lt; 80)&#123;\n                scores.remove(i);\n            &#125;\n        &#125;\n        System.out.println(scores);\n    &#125;\n&#125;\n\n存储自定义类型\n需求:某影院系统需要在后台存储上述三部电影，然后依次展示出来。\npublic class Movie &#123;\n    private String name;\n    private double score;\n    private String actor;\n\n    public Movie() &#123;\n    &#125;\n\n    public Movie(String name, double score, String actor) &#123;\n        this.name = name;\n        this.score = score;\n        this.actor = actor;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public double getScore() &#123;\n        return score;\n    &#125;\n\n    public void setScore(double score) &#123;\n        this.score = score;\n    &#125;\n\n    public String getActor() &#123;\n        return actor;\n    &#125;\n\n    public void setActor(String actor) &#123;\n        this.actor = actor;\n    &#125;\n&#125;\n\nimport java.util.ArrayList;\n\n/**\n    案例：集合存储自定义元素并遍历。\n    需求：定义电影类（名称，分值，演员），创建3个电影对象，代表三部影片，存入集合中并遍历。\n    《肖生克的救赎》, 9.7 , 罗宾斯\n    《霸王别姬》, 9.6 , 张国荣、张丰毅\n    《阿甘正传》, 9.5 , 汤姆.汉克斯\n */\npublic class ArrayListTest5&#123;\n    public static void main(String[] args) &#123;\n        // 1、定义一个电影类：Movie\n        // 2、定义一个ArrayList集合存储这些影片对象。\n        ArrayList&lt;Movie&gt; movies = new ArrayList&lt;&gt;();\n\n        // 3、创建影片对象封装电影数据，把对象加入到集合中去。\n//        Movie m1 = new Movie(&quot;《肖生克的救赎》&quot;, 9.7 , &quot;罗宾斯&quot;);\n//        movies.add(m1);\n        movies.add(new Movie(&quot;《肖生克的救赎》&quot;, 9.7 , &quot;罗宾斯&quot;));\n        movies.add(new Movie(&quot;《霸王别姬》&quot;, 9.6 , &quot;张国荣、张丰毅&quot;));\n        movies.add(new Movie(&quot;《阿甘正传》&quot;, 9.5 , &quot;汤姆.汉克斯&quot;));\n\n        System.out.println(movies);\n\n        // 4、遍历集合中的影片对象并展示出来\n        for (int i = 0; i &lt; movies.size(); i++) &#123;\n            Movie movie = movies.get(i);\n            System.out.println(&quot;片名：&quot; + movie.getName());\n            System.out.println(&quot;评分：&quot; + movie.getScore());\n            System.out.println(&quot;主演：&quot; + movie.getActor());\n        &#125;\n    &#125;\n&#125;\n\n\n\n元素搜索\n需求:后台程序需要存储如上学生信息并展示，然后要提供按照学号搜索学生信息的功能。\npublic class Student &#123;\n    private String studyId;\n    private String name;\n    private int age;\n    private String className;\n\n    public Student() &#123;\n    &#125;\n\n    public Student(String studyId, String name, int age, String className) &#123;\n        this.studyId = studyId;\n        this.name = name;\n        this.age = age;\n        this.className = className;\n    &#125;\n\n    public String getStudyId() &#123;\n        return studyId;\n    &#125;\n\n    public void setStudyId(String studyId) &#123;\n        this.studyId = studyId;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n\n    public String getClassName() &#123;\n        return className;\n    &#125;\n\n    public void setClassName(String className) &#123;\n        this.className = className;\n    &#125;\n&#125;\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\n/**\n    案例：学生信息系统：展示数据，并按照学号完成搜索\n     学生类信息（学号，姓名，性别，班级）\n     测试数据：\n     &quot;20180302&quot;,&quot;叶孤城&quot;,23,&quot;护理一班&quot;\n     &quot;20180303&quot;,&quot;东方不败&quot;,23,&quot;推拿二班&quot;\n     &quot;20180304&quot;,&quot;西门吹雪&quot;,26,&quot;中药学四班&quot;\n     &quot;20180305&quot;,&quot;梅超风&quot;,26,&quot;神经科2班&quot;\n */\npublic class ArrayListTest6 &#123;\n    public static void main(String[] args) &#123;\n        // 1、定义一个学生类，后期用于创建对象封装学生数据\n        // 2、定义一个集合对象用于装学生对象\n        ArrayList&lt;Student&gt; students = new ArrayList&lt;&gt;();\n        students.add(new Student(&quot;20180302&quot;,&quot;叶孤城&quot;,23,&quot;护理一班&quot;));\n        students.add(new Student(&quot;20180303&quot;,&quot;东方不败&quot;,23,&quot;推拿二班&quot;));\n        students.add(new Student( &quot;20180304&quot;,&quot;西门吹雪&quot;,26,&quot;中药学四班&quot;));\n        students.add(new Student( &quot;20180305&quot;,&quot;梅超风&quot;,26,&quot;神经科2班&quot;));\n        System.out.println(&quot;学号\\t\\t名称\\t年龄\\t\\t班级&quot;);\n\n        // 3、遍历集合中的每个学生对象并展示其数据\n        for (int i = 0; i &lt; students.size(); i++) &#123;\n            Student s = students.get(i);\n            System.out.println(s.getStudyId() +&quot;\\t\\t&quot; + s.getName()+&quot;\\t\\t&quot;\n                    + s.getAge() +&quot;\\t\\t&quot; + s.getClassName());\n        &#125;\n\n        // 4、让用户不断的输入学号，可以搜索出该学生对象信息并展示出来（独立成方法）\n        Scanner sc = new Scanner(System.in);\n        while (true) &#123;\n            System.out.println(&quot;请您输入要查询的学生的学号：&quot;);\n            String id = sc.next();\n            Student s = getStudentByStudyId(students, id);\n            // 判断学号是否存在\n            if(s == null)&#123;\n                System.out.println(&quot;查无此人！&quot;);\n            &#125;else &#123;\n                // 找到了该学生对象了，信息如下\n                System.out.println(s.getStudyId() +&quot;\\t\\t&quot; + s.getName()+&quot;\\t\\t&quot;\n                        + s.getAge() +&quot;\\t\\t&quot; + s.getClassName());\n            &#125;\n        &#125;\n    &#125;\n\n    /**\n      根据学号，去集合中找出学生对象并返回。\n     * @param students\n     * @param studyId\n     * @return\n     */\n    public static Student getStudentByStudyId(ArrayList&lt;Student&gt; students, String studyId)&#123;\n        for (int i = 0; i &lt; students.size(); i++) &#123;\n            Student s = students.get(i);\n            if(s.getStudyId().equals(studyId))&#123;\n                return s;\n            &#125;\n        &#125;\n        return null; // 查无此学号！\n    &#125;\n&#125;\n\n\n","slug":"Java程序设计 -- 常用API(上)（九）","date":"2022-03-21T14:27:13.000Z","categories_index":"后端","tags_index":"Java","author_index":"会思想的苇草i"},{"id":"d1d7e86490a5e69b9e63a3257b8f9b8b","title":"Java程序设计--面向对象进阶(下)","content":"\n1、包包是用来分门别类的管理各种不同类的，类似于文件夹、建包利于程序的管理和维护。建包的语法格式: package公司域名倒写.技术名称。包名建议全部英文小写，且具备意义建包语句必须在第一行，一般IDEA工具会帮助创建。\n导包\n相同包下的类可以直接访问，不同包下的类必须导包,才可以使用!导包格式: import包名.类名;&#x3D;&#x3D;假如一个类中需要用到不同类，而这个两个类的名称是一样的，那么默认只能导入一个类，另一个类要带包名访问&#x3D;&#x3D;。\n\n2、权限修饰符权限修饰符:是用来控制一个成员能够被访问的范围的。\n可以修饰成员变量，方法，构造器，内部类，不同权限修饰符修饰的成员能够被访问的范围将受到限制。\n权限修饰符的分类和具体作用范围:\n&#x3D;&#x3D;权限修饰符:有四种作用范围由小到大(private -&gt;缺省-&gt; protected - &gt; public )&#x3D;&#x3D;\n\n\n\n修饰符\n同一个类中\n同一个包中其它类\n不同包下的子类\n不同包下的无关类\n\n\n\nprivate\n√\n\n\n\n\n\n缺省\n√\n√\n\n\n\n\nprotected\n√\n√\n√\n\n\n\npublic\n√\n√\n√\n√\n\n\npublic class Fu &#123;\n    // 1.private 只能本类中访问\n    private void show1() &#123;\n        System.out.println(&quot;private&quot;);\n    &#125;\n\n    // 2.缺省：本类，同一个包下的类中。\n    void show2() &#123;\n        System.out.println(&quot;缺省&quot;);\n    &#125;\n\n    // 3.protected：本类，同一个包下的类中，其他包下的子类\n    protected void show3() &#123;\n        System.out.println(&quot;protected&quot;);\n    &#125;\n\n    // 4.任何地方都可以\n    public void show4() &#123;\n        System.out.println(&quot;public&quot;);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        //创建Fu的对象，测试看有哪些方法可以使用\n        Fu f = new Fu();\n        f.show1();\n        f.show2();\n        f.show3();\n        f.show4();\n    &#125;\n&#125;\n\npublic class Demo &#123;\n    public static void main(String[] args) &#123;\n        //创建Fu的对象，测试看有哪些方法可以使用\n        Fu f = new Fu();\n//        f.show1(); // 私有的\n        f.show2();\n        f.show3();\n        f.show4();\n    &#125;\n&#125;\n\n\n3、final&#x3D;&#x3D;final关键字是最终的意思，可以修饰(方法，变量，类)&#x3D;&#x3D;\n\n&#x3D;&#x3D;修饰方法:表明该方法是最终方法，不能被重写。&#x3D;&#x3D;\n&#x3D;&#x3D;修饰变量:表示该变量第一次赋值后，不能再次被赋值(有且仅能被赋值一次)。&#x3D;&#x3D;\n&#x3D;&#x3D;修饰类:表明该类是最终类，不能被继承。&#x3D;&#x3D;\n\npublic class Test &#123;\n    // 属于类，只加载一次，可以共享 (常量)\n    public static final String schoolName = &quot;河工大&quot;;\n    public static final String schoolName2;\n    static&#123;\n        schoolName2 = &quot;中粮大&quot;;\n        // schoolName2 = &quot;中粮大&quot;; // 第二次赋值，报错了！\n    &#125;\n\n    // 属于对象的！ (final基本上不会用来修饰实例成员变量，没有意义！)\n    private final String name = &quot;王麻子&quot;;\n\n    public static void main(String[] args) &#123;\n       // final修饰变量，变量有且仅能被赋值一次。\n        /* 变量有几种：\n           局部变量。\n           成员变量。\n                -- 1、静态成员变量。\n                -- 2、实例成员变量。\n       */\n        final int age;\n        age = 12;\n        // age = 20; // 第二次赋值，报错了！\n        System.out.println(age);\n\n        final double rate = 3.14;\n\n        buy(0.8);\n\n        // schoolName = &quot;传智&quot;; // 第二次赋值，报错了！\n        Test t = new Test();\n        // t.name = &quot;麻子&quot;; // 第二次赋值，报错了！\n        System.out.println(t.name);\n    &#125;\n\n    public static void buy(final double z)&#123;\n        // z = 0.1; // 第二次赋值，报错了！\n    &#125;\n&#125;\n\n/**\n   final修饰方法，方法不能被重写\n */\nclass Animal&#123;\n    public final void run()&#123;\n        System.out.println(&quot;动物可以跑~~&quot;);\n    &#125;\n&#125;\n\nclass Tiger extends Animal&#123;\n//    @Override\n//    public void run() &#123;\n//        System.out.println(&quot;老虎跑的贼快~~~&quot;);\n//    &#125;\n&#125;\n\nfinal修饰变量的注意\n\nfinal修饰的变量是基本类型:那么变量存储的数据值不能发生改变。\nfinal修饰的变量是引用类型:那么变量存储的地址值不能发生改变，但是地址指向的对象内容是可以发生变化的。\n\npublic class Test2 &#123;\n    public static void main(String[] args) &#123;\n        // final修饰变量的注意事项：\n        // 1、final修饰基本类型变量，其数据不能再改变\n        final double rate = 3.14;\n        // rate = 3.15; // 第二次赋值，报错\n\n        // 2、final修饰引用数据类型的变量，变量中存储的地址不能被改变，但是地址指向的对象内容可以改变。\n        final int[] arr = &#123;10, 20, 30&#125;;\n        System.out.println(arr);\n        // arr = null; // 属于第二次赋值，arr中的地址不能被改变\n        arr[1] = 200;\n        System.out.println(arr);\n        System.out.println(arr[1]);\n    &#125;\n&#125;\n\n\n4、常量常量是使用了public static final修饰的成员变量，必须有初始化值，而且执行的过程中其值不能被改变。\n常量的作用和好处:可以用于做系统的配置信息，方便程序的维护，同时也能提高可读性。\n常量命名规范：英文单词全部大写，多个单词下划线连接起来。\npublic class ConstantDemo &#123;\n    public static final String SCHOOL_NAME = &quot;河工大&quot;;\n    public static final String USER_NAME = &quot;hauter&quot;;\n    public static final String PASS_WORD = &quot;123456&quot;;\n\n    public static void main(String[] args) &#123;\n        System.out.println(SCHOOL_NAME);\n        System.out.println(SCHOOL_NAME);\n        System.out.println(SCHOOL_NAME);\n        System.out.println(SCHOOL_NAME);\n        System.out.println(SCHOOL_NAME);\n        System.out.println(SCHOOL_NAME);\n\n        if(USER_NAME.equals(&quot;&quot;))&#123;\n\n        &#125;\n    &#125;\n&#125;\n\n常量的执行原理\n在编译阶段会进行“宏替换”，把使用常量的地方全部替换成真实的字面量。\n这样做的好处是让使用常量的程序的执行性能与直接使用字面量是一样的。\n\n5、枚举枚举是Java中的一种特殊类型\n枚举的作用:”是为了做信息的标志和信息的分类”。\n修饰符 enum 枚举名称&#123;\n    第一行都是罗列枚举类实例的名称\n&#125;\n\npublic enum Season&#123;\n    SPRING,SUMMER.AUTUMN,WINTER;\n&#125;\n\n枚举的特征:\n\n枚举类都是继承了枚举类型: java.lang.Enum\n&#x3D;&#x3D;枚举都是最终类，不可以被继承。&#x3D;&#x3D;\n&#x3D;&#x3D;构造器都是私有的，枚举对外不能创建对象。&#x3D;&#x3D;\n枚举类的第一行默认都是罗列枚举对象的名称的。\n枚举类相当于是多例模式。\n\n\n6、抽象类6.1 抽象类、抽象方法&#x3D;&#x3D;在Java中abstract是抽象的意思，如果一个类中的某个方法的具体实现不能确定，就可以申明成abstract修饰的抽象方法（不能写方法体了)，这个类必须用abstract修饰，被称为抽象类。&#x3D;&#x3D;\n修饰符 abstract 返回值类型 方法名称(形参列表);\n\n修饰符 abstract class 类名&#123;&#125;\n\npublic abstract class Animal &#123;\n    private String name;\n\n    public abstract void run();\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n&#125;\n\npublic class Dog extends Animal&#123;\n    @Override\n    public void run() &#123;\n        System.out.println(&quot;狗跑的也很快~~~&quot;);\n    &#125;\n&#125;\n\npublic class Tiger extends Animal&#123;\n    @Override\n    public void run() &#123;\n        System.out.println(&quot;老虎跑的贼溜~~~~&quot;);\n    &#125;\n&#125;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        Tiger t = new Tiger();\n        t.run();\n\n        Dog t1 = new Dog();\n        t1.run();\n    &#125;\n&#125;\n\n抽象的使用总结与注意事项\n\n&#x3D;&#x3D;抽象类可以理解成类的不完整设计图，是用来被子类继承的。&#x3D;&#x3D;\n&#x3D;&#x3D;一个类如果继承了抽象类，那么这个类必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类。&#x3D;&#x3D;\n\n6.2 抽象的特征和注意事项\n有得有失:得到了抽象方法，失去了创建对象的能力。\n类有的成员（成员变量、方法、构造器）抽象类都具备\n抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类\n一个类继承了抽象类必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类\n不能用abstract修饰变量、代码块、构造器。\n\nfinal和abstract是互斥关系\n\nabstract定义的抽象类作为模板让子类继承，final定义的类不能被继承。\n抽象方法定义通用功能让子类重写，final定义的方法子类不能重写。\n\n6.3 模板方法模式模板方法模式实现步骤\n\n把功能定义成一个所谓的模板方法，放在抽象类中，模板方法中只定义通用且能确定的代码。\n模板方法中不能决定的功能定义成抽象方法让具体子类去实现。\n\npublic abstract class Account &#123;\n    private String cardId;\n    private double money;\n\n    public Account() &#123;\n    &#125;\n\n    public Account(String cardId, double money) &#123;\n        this.cardId = cardId;\n        this.money = money;\n    &#125;\n\n    /**\n      模板方法\n     */\n    public final void handle(String loginName , String passWord )&#123;\n        // a.判断登录是否成功\n        if(&quot;huater&quot;.equals(loginName) &amp;&amp; &quot;123456&quot;.equals(passWord))&#123;\n            System.out.println(&quot;登录成功。。&quot;);\n            // b.正式结算利息\n            // 当前模板方法知道所有子类账户都要结算利息，但是具体怎么结算，模板不清楚，交给具体的子类来计算\n            double result = calc();\n            // c.输出利息详情\n            System.out.println(&quot;本账户利息是：&quot;+ result);\n        &#125;else&#123;\n            System.out.println(&quot;用户名或者密码错误了&quot;);\n        &#125;\n    &#125;\n\n    public abstract double calc();\n\n\n    public String getCardId() &#123;\n        return cardId;\n    &#125;\n\n    public void setCardId(String cardId) &#123;\n        this.cardId = cardId;\n    &#125;\n\n    public double getMoney() &#123;\n        return money;\n    &#125;\n\n    public void setMoney(double money) &#123;\n        this.money = money;\n    &#125;\n&#125;\n\n/**\n  活期账户\n */\npublic class CurrentAccount extends Account &#123;\n\n    public CurrentAccount(String cardId,  double money) &#123;\n        super(cardId, money);\n    &#125;\n\n    @Override\n    public double calc() &#123;\n        // b.正式结算利息\n        double result =  getMoney() * 0.0175; // 结算利息了\n        return result;\n    &#125;\n\n&#125;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        CurrentAccount acc = new CurrentAccount(&quot;ICBC-111&quot;, 100000);\n        acc.handle(&quot;hauter&quot;, &quot;123456&quot;);\n    &#125;\n&#125;\n\n\n7、接口7.1 接口概述接口是一种规范，是接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。接口的定义如下\npublic interface 接口名&#123;\n    //常量\n    //抽象方法\n&#125;\n\n接口不能实例化。\n接口中的成员都是public修饰的，写不写都是，因为规范的目的是为了公开化。\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        // 接口不能创建对象！\n        // SportManInterface s = new SportManInterface();\n    &#125;\n&#125;\n\npublic interface SportManInterface &#123;\n    // 接口中的成员：JDK 1.8之前只有常量 和 抽象方法\n    // public static final 可以省略不写，接口默认会为你加上！\n    // public static final String SCHOOL_NAME = &quot;河工大&quot;;\n    String SCHOOL_NAME = &quot;河工大&quot;;\n\n    // 2、抽象方法\n    //  public abstract 可以省略不写，接口默认会为你加上！\n    // public abstract void run();\n    void run();\n\n    // public abstract void eat();\n    void eat();\n&#125;\n\n7.2 接口的使用–被实现接口的用法:\n接口是用来被类实现(implements)的，实现接口的类称为实现类。实现类可以理解成所谓的子类。\n修饰符  class 实现类 implements 接口1，接口2，接口3，...&#123;\n&#125;\n\n接口可以被类单实现，也可以被类多实现\n接口实现的注意事项:\n一个类实现接口，必须重写完全部接口的全部抽象方法，否则这个类需要定义成抽象类。\npublic interface Law &#123;\n    void rule(); // 遵章守法\n&#125;\n\npublic interface SportMan &#123;\n    void run();\n    void competition();\n&#125;\n\n/**\n   实现类（子类）\n */\npublic class PingPongMan implements SportMan , Law&#123;\n    private String name;\n    public PingPongMan(String name) &#123;\n        this.name = name;\n    &#125;\n\n    @Override\n    public void rule() &#123;\n        System.out.println(name + &quot;要遵章守法，不能随意外出，酗酒，约会~~~&quot;);\n    &#125;\n\n    @Override\n    public void run() &#123;\n        System.out.println(name + &quot;必须要跑步训练~~&quot;);\n    &#125;\n\n    @Override\n    public void competition() &#123;\n        System.out.println(name + &quot;需要参加国际比赛~~&quot;);\n    &#125;\n&#125;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        PingPongMan p = new PingPongMan(&quot;张松松&quot;);\n        p.rule();\n        p.run();\n        p.competition();\n    &#125;\n&#125;\n\n7.3 接口与接口的关系–多继承类和类的关系:单继承。\n类和接口的关系:多实现。\n接口和接口的关系:多继承，一个接口可以同时继承多个接口。\npublic interface Law &#123;\n    void rule(); // 遵章守法\n    void eat();\n&#125;\n\npublic interface People &#123;\n    void eat();\n&#125;\n\npublic interface SportMan extends Law, People &#123;\n    void run();\n    void competition();\n&#125;\n\n/**\n   实现类\n */\n// public class BasketballMan implements Law, SportMan, People &#123;\npublic class BasketballMan implements SportMan&#123;\n\n    @Override\n    public void rule() &#123;\n\n    &#125;\n\n    @Override\n    public void eat() &#123;\n\n    &#125;\n\n\n    @Override\n    public void run() &#123;\n\n    &#125;\n\n    @Override\n    public void competition() &#123;\n\n    &#125;\n&#125;\n\n接口多继承的作用\n规范合并，整合多个接口为同一个接口，便于子类实现。\n7.4 接口的注意事项\n接口不能创建对象\n一个类实现多个接口，多个接口中有同样的静态方法不冲突。\n一个类继承了父类，同时又实现了接口，父类中和接口中有同名方法，默认用父类的。\n一个类实现了多个接口，多个接口中存在同名的默认方法，不冲突，这个类重写该方法即可\n一个接口继承多个接口，是没有问题的，如果多个接口中存在规范冲突则不能多继承。\n\n\n8、面向对象特征–多态同类型的对象，执行同一个行为，会表现出不同的行为特征。\n父类类型对象名称=new子类构造器;\n接口对象名称=new 实现类构造器;\n\n/**\n    父类\n */\npublic class Animal &#123;\n    public String name = &quot;动物名称&quot;;\n    public void run()&#123;\n        System.out.println(&quot;动物可以跑~~&quot;);\n    &#125;\n&#125;\n\npublic class Dog extends Animal&#123;\n    public String name = &quot;狗名称&quot;;\n    @Override\n    public void run() &#123;\n        System.out.println(&quot;🐕跑的贼溜~~~~~&quot;);\n    &#125;\n&#125;\n\npublic class Tortoise extends Animal&#123;\n    public String name = &quot;乌龟名称&quot;;\n\n    @Override\n    public void run() &#123;\n        System.out.println(&quot;🐢跑的非常慢~~~&quot;);\n    &#125;\n&#125;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        // 目标：先认识多态的形式\n        // 父类  对象名称 = new 子类构造器();\n        Animal a = new Dog();\n        a.run(); // 方法调用：编译看左，运行看右\n        System.out.println(a.name); // 方法调用：编译看左，运行也看左，动物名称\n\n        Animal a1 = new Dog();\n        a1.run();\n        System.out.println(a1.name); // 动物名称\n    &#125;\n&#125;\n\n多态中成员访问特点\n\n方法调用:编译看左边，运行看右边。\n变量调用:编译看左边，运行也看左边。\n\n(多态侧重行为多态)多态的前提\n\n有继承&#x2F;实现关系;\n有父类引用指向子类对象;\n有方法重写。\n\n在多态形式下，右边对象可以实现解耦合，便于扩展和维护。\nAnimal a =new Dog0;\na.run();//后续业务行为随对象而变,后续代码无需修改\n\n定义方法的时候，使用父类型作为参数，该方法就可以接收这父类的一切子类对象，体现出多态的扩展性与便利。\n多态下会产生的一个问题:多态下不能使用子类的独有功能\n\n自动类型转换（从子到父):子类对象赋值给父类类型的变量指向。\n强制类型转换（从父到子) 此时必须进行强制类型转换:&#x3D;&#x3D;子类对象变量&#x3D;(子类)父类类型的变量&#x3D;&#x3D;\n\n&#x3D;&#x3D;作用:可以解决多态下的劣势，可以实现调用子类独有的功能。&#x3D;&#x3D;\n&#x3D;&#x3D;注意:如果转型后的类型和对象真实类型不是同一种类型，那么在转换的时候就会出现ClassCastException&#x3D;&#x3D;\nAnimal t = new Tortoise();\nDog d = (Dog)t; //出现异常ClassCastException\n\n/**\n    父类\n */\npublic class Animal &#123;\n    public String name = &quot;动物名称&quot;;\n    public void run()&#123;\n        System.out.println(&quot;动物可以跑~~&quot;);\n    &#125;\n&#125;\n\npublic class Dog extends Animal &#123;\n    public String name = &quot;狗名称&quot;;\n    @Override\n    public void run() &#123;\n        System.out.println(&quot;🐕跑的贼溜~~~~~&quot;);\n    &#125;\n\n    /**\n      独有功能\n     */\n    public void lookDoor()&#123;\n        System.out.println(&quot;🐕在看🚪！！！&quot;);\n    &#125;\n&#125;\n\npublic class Tortoise extends Animal &#123;\n    public String name = &quot;乌龟名称&quot;;\n\n    @Override\n    public void run() &#123;\n        System.out.println(&quot;🐢跑的非常慢~~~&quot;);\n    &#125;\n\n    /**\n     独有功能\n     */\n    public void layEggs()&#123;\n        System.out.println(&quot;🐢在下蛋~~~&quot;);\n    &#125;\n&#125;\n\n/**\n     多态形式下的类中转换机制。\n */\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        // 自动类型转换\n        Animal a = new Dog();\n        a.run();\n//        a.lookDoor(); // 多态下无法调用子类独有功能\n\n        // 强制类型转换:可以实现调用子类独有功能的\n        Dog d = (Dog) a;\n        d.lookDoor();\n\n        // 注意：多态下直接强制类型转换，可能出现类型转换异常\n        // 规定：有继承或者实现关系的2个类型就可以强制类型转换，运行时可能出现问题。\n        // Tortoise t1 = (Tortoise) a;\n        // 建议强制转换前，先判断变量指向对象的真实类型，再强制类型转换。\n        if(a instanceof Tortoise)&#123;\n            Tortoise t = (Tortoise) a;\n            t.layEggs();\n        &#125;else if(a instanceof Dog)&#123;\n            Dog d1 = (Dog) a;\n            d1.lookDoor();\n        &#125;\n\n        System.out.println(&quot;---------------------&quot;);\n        Animal a1 = new Dog();\n        go(a1);\n    &#125;\n\n    public static void go(Animal a)&#123;\n        System.out.println(&quot;预备~~~&quot;);\n        a.run();\n        // 独有功能\n        if(a instanceof Tortoise)&#123;\n            Tortoise t = (Tortoise) a;\n            t.layEggs();\n        &#125;else if(a instanceof Dog)&#123;\n            Dog d1 = (Dog) a;\n            d1.lookDoor();\n        &#125;\n        System.out.println(&quot;结束~~~~&quot;);\n    &#125;\n&#125;\n\nJava建议强转转换前使用instanceof判断当前对象的真实类型，再进行强制转换\n变量名instanceof真实类型\n\n判断关键字左边的变量指向的对象的真实类型，是否是右边的类型或者是其子类类型，是则源回true,反之。\n\n9、内部类9.1 内部类概述内部类就是定义在一个类里面的类，里面的类可以理解成(寄生)，外部类可以理解成（宿主)。\npublic class People&#123;\n    public class Heart&#123;\n    &#125;\n&#125;\n\n内部类的使用场景、作用\n\n当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构可以选择使用内部类来设计。\n内部类通常可以方便访问外部类的成员，包括私有的成员。\n内部类提供了更好的封装性，内部类本身就可以用private protectecd等修饰，封装性可以做更多控制\n\n9.2 静态内部类（了解）有static修饰，属于外部类本身。\n它的特点和使用与普通类是完全一样的，类有的成分它都有，只是位置在别人里面而已。\npublic class Outer&#123;\n    //静态成员内部类\n    public static class Inner&#123;\n    &#125;\n&#125;\n\n静态内部类创建对象的格式\n外部类名.内部类名 对象名 = new 外部类名.内部类构造器;\n\nOuter.Inner in = new Outer.Inner();\n\n&#x3D;&#x3D;静态内部类中可以直接访问外部类的静态成员，外部类的静态成员只有一份可以被共享访问。&#x3D;&#x3D;\n&#x3D;&#x3D;静态内部类中不可以直接访问外部类的实例成员，外部类的实例成员必须用外部类对象访问。&#x3D;&#x3D;\n9.3 成员内部类（了解）无static修饰，属于外部类的对象。\nJDK16之前，成员内部类中不能定义静态成员，JDK16开始也可以定义静态成员了。\npublic class Outer&#123;\n    //成员内部类\n    public class Inner&#123;\n    &#125;\n&#125;\n\n成员内部类创建对象的格式：\n外部类名.内部类名 对象名 = new 外部类构造器.new 内部类构造器();\n\nOuter.Inner in = new Outer().new Inner();\n\n&#x3D;&#x3D;成员内部类中可以直接访问外部类的静态成员，外部类的静态成员只有一份可以被共享访问。&#x3D;&#x3D;\n&#x3D;&#x3D;成员内部类的实例方法中可以直接访问外部类的实例成员，因为必须先有外部类对象，才能有成员内部类对象，所以可以直接访问外部类对象的实例成员&#x3D;&#x3D;\n9.4 局部内部类（了解）局部内部类放在方法、代码块、构造器等执行体中。\n局部内部类的类文件名为:外部类$N内部类.class。\n9.5 匿名内部类（重点）本质上是一个没有名字的局部内部类，定义在方法中、代码块中、等。\n作用:方便创建子类对象，最终目的为了简化代码编写。\nnew 类|抽象名|接口名()&#123;\n    重写方法；\n&#125;；\n\n/**\n      匿名内部类的形式和特点。\n */\npublic class Test1 &#123;\n    public static void main(String[] args) &#123;\n        Animal a = new Animal()&#123;\n            @Override\n            public void run() &#123;\n                System.out.println(&quot;老虎跑的块~~~&quot;);\n            &#125;\n        &#125;;\n        a.run();\n    &#125;\n&#125;\n\n//class Tiger extends Animal&#123;\n//    @Override\n//    public void run() &#123;\n//        System.out.println(&quot;老虎跑的块~~~&quot;);\n//    &#125;\n//&#125;\n\nabstract class Animal&#123;\n    public abstract void run();\n&#125;\n\n/**\n    匿名内部类的使用形式（语法）\n */\npublic class Test2 &#123;\n    public static void main(String[] args) &#123;\n        Swimming s = new Swimming() &#123;\n            @Override\n            public void swim() &#123;\n                System.out.println(&quot;学生快乐的自由泳🏊‍&quot;);\n            &#125;\n        &#125;;\n        go(s);\n\n        System.out.println(&quot;--------------&quot;);\n\n        Swimming s1 = new Swimming() &#123;\n            @Override\n            public void swim() &#123;\n                System.out.println(&quot;老师泳🏊的贼快~~~~~&quot;);\n            &#125;\n        &#125;;\n        go(s1);\n\n        System.out.println(&quot;--------------&quot;);\n\n        go(new Swimming() &#123;\n            @Override\n            public void swim() &#123;\n                System.out.println(&quot;运动员🏊的贼快啊~~~~~&quot;);\n            &#125;\n        &#125;);\n\n\n    &#125;\n\n    /**\n       学生 老师 运动员可以一起参加游泳比赛\n     */\n    public static void go(Swimming s)&#123;\n        System.out.println(&quot;开始。。。&quot;);\n        s.swim();\n        System.out.println(&quot;结束。。。&quot;);\n    &#125;\n&#125;\n\n\ninterface Swimming&#123;\n    void swim();\n&#125;\n\n特点总结:\n\n匿名内部类是一个没有名字的内部类。\n匿名内部类写出来就会产生一个匿名内部类的对象。\n匿名内部类的对象类型相当于是当前new的那个的类型的子类类型。\n匿名内部类可以作为方法的实际参数进行传输。\n\n\n10、泛型\n定义类、接口、方法时，**同时声明了一个或者多个类型变量(如: &lt; E &gt;)**，称为泛型类、泛型接口，泛型方法、它们统称为泛型。\n\npublic class ArrayList&lt;E&gt;&#123;\n    ...\n&#125;\n\n\n作用：泛型提供了在编译阶段约束所能操作的数据类型，并自动进行检查的能力!这样可以避免强制类型转换，及其可能出现的异常。\n泛型的本质：把具体的数据类型作为参数传给类型变量。\n\n// 泛型类\n修饰符 class 类名&lt;类型变量,类型变量,...&gt;&#123;\n    \n&#125;\npublic class ArrayList&lt;E&gt;&#123;\n    ...\n&#125;\n\n// 泛型接口\n修饰符 interface 接口名&lt;类型变量,类型变量,...&gt;&#123;\n    \n&#125;\npublic interface A&lt;E&gt;&#123;\n    ...\n&#125;\n\n// 泛型方法\n修饰符 &lt;类型变量,类型变量,...&gt; 返回值类型 方法名(形参列表)&#123;\n    \n&#125;\n\n\n类型变量建议用大写的英文字母，常用的有：E、T、K、V等\n通配符：就是“?”，可以在“使用泛型”的时候代表一切类型；E、T、K、V是在定义泛型的时候使用。\n泛型上下限：\n泛型上限: ? extends car:?能接收的必须是Car或者其子类。\n泛型下限:? super Car : ?能接收的必须是Car或者其父类。\n\n\n注意：\n泛型是工作在编译阶段的，一旦程序编译成class文件，class文件中就不存在泛型了，这就是泛型擦除。\n泛型不支持基本数据类型，只能支持对象类型(引用数据类型)。\n\n\n\n","slug":"Java程序设计 -- 面向对象进阶(下)（八）","date":"2022-03-21T03:01:58.000Z","categories_index":"后端","tags_index":"Java","author_index":"会思想的苇草i"},{"id":"85159c9648aa55d2d25caaf72205c399","title":"Java程序设计--面向对象进阶(上)","content":"\n1、静态关键字–static1.1 static修饰成员变量的基本用法sctatic是静态的意思，可以修饰成员变量和成员方法。\n&#x3D;&#x3D;static修饰成员变量表示该成员变量只在内存中只存储一份，可以被共享访问、修改。&#x3D;&#x3D;\n静态成员变量(有static修饰，属于类，内存中加载一次)∶常表示如在线人数信息、等需要被共享的信息，可以被共享访问。\n类名.静态成员变量(推荐)\n\n对象.静态成员变量(不推荐)\n\n实例成员变量（无static修饰，存在于每个对象中)︰常表示姓名name、年龄age、等属于每个对象的信息。\n对象.实例成员变量\n\npublic class User &#123;\n    // 在线人数信息：静态成员变量\n    public static int onLineNumber = 161;\n    // 实例成员变量\n    private String name;\n    private int age;\n\n    public static void main(String[] args) &#123;\n        // 1、类名.静态成员变量\n        User.onLineNumber++;\n        // 注意：同一个类中访问静态成员变量，类名可以省略不写\n        System.out.println(onLineNumber);\n\n        // 2、对象.实例成员变量\n        // System.out.println(name);\n        User u1 = new User();\n        u1.name = &quot;猪八戒&quot;;\n        u1.age = 36;\n        System.out.println(u1.name);\n        System.out.println(u1.age);\n        // 对象.静态成员变量(不推荐这样访问)\n        u1.onLineNumber++;\n\n        User u2 = new User();\n        u2.name = &quot;孙悟空&quot;;\n        u2.age = 38;\n        System.out.println(u2.name);\n        System.out.println(u2.age);\n        // 对象.静态成员变量(不推荐这样访问)\n        u2.onLineNumber++;\n\n        System.out.println(onLineNumber);\n\n    &#125;\n&#125;\n\n1.2 static修饰成员变量的内存原理\n1.3 static修饰成员方法的基本用法成员方法的分类:\n\n静态成员方法（有static修饰，属于类)，建议用类名访问，也可以用对象访问。\n实例成员方法（无static修饰，属于对象)，只能用对象触发访问。\n\n使用场景\n\n表示对象自己的行为的，且方法中需要访问实例成员的，则该方法必须申明成实例方法。\n如果该方法是以执行一个共用功能为目的，则可以申明成静态方法。\n\npublic class Student &#123;\n    private String name;\n    private int age;\n\n    /**\n        实例方法：无static修饰，属于对象的，通常表示对象自己的行为，可以访问对象的成员变量\n     */\n    public void study()&#123;\n        System.out.println(name + &quot;在好好学习，天天向上~~&quot;);\n    &#125;\n\n    /**\n        静态方法：有static修饰，属于类，可以被类和对象共享访问。\n     */\n    public static void getMax(int a, int b)&#123;\n        System.out.println(a &gt; b ? a : b);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        // 1、类名.静态方法\n        Student.getMax(10, 100);\n        // 注意：同一个类中访问静态成员 可以省略类名不写\n        getMax(200, 20);\n\n        // 2、对象.实例方法\n        // study(); // 报错的\n        Student s = new Student();\n        s.name = &quot;全蛋儿&quot;;\n        s.study();\n\n        // 3、对象.静态方法(不推荐)\n        s.getMax(300,20);\n    &#125;\n&#125;\n\n1.4 static修饰成员方法的内存原理\n1.5 static实际应用案例工具类中定义的都是一些静态方法，每个方法都是以完成一个共用的功能为目的。\n工具类的好处\n\n调用方便\n提高了代码复用\n\n工具类的定义注意\n\n&#x3D;&#x3D;建议将工具类的构造器进行私有，工具类无需创建对象。&#x3D;&#x3D;\n&#x3D;&#x3D;里面都是静态方法，直接用类名访问即可。&#x3D;&#x3D;\n\npublic class ArrayUtils &#123;\n    /**\n       把它的构造器私有化\n     */\n    private ArrayUtils()&#123;\n    &#125;\n\n    /**\n       静态方法，工具方法\n     */\n    public static String toString(int[] arr)&#123;\n        if(arr != null )&#123;\n            String result = &quot;[&quot;;\n            for (int i = 0; i &lt; arr.length; i++) &#123;\n                result += (i == arr.length - 1 ? arr[i] : arr[i] + &quot;, &quot;);\n            &#125;\n            result += &quot;]&quot;;\n            return result;\n        &#125;else &#123;\n            return null;\n        &#125;\n    &#125;\n\n    /**\n     静态方法，工具方法\n     */\n    public static double getAverage(int[] arr)&#123;\n        // 总和  最大值 最小值\n        int max = arr[0];\n        int min = arr[0];\n        int sum = 0;\n        for (int i = 0; i &lt; arr.length; i++) &#123;\n            if(arr[i] &gt; max)&#123;\n                max = arr[i];\n            &#125;\n            if(arr[i] &lt; min)&#123;\n                min = arr[i];\n            &#125;\n            sum += arr[i];\n        &#125;\n        return (sum - max - min)*1.0 / (arr.length - 2);\n    &#125;\n&#125;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        int[] arr = &#123;10, 20, 30&#125;;\n        System.out.println(arr);\n        System.out.println(ArrayUtils.toString(arr));\n        System.out.println(ArrayUtils.getAverage(arr));\n\n        int[] arr1 = null;\n        System.out.println(ArrayUtils.toString(arr1));\n        int[] arr2 = &#123;&#125;;\n        System.out.println(ArrayUtils.toString(arr2));\n\n    &#125;\n&#125;\n\n1.6 static的注意事项\n&#x3D;&#x3D;静态方法只能访问静态的成员，不可以直接访问实例成员。&#x3D;&#x3D;\n&#x3D;&#x3D;实例方法可以访问静态的成员，也可以访问实例成员。&#x3D;&#x3D;\n&#x3D;&#x3D;静态方法中是不可以出现this关键字的。&#x3D;&#x3D;\n\n\n2、static应用–代码块代码块概述\n\n代码块是类的5大成分之一(成员变量、构造器，方法，代码块，内部类)，定义在类中方法外。\n在Java类下，使用{}括起来的代码被称为代码块。\n\n代码块分为\n\n静态代码块: - 格式: static{} - 特点:需要通过static关键字修饰，随着类的加载而加载，并且自动触发、只执行一次 - 使用场景:在类加载的时候做一些静态数据初始化的操作，以便后续使用。\n\npublic class TestDemo1 &#123;\n\n    public static String schoolName;\n\n    public static void main(String[] args) &#123;\n        // 目标：学习静态代码块的特点、基本作用\n        System.out.println(&quot;=========main方法被执行输出===========&quot;);\n        System.out.println(schoolName);\n    &#125;\n\n    /**\n     特点：与类一起加载，自动触发一次，优先执行\n     作用：可以在程序加载时进行静态数据的初始化操作（准备内容）\n     */\n    static&#123;\n        System.out.println(&quot;==静态代码块被触发执行==&quot;);\n        schoolName = &quot;河工大&quot;;\n    &#125;\n&#125;\n\n\n构造代码块（了解，用的少): - 格式:{} - 特点:每次创建对象，调用构造器执行时，都会执行该代码块中的代码，并且在构造器执行前执行 - 使用场景:初始化实例资源。\n\npublic class TestDemo2 &#123;\n\n    private String name;\n\n    /**\n       属于对象的，与对象一起加载，自动触发执行。\n     */\n    &#123;\n        System.out.println(&quot;==构造代码块被触发执行一次==&quot;);\n        name = &quot;老王&quot;;\n    &#125;\n\n    public TestDemo2()&#123;\n        System.out.println(&quot;==构造器被触发执行==&quot;);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        // 目标：学习构造代码块的特点、基本作用\n        TestDemo2 t = new TestDemo2();\n        System.out.println(t.name);\n\n        TestDemo2 t1 = new TestDemo2();\n        System.out.println(t1.name);\n    &#125;\n\n&#125;\n\n\n3、static应用–单例设计模式3.1 设计模式设计模式(Design pattern)：开发中经常遇到一些问题，一个问题通常有n种解法的，但其中肯定有一种解法是最优的，这个最优的解法被人总结出来了，称之为设计模式。设计模式有20多种，对应20多种软件开发中会遇到的问题，学设计模式主要是学2点:\n\n这种模式用来解决什么问题。\n遇到这种问题了，该模式是怎么写的，他是如何解决这个问题的。\n\n单例模式\n可以保证系统中，应用该模式的这个类永远只有一个实例，即一个类永远只能创建一个对象。例如任务管理器对象我们只需要一个就可以解决问题了，这样可以节省内存空间。\n3.2 饿汉单例设计模式在用类获取对象的时候，对象已经提前为你创建好了。\n设计步骤\n\n定义一个类，把构造器私有。\n定义一个静态变量存储一个对象。\n\n/**\n    目标：学会使用饿汉单例模式设计单例类\n */\npublic class SingleInstance1 &#123;\n    /**\n       static修饰的成员变量，静态成员变量，加载一次，只有一份\n     */\n    // public static int onLineNumber = 21;\n    public static SingleInstance1 instance = new SingleInstance1();\n\n    /**\n        1、必须私有构造器：私有构造器对外不能被访问。\n     */\n    private SingleInstance1()&#123;\n    &#125;\n\n\n&#125;\n\npublic class Test1 &#123;\n    public static void main(String[] args) &#123;\n//        SingleInstance1 s1 = new SingleInstance1();\n//        SingleInstance1 s2 = new SingleInstance1();\n//        SingleInstance1 s3 = new SingleInstance1();\n\n        SingleInstance1 s1 = SingleInstance1.instance;\n        SingleInstance1 s2 = SingleInstance1.instance;\n        SingleInstance1 s3 = SingleInstance1.instance;\n        System.out.println(s1);\n        System.out.println(s2);\n        System.out.println(s3);\n        System.out.println(s1 == s2);\n    &#125;\n&#125;\n\n3.3 懒汉单例设计模式在真正需要该对象的时候，才去创建一个对象（延迟加载对象）\n设计步骤\n\n定义一个类，把构造器私有\n定义一个静态变量存储一个对象\n提供一个返回单例对象的方法\n\n/**\n    目标：设计懒汉单例\n */\npublic class SingleInstance2 &#123;\n    /**\n       2、定义一个静态的成员变量用于存储一个对象，一开始不要初始化对象，因为人家是懒汉\n     */\n    private static SingleInstance2 instance;\n\n    /**\n       1、私有构造器啊\n     */\n    private SingleInstance2()&#123;\n    &#125;\n\n    /**\n      3、提供一个方法暴露，真正调用这个方法的时候才创建一个单例对象\n     */\n    public static SingleInstance2 getInstance()&#123;\n        if(instance == null)&#123;\n            // 第一次来拿对象，为他做一个对象\n            instance = new SingleInstance2();\n        &#125;\n        return instance;\n    &#125;\n&#125;\n\npublic class Test2 &#123;\n    public static void main(String[] args) &#123;\n        // 得到一个对象\n        SingleInstance2 s1 = SingleInstance2.getInstance();\n        SingleInstance2 s2 = SingleInstance2.getInstance();\n\n        System.out.println(s1 == s2);\n    &#125;\n&#125;\n\n\n4、面向对象特征–继承4.1 继承Java中提供一个关键字extends，用这个关键字，我们可以让一个类和另一个类建立起父子关系。\npublic class 子类 extends 父类 &#123;\n&#125;\n\n使用继承的好处：\n当子类继承父类后，就可以直接使用父类公共的属性和方法了。因此，用好这个技术可以很好的我们提高代码的复用性\npublic class People &#123;\n    private String name;\n    private int age;\n\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n&#125;\n\npublic class Student extends People&#123;\n    /**\n       独有的行为\n     */\n    public void study()&#123;\n        System.out.println(getName() + &quot;学生开始学习~~~~~&quot;);\n    &#125;\n&#125;\n\npublic class Teacher extends People&#123;\n    /**\n       独有的行为\n     */\n    public void teach()&#123;\n        System.out.println(&quot;老师在快乐的教Java~~~~~&quot;);\n    &#125;\n\n&#125;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        // 创建子类对象，看是否可以使用父类的属性和行为\n        Student s = new Student();\n        s.setName(&quot;杰哥&quot;); // 父类的\n        s.setAge(25);// 父类的\n        System.out.println(s.getName());// 父类的\n        System.out.println(s.getAge());// 父类的\n        s.study();\n    &#125;\n&#125;\n\n4.2 继承的原理继承设计规范:\n子类们相同特征（共性属性，共性方法)放在父类中定义，子类独有的的属性和行为应该定义在子类自己里面。\n4.3 继承的特点\n&#x3D;&#x3D;子类可以继承父类的属性和行为，但是子类不能继承父类的构造器。&#x3D;&#x3D;\nJava不支持多继承、但是支持多层继承。Java中所有的类都是Object类的子类。\nJava是单继承模式:一个类只能继承一个直接父类，支持多层继承。\n\n\n\n子类不可以继承父类的构造器，子类有自己的构造器，父类构造器用于初始化父类对象。\n子类可以继承父类的私有成员，只是不能直接访问。\n\n\n\n子类不可以继承父类的静态成员，可以直接使用（共享并非继承）\n\n4.4 继承后的访问在子类方法中访问成员（成员变量、成员方法)满足:就近原则\n\n先子类局部范围找\n然后子类成员范围找\n然后父类成员范围找，如果父类范围还没有找到则报错。\n\n&#x3D;&#x3D;如果子父类中，出现了重名的成员，会优先使用子类的，此时如果一定要在子类中使用父类可以通过super关键字，指定访问父类的成员。&#x3D;&#x3D;\nsuper.父类成员变量/父类成员方法\n\npublic class ExtendsDemo &#123;\n    public static void main(String[] args) &#123;\n        Wolf w = new Wolf();\n        System.out.println(w.name); // 子类的\n        w.showName();\n    &#125;\n&#125;\n\nclass Animal&#123;\n    public String name = &quot;父类动物&quot;;\n&#125;\n\nclass Wolf extends Animal&#123;\n    public String name = &quot;子类动物&quot;;\n\n    public void showName()&#123;\n        String name = &quot;局部名称&quot;;\n        System.out.println(name); // 局部的\n        System.out.println(this.name); // 子类name\n        System.out.println(super.name); // 父类name\n    &#125;\n&#125;\n\n4.5 继承后的方法重写什么是方法重写?\n&#x3D;&#x3D;在继承体系中，子类出现了和父类中一模一样的方法声明，我们就称子类这个方法是重写的方法。&#x3D;&#x3D;\n方法重写的应用场景\n\n当子类需要父类的功能，但父类的该功能不完全满足自己的需求时。\n子类可以重写父类中的方法。\n\nOverride重写注解\n\n&#x3D;&#x3D;@Override是放在重写后的方法上，作为重写是否正确的校验注解。&#x3D;&#x3D;\n加上该注解后如果重写错误，编译阶段会出现错误提示。\n建议重写方法都加@Override注解，代码安全，优雅!\n\n方法重写注意事项和要求\n\n&#x3D;&#x3D;重写方法的名称、形参列表必须与被重写方法的名称和参数列表一致。&#x3D;&#x3D;\n&#x3D;&#x3D;私有方法不能被重写。&#x3D;&#x3D;\n&#x3D;&#x3D;子类重写父类方法时，访问权限必须大于或者等于父类（暂时了解∶缺省&lt;protected &lt; public)&#x3D;&#x3D;\n&#x3D;&#x3D;子类不能重写父类的静态方法，如果重写会报错的。&#x3D;&#x3D;\n\npublic class Phone &#123;\n    public void call()&#123;\n        System.out.println(&quot;打电话开始~~~&quot;);\n    &#125;\n\n    public void sendMessage()&#123;\n        System.out.println(&quot;发送短信开始~~~&quot;);\n    &#125;\n&#125;\n\npublic class NewPhone extends Phone&#123;\n    /**\n      方法重写了\n     */\n    @Override\n    public void call() &#123;\n        super.call();\n        System.out.println(&quot;支持视频通话~~~&quot;);\n    &#125;\n\n    /**\n     方法重写了\n     */\n    @Override\n    public void sendMessage() &#123;\n        super.sendMessage();\n        System.out.println(&quot;支持发送图片和视频~~~&quot;);\n    &#125;\n&#125;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        NewPhone huawei = new NewPhone();\n        huawei.call();\n        huawei.sendMessage();\n    &#125;\n&#125;\n\n4.6 继承后的子类构造器子类继承父类后构造器的特点:\n\n子类中所有的构造器默认都会先访问父类中无参的构造器，再执行自己。\n子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据。\n子类初始化之前，一定要调用父类构造器先完成父类数据空间的初始化。\n\n怎么调用父类构造器的\n\n子类构造器的第一行语句默认都是:super()，不写也存在。\n\n&#x3D;&#x3D;super调用父类有参数构造器的作用:初始化继承自父类的数据。&#x3D;&#x3D;\n如果父类中没有无参数构造器，只有有参构造器，会报错。因为子类默认是调用父类无参构造器的。\n子类构造器中可以通过书写super(.….)，手动调用父类的有参数构造器\n4.7 this、super使用总结&#x3D;&#x3D;this:代表本类对象的引用; super:代表父类存储空间的标识。&#x3D;&#x3D;\n\n\n\n关键字\n访问成员变量\n访问成员方法\n访问构造方法\n\n\n\nthis\nthis.成员变量 访问本类成员变量\nthis.成员方法(…) 访问本类成员方法\nthis(…) 访问本类构造器\n\n\nsuper\nsuper.成员变量 访问父类成员变量\nsuper.成员方法 访问父类成员方法\nsuper(…) 访问父类构造器\n\n\nthis(…)和super(..)使用注意点:\n\n子类通过this (..） 去调用本类的其他构造器，本类其他构造器会通过super去手动调用父类的构造器，最终还是会调用父类构造器的。\nthis(..) super(..)都只能放在构造器的第一行，所以二者不能共存在同一个构造器中。\n\npublic class Student &#123;\n    private String name;\n    private String schoolName;\n\n    public Student() &#123;\n    &#125;\n\n    public Student(String name) &#123;\n        // 借用兄弟构造器！\n        this(name, &quot;河工大&quot;);\n    &#125;\n\n\n    public Student(String name, String schoolName) &#123;\n        this.name = name;\n        this.schoolName = schoolName;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public String getSchoolName() &#123;\n        return schoolName;\n    &#125;\n\n    public void setSchoolName(String schoolName) &#123;\n        this.schoolName = schoolName;\n    &#125;\n&#125;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        Student s1 = new Student(&quot;杰哥&quot;, &quot;南德大学&quot;);\n        System.out.println(s1.getName());\n        System.out.println(s1.getSchoolName());\n\n\n        Student s2 = new Student(&quot;阿伟&quot;);\n        System.out.println(s2.getName());\n        System.out.println(s2.getSchoolName());\n    &#125;\n&#125;\n\n\n","slug":"Java程序设计 -- 面向对象进阶(上)（七）","date":"2022-03-20T01:40:03.000Z","categories_index":"后端","tags_index":"Java","author_index":"会思想的苇草i"},{"id":"43ba7a87029e6d08249bdb5a925cb91f","title":"Java程序设计--面向对象基础（六）","content":"\n1、类、对象对象:是真实存在的具体实例。\n类(设计图):是对象共同特征的描述。\n\n定义类\npublic class 类名&#123;\n    1、成员变量(代表属性)\n    2、成员方法(代表行为)\n    3、构造器\n    4、代码块\n    5、内部类\n&#125;\n\n得到类的对象\n类名 对象名 = new 类名();\n\nCar c = new Car();\n\n使用对象\n访问属性：&#x3D;&#x3D;对象名.成员变量&#x3D;&#x3D;\n访问行为：&#x3D;&#x3D;对象名.方法名(…)&#x3D;&#x3D;\n定义类的注意事项\n\n成员变量的完整定义格式是∶修饰符数据类型变量名称&#x3D;初始化值;一般无需指定初始化值，存在默认值。\n类名首字母建议大写，且有意义，满足“驼峰模式”。\n一个Java文件中可以定义多个class类，且只能一个类是public修饰，而且public修饰的类名必须成为代码文件名。实际开发中建议还是一个文件定义一个class类。\n\n&#x3D;&#x3D;对象的成员变量的默认规则&#x3D;&#x3D;\n\n\n\n数据类型\n明细\n默认值\n\n\n\n基本类型\nbyte、short、char、int、long\n0\n\n\n基本类型\nfloa、double\n0.0\n\n\n基本类型\nboolean\nfalse\n\n\n引用类型\n类、接口、数组、String\nnull\n\n\n\n2、Java对象内存图多个对象的内存图\n\n\n&#x3D;&#x3D;对象放在堆内存中&#x3D;&#x3D;\n&#x3D;&#x3D;对象变量在内存的栈内存中，其中存储的是对象在堆内存中的地址&#x3D;&#x3D;\n&#x3D;&#x3D;成员变量的数据放在对象中，存在于堆内存中&#x3D;&#x3D;\n\n两个变量指向同一个对象内存图\n垃圾回收\n注意:当堆内存中的类对象或数组对象，没有被任何变量引用（指向）时，就会被判定为内存中的“垃圾”。\nJava存在自动垃圾回收器，会定期进行清理。\n\n3、构造器用于初始化一个类的对象，并返回对象的地址。\n构造器的定义格式\n修饰符 类名(形参列表)&#123;\n    ...\n&#125;\n\n构造器的分类\n\n**无参数构造器（默认存在的)**︰初始化的对象时，成员变量的数据均采用默认值。\n有参数构造器：在初始化对象的时候，同时可以为对象进行赋值。\n\npublic class Car &#123;\n    String name;\n    double price;\n\n    /**\n      无参数构造器(默认存在的)\n     */\n    public Car()&#123;\n        System.out.println(&quot;无参数构造器被触发执行~~~&quot;);\n    &#125;\n\n    /**\n       有参数构造器\n     */\n    public Car(String n, double p)&#123;\n        System.out.println(&quot;有参数构造器被触发执行~~~&quot;);\n        name = n;\n        price = p;\n    &#125;\n&#125;\n\npublic class ConstructorDemo &#123;\n    public static void main(String[] args) &#123;\n        Car c = new Car();\n//        c.name = &quot;&quot;;\n//        c.price\n        System.out.println(c.name);//null\n        System.out.println(c.price);//0.0\n\n        Car c2 = new Car(&quot;奔驰GLC&quot;, 39.78);\n        System.out.println(c2.name);//奔驰GLC\n        System.out.println(c2.price);//39.78\n    &#125;\n&#125;\n\n注意事项\n\n&#x3D;&#x3D;任何类定义出来，默认就自带了无参数构造器，写不写都有。&#x3D;&#x3D;\n&#x3D;&#x3D;一旦定义了有参数构造器，无参数构造器就没有了，此时就需要自己写一个无参数构造器了。&#x3D;&#x3D;\n\n\n4、this关键字this关键字可以出现在成员方法、构造器中，&#x3D;&#x3D;代表当前对象的地址&#x3D;&#x3D;。\n作用:&#x3D;&#x3D;访问当前对象的成员变量、成员方法。&#x3D;&#x3D;\npublic class Car &#123;\n    String name;\n    double price;\n\n    public void goWith(String name)&#123;\n        System.out.println(this.name +&quot;正在和：&quot; + name +&quot;比赛！&quot;);\n    &#125;\n\n    /**\n      无参数构造器(默认存在的)\n     */\n    public Car()&#123;\n        System.out.println(&quot;无参数构造器被触发执行~~~&quot;);\n    &#125;\n\n    /**\n       有参数构造器\n     */\n    public Car(String name, double price)&#123;\n        System.out.println(&quot;有参数构造器被触发执行~~~&quot;);\n        System.out.println(this);\n        this.name = name;\n        this.price = price;\n    &#125;\n&#125;\n\npublic class ThisDemo &#123;\n    public static void main(String[] args) &#123;\n        Car c = new Car(&quot;宝马X3&quot;, 37.89);\n        System.out.println(c);\n        System.out.println(c.name);\n        System.out.println(c.price);\n\n        c.goWith(&quot;奔驰GLC&quot;);\n    &#125;\n&#125;\n\n\n5、面向对象特征–封装面向对象的三大特征：&#x3D;&#x3D;封装、继承、多态&#x3D;&#x3D;\n封装的实现步骤\n\n&#x3D;&#x3D;一般对成员变量使用private(私有)关键字修饰进行隐藏，private修饰后该成员变量就只能在当前类中访问。&#x3D;&#x3D;\n&#x3D;&#x3D;提供public修饰的公开的getter、setter方法暴露其取值和赋值。&#x3D;&#x3D;\n\npublic class Student &#123;\n    // private私有的成员变量，只能在本类访问。\n   private int age;\n\n   public int getAge()&#123;\n       return age;\n   &#125;\n\n   public void setAge(int age)&#123;\n        if(age &gt;= 0 &amp;&amp; age &lt;= 200)&#123;\n            this.age = age;\n        &#125;else &#123;\n            System.out.println(&quot;年龄数据有问题，应该不是人的年龄！&quot;);\n        &#125;\n   &#125;\n&#125;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        Student s = new Student();\n        // s.age = -23;\n        s.setAge(-23);\n        System.out.println(s.getAge());\n    &#125;\n&#125;\n\n封装的好处小结\n\n加强了程序代码的安全性。\n适当的封装可以提升开发效率，同时可以让程序更容易理解与维护。\n\n\n6、标准JavaBean也可以理解为实体类\n标准JavaBean须满足如下要求:\n\n成员变量使用private修饰。\n提供每一个成员变量对应的setXxx() &#x2F; getXxx()。\n必须提供一个无参构造器。\n\npublic class User &#123;\n    private double height;\n    private String name;\n    private double salary;\n    private String address;\n    private String phone;\n\n    public User() &#123;\n    &#125;\n\n    public User(double height, String name, double salary, String address, String phone) &#123;\n        this.height = height;\n        this.name = name;\n        this.salary = salary;\n        this.address = address;\n        this.phone = phone;\n    &#125;\n\n    public double getHeight() &#123;\n        return height;\n    &#125;\n\n    public void setHeight(double height) &#123;\n        this.height = height;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public double getSalary() &#123;\n        return salary;\n    &#125;\n\n    public void setSalary(double salary) &#123;\n        this.salary = salary;\n    &#125;\n\n    public String getAddress() &#123;\n        return address;\n    &#125;\n\n    public void setAddress(String address) &#123;\n        this.address = address;\n    &#125;\n\n    public String getPhone() &#123;\n        return phone;\n    &#125;\n\n    public void setPhone(String phone) &#123;\n        this.phone = phone;\n    &#125;\n&#125;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        User user = new User();\n        user.setName(&quot;二狗&quot;);\n        user.setHeight(163);\n        user.setSalary(50000);\n        user.setAddress(&quot;中国&quot;);\n        user.setPhone(&quot;13141314520&quot;);\n//        String name = user.getName();\n//        System.out.println(name);\n        System.out.println(user.getName());\n        System.out.println(user.getHeight());\n        System.out.println(user.getSalary());\n        System.out.println(user.getAddress());\n        System.out.println(user.getPhone());\n        &#125;\n&#125;\n\n\n8、成员变量、局部变量区别\n\n\n区别\n成员变量\n局部变量\n\n\n\n类中位置不同\n类中，方法外\n常见于方法中\n\n\n初始化值不同\n&#x3D;&#x3D;有默认初始化值&#x3D;&#x3D;\n&#x3D;&#x3D;没有，使用之前需要完成赋值&#x3D;&#x3D;\n\n\n内存位置不同\n&#x3D;&#x3D;堆内存&#x3D;&#x3D;\n&#x3D;&#x3D;栈内存&#x3D;&#x3D;\n\n\n生命周期不同\n随着对象的创建而存在，随着对象的消失而消失\n随着方法的调用而存在，随着方法的运行结束而消失\n\n\n作用域\n\n在所属的大括号中\n\n\n\n","slug":"Java程序设计 -- 面向对象基础（六）","date":"2022-03-19T14:24:11.000Z","categories_index":"后端","tags_index":"Java","author_index":"会思想的苇草i"},{"id":"e865c90ea90eb26ac07b0e4b3b7fa410","title":"Java程序设计--方法","content":"\n1、方法定义、调用方法完整的定义形式、应用\n方法定义的完整格式\n修饰符 返回值类型 方法名(形参表)&#123;\n    方法体代码(需要执行的功能代码)\n    return 返回值;\n&#125;\n\n方法的调用格式\n方法名(...)\n\n方法格式的注意点\n\n&#x3D;&#x3D;方法的修饰符:暂时都使用public static修饰。&#x3D;&#x3D;\n&#x3D;&#x3D;方法申明了具体的返回值类型，内部必须使用return返回对应类型的数据。&#x3D;&#x3D;\n&#x3D;&#x3D;形参列表可以有多个，甚至可以没有;如果有多个形参，多个形参必须用“，”隔开，且不能给初始化值。&#x3D;&#x3D;\n\n方法其他的定义形式、应用\n方法的其他写法\n方法定义时：返回值类型、形参列表可以按照需求进行填写\n修饰符 返回值类型 方法名(形参列表)\n\n注意事项\n\n&#x3D;&#x3D;如果方法不需要返回结果，返回值类型必须申明成void (无返回值)，此时方法内部不可以使用return返回数据。&#x3D;&#x3D;\n&#x3D;&#x3D;方法如果没有参数，或者返回值类型申明为void可以称为无参数、无返回值的方法，依次类推。&#x3D;&#x3D;\n\n\n2、方法使用的常见问题方法常见问题\n\n方法的编写顺序无所谓。\n方法与方法之间是平级关系，不能嵌套定义\n方法的返回值类型为void(无返回值)，方法内则不能使用return返回数据，如果方法的返回值类型写了具体类型，方法内部则必须使用return返回对应类型的数据。\nreturn语句下面，不能编写代码，因为永远执行不到,属于无效的代码。\n方法不调用就不执行，调用时必须严格匹配方法的参数情兄。\n有返回值的方法调用时可以选择定义变量接收结果，或者直接输出调用，甚至直接调用;无返回值方法的调用只能直接调用。\n\n\n3、方法案例计算1–n的和返回\n需求:定义一个方法，方法中计算出1–n的和并返回。\npublic class Test1 &#123;\n    public static void main(String[] args) &#123;\n        // 需求：使用方法计算1-n的和并返回\n        System.out.println(&quot;1-5的和是：&quot; + sum(5));\n        System.out.println(&quot;--------------------&quot;);\n        System.out.println(&quot;1-100的和是：&quot; + sum(100));\n    &#125;\n\n    public static int sum(int n)&#123;\n        int sum = 0;\n        for (int i = 1; i &lt;= n ; i++) &#123;\n            sum += i;\n        &#125;\n        return sum;\n    &#125;\n&#125;\n\n判断奇偶数\n需求:拿一个整数，然后调用方法，把整数交给方法，在方法中输出该数为奇数还是偶数\npublic class Test2 &#123;\n    public static void main(String[] args) &#123;\n        // 需求：判断一个整数是奇数还是偶数 并进行结果的输出 使用方法完成\n        check(11);\n        System.out.println(&quot;-------------&quot;);\n        check(100);\n    &#125;\n\n    public static void check(int number) &#123;\n        if(number % 2 == 0)&#123;\n            System.out.println(number + &quot;是偶数&quot;);\n        &#125;else &#123;\n            System.out.println(number + &quot;是奇数&quot;);\n        &#125;\n    &#125;\n&#125;\n\n数组求最值\n需求：把找出数组的最大值案例，改造成方法，可以支持返回任意整型数组的最大值数据。\npublic class Test3 &#123;\n    public static void main(String[] args) &#123;\n        // 需求：使用方法，支持找出任意整型数组的最大值返回。\n        int[] ages = &#123;23, 19, 25, 78, 34&#125;;\n        int max = getArrayMaxData(ages);\n        System.out.println(&quot;最大值数据是：&quot; + max);\n\n        System.out.println(&quot;-------------------&quot;);\n        int[] ages1 = &#123;31, 21, 99, 78, 34&#125;;\n        int max1 = getArrayMaxData(ages1);\n        System.out.println(&quot;最大值数据是：&quot; + max1);\n    &#125;\n\n    public static int getArrayMaxData(int[] arr)&#123;\n        // 找出数组的最大值返回\n        int max = arr[0];\n        // 遍历数组的每个元素与最大值的数据进行比较，若较大则替换\n        for (int i = 1; i &lt; arr.length; i++) &#123;\n            if(arr[i] &gt; max)&#123;\n                max = arr[i];\n            &#125;\n        &#125;\n        return max;\n    &#125;\n&#125;\n\n\n4、方法调用的内存图\n方法没有被调用的时候，在方法区中的字节码文件中存放\n方法被调用的时候，需要进入到栈内存中运行\n\n\n\n\n5、方法的参数传递&#x3D;&#x3D;Java的参数传递机制:值传递&#x3D;&#x3D;\n在传输实参给方法的形参的时候，并不是传输实参变量本身，而是传输实参变量中存储的值，这就是值传递。\n基本类型和引用类型的参数在传递的时候的不同\n\n&#x3D;&#x3D;都是值传递。&#x3D;&#x3D;\n&#x3D;&#x3D;基本类型的参数传输存储的数据值。引用类型的参数传输存储的地址值。&#x3D;&#x3D;\n\n案例\n打印数组内容\n设计一个方法用于输出任意整型数组的内容\npublic class MethodTest1 &#123;\n    public static void main(String[] args) &#123;\n        // 需求：定义方法，可以打印任意整型数组的内容：[12, 32, 23]\n        // 4、定义数组，再调用方法\n        int[] arr = &#123;12, 32, 23&#125;;\n        printArray(arr);\n\n        System.out.println(&quot;-----------------&quot;);\n        int[] arr2 = &#123;&#125;;\n        printArray(arr2);\n\n        System.out.println(&quot;-----------------&quot;);\n        int[] arr3 = null;\n        printArray(arr3);\n    &#125;\n\n    /**\n        1、定义一个方法：参数：整型数组类型的变量  返回值类型申明：void\n     */\n    public static void printArray(int[] arr)&#123;\n        if(arr != null)&#123;\n            // 2、把数组内容打印出来。\n            System.out.print(&quot;[&quot;);\n            // 3、开始遍历数组中的每个数据\n            for (int i = 0; i &lt; arr.length; i++) &#123;\n                // 如果发现是最后一个元素不加逗号\n//            if(i == arr.length - 1)&#123;\n//                System.out.print(arr[i]);\n//            &#125;else &#123;\n//                System.out.print(arr[i] + &quot;, &quot;);\n//            &#125;\n                System.out.print(i == arr.length - 1 ? arr[i] : arr[i] + &quot;, &quot;);\n            &#125;\n            System.out.println(&quot;]&quot;);\n        &#125;else &#123;\n            System.out.println(&quot;当前数组对象不存在，其地址是：null&quot;);\n        &#125;\n    &#125;\n\n    \n&#125;\n\n从数组中查询元素的索引返回\n需求：设计一个方法可以接收整型数组，和要查询的元素值;最终要返回元素在该数组中的索引，如果数组中不存在该元素则返回-1。\npublic class MethodTest2 &#123;\n    public static void main(String[] args) &#123;\n        // 需求：从整型数组中查询某个数据的索引返回，不存在该数据返回-1\n        // 3、定义数组，调用方法\n        int[] arr = &#123;11, 22, 33, 66, 87, 19&#125;;\n        int index = searchIndex(arr, 17);\n        System.out.println(&quot;您查询的数据的索引是：&quot; + index);\n    &#125;\n\n    /**\n       1、定义一个方法：参数接收数组，要查询的数据，返回值：整型\n     */\n    public static int searchIndex(int[] arr, int data)&#123;\n        // 2、开始找出这个数据的索引\n        for (int i = 0; i &lt; arr.length; i++) &#123;\n            if(arr[i] == data)&#123;\n                return i;\n            &#125;\n        &#125;\n        return -1; // 查无此元素！\n    &#125;\n&#125;\n\n比较两个数组内容是否相等\n需求：如果两个数组的类型，元素个数，元素顺序和内容是一样的我们就认为这2个数组是一模一样的。\npublic class MethodTest3 &#123;\n    public static void main(String[] args) &#123;\n        // 需求：比较任意2个整型数组的内容是否一样，一样返回true 反之\n        int[] arr1 = &#123;10, 20, 30&#125;;\n        int[] arr2 = &#123;10, 20, 30&#125;;\n        System.out.println(compare(arr1, arr2));\n\n        System.out.println(&quot;-------------------&quot;);\n        int[] arr3 = null;\n        int[] arr4 = &#123;&#125;;\n        System.out.println(compare(arr3, arr4));\n    &#125;\n\n    /**\n        1、定义一个方法：参数：接收2个整型数组，返回值类型：布尔类型\n     */\n    public static boolean compare(int[] arr1, int[] arr2)&#123;\n        if(arr1 != null &amp;&amp; arr2 != null)&#123;\n            // 2、判断2个数组的内容是一样的呢\n            if(arr1.length == arr2.length)&#123;\n                for (int i = 0; i &lt; arr1.length; i++) &#123;\n                    if(arr1[i] != arr2[i])&#123;\n                        return false;\n                    &#125;\n                &#125;\n                return true; // 是一样的！\n            &#125;else &#123;\n                return false;\n            &#125;\n        &#125;else &#123;\n            return false;\n        &#125;\n    &#125;\n&#125;\n\n\n6、方法重载&#x3D;&#x3D;同一个类中，出现多个方法名称相同，但是形参列表是不同的，那么这些方法就是重载方法。&#x3D;&#x3D;\npublic class MethodDemo1 &#123;\n    public static void main(String[] args) &#123;\n        // 目标：识别方法重载的形式。并理解其调用流程，最后需要知道使用方法重载的好处。\n        fire();\n        fire(&quot;B国&quot;);\n        fire(&quot;B国&quot;, 1000);\n    &#125;\n\n    public static void fire()&#123;\n        fire(&quot;A国&quot;);\n    &#125;\n\n    public static void fire(String location)&#123;\n        fire(location, 1);\n    &#125;\n\n    public static void fire(String location, int number)&#123;\n        System.out.println(&quot;默认发射&quot;+number+&quot;枚武器给&quot;+location+&quot;~~~&quot;);\n    &#125;\n&#125;\n\n\n7、return关键字&#x3D;&#x3D;return; —&gt;可以立即跳出并结束当前方法的执行;return关键字单独使用可以放在任何方法中。&#x3D;&#x3D;\npublic class ReturnDemo &#123;\n    public static void main(String[] args) &#123;\n        // 目标：明确return关键字的作用。\n        System.out.println(&quot;main开始。。&quot;);\n        chu(10 , 0);\n        System.out.println(&quot;main结束。。&quot;);\n    &#125;\n\n    public static void chu(int a, int b)&#123;\n        if(b == 0)&#123;\n            System.out.println(&quot;您输入的数据有问题，除数不能是0！！&quot;);\n            return; // 立即跳出当前方法，并结束当前方法的执行。\n        &#125;\n\n        int c = a / b;\n        System.out.println(&quot;结果是：&quot; + c);\n    &#125;\n&#125;\n\n\n\n\n关键字\n作用\n\n\n\nreturn\n跳出并立即结束所在方法的执行\n\n\nbreak\n跳出并结束当前所在循环的执行\n\n\ncontinue\n结束当前所在循环的当次继续，进入下一次执行\n\n\n\n","slug":"Java程序设计 -- 方法（五）","date":"2022-03-19T14:05:28.000Z","categories_index":"后端","tags_index":"Java","author_index":"会思想的苇草i"},{"id":"68e93659b0f140c2b8d62ff1a84702c9","title":"Java程序设计--数组","content":"\n1、数组的定义1.1 什么是数组数组就是用来存储一批&#x3D;&#x3D;同种类型数据&#x3D;&#x3D;的&#x3D;&#x3D;内存区域&#x3D;&#x3D;(可以理解成容器)。\n\n1.2 数组定义格式第一种\n​\t&#x3D;&#x3D;数据类型[]  数组名&#x3D;&#x3D;\n​\t示例：\nint[] arr;        \ndouble[] arr;      \nchar[] arr;\n\n第二种\n​\t&#x3D;&#x3D;数据类型 数组名[]&#x3D;&#x3D;\n​\t示例：\nint arr[];\ndouble arr[];\nchar arr[];\n\n1.3 静态化初始化数组定义数组的时候直接给数组赋值\n静态初始化格式\n\n完整版格式\n数据类型[] 数组名 = new 数据类型[] &#123;元素1,元素2,...&#125;;\n\n\n简化版格式\n数据类型[] 数组名 = &#123;元素1,元素2,...&#125;;\n\n\n\n示例代码：\npublic class ArrayDemo &#123;\n    public static void main(String[] args) &#123;\n        //定义数组\n        int[] arr = &#123;1, 2, 3&#125;;\n\n        //输出数组名\n        System.out.println(arr);\n\n        //输出数组中的元素\n        System.out.println(arr[0]);\n        System.out.println(arr[1]);\n        System.out.println(arr[2]);\n    &#125;\n&#125;\n\n&#x3D;&#x3D;数组变量名中存储的是数组在内存中的地址，数组是引用类型。&#x3D;&#x3D;\n数组元素访问\n\n每一个存储到数组的元素，都会自动的拥有一个编号，从0开始。\n​\t这个自动编号称为数组索引(index)，可以通过数组的索引访问到数组中的元素。\n数组的最大索引可以表示为：数组名.length - 1（前提是元素个数大于0）\n\n访问数组元素格式\n数组名[索引];\n\n示例代码：\npublic class ArrayDemo &#123;\n    public static void main(String[] args) &#123;\n        int[] arr = new int[3];\n\n        //输出数组名\n        System.out.println(arr); //[I@880ec60\n\n        //输出数组中的元素\n        System.out.println(arr[0]);\n        System.out.println(arr[1]);\n        System.out.println(arr[2]);\n    &#125;\n&#125;\n\n数组的几个注意事项：\n\n&#x3D;&#x3D;“数据类型[] 数组名”也可以写成“数据类型 数组名[]”&#x3D;&#x3D;。\n&#x3D;&#x3D;什么类型的数组存放什么类型的数据，否则报错&#x3D;&#x3D;。\n&#x3D;&#x3D;数组一旦定义出来，程序执行的过程中，长度、类型就固定了&#x3D;&#x3D; 。\n\n1.4 数组动态初始化定义数组的时候只确定元素的类型和数组的长度，之后再存入具体数据。\n动态初始化格式\n数据类型[] 数组名 = new 数据类型[数组长度];\n\nint[] arr = new int[3];\n\n动态初始化数组的元素默认值\n元素默认值\n\n\n\n数据类型\n明细\n默认值\n\n\n\n基本类型\nbyte、short、char、int、long\n0\n\n\n基本类型\nfloat、double\n0.0\n\n\n基本类型\nboolean\nfalse\n\n\n引用类型\n类、接口、数组、String\nnull\n\n\n\n2、数组的遍历遍历就是一个一个数据的访问。\npublic class ArrayDemo &#123;\n    public static void main(String[] args) &#123;\n        // 目标：学会进行数组元素的遍历\n        int[] arr = &#123;12, 24, 12, 48, 98&#125;;\n        //           0    1   2   3   4\n\n        // 原始遍历方式\n//        System.out.println(arr[0]);\n//        System.out.println(arr[1]);\n//        System.out.println(arr[2]);\n//        System.out.println(arr[3]);\n//        System.out.println(arr[4]);\n\n//        for (int i = 0; i &lt; 5; i++) &#123;\n//            System.out.println(arr[i]);\n//        &#125;\n\n        // 终极数组遍历形式\n        for (int i = 0; i &lt; arr.length; i++) &#123;\n            System.out.println(arr[i]);\n        &#125;\n    &#125;\n&#125;\n\n\n3、数组的案例数组元素求和\n需求:某部门5名员工的销售额分别是: 16、26、36、6、100，请计算出他们部门的总销售额。\npublic class Test1 &#123;\n    public static void main(String[] args) &#123;\n        // 需求：数组元素求和\n        // 1、把这些数据拿到程序中使用数组记住\n        int[] money = &#123;16, 32, 8, 100, 78&#125;;\n\n        // 3、定义一个求和变量累加数组的元素值\n        int sum = 0;\n\n        // 2、遍历数组中的每个元素\n        for (int i = 0; i &lt; money.length; i++) &#123;\n            // 拿到每个元素值累加\n            sum += money[i];\n        &#125;\n\n        // 4、输出求和变量即可\n        System.out.println(&quot;数组的元素和是：&quot; + sum);\n    &#125;\n&#125;\n\n数组求最值\n\npublic class Test2 &#123;\n    public static void main(String[] args) &#123;\n        // 需求：数组元素求最值。\n\n        // 1、定义一个静态初始化的数组，存储一批颜值。\n        int[] faceScore = &#123;15, 9000, 10000, 20000, 9500, -5&#125;;\n        //                 0    1      2     3      4    5\n\n        // 2、定义一个变量用于存储最大值元素，建议使用第一个元素作为参照。\n        int max = faceScore[0];\n\n        // 3、遍历数组的每个元素，依次与最大值变量的数据比较，若较大，则替换。\n        for (int i = 1; i &lt; faceScore.length; i++) &#123;\n            if(faceScore[i] &gt; max)&#123;\n                max = faceScore[i];\n            &#125;\n        &#125;\n\n        // 4、输出最大值变量存储的数据即可。\n        System.out.println(&quot;数组的最大值是：&quot; + max);\n    &#125;\n&#125;\n\n猜数字游戏\n开发一个幸运小游戏，游戏规则如下:游戏后台随机生成1-20之间的5个数（无所谓是否重复)，然后让大家来猜数字:\n\n未猜中提示:“未命中”，并继续猜测\n猜中提示:“运气不错，猜中了”，并输出该数据第一次出现的位置，且输出全部5个数据，\n\n最终结束本游戏。\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class Test3 &#123;\n    public static void main(String[] args) &#123;\n        // 需求：5个 1-20之间的随机数，让用户猜测，猜中要提示猜中，还要输出该数据在数组中第一次出现的索引，并打印数组的内容出来。\n        // 没有猜中继续。\n\n        // 1、定义一个动态初始化的数组存储5个随机的1-20之间的数据\n        int[] data = new int[5];\n\n        // 2、动态的生成5个1-20之间的随机数并存入到数组中去。\n        Random r = new Random();\n        for (int i = 0; i &lt; data.length; i++) &#123;\n            // i = 0 1 2 3 4\n            data[i] = r.nextInt(20) + 1;\n        &#125;\n\n        // 3、使用一个死循环让用户进行猜测\n        Scanner sc = new Scanner(System.in);\n        OUT:\n        while (true) &#123;\n            System.out.println(&quot;请您输入一个1-20之间的整数进行猜测：&quot;);\n            int guessData = sc.nextInt();\n\n            // 4、遍历数组中的每个数据，看是否有数据与猜测的数据相同，相同代表猜中了，给出提示\n            for (int i = 0; i &lt; data.length; i++) &#123;\n                if(data[i] == guessData)&#123;\n                    System.out.println(&quot;您已经猜中了该数据，运气不错了！您猜中的数据索引是：&quot; + i);\n                    break OUT; // 结束了整个死循环，代表游戏结束了！\n                &#125;\n            &#125;\n            System.out.println(&quot;当前猜测的数据在数组中不存在，请重新猜测！&quot;);\n        &#125;\n\n        // 5、输出数组的全部元素，让用户看到自己确实是猜中了某个数据。\n        for (int i = 0; i &lt; data.length; i++) &#123;\n            System.out.print(data[i] + &quot;\\t&quot;);\n        &#125;\n    &#125;\n&#125;\n\n随机排名\n某公司开发部5名开发人员，要进行项目进展汇报演讲，现在采取随机排名后进行汇报。请先依次录入5名员工的工号，然后展示出一组随机的排名顺序。\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class Test4 &#123;\n    public static void main(String[] args) &#123;\n        // 目标：键盘录入一组工号，最终要随机输出一组出来作为排名\n        // 1、动态初始化一个数组，存储5个工号\n        int[] codes = new int[5];\n\n        // 2、定义一个循环，循环5次，依次录入一个工号存入对应的位置\n        Scanner sc = new Scanner(System.in);\n        for (int i = 0; i &lt; codes.length; i++) &#123;\n            // 正式录入工号\n            System.out.println(&quot;请您输入第&quot; + (i + 1) + &quot;个员工的工号：&quot;);\n            int code = sc.nextInt();\n            // 存入到数组中去\n            codes[i] = code;\n        &#125;\n\n        // 3、遍历数组中的每个元素，然后随机一个索引出来，让该元素与随机索引位置处的元素值进行交换（本节的重点）\n        // codes = [12, 36, 28, 45, 99]\n        Random r = new Random();\n        for (int i = 0; i &lt; codes.length; i++) &#123;\n            // 当前遍历的元素值：codes[i]\n            // 随机一个索引位置出来：codes[index]\n            int index = r.nextInt(codes.length);\n\n            // 定义一个临时变量存储index位置处的值\n            int temp = codes[index];\n            codes[index] = codes[i];\n            codes[i] = temp;\n        &#125;\n\n        // 4、遍历数组元素输出就是随机排名的结果\n        for (int i = 0; i &lt; codes.length; i++) &#123;\n            System.out.print(codes[i] + &quot;\\t&quot;);\n        &#125;\n    &#125;\n&#125;\n\n数组排序\npublic class Test5 &#123;\n    public static void main(String[] args) &#123;\n        // 1、定义一个数组，存储一些数据啊\n        int[] arr = &#123;5, 2, 3, 1&#125;;\n        //           0  1  2  3\n\n        // 2、定义一个循环控制比较的轮数\n        for (int i = 0; i &lt; arr.length - 1; i++) &#123;\n            // i == 0  比较的次数 3  j = 0 1 2\n            // i == 1  比较的次数 2  j = 0 1\n            // i == 2  比较的次数 1  j = 0\n            // 3、定义一个循环控制每轮比较的次数，占位\n            for (int j = 0; j &lt; arr.length - i - 1; j++) &#123;\n                // 判断j当前位置的元素值 是否 大于后一个位置 若较大 则交换\n                if(arr[j] &gt; arr[j+1]) &#123;\n                    int temp = arr[j+1];\n                    arr[j+1] = arr[j];\n                    arr[j] = temp;\n                &#125;\n            &#125;\n        &#125;\n\n        // 遍历数组内容输出\n        for (int i = 0; i &lt; arr.length; i++) &#123;\n            System.out.print(arr[i] + &quot;\\t&quot;);\n        &#125;\n    &#125;\n&#125;\n\n\n4、数组的内存图4.1 内存概述​\t内存是计算机中的重要原件，临时存储区域，作用是运行程序。\n​\t我们编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的。\n​\t必须放进内存中才能运行，运行完毕后会清空内存。 \n​\tJava虚拟机要运行程序，必须要对内存进行空间的分配和管理。 \n4.2 java中的内存分配\n目前我们只需要记住两个内存，分别是：栈内存和堆内存\n\n\n\n\n区域名称\n作用\n\n\n\n寄存器\n给CPU使用，和我们开发无关。\n\n\n本地方法栈\nJVM在使用操作系统功能的时候使用，和我们开发无关。\n\n\n方法区\n存储可以运行的class文件。\n\n\n堆内存\n存储对象或者数组，new来创建的，都存储在堆内存。\n\n\n方法栈\n方法运行时使用的内存，比如main方法运行，进入方法栈中执行。\n\n\njava内存分配、数组内存图\n\n两个数组变量指向同一个数组对象\n\n\n5、数组使用的常见问题5.1 索引越界异常出现原因\npublic class ArrayDemo &#123;\n    public static void main(String[] args) &#123;\n        int[] arr = new int[3];\n        System.out.println(arr[3]);\n    &#125;\n&#125;\n\n  数组长度为3，索引范围是0~2，但是我们却访问了一个3的索引。\n  程序运行后，将会抛出ArrayIndexOutOfBoundsException 数组越界异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。 \n\n解决方案\n将错误的索引修改为正确的索引范围即可！\n\n\n5.2 空指针异常出现原因\npublic class ArrayDemo &#123;\n    public static void main(String[] args) &#123;\n        int[] arr = new int[3];\n\n        //把null赋值给数组\n        arr = null;\n        System.out.println(arr[0]);\n    &#125;\n&#125;\n\n  arr &#x3D; null 这行代码，意味着变量arr将不会再保存数组的内存地址，也就不允许再操作数组了，因此运行的时候会抛出 NullPointerException 空指针异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。\n\n解决方案\n给数组一个真正的堆内存空间引用即可！\n\n\n\n6、Debug工具的使用Debug工具\nIDEA自带的断点调试(排错)工具，可以控制代码从断点开始一行一行的执行，然后详细观看程序执行的情况。\n\n","slug":"Java程序设计 -- 数组（四）","date":"2022-03-18T15:10:42.000Z","categories_index":"后端","tags_index":"Java","author_index":"会思想的苇草i"},{"id":"6d1d4ce6ed78a6b43fb777ff72a43b22","title":"Java程序设计--程序流程控制","content":"\n1、流程控制语句在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。所以，我们必须清楚每条语句的执行流程。而且，很多时候要通过控制语句的执行顺序来实现我们想要的功能。\n流程控制语句分类\n\n​\t顺序结构\n​\t分支结构(if, switch)\n​\t循环结构(for, while, do…while)\n\n\n2、顺序结构顺序结构是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。\n顺序结构执行流程图：\n\n\n3、分支结构3.1 if语句格式1格式：\nif (关系表达式) &#123;\n    语句体;\t\n&#125;\n\n执行流程：\n\n首先计算关系表达式的值\n如果关系表达式的值为true就执行语句体\n如果关系表达式的值为false就不执行语句体\n继续执行后面的语句内容\n\n\n示例：判断相等\npublic class IfDemo &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(&quot;开始&quot;);\t\n        //定义两个变量\n        int a = 10;\n        int b = 20;\t\n        //需求：判断a和b的值是否相等，如果相等，就在控制台输出：a等于b\n        if(a == b) &#123;\n            System.out.println(&quot;a等于b&quot;);\n        &#125;\t\t\n        //需求：判断a和c的值是否相等，如果相等，就在控制台输出：a等于c\n        int c = 10;\n        if(a == c) &#123;\n            System.out.println(&quot;a等于c&quot;);\n        &#125;\t\t\n        System.out.println(&quot;结束&quot;);\n    &#125;\n&#125;\n\n3.2 if语句格式2格式：\nif (关系表达式) &#123;\n    语句体1;\t\n&#125; else &#123;\n    语句体2;\t\n&#125;\n\n执行流程：\n\n首先计算关系表达式的值\n如果关系表达式的值为true就执行语句体1\n如果关系表达式的值为false就执行语句体2\n继续执行后面的语句内容\n\n\n示例：比较大小\npublic class IfDemo02 &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(&quot;开始&quot;);\t\t\n        //定义两个变量\n        int a = 10;\n        int b = 20;\n        b = 5;\t\n        //需求：判断a是否大于b，如果是，在控制台输出：a的值大于b，否则，在控制台输出：a的值不大于b\n        if(a &gt; b) &#123;\n            System.out.println(&quot;a的值大于b&quot;);\n        &#125; else &#123;\n            System.out.println(&quot;a的值不大于b&quot;);\n        &#125;\t\t\n        System.out.println(&quot;结束&quot;);\n    &#125;\n&#125;\n\n3.3 if语句格式3格式：\nif (关系表达式1) &#123;\n    语句体1;\t\n&#125; else if (关系表达式2) &#123;\n    语句体2;\t\n&#125; \n…\nelse &#123;\n    语句体n+1;\n&#125;\n\n执行流程：\n\n首先计算关系表达式1的值\n如果值为true就执行语句体1；如果值为false就计算关系表达式2的值\n如果值为true就执行语句体2；如果值为false就计算关系表达式3的值\n…\n如果没有任何关系表达式为true，就执行语句体n+1。\n\n\n示例：键盘录入一个星期数(1,2,…7)，输出对应的星期一，星期二，…星期日。\nimport java.util.Scanner;\npublic class IfDemo03 &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(&quot;开始&quot;);\n        // 需求：键盘录入一个星期数(1,2,...7)，输出对应的星期一，星期二，...星期日\n        Scanner sc = new Scanner(System.in);\n        System.out.println(&quot;请输入一个星期数(1-7)：&quot;);\n        int week = sc.nextInt();\n        if(week == 1) &#123;\n            System.out.println(&quot;星期一&quot;);\n        &#125; else if(week == 2) &#123;\n            System.out.println(&quot;星期二&quot;);\n        &#125; else if(week == 3) &#123;\n            System.out.println(&quot;星期三&quot;);\n        &#125; else if(week == 4) &#123;\n            System.out.println(&quot;星期四&quot;);\n        &#125; else if(week == 5) &#123;\n            System.out.println(&quot;星期五&quot;);\n        &#125; else if(week == 6) &#123;\n            System.out.println(&quot;星期六&quot;);\n        &#125; else &#123;\n            System.out.println(&quot;星期日&quot;);\n        &#125;\t\n        System.out.println(&quot;结束&quot;);\n    &#125;\n&#125;\n\n3.4 分支结构：switch语句switch语句也是匹配条件去执行分支，适合做值匹配的分支选择，结构清晰，格式良好。\n switch语句结构\n格式\nswitch (表达式) &#123;\n    case 1:\n        语句体1;\n        break;\n    case 2:\n        语句体2;\n        break;\n    ...\n    default:\n        语句体n+1;\n        break;\n&#125;\n\n执行流程：\n\n首先计算出表达式的值\n其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结束。\n最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。\n\nswitch语句练习-春夏秋冬\n需求：一年有12个月，分属于春夏秋冬4个季节，键盘录入一个月份，请用程序实现判断该月份属于哪个季节，并输出。 \n运行结果：\n春：3、4、5\n夏：6、7、8\n秋：9、10、11\n冬：1、2、12\n\n示例代码：\npublic class Demo1 &#123;\n    public static void main(String[] args) &#123;\n        //键盘录入月份数据，使用变量接收\n        Scanner sc = new Scanner(System.in);\n        System.out.println(&quot;请输入一个月份：&quot;);\n        int month = sc.nextInt();\n        //case穿透\n        switch(month) &#123;\n            case 1:\n            case 2:\n            case 12:\n                System.out.println(&quot;冬季&quot;);\n                break;\n            case 3:\n            case 4:\n            case 5:\n                System.out.println(&quot;春季&quot;);\n                break;\n            case 6:\n            case 7:\n            case 8:\n                System.out.println(&quot;夏季&quot;);\n                break;\n            case 9:\n            case 10:\n            case 11:\n                System.out.println(&quot;秋季&quot;);\n                break;\n            default:\n                System.out.println(&quot;你输入的月份有误&quot;);\n        &#125;\n    &#125;\n&#125;\n\n注意：如果switch中得case，没有对应break的话，则会出现case穿透的现象。\nswitch分支注意事项:\n\n&#x3D;&#x3D;表达式类型只能是byte、short、int、char，JDK5开始支持枚举，JDK7开始支持String.不支持double、float、long&#x3D;&#x3D;。\n&#x3D;&#x3D;case给出的值不允许重复，且只能是字面量，不能是变量&#x3D;&#x3D;。\n&#x3D;&#x3D;不要忘记写break，否则会出现穿透现象&#x3D;&#x3D;。\n\n\n4、循环结构4.1 for循环结构循环：\n  循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复 执行这个循环体时，需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形成死循环。 \nfor循环格式：\nfor (初始化语句;条件判断语句;条件控制语句) &#123;\n    循环体语句;\n&#125;\n\n格式解释：\n\n初始化语句：  用于表示循环开启时的起始状态，简单说就是循环开始的时候什么样\n条件判断语句：用于表示循环反复执行的条件，简单说就是判断循环是否能一直执行下去\n循环体语句：  用于表示循环反复执行的内容，简单说就是循环反复执行的事情\n条件控制语句：用于表示循环执行中每次变化的内容，简单说就是控制循环是否能执行下去\n\n 执行流程：\n\n执行初始化语句\n\n执行条件判断语句，看其结果是true还是false    - 如果是false，循环结束\t\t    - 如果是true，继续执行\n\n执行循环体语句\n\n执行条件控制语句\n\n回到2继续\n\n\nfor循环练习-输出数据\n需求：在控制台输出1-5和5-1的数据\n示例代码：\npublic class ForTest01 &#123;\n    public static void main(String[] args) &#123;\n        //需求：输出数据1-5\n        for(int i=1; i&lt;=5; i++) &#123;\n            System.out.println(i);\n        &#125;\n        System.out.println(&quot;--------&quot;);\n        //需求：输出数据5-1\n        for(int i=5; i&gt;=1; i--) &#123;\n            System.out.println(i);\n        &#125;\n    &#125;\n&#125;\n\nfor循环练习-求和\n需求：求1-5之间的数据和，并把求和结果在控制台输出  \n示例代码：\npublic class ForTest02 &#123;\n    public static void main(String[] args) &#123;\n        //求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0\n        int sum = 0;\n        //从1开始到5结束的数据，使用循环结构完成\n        for(int i=1; i&lt;=5; i++) &#123;\n            //将反复进行的事情写入循环结构内部\n             // 此处反复进行的事情是将数据 i 加到用于保存最终求和的变量 sum 中\n            sum += i;\n            /*\n                sum += i;\tsum = sum + i;\n                第一次：sum = sum + i = 0 + 1 = 1;\n                第二次：sum = sum + i = 1 + 2 = 3;\n                第三次：sum = sum + i = 3 + 3 = 6;\n                第四次：sum = sum + i = 6 + 4 = 10;\n                第五次：sum = sum + i = 10 + 5 = 15;\n            */\n        &#125;\n        //当循环执行完毕时，将最终数据打印出来\n        System.out.println(&quot;1-5之间的数据和是：&quot; + sum);\n    &#125;\n&#125;\n\n本题要点：\n\n今后遇到的需求中，如果带有求和二字，请立即联想到求和变量\n求和变量的定义位置，必须在循环外部，如果在循环内部则计算出的数据将是错误的\n\nfor循环练习-求偶数和\n 需求：求1-100之间的偶数和，并把求和结果在控制台输出 \n 示例代码：\npublic class ForTest03 &#123;\n    public static void main(String[] args) &#123;\n        //求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0\n        int sum = 0;\n        //对1-100的数据求和与1-5的数据求和几乎完全一样，仅仅是结束条件不同\n        for(int i=1; i&lt;=100; i++) &#123;\n            //对1-100的偶数求和，需要对求和操作添加限制条件，判断是否是偶数\n            if(i%2 == 0) &#123;\n                sum += i;\n            &#125;\n        &#125;\n        //当循环执行完毕时，将最终数据打印出来\n        System.out.println(&quot;1-100之间的偶数和是：&quot; + sum);\n    &#125;\n&#125;\n\nfor循环练习-水仙花\n需求：在控制台输出所有的“水仙花数” \n解释：什么是水仙花数？\n水仙花数，指的是一个三位数，个位、十位、百位的数字立方和等于原数\n例如153  3*3*3 + 5*5*5 + 1*1*1 = 153\n思路：\n\n获取所有的三位数，准备进行筛选，最小的三位数为100，最大的三位数为999，使用for循环获取\n获取每一个三位数的个位，十位，百位，做if语句判断是否是水仙花数\n\n示例代码\npublic class ForTest04 &#123;\n    public static void main(String[] args) &#123;\n        //输出所有的水仙花数必然要使用到循环，遍历所有的三位数，三位数从100开始，到999结束\n        for(int i=100; i&lt;1000; i++) &#123;\n            //在计算之前获取三位数中每个位上的值\n            int ge = i%10;\n            int shi = i/10%10;\n            int bai = i/10/10%10;\n            \n            //判定条件是将三位数中的每个数值取出来，计算立方和后与原始数字比较是否相等\n            if(ge*ge*ge + shi*shi*shi + bai*bai*bai == i) &#123;\n                //输出满足条件的数字就是水仙花数\n                System.out.println(i);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n4.2 循环结构： while循环 while结构\nwhile循环完整格式：\n初始化语句;\nwhile (条件判断语句) &#123;\n    循环体语句;\n    条件控制语句;\n&#125;\n\n while循环执行流程：\n\n执行初始化语句\n\n执行条件判断语句，看其结果是true还是false- 如果是false，循环结束- 如果是true，继续执行\n\n执行循环体语句\n\n执行条件控制语句\n\n回到②继续\n\n\n 示例代码：\npublic class WhileDemo &#123;\n    public static void main(String[] args) &#123;\n        //需求：在控制台输出5次&quot;HelloWorld&quot;\n        //for循环实现\n        for(int i=1; i&lt;=5; i++) &#123;\n            System.out.println(&quot;HelloWorld&quot;);\n        &#125;\n        System.out.println(&quot;--------&quot;);\n        //while循环实现\n        int j = 1;\n        while(j&lt;=5) &#123;\n            System.out.println(&quot;HelloWorld&quot;);\n            j++;\n        &#125;\n    &#125;\n&#125;\n\nwhile循环练习-珠穆朗玛峰\n需求：世界最高山峰是珠穆朗玛峰(8844.43米&#x3D;8844430毫米)，假如我有一张足够大的纸，它的厚度是0.1毫米。请问，我折叠多少次，可以折成珠穆朗玛峰的高度?示例代码：\npublic class WhileTest &#123;\n    public static void main(String[] args) &#123;\n        //定义一个计数器，初始值为0\n        int count = 0;\n        //定义纸张厚度\n        double paper = 0.1;\n        //定义珠穆朗玛峰的高度\n        int zf = 8844430;\n        //因为要反复折叠，所以要使用循环，但是不知道折叠多少次，这种情况下更适合使用while循环\n        //折叠的过程中当纸张厚度大于珠峰就停止了，因此继续执行的要求是纸张厚度小于珠峰高度\n        while(paper &lt;= zf) &#123;\n            //循环的执行过程中每次纸张折叠，纸张的厚度要加倍\n            paper *= 2;\n            //在循环中执行累加，对应折叠了多少次\n            count++;\n        &#125;\n        //打印计数器的值\n        System.out.println(&quot;需要折叠：&quot; + count + &quot;次&quot;);\n    &#125;\n&#125;\n\n4.3 循环结构：do-while循环do…while循环结构\n完整格式：\n初始化语句;\ndo &#123;\n    循环体语句;\n    条件控制语句;\n&#125;while(条件判断语句);\n\n执行流程：\n\n执行初始化语句\n\n执行循环体语句\n\n执行条件控制语句\n\n执行条件判断语句，看其结果是true还是false- 如果是false，循环结束- 如果是true，继续执行\n\n回到②继续\n\n\n 示例代码：\npublic class DoWhileDemo &#123;\n    public static void main(String[] args) &#123;\n        //需求：在控制台输出5次&quot;HelloWorld&quot;\n        //for循环实现\n        for(int i=1; i&lt;=5; i++) &#123;\n            System.out.println(&quot;HelloWorld&quot;);\n        &#125;\n        System.out.println(&quot;--------&quot;);\n        //do...while循环实现\n        int j = 1;\n        do &#123;\n            System.out.println(&quot;HelloWorld&quot;);\n            j++;\n        &#125;while(j&lt;=5);\n    &#125;\n&#125;\n\n4.4 三种循环的区别\n三种循环的区别\nfor循环和while循环先判断条件是否成立，然后决定是否执行循环体（先判断后执行）\ndo…while循环先执行一次循环体，然后判断条件是否成立，是否继续执行循环体（先执行后判断）\n\n\nfor循环和while的区别\n条件控制语句所控制的自增变量，因为归属for循环的语法结构中，在for循环结束后，就不能再次被访问到了\n条件控制语句所控制的自增变量，对于while循环来说不归属其语法结构中，在while循环结束后，该变量还可以继续使用\n\n\n死循环（无限循环）的三种格式\nfor( ; ; ) {}\nwhile(true){}\ndo {} while(true);\n\n\n\n4.5  跳转控制语句\n跳转控制语句（break）\n跳出循环，结束循环\n\n\n跳转控制语句（continue）\n跳过本次循环，继续下次循环\n\n\n注意： continue只能在循环中进行使用！\n\n4.5 循环嵌套 循环嵌套概述：在循环中，继续定义循环\n示例代码：\n    public static void main(String[] args) &#123;\n        //外循环控制小时的范围，内循环控制分钟的范围\n        for (int hour = 0; hour &lt; 24; hour++) &#123;\n            for (int minute = 0; minute &lt; 60; minute++) &#123;\n                System.out.println(hour + &quot;时&quot; + minute + &quot;分&quot;);\n            &#125;\n            System.out.println(&quot;--------&quot;);\n        &#125;\n    &#125;\n\n理解：\n整个内循环，就是外循环的一个循环体，内部循环体没有执行完毕，外循环是不会继续向下执行的\n结论：\n外循环执行一次，内循环执行一圈\n\n5、Random类Random产生随机数\n概述：\nRandom类似Scanner，也是Java提供好的API，内部提供了产生随机数的功能\n使用步骤：\n\n导入包\nimport java.util.Random;\n\n创建对象\nRandom r &#x3D; new Random();\n\n产生随机数\nint num &#x3D; r.nextInt(10);\n\n\n解释： 10代表的是一个范围，如果括号写10，产生的随机数就是0-9，括号写20，参数的随机数则是0-19\n示例代码：\nimport java.util.Random;\npublic class RandomDemo &#123;\n    public static void main(String[] args) &#123;\n        //创建对象\n        Random r = new Random();\n        //用循环获取10个随机数\n        for(int i=0; i&lt;10; i++) &#123;\n            //获取随机数\n            int number = r.nextInt(10);\n            System.out.println(&quot;number:&quot; + number);\n        &#125;\n        //需求：获取一个1-100之间的随机数\n        int x = r.nextInt(100) + 1;\n        System.out.println(x);\n    &#125;\n&#125;\n\n Random练习-猜数字（应用）\n\n需求：\n程序自动生成一个1-100之间的数字，使用程序实现猜出这个数字是多少？\n当猜错的时候根据不同情况给出相应的提示\nA. 如果猜的数字比真实数字大，提示你猜的数据大了\nB. 如果猜的数字比真实数字小，提示你猜的数据小了\nC. 如果猜的数字与真实数字相等，提示恭喜你猜中了\n\n示例代码：\n\n\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class RandomTest &#123;\n    public static void main(String[] args) &#123;\n        //要完成猜数字的游戏，首先需要有一个要猜的数字，使用随机数生成该数字，范围1到100\n        Random r = new Random();\n        int number = r.nextInt(100) + 1;\n        \n        while(true) &#123;\n            //使用程序实现猜数字，每次均要输入猜测的数字值，需要使用键盘录入实现\n            Scanner sc = new Scanner(System.in);\n            \n            System.out.println(&quot;请输入你要猜的数字：&quot;);\n            int guessNumber = sc.nextInt();\n            \n            //比较输入的数字和系统产生的数据，需要使用分支语句。\n             //这里使用if..else..if..格式，根据不同情况进行猜测结果显示\n            if(guessNumber &gt; number) &#123;\n                System.out.println(&quot;你猜的数字&quot; + guessNumber + &quot;大了&quot;);\n            &#125; else if(guessNumber &lt; number) &#123;\n                System.out.println(&quot;你猜的数字&quot; + guessNumber + &quot;小了&quot;);\n            &#125; else &#123;\n                System.out.println(&quot;恭喜你猜中了&quot;);\n                break;\n            &#125;\n        &#125;\n        \n    &#125;\n&#125;\n\n\n","slug":"Java程序设计 -- 程序流程控制（三）","date":"2022-03-17T13:17:26.000Z","categories_index":"后端","tags_index":"Java","author_index":"会思想的苇草i"},{"id":"fb9ec5e89e1cf92677e3b29d5efa3c22","title":"Java程序设计--Java基础语法","content":"\n1、注释注释是对代码的解释和说明文字，可以提高程序的可读性，因此在程序中添加必要的注释文字十分重要。Java中的注释分为三种：\n\n单行注释。单行注释的格式是使用&#x2F;&#x2F;，从&#x2F;&#x2F;开始至本行结尾的文字将作为注释文字。\n\n// 这是单行注释文字\n\n\n多行注释。多行注释的格式是使用&#x2F;* 和 *&#x2F;将一段较长的注释括起来。\n\n/*\n这是多行注释文字\n这是多行注释文字\n这是多行注释文字\n*/\n注意：多行注释不能嵌套使用。\n\n\n文档注释。文档注释以/**开始，以*/结束。一般用在类和方法上的注释。\n\n\n2、字面量作用：告诉程序员，数据在程序中的书写格式。\n\n\n\n字面量类型\n说明\n程序中的写法\n\n\n\n整数\n不带小数的数字\n666，-88\n\n\n小数\n带小数的数字\n13.14，-5.21\n\n\n字符\n必须使用单引号，有且仅能一个字符\n‘A’，‘0’，   ‘我’\n\n\n字符串\n必须使用双引号，内容可有可无\n“HelloWorld”，“程序员”\n\n\n布尔值\n布尔值，表示真假，只有两个值：true，false\ntrue 、false\n\n\n空值\n一个特殊的值，空值\n值是：null\n\n\npublic class Demo &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(10); // 输出一个整数\n        System.out.println(5.5); // 输出一个小数\n        System.out.println(&#39;a&#39;); // 输出一个字符\n        System.out.println(true); // 输出boolean值true\n        System.out.println(&quot;欢迎学习java&quot;); // 输出字符串\n    &#125;\n&#125;\n\n\n3、数据类型3.1 计算机存储单元计算机底层都是一些数字电路(理解成开关)，用开表示0、关表示1，这些01的形式就是二进制。\n数据在计算机底层都是采用二进制存储的，在计算机中认为一个开关表示的0|1称为1位（b），每8位称为一个字节（B）， 所以1B&#x3D;8b\n字节是计算机中数据的最小单位。\n我们知道计算机是可以用来存储数据的，但是无论是内存还是硬盘，计算机存储设备的最小信息单元叫“位（bit）”，我们又称之为“比特位”，通常用小写的字母”b”表示。而计算机中最基本的存储单元叫“字节（byte）”，\n通常用大写字母”B”表示，字节是由连续的8个位组成。\n除了字节外还有一些常用的存储单位，其换算单位如下：\n1B（字节） &#x3D;  8bit\n1KB &#x3D; 1024B\n1MB &#x3D; 1024KB\n1GB &#x3D; 1024MB\n1TB &#x3D; 1024GB\n3.2 Java中的数据类型Java是一个强类型语言，Java中的数据必须明确数据类型。在Java中的数据类型包括基本数据类型和引用数据类型两种。\nJava中的基本数据类型：\n\n\n\n数据类型\n关键字\n内存占用\n取值范围\n\n\n\n整数\nbyte\n1\n负的2的7次方 ~ 2的7次方-1(-128~127)\n\n\n\nshort\n2\n负的2的15次方 ~ 2的15次方-1(-32768~32767)\n\n\n\nint\n4\n负的2的31次方 ~ 2的31次方-1\n\n\n\nlong\n8\n负的2的63次方 ~ 2的63次方-1\n\n\n浮点数\nfloat\n4\n1.401298e-45 ~ 3.402823e+38\n\n\n\ndouble\n8\n4.9000000e-324 ~ 1.797693e+308\n\n\n字符\nchar\n2\n0-65535\n\n\n布尔\nboolean\n1\ntrue，false\n\n\n说明：\n\n​\te+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方。\n​\t&#x3D;&#x3D;在java中整数默认是int类型，浮点数默认是double类型。&#x3D;&#x3D;\n\n\n4、变量4.1 变量的定义变量：在程序运行过程中，其值可以发生改变的量。就是用来存储一个数据的内存区域（可以理解成盒子），且里面存储的数据可以变化。\n变量的定义格式：\n数据类型 变量名 = 初始化值; // 声明变量并赋值\n\nint age = 18;\n\nSystem.out.println(age);\n\n或者\n// 先声明，后赋值（使用前赋值即可）\n数据类型 变量名;\n变量名 = 初始化值;\ndouble money;\nmoney = 55.5;\nSystem.out.println(money);\n\n还可以在同一行定义多个同一种数据类型的变量，中间使用逗号隔开。但不建议使用这种方式，降低程序的可读性。\nint a = 10, b = 20; // 定义int类型的变量a和b，中间使用逗号隔开\nSystem.out.println(a);\nSystem.out.println(b);\n\nint c,d; // 声明int类型的变量c和d，中间使用逗号隔开\nc = 30;\nd = 40;\nSystem.out.println(c);\nSystem.out.println(d);\n\n变量的使用：通过变量名访问即可。\n4.2 使用变量时的注意事项\n在同一对花括号中，变量名不能重复。\n变量在使用之前，必须初始化（赋值）。\n&#x3D;&#x3D;定义long类型的变量时，需要在整数的后面加L（大小写均可，建议大写）。因为整数默认是int类型，整数太大可能超出int范围。&#x3D;&#x3D;\n&#x3D;&#x3D;定义float类型的变量时，需要在小数的后面加F（大小写均可，建议大写）。因为浮点数的默认类型是double， double的取值范围是大于float的，类型不兼容。&#x3D;&#x3D;\n\n\n5、关键字、标志符关键字\nJava自己保留的一些单词，作为特殊功能的，例如：public、class、byte、short、int、long、double… \n我们不能用来作为类名或者是变量名称，否则报错。\n注意：关键字很多，不用刻意去记。\n\n\n\nabstract\nassert\nboolean\nbreak\nbyte\n\n\n\ncase\ncatch\nchar\nclass\nconst\n\n\ncontinue\ndefault\ndo\ndouble\nelse\n\n\nenum\nextends\nfinal\nfinally\nfloat\n\n\nfor\ngoto\nif\nimplements\nimport\n\n\ninstanceof\nint\ninterface\nlong\nnative\n\n\nnew\npackage\nprivate\nprotected\npublic\n\n\nreturn\nstrictfp\nshort\nstatic\nsuper\n\n\nswitch\nsynchronized\nthis\nthrow\nthrows\n\n\ntransient\ntry\nvoid\nvolatile\nwhile\n\n\n标志符\n标志符就是由一些字符、符号组合起来的名称，用于给类，方法，变量等起名字的规矩。\n\n&#x3D;&#x3D;基本要求：由数字、字母、下划线(_)和美元符($)等组成&#x3D;&#x3D;\n&#x3D;&#x3D;强制要求：不能以数字开头、不能是关键字、区分大小写&#x3D;&#x3D;\n\n基本命令规范\n\n\n变量名称：满足标识符规则，建议全英文、有意义、首字母小写，满足“驼峰模式”，例如：int studyNumber &#x3D; 59。\n类名称： 满足标识符规则，建议全英文、有意义、首字母大写，满足“驼峰模式”，例如：HelloWorld.java。\n\n\n6、类型转换在Java中，会存在不同类型的数据需要一起参与运算，所以这些数据类型之间是需要相互转换的，分为两种情况：自动类型转换和强制类型转换。\n6.1 自动类型转换类型范围小的变量，可以直接赋值给类型范围大的变量。\n\n把一个表示数据范围小的数值或者变量赋值给另一个表示数据范围大的变量，这种转换方式是自动的，直接书写即可。例如：\ndouble num = 10; // 将int类型的10直接赋值给double类型\nSystem.out.println(num); // 输出10.0\n\nbyte a = 12 ;\nint b = a;\nSystem.out.println(b); // 12\n\n\npublic class TypeDemo&#123;\n    public static void main(String[] args) &#123;\n        // 目标：理解自动类型转换\n        byte a = 20;\n        int b = a; // 发生了自动类型转换\n        System.out.println(a);\n        System.out.println(b);\n\n        int age = 23;\n        double db = age; // 自动类型转换\n        System.out.println(db);\n\n        char ch = &#39;a&#39;; // 00000000 01100001\n        int code = ch; // 00000000 00000000 00000000 01100001\n        System.out.println(code);\n    &#125;\n&#125;\n\n6.2 表达式的自动类型转换在表达式中，小范围类型的变量会自动转换成当前较大范围的类型再运算。\n\npublic class TypeDemo2 &#123;\n    public static void main(String[] args) &#123;\n        //目标：掌握表达式的自动类型转换的规则。\n        byte a = 10;\n        int b = 20;\n        double c = 1.0;\n        double rs = a + b + c;\n        System.out.println(rs);\n\n        double rs2 = a + b - 2.3;\n        System.out.println(rs2);\n\n        // 面试题\n        byte i = 100;\n        byte j = 120;\n        int k = i + j;\n        System.out.println(k);\n    &#125;\n&#125;\n\n注意事项：\n&#x3D;&#x3D;表达式的最终结果类型由表达式中的最高类型决定。&#x3D;&#x3D;\n&#x3D;&#x3D;在表达式中，byte、short、char 是直接转换成int类型参与运算的。&#x3D;&#x3D; \n6.3 强制类型转换类型范围大的数据或者变量，不能直接赋值给类型范围小的变量，会报错，把一个表示数据范围大的数值或者变量赋值给另一个表示数据范围小的变量必须进行强制类型转换。\n强制类型转换格式：&#x3D;&#x3D;目标数据类型 变量名 &#x3D; (目标数据类型)值或者变量;&#x3D;&#x3D;\n​\t例如：\ndouble num1 = 5.5;\n\nint num2 = (int) num1; // 将double类型的num1强制转换为int类型\n\nSystem.out.println(num2); // 输出5（小数位直接舍弃）\n\n说明：\n\nchar类型的数据转换为int类型是按照码表中对应的int值进行计算的。比如在ASCII码表中，’a’对应97。\n\nint a = &#39;a&#39;;\nSystem.out.println(a); // 将输出97\n\n\n整数默认是int类型，byte、short和char类型数据参与运算均会自动转换为int类型。\n\nbyte b1 = 10;\nbyte b2 = 20;\nbyte b3 = b1 + b2; \n// 第三行代码会报错，b1和b2会自动转换为int类型，计算结果为int，int赋值给byte需要强制类型转换。\n// 修改为:\nint num = b1 + b2;\n// 或者：\nbyte b3 = (byte) (b1 + b2);\n\n\nboolean类型不能与其他基本数据类型相互转换。\n\n\n注意:\n\n&#x3D;&#x3D;强制类型转换可能造成数据(丢失)溢出;&#x3D;&#x3D;\n&#x3D;&#x3D;浮点型强转成整型，直接丢掉小数部分，保留整数部分返回。&#x3D;&#x3D;\n\n\n7、运算符7.1 算术运算符运算符： 对常量或者变量进行操作的符号\n表达式： 用运算符把常量或者变量连接起来符合java语法的式子就可以称为表达式。\n不同运算符连接的表达式体现的是不同类型的表达式。\n举例说明：\nint a = 10;\nint b = 20;\nint c = a + b;\n\n  +：是运算符，并且是算术运算符。\n  a + b：是表达式，由于+是算术运算符，所以这个表达式叫算术表达式。\n算术运算符\n\n\n\n符号\n作用\n说明\n\n\n\n+\n加\n参看小学一年级\n\n\n-\n减\n参看小学一年级\n\n\n*\n乘\n参看小学二年级，与“×”相同\n\n\n&#x2F;\n除\n参看小学二年级，与“÷”相同\n\n\n%\n取余\n获取的是两个数据做除法的余数\n\n\n注意：\n\n&#x2F;和%的区别：两个数据做除法，&#x2F;取结果的商，%取结果的余数。\n整数操作只能得到整数，要想得到小数，必须有浮点数参与运算。\n\nint a = 10;\nint b = 3;\nSystem.out.println(a / b); // 输出结果3\nSystem.out.println(a % b); // 输出结果1\n\n字符的“+”操作\nchar类型参与算术运算，使用的是计算机底层对应的十进制数值。需要我们记住三个字符对应的数值：\n\n‘a’  –  97\t\ta-z是连续的，所以’b’对应的数值是98，’c’是99，依次递加\n‘A’  –  65\t\tA-Z是连续的，所以’B’对应的数值是66，’C’是67，依次递加\n‘0’  –  48\t\t0-9是连续的，所以’1’对应的数值是49，’2’是50，依次递加\n\n// 可以通过使用字符与整数做算术运算，得出字符对应的数值是多少\nchar ch1 = &#39;a&#39;;\nSystem.out.println(ch1 + 1); // 输出98，97 + 1 = 98\n\nchar ch2 = &#39;A&#39;;\nSystem.out.println(ch2 + 1); // 输出66，65 + 1 = 66\n\nchar ch3 = &#39;0&#39;;\nSystem.out.println(ch3 + 1); // 输出49，48 + 1 = 49\n\n算术表达式中包含不同的基本数据类型的值的时候，整个算术表达式的类型会自动进行提升。\n提升规则：\nbyte类型，short类型和char类型将被提升到int类型，不管是否有其他类型参与运算。\n整个表达式的类型自动提升到与表达式中最高等级的操作数相同的类型\n&#x3D;&#x3D;等级顺序：byte,short,char –&gt; int –&gt; long –&gt; float –&gt; double&#x3D;&#x3D;\n例如：\nbyte b1 = 10;\nbyte b2 = 20;\n// byte b3 = b1 + b2; // 该行报错，因为byte类型参与算术运算会自动提示为int，int赋值给byte可能损失精度\nint i3 = b1 + b2; // 应该使用int接收\nbyte b3 = (byte) (b1 + b2); // 或者将结果强制转换为byte类型\n-------------------------------\nint num1 = 10;\ndouble num2 = 20.0;\ndouble num3 = num1 + num2; // 使用double接收，因为num1会自动提升为double类型\n\ntips：正是由于上述原因，所以在程序开发中我们很少使用byte或者short类型定义整数。也很少会使用char类型定义字符，而使用字符串类型，更不会使用char类型做算术运算。\n字符串的“+”操作\n当“+”操作中出现字符串时，这个”+”是字符串连接符，而不是算术运算。\nSystem.out.println(&quot;java&quot;+ 666); // 输出：java666\n\n在”+”操作中，如果出现了字符串，就是连接运算符，否则就是算术运算。当连续进行“+”操作时，从左到右逐个执行。\nSystem.out.println(1 + 99 + &quot;java&quot;); // 输出：199年java\nSystem.out.println(1 + 2 + &quot;java&quot; + 3 + 4); // 输出：3java34\n// 可以使用小括号改变运算的优先级 \nSystem.out.println(1 + 2 + &quot;java&quot; + (3 + 4)); // 输出：3java7\n\n7.2  赋值运算符赋值运算符的作用是将一个表达式的值赋给左边，左边必须是可修改的，不能是常量。\n\n\n\n符号\n作用\n说明\n\n\n\n&#x3D;\n赋值\na&#x3D;10，将10赋值给变量a\n\n\n+&#x3D;\n加后赋值\na+&#x3D;b，将a+b的值给a\n\n\n-&#x3D;\n减后赋值\na-&#x3D;b，将a-b的值给a\n\n\n*&#x3D;\n乘后赋值\na*&#x3D;b，将a×b的值给a\n\n\n&#x2F;&#x3D;\n除后赋值\na&#x2F;&#x3D;b，将a÷b的商给a\n\n\n%&#x3D;\n取余后赋值\na%&#x3D;b，将a÷b的余数给a\n\n\n注意：\n扩展的赋值运算符隐含了强制类型转换。\nshort s = 10;\ns = s + 10; // 此行代码报出，因为运算中s提升为int类型，运算结果int赋值给short可能损失精度\n\ns += 10; // 此行代码没有问题，隐含了强制类型转换，相当于 s = (short) (s + 10);\n\n7.3 自增自减运算符\n\n\n符号\n作用\n说明\n\n\n\n++\n自增\n变量的值加1\n\n\n–\n自减\n变量的值减1\n\n\n注意事项：\n​\t++和– 既可以放在变量的后边，也可以放在变量的前边。\n​\t单独使用的时候， ++和– 无论是放在变量的前边还是后边，结果是一样的。\n​\t参与操作的时候，如果放在变量的后边，先拿变量参与操作，后拿变量做++或者- -。\n​\t参与操作的时候，如果放在变量的前边，先拿变量做++或者- -，后拿变量参与操作。\n​\t最常见的用法：单独使用。\npublic class OperatorDemo &#123;\n    public static void main(String[] args) &#123;\n        // 目标：学会使用自增自减运算符： ++ --\n        int a = 10;\n        // a++; // a = a + 1\n        ++a; // a = a + 1\n        System.out.println(a);\n\n        int b = 10;\n        //b--; // b = b -1\n        --b;\n        System.out.println(b);\n\n        System.out.println(&quot;------------------------------&quot;);\n        // 在表达式中或者不是单独操作的情况，++ -- 在变量前后存在区别\n        // ++ -- 在变量前面。先+1 -1 再使用。\n        int i = 10;\n        int j = ++i;\n        System.out.println(i); // 11\n        System.out.println(j); // 11\n\n        // ++ -- 在变量的后面 先使用再+1 -1\n        int m = 10;\n        int n = m++;\n        System.out.println(m); // 11\n        System.out.println(n); // 10\n\n        System.out.println(&quot;-----------拓展案例（可以了解和参考）--------------&quot;);\n        int k = 3;\n        int p = 5;\n        // k  3 4 5 4\n        // p  5 4 3 4\n        // rs    3  +  5  -   4  + 4   - 5   +  4 + 2\n        int rs = k++ + ++k - --p + p-- - k-- + ++p + 2;\n        System.out.println(k); // 4\n        System.out.println(p); // 4\n        System.out.println(rs); // 9\n    &#125;\n&#125;\n\n7.4 关系运算符关系运算符有6种关系，分别为小于、小于等于、大于、等于、大于等于、不等于。\n\n\n\n符号\n说明\n\n\n\n&#x3D;&#x3D;\na&#x3D;&#x3D;b，判断a和b的值是否相等，成立为true，不成立为false\n\n\n!&#x3D;\na!&#x3D;b，判断a和b的值是否不相等，成立为true，不成立为false\n\n\n&gt;\na&gt;b，判断a是否大于b，成立为true，不成立为false\n\n\n&gt;&#x3D;\na&gt;&#x3D;b，判断a是否大于等于b，成立为true，不成立为false\n\n\n&lt;\na&lt;b，判断a是否小于b，成立为true，不成立为false\n\n\n&lt;&#x3D;\na&lt;&#x3D;b，判断a是否小于等于b，成立为true，不成立为false\n\n\n注意事项：\n\n​\t关系运算符的结果都是boolean类型，要么是true，要么是false。\n​\t千万不要把“&#x3D; &#x3D;”误写成“ &#x3D; ”，”&#x3D; &#x3D;”是判断是否相等的关系，”&#x3D;”是赋值。\n\npublic class OperatorDemo5 &#123;\n    public static void main(String[] args) &#123;\n        // 目标：学会使用赋值运算符：= += -= *= /= %=\n        int a = 10;\n        int b = 200;\n        // a = a + b;\n        a += b; // a = (int)(a + b)\n        System.out.println(a);\n\n        byte i = 10;\n        byte j = 20;\n        // i = (byte) (i + j);\n        i += j; // i = (byte) (i + j);\n        System.out.println(i);\n\n        int m = 10;\n        int n = 5;\n        //m += n;\n        //m -= n;  // 等价于： m = (int)(m - n)\n        //m *= n;  // 等价于： m = (int)(m * n)\n//        m /= n;  // 等价于： m = (int)(m / n)\n        m %= n;  // 等价于： m = (int)(m % n)\n        System.out.println(m);\n    &#125;\n&#125;\n\n7.5 逻辑运算符逻辑运算符把各个运算的关系表达式连接起来组成一个复杂的逻辑表达式，以判断程序中的表达式是否成立，判断的结果是 true 或 false。\n\n\n\n符号\n作用\n说明\n\n\n\n&amp;\n逻辑与\na&amp;b，a和b都是true，结果为true，否则为false\n\n\n|\n逻辑或\na|b，a和b都是false，结果为false，否则为true\n\n\n^\n逻辑异或\na^b，a和b结果不同为true，相同为false\n\n\n!\n逻辑非\n!a，结果和a的结果正好相反\n\n\npublic class OperatorDemo6 &#123;\n    public static void main(String[] args) &#123;\n        // 目标：学会使用关系运算符。\n        int a = 10;\n        int b = 10;\n\n        boolean rs = a == b;\n        System.out.println(rs);\n\n        System.out.println(a == b);\n        System.out.println(a != b); // false\n        System.out.println(a &gt; b); //  false\n        System.out.println(a &gt;= b); // true\n        System.out.println(a &lt; b); // false\n        System.out.println(a &lt;= b); // true\n\n        int i = 10;\n        int j = 5;\n        System.out.println(i == j); // false\n        System.out.println(i != j); // true\n        System.out.println(i &gt; j); // true\n        System.out.println(i &gt;= j); // true\n        System.out.println(i &lt; j); // false\n        System.out.println(i &lt;= j); // false\n\n        System.out.println(i = j); // 5 相等判断必须是== 如果使用=是在进行赋值操作！\n    &#125;\n&#125;\n\n短路逻辑运算符\n\n\n\n符号\n作用\n说明\n\n\n\n&amp;&amp;\n短路与\n作用和&amp;相同，但是有短路效果\n\n\n||\n短路或\n作用和|相同，但是有短路效果\n\n\n在逻辑与运算中，只要有一个表达式的值为false，那么结果就可以判定为false了，没有必要将所有表达式的值都计算出来，短路与操作就有这样的效果，可以提高效率。同理在逻辑或运算中，一旦发现值为true，右边的表达式将不再参与运算。\n\n逻辑与&amp;，无论左边真假，右边都要执行。\n\n短路与&amp;&amp;，如果左边为真，右边执行；如果左边为假，右边不执行。\n\n逻辑或|，无论左边真假，右边都要执行。\n\n短路或||，如果左边为假，右边执行；如果左边为真，右边不执行。\n\n\npublic class OperatorDemo7 &#123;\n    public static void main(String[] args) &#123;\n        // 目标：学会使用逻辑运算符，并能够选择合适的逻辑运算符解决问题。\n        double size = 9.8;\n        double storage = 6;\n        // 需求：尺寸大于等于6.95 内存要大于等于8GB\n        // 注意：必须前后都是true结果才是true\n        System.out.println(size &gt;= 6.95 &amp; storage &gt;=8);\n\n        // 需求：要么内存大于等于8 要么尺寸大于等于6.95\n        // 注意：只要有一个是true 结果就一定是true\n        System.out.println(size &gt;= 6.95 | storage &gt;=8);\n\n        System.out.println(!true);\n        System.out.println(!false);\n\n        // 逻辑异或：必须两个不同结果才是true\n        System.out.println(false ^ true); // true\n        System.out.println(true ^ false); // true\n        System.out.println(true ^ true); // false\n        System.out.println(false ^ false); // false\n\n        System.out.println(&quot;-----------&amp;&amp;  &amp;  || |的区别-------------------&quot;);\n        int a = 10;\n        int b = 20;\n        // System.out.println(a &gt; 100 &amp;&amp; ++b &gt; 10);\n        System.out.println(a &gt; 100 &amp; ++b &gt; 10);\n        System.out.println(b);\n\n        int i = 10;\n        int j = 20;\n        //System.out.println(i &gt; 2 || ++j &gt; 10);\n        System.out.println(i &gt; 2 | ++j &gt; 10);\n        System.out.println(j);\n    &#125;\n&#125;\n\n7.6 三元运算符三元运算符语法格式：\n关系表达式 ? 表达式1 : 表达式2;\n\n解释：问号前面的位置是判断的条件，判断结果为boolean型，为true时调用表达式1，为false时调用表达式2。其逻辑为：如果条件表达式成立或者满足则执行表达式1，否则执行第二个。\n举例：\nint a = 10;int b = 20;int c = a &gt; b ? a : b; // 判断 a&gt;b 是否为真，如果为真取a的值，如果为假，取b的值\n\n三元运算符案例：\n1、需求：动物园里有两只老虎，已知两只老虎的体重分别为180kg、200kg，请用程序实现判断两只老虎的体重是否相同。\npublic class OperatorTest01 &#123;\n    public static void main(String[] args) &#123;\n        //1：定义两个变量用于保存老虎的体重，单位为kg，这里仅仅体现数值即可。\n        int weight1 = 180;\n        int weight2 = 200;\t\n        //2：用三元运算符实现老虎体重的判断，体重相同，返回true，否则，返回false。\n        boolean b = weight1 == weight2 ? true : false;\t\n        //3：输出结果\n        System.out.println(&quot;b:&quot; + b);\n    &#125;\n&#125;\n\n2、需求：一座寺庙里住着三个和尚，已知他们的身高分别为150cm、210cm、165cm，请用程序实现获取这三个和尚的最高身高。\npublic class OperatorTest02 &#123;\n    public static void main(String[] args) &#123;\n        //1：定义三个变量用于保存和尚的身高，单位为cm，这里仅仅体现数值即可。\n        int height1 = 150;\n        int height2 = 210;\n        int height3 = 165;\t\n        //2：用三元运算符获取前两个和尚的较高身高值，并用临时身高变量保存起来。\n        int tempHeight = height1 &gt; height2 ? height1 : height2;\t\t\n        //3：用三元运算符获取临时身高值和第三个和尚身高较高值，并用最大身高变量保存。\n        int maxHeight = tempHeight &gt; height3 ? tempHeight : height3;\t\n        //4：输出结果\n        System.out.println(&quot;maxHeight:&quot; + maxHeight);\n    &#125;\n&#125;\n\n7.7 运算符优先级\n\n8、数据输入我们可以通过 Scanner 类来获取用户的输入。使用步骤如下：\n1、导包。Scanner 类在java.util包下，所以需要将该类导入。导包的语句需要定义在类的上面。\nimport java.util.Scanner; \n\n2、创建Scanner对象。\nScanner sc = new Scanner(System.in);// 创建Scanner对象，sc表示变量名，其他均不可变\n\n3、接收数据\nint i = sc.nextInt(); // 表示将键盘录入的值作为int数返回。\n\n示例：\nimport java.util.Scanner;\npublic class ScannerDemo &#123;\n    public static void main(String[] args) &#123;\n        //创建对象\n        Scanner sc = new Scanner(System.in);\n        //接收数据\n        int x = sc.nextInt();\n        //输出数据\n        System.out.println(&quot;x:&quot; + x);\n    &#125;\n&#125;\n\nimport java.util.Scanner;\n// 1、导包操作 (并不需要自己写的，以后通过工具进行导入更方便)\npublic class ScannerDemo &#123;\n    public static void main(String[] args) &#123;\n        // 目标：接收用户的键盘输入的数据。\n        // 2、得到一个键盘扫描器对象\n        Scanner sc = new Scanner(System.in);\n\n        System.out.println(&quot;请您输入您的年龄：&quot;);\n        // 3、等待接收用户输入一个整数，按了回车键才会把数据交给age变量\n        int age = sc.nextInt();\n        System.out.println(&quot;您的年龄是：&quot; + age);\n\n        System.out.println(&quot;请您输入您的名称：&quot;);\n        // 4、等待接收用户输入一个字符串，按了回车键才会把数据交给name变量\n        String name = sc.next();\n        System.out.println(name + &quot;欢迎进入系统！&quot;);\n    &#125;\n&#125;\n\n\n","slug":"Java程序设计 -- Java基础语法（二）","date":"2022-03-16T14:26:39.000Z","categories_index":"后端","tags_index":"Java","author_index":"会思想的苇草i"},{"id":"1239464e856eda74e8dd930a35c271b7","title":"Java程序设计--Java入门","content":"\n1、Java概述1.1 Java语言发展史语言：人与人交流沟通的表达方式\n计算机语言：人与计算机之间进行信息交流沟通的一种特殊语言\nJava语言是美国Sun公司（Stanford University Network）在1995年推出的计算机语言\nJava之父：詹姆斯●高斯林（James Gosling）\n2009年，Sun公司被甲骨文公司收购，所以我们现在访问oracle官网即可：\nhttps://www.oracle.com \n\n\n\n技术体系\n说明\n\n\n\nJava SE(标准版)\nJava技术的核心和基础\n\n\nJava EE(企业版)\n企业级应用开发的一套解决方案\n\n\nJava ME(小型版)\n针对移动设备应用的解决方案\n\n\n1.2 Java语言跨平台原理&#x3D;&#x3D;Java程序并非是直接运行的，Java编译器将Java源程序编译成与平台无关的字节码文件(class文件)，然后由Java虚拟机（JVM）对字节码文件解释执行&#x3D;&#x3D;。\n所以在不同的操作系统下，只需安装不同的Java虚拟机即可实现java程序的跨平台。\n\n1.3 JRE和JDK\n&#x3D;&#x3D;JVM（Java Virtual Machine），Java虚拟机&#x3D;&#x3D;\n&#x3D;&#x3D;JRE（Java Runtime Environment），Java运行环境，包含了JVM和Java的核心类库（Java API）&#x3D;&#x3D;\n&#x3D;&#x3D;JDK（Java Development Kit）称为Java开发工具，包含了JRE和开发工具&#x3D;&#x3D;\n总结：我们只需安装JDK即可，它包含了java的运行环境和虚拟机。\n1.4 JDK的下载和安装 下载\n通过官方网站获取JDK\nhttp://www.oracle.com\n安装\n双击打开安装包，直接下一步， 等待进度条完成、点击关闭，安装成功。\n\n小贴士：安装路径不要有中文，不要有空格找一个固定的文件夹专门安装所有跟开发相关的软件，方便管理。\n\n注意：安装路径不要包含中文或者空格等特殊字符（使用纯英文目录）。\nJDK的安装目录介绍\n\n\n\n目录名称\n说明\n\n\n\nbin\n该路径下存放了JDK的各种工具命令。javac和java就放在这个目录。\n\n\nconf\n该路径下存放了JDK的相关配置文件。\n\n\ninclude\n该路径下存放了一些平台特定的头文件。\n\n\njmods\n该路径下存放了JDK的各种模块。\n\n\nlegal\n该路径下存放了JDK各模块的授权文档。\n\n\nlib\n该路径下存放了JDK工具的一些补充JAR包。\n\n\n\n2. 入门程序HelloWorld2.1 常用DOS命令在接触集成开发环境之前，我们需要使用命令行窗口对java程序进行编译和运行，所以需要知道一些常用DOS命令。\n1、打开命令行窗口的方式：win + r 打开运行窗口，输入cmd，回车。\n2、常用命令及其作用\n\n\n\n操作\n说明\n\n\n\n盘符名称:\n盘符切换。E:回车，表示切换到E盘。\n\n\ndir\n查看当前路径下的内容。\n\n\ncd 目录\n进入单级目录。cd itheima\n\n\ncd ..\n回退到上一级目录。\n\n\ncd 目录1\\目录2...\n进入多级目录。cd itheima\\JavaSE\n\n\ncd \\\n回退到盘符目录。\n\n\ncls\n清屏。\n\n\nexit\n退出命令提示符窗口。\n\n\n2.2 Path环境变量的配置 2.2.1 为什么配置环境变量\n开发Java程序，需要使用JDK提供的开发工具（比如javac.exe、java.exe等命令），而这些工具在JDK的安装目录的bin目录下，如果不配置环境变量，那么这些命令只可以在该目录下执行。我们不可能把所有的java文件都放到JDK的bin目录下，所以&#x3D;&#x3D;配置环境变量的作用就是可以使bin目录下的java相关命令可以在任意目录下使用。&#x3D;&#x3D;\n注意：目前较新的JDK安装时会自动配置javac、java命令的路径到Path环境变量中去 ，所以javac、java可以直接使用。\n\n但是以前下载的老版本的JDK是没有自动配置的，此时必需要自己配置Path环境变量。\n①JAVA_HOME：告诉操作系统JDK安装在了哪个位置（未来其他技术要通过这个找JDK）\n②Path：告诉操作系统JDK提供的javac(编译)、java(执行)命令安装到了哪个位置\n\n注意：新版本的JDK只是自动配置了Path，没有自动配置JAVA_HOME。\n2.3 HelloWorld案例HelloWorld案例是指在计算机屏幕上输出“HelloWorld”这行文字。各种计算机语言都习惯使用该案例作为第一个演示案例。\nJava程序开发运行流程\n开发Java程序，需要三个步骤：&#x3D;&#x3D;编写程序，编译程序，运行程序&#x3D;&#x3D;。\nHelloWorld案例的编写\n1、新建文本文档文件，修改名称为HelloWorld.java。\n2、用记事本打开HelloWorld.java文件，输写程序内容。\npublic class HelloWorld &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(&quot;HelloWorld&quot;);\n    &#125;\n&#125;\n\nHelloWorld案例的编译和运行\n存文件，打开命令行窗口，将目录切换至java文件所在目录，编译java文件生成class文件，运行class文件。\n\n编译：javac 文件名.java\n范例：javac HelloWorld.java\n执行：java 类名\n范例：java HelloWorld\n\n2.4 HelloWorld案例常见问题BUG\n在电脑系统或程序中，隐藏着的一些未被发现的缺陷或问题统称为bug（漏洞）。\nBUG的解决\n1、具备识别BUG的能力：多看\n2、具备分析BUG的能力：多思考，多查资料\n3、具备解决BUG的能力：多尝试，多总结\nHelloWorld案例常见问题\n1、非法字符问题。Java中的符号都是英文格式的。\n2、大小写问题。Java语言对大小写敏感（区分大小写）。\n3、在系统中显示文件的扩展名，避免出现HelloWorld.java.txt文件。\n4、编译命令后的java文件名需要带文件后缀.java\n5、运行命令后的class文件名（类名）不带文件后缀.class\n…\n\n3、IDEA安装使用3.1 IDEA概述、安装之前的开发工具：\n文本编辑工具:记事本、ultraEdit , EditPlus , TextPad , NotePad++、sublime..存在的问题:编写代码时没有错误提醒、没有智能提示、需要自己进行编译、执行。功能不够强大。\n集成开发环境（ IDE， Integrated Development Environment )：\n把代码编写，编译，执行等多种功能综合到一起的开发工具，可以进行代码智能提示，错误提醒，项目管理等等。常见Java的IDE工具有: Eclipse、MyEclipse、Intelli IDEA、Jbuilder、NetBeans等。\nIntelli] IDEA开发工具：\nIntelli3 IDEA一般简称IDEA，是Java编程语言开发的集成环境，在业界被公认为最好的java开发工具。IDEA在代码错误提醒，智能代码补全等多方面表现的都非常优秀，是Java开发企业级首选工具。\n下载：IDEA下载\n安装：直接安装，建议修改安装路径（不要安装在有空格和中文的路径下）\n3.2 IDEA编写程序使用步骤:\n\n创建Project空工程\n创建Module模块\n创建Package包\n创建class 类\n在类中编写代码\n完成编译运行\n\n3.3 IDEA设置主题、字体\n3.4 IDEA常用快捷键操作\n\n\n快捷键\n功能效果\n\n\n\nmain&#x2F;psvm、sout、…\n快速键入相关代码\n\n\nCtrl + D\n复制当前行数据到下一行\n\n\nCtrl + Y\n删除所在行，建议用Ctrl + X\n\n\nCtrl + ALT + L\n格式化代码\n\n\nALT +SHIFT + ↑, ALT + SHIFT + ↓\n上下移动当前代码\n\n\nCtrl + &#x2F; , Ctrl + Shift + &#x2F;\n对代码进行注释(讲注释的时候再说)\n\n\n\n","slug":"Java程序设计 -- Java入门（一）","date":"2022-03-15T06:57:34.000Z","categories_index":"后端","tags_index":"Java","author_index":"会思想的苇草i"},{"id":"2a1893ca085cc0c5b7d1cdcd8c0b1c91","title":"排序","content":"\n1、排序的基本概念排序是计算机内经常进行的一种操作，其目的是将一组“无序”的记录序列调整为“有序”的记录序列。排序的目的是为了便于查找。\n若整个排序过程不需要访问外存便能完成，则称此类排序问题为内部排序;反之，若参加排序的记录数量很大，整个序列的排序过程不可能在内存中完成，必须访问外存，则称此类排序问题为外部排序。\n内部排序方法的分类\n\n插入排序(直接插入、折半插入、希尔排序) 将无序子序列中的一个或几个记录“插入”到有序序列中，从而增加记录的有序子序列的长度。\n\n交换排序(冒泡排序、快速排序) 通过“交换”无序序列中的记录从而得到其中关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加记录的有序子序列的长度。\n\n选择排序(简单选择、树形选择、堆排序) 从记录的无序子序列中“选择”关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加记录的有序子序列的长度。\n\n归并排序 通过“归并”两个或两个以上的记录有序子序列，逐步增加记录有序序列的长度。\n\n基数排序 不需要进行关键字之间的比较，依据“多关键字”排序的思想，借助“分配”和“收集”两种操作，对单逻辑关键字进行排序的方法。\n\n\n待排序记录的存储方式：顺序表、链表、地址向量\n排序算法效率的评价指标\n\n时间效率——排序速度（比较次数与移动次数)\n空间效率——占内存辅助空间的大小\n稳定性——A和B的关键字相等，排序后A、B的先后次序保持不变，则称这种排序算法是稳定的。\n\n\n2、插入排序&#x3D;&#x3D;插人排序的基本思想是:每一趟将一个待排序的记录，按其关键字的大小插人到已经排好序的一组记录的适当位置上，直到所有待排序记录全部插人为止。&#x3D;&#x3D;\n①.直接插入排序&#x3D;&#x3D;直接插入排序(Straight Insertion Sort)是一种最简单的排序方法，其基本操作是将―条记录插入到已排好序的有序表，从而得到一个新的、记录数量增1的有序表。&#x3D;&#x3D;\n直接插入排序算法步骤：\n\n设待排序的记录存放在数组r[1..n]中，r[1]是一个有序序列。\n循环n -1次，每次使用顺序查找法，查找r[i](i&#x3D;2,…,n）在已排好序的序列r[1…i-1]中的插入位置，然后将r[i]插人表长为i-1的有序序列r[1…i-1]，直到将r[n]插入表长为n-1的有序序列r[1…n-1]，最后得到一个表长为n的有序序列。\n\n//直接插入排序\n#include &lt;iostream&gt;\nusing namespace std;\n#define  MAXSIZE  20          \t\t\t\t\t\t//顺序表的最大长度\ntypedef struct\n&#123;\n    int key;\n    char *otherinfo;\n&#125;ElemType;\n//顺序表的存储结构                         \ntypedef struct\n&#123;\n    ElemType *r;\t         \t\t\t\t\t\t//存储空间的基地址\n    int  length;            \t\t\t\t\t\t//顺序表长度\n&#125;SqList;\t\t\t\t\t\t\t\t\t\t\t//顺序表类型\n\nvoid InsertSort(SqList &amp;L)\n&#123;\n   //对顺序表L做直接插入排序\n    int i,j;\n    for(i=2;i&lt;=L.length;++i)\n        if(L.r[i].key&lt;L.r[i-1].key)\n        &#123;   \t\t\t\t\t\t\t\t\t\t//&quot;&lt;&quot;，需将r[i]插入有序子表\n            L.r[0]=L.r[i];\t\t\t\t \t\t\t//将待插入的记录暂存到监视哨中\n            L.r[i]=L.r[i-1];\t            \t\t//r[i-1]后移\n            for(j=i-2; L.r[0].key&lt;L.r[j].key;--j)\t\t\t//从后向前寻找插入位置\n                L.r[j+1]=L.r[j];\t\t\t\t\t//记录逐个后移，直到找到插入位置\n            L.r[j+1]=L.r[0];\t\t\t\t\t\t//将r[0]即原r[i]，插入到正确位置\n        &#125;\t\t\t\t\t\t\t\t\t\t\t//if\n&#125;\t\t\t\t\t\t\t\t\t\t\t\t\t//InsertSort\n\nvoid Create_Sq(SqList &amp;L)\n&#123;\n    int i,n;\n    cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl;\n    cin&gt;&gt;n;\t\t\t\t\t\t\t\t\t\t\t//输入个数\n    cout&lt;&lt;&quot;请输入待排序的数据:\\n&quot;;\n    while(n&gt;MAXSIZE)\n    &#123;\n        cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl;\n        cin&gt;&gt;n;\n    &#125;\n    for(i=1;i&lt;=n;i++)\n    &#123;\n        cin&gt;&gt;L.r[i].key;\n        L.length++;\n    &#125;\n&#125;\nvoid show(SqList L)\n&#123;\n    int i;\n    for(i=1;i&lt;=L.length;i++)\n        cout&lt;&lt;L.r[i].key&lt;&lt;endl;\n&#125;\n\nvoid main()\n&#123;\n    SqList L;\n    L.r=new ElemType[MAXSIZE+1];\n    L.length=0;\n    Create_Sq(L);\n    InsertSort(L);\n    cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl;\n    show(L);\n&#125;\n\n例：已知待排序记录的关键字序列为{49,38,65,97,76,13,27,49 }，用直接插入排序法进行排序的过程。\n直接插入排序特点：\n\n稳定排序。\n算法简便，且容易实现。\n也适用于链式存储结构，只是在单链表上无需移动记录，只需修改相应的指针。\n更适合于初始记录基本有序（正序)的情况，当初始记录无序，n较大时，此算法时间复杂度较高，不宜采用。\n\n②.折半插入排序折半插入排序算法步骤：\n\n设待排序的记录存放在数组r[1…n]中，r[1]是一个有序序列。\n循环n-1次，每次使用折半查找法，查找ri在已排好序的序列r[1..i-1]中的插入位置，然后将r[i插入表长为i-1的有序序列r[1…i-1]，直到将r[n]插入表长为n-l的有序序列r[1…n-1]，最后得到一个表长为n的有序序列。\n\n \n//折半插入排序\n#include &lt;iostream&gt;\nusing namespace std;\n#define  MAXSIZE  20          \t\t\t//顺序表的最大长度\ntypedef struct\n&#123;\n    int key;\n    char *otherinfo;\n&#125;ElemType;\n//顺序表的存储结构                         \ntypedef struct\n&#123;\n    ElemType *r;\t         \t\t\t\t\t\t//存储空间的基地址\n    int  length;            \t\t\t\t\t\t//顺序表长度\n&#125;SqList;\t\t\t\t\t\t\t\t\t\t\t//顺序表\n\nvoid BInsertSort(SqList &amp;L)&#123;\n    //对顺序表L做折半插入排序\n    int i,j,low,high,m;\n    for(i=2;i&lt;=L.length;++i)\n    &#123;\n        L.r[0]=L.r[i];          \t\t\t\t\t//将待插入的记录暂存到监视哨中\n        low=1; high=i-1;        \t\t\t\t\t//置查找区间初值\n        while(low&lt;=high)\n        &#123;\t\t\t\t\t\t\t\t\t\t\t//在r[low..high]中折半查找插入的位置\n            m=(low+high)/2;             \t\t\t//折半\n            if(L.r[0].key&lt;L.r[m].key)  high=m-1;\t//插入点在前一子表\n            else  low=m+1;\t\t\t\t\t   \t\t//插入点在后一子表\n        &#125;//while\n        for(j=i-1;j&gt;=high+1;--j)  L.r[j+1]=L.r[j];\t//记录后移\n        L.r[high+1]=L.r[0];\t\t\t\t\t\t\t//将r[0]即原r[i]，插入到正确位置\n    &#125;\t\t\t\t\t\t\t\t\t\t\t\t//for\n&#125;\t\t\t\t\t\t\t\t\t\t\t\t\t//BInsertSort\n\nvoid Create_Sq(SqList &amp;L)\n&#123;\n    int i,n;\n    cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl;\n    cin&gt;&gt;n;\t\t\t\t\t\t\t\t\t\t\t//输入个数\n    cout&lt;&lt;&quot;请输入待排序的数据：\\n&quot;;\n    while(n&gt;MAXSIZE)\n    &#123;\n        cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl;\n        cin&gt;&gt;n;\n    &#125;\n    for(i=1;i&lt;=n;i++)\n    &#123;\n        cin&gt;&gt;L.r[i].key;\n        L.length++;\n    &#125;\n&#125;\n\nvoid show(SqList L)\n&#123;\n    int i;\n    for(i=1;i&lt;=L.length;i++)\n        cout&lt;&lt;L.r[i].key&lt;&lt;endl;\n&#125;\n\nvoid main()\n&#123;\n    SqList L;\n    L.r=new ElemType[MAXSIZE+1];\n    L.length=0;\n    Create_Sq(L);\n    BInsertSort(L);\n    cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl;\n    show(L);\n&#125;\n\n折半插入排序特点：\n\n稳定排序。\n因为要进行折半查找，所以只能用于顺序结构，不能用于链式结构。\n适合初始记录无序、n较大时的情况。\n\n③.希尔排序&#x3D;&#x3D;希尔排序：先将整个待排记录序列分割成若干子序列,分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。&#x3D;&#x3D;\n\n//希尔排序\n#include &lt;iostream&gt;\nusing namespace std;\n#define  MAXSIZE  20          \t\t\t//顺序表的最大长度\ntypedef struct\n&#123;\n    int key;\n    char *otherinfo;\n&#125;ElemType;\n//顺序表的存储结构                         \ntypedef struct\n&#123;\n    ElemType *r;\t         \t\t\t\t\t\t//存储空间的基地址\n    int  length;            \t\t\t\t\t\t//顺序表长度\n&#125;SqList;\t\t\t\t\t\t\t\t\t\t\t//顺序表类型\n\nvoid ShellInsert(SqList &amp;L,int dk)\n&#123;\n    //对顺序表L做一趟增量是dk的希尔插入排序\n    int i,j;\n    for(i=dk+1;i&lt;=L.length;++i)\n        if(L.r[i].key&lt;L.r[i-dk].key)\n        &#123;\t\t\t\t\t\t\t\t\t\t//需将L.r[i]插入有序增量子表\n            L.r[0]=L.r[i];\t\t\t\t\t\t//暂存在L.r[0]\n            for(j=i-dk;j&gt;0&amp;&amp; L.r[0].key&lt;L.r[j].key;j-=dk)\n                L.r[j+dk]=L.r[j];\t\t\t\t//记录后移，直到找到插入位置\n            L.r[j+dk]=L.r[0];\t\t\t\t\t//将r[0]即原r[i]，插入到正确位置\n        &#125;\t\t\t\t\t\t\t\t\t\t//for\n&#125;\n                                                //ShellInsert\nvoid ShellSort(SqList &amp;L,int dt[ ],int t)&#123;\n   //按增量序列dt[0..t-1]对顺序表L作t趟希尔排序\n    int k;\n    for(k=0;k&lt;t;++k)\n        ShellInsert(L,dt[k]);\t\t\t \t\t//一趟增量为dt[t]的希尔插入排序\n&#125;\t\t\t\t\t\t\t\t\t\t\t\t//ShellSort\n\nvoid Create_Sq(SqList &amp;L)\n&#123;\n    int i,n;\n    cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl;\n    cin&gt;&gt;n;\t\t\t\t\t\t\t\t\t\t//输入个数\n    cout&lt;&lt;&quot;请输入待排序的数据：\\n&quot;;\n    while(n&gt;MAXSIZE)\n    &#123;\n        cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl;\n        cin&gt;&gt;n;\n    &#125;\n    for(i=1;i&lt;=n;i++)\n    &#123;\n        cin&gt;&gt;L.r[i].key;\n        L.length++;\n    &#125;\n&#125;\n\nvoid show(SqList L)\n&#123;\n    int i;\n    for(i=1;i&lt;=L.length;i++)\n        cout&lt;&lt;L.r[i].key&lt;&lt;endl;\n&#125;\n\nvoid main()\n&#123;\n    SqList L;\n    L.r=new ElemType[MAXSIZE+1];\n    L.length=0;\n    Create_Sq(L);\n    \n    int i,t;//增量数组的长度\n    int *dt=new int[MAXSIZE];//增量数组\n    cout&lt;&lt;&quot;请输入增量个数：\\n&quot;;\n    cin&gt;&gt;t;\n    for(i=0;i&lt;t;i++)\n    &#123;\n        cout&lt;&lt;&quot;第&quot;&lt;&lt;i+1&lt;&lt;&quot;个增量:\\n&quot;;\n        cin&gt;&gt;dt[i];\n    &#125;\n    ShellSort(L,dt,t);\n    cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl;\n    show(L);\n&#125;\n\n希尔排序特点：\n\n记录跳跃式地移动导致排序方法是不稳定的。\n只能用于顺序结构，不能用于链式结构。\n增量序列可以有各种取法，但应该使增量序列中的值没有除1之外的公因子，并且最后一个增量值必须等于1。\n记录总的比较次数和移动次数都比直接插人排序要少，n越大时，效果越明显。所以适合初始记录无序、n较大时的情况。\n\n\n3、交换排序&#x3D;&#x3D;交换排序的基本思想是:两两比较待排序记录的关键字，一旦发现两个记录不满足次序要求时则进行交换，直到整个序列全部满足要求为止。&#x3D;&#x3D;\n①.冒泡排序&#x3D;&#x3D;冒泡排序(Bubble Sort)是一种最简单的交换排序方法，它通过两两比较相邻记录的关键字，如果发生逆序，则进行交换，从而使关键字小的记录如气泡一般逐渐往上“漂浮”(左移)，或者使关键字大的记录如石块一样逐渐向下“坠落”(右移)。&#x3D;&#x3D;\n冒泡排序算法步骤：\n\n设待排序的记录存放在数组r[1…n]中。首先将第一个记录的关键字和第二个记录的关键字进行比较，若为逆序（即 L.r[1].key&gt;L.r[2].key)，则交换两个记录。然后比较第二个记录和第三个记录的关键字。依次类推，直至第n-1个记录和第n个记录的关键字进行过比较为止。上述过程称作第一趟起泡排序，其结果使得关键字最大的记录被安置到最后一个记录的位置上。\n然后进行第二趟起泡排序，对前n-1个记录进行同样操作，其结果是使关键字次大的记录被安置到第n-1个记录的位置上。\n重复上述比较和交换过程,第i趟是从L.r[1]到L.r[n-i+l]依次比较相邻两个记录的关键字，并在“逆序”时交换相邻记录，其结果是这n-i+1个记录中关键字最大的记录被交换到第n-i+1的位置上。直到在某一趟排序过程中没有进行过交换记录的操作,说明序列已全部达到排序要求，则完成排序。\n\n//冒泡排序\n#include &lt;iostream&gt;\nusing namespace std;\n#define  MAXSIZE  20          \t\t\t//顺序表的最大长度\ntypedef struct\n&#123;\n    int key;\n    char *otherinfo;\n&#125;ElemType;\n//顺序表的存储结构                         \ntypedef struct\n&#123;\n    ElemType *r;\t         \t\t\t\t\t\t//存储空间的基地址\n    int  length;            \t\t\t\t\t\t//顺序表长度\n&#125;SqList;\t\t\t\t\t\t\t\t\t\t\t//顺序表类型\n\nvoid BubbleSort(SqList &amp;L)\n&#123;\n    //对顺序表L做冒泡排序\n    int m,j,flag;\n    ElemType t;\n    m=L.length-1; flag=1; \t\t\t\t//flag用来标记某一趟排序是否发生交换\n    while((m&gt;0)&amp;&amp;(flag==1))\n    &#123;\n        flag=0;           \t\t\t\t//flag置为0，如果本趟排序没有发生交换，则不会执行下一趟排序\n        for(j=1;j&lt;=m;j++)\n            if(L.r[j].key&gt;L.r[j+1].key) \n            &#123;\n                flag=1;\t\t\t\t\t//flag置为1，表示本趟排序发生了交换\n                t=L.r[j];L.r[j]=L.r[j+1];L.r[j+1]=t;\t//交换前后两个记录\n            &#125;\t\t\t\t\t\t\t//if\n        --m;\n    &#125;\t\t\t\t\t\t\t\t\t//while\n&#125;\t\t\t\t\t\t\t\t\t\t//BubbleSort\n\nvoid Create_Sq(SqList &amp;L)\n&#123;\n    int i,n;\n    cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl;\n    cin&gt;&gt;n;\t\t\t\t\t\t\t\t\t\t\t//输入个数\n    cout&lt;&lt;&quot;请输入待排序的数据:\\n&quot;;\n    while(n&gt;MAXSIZE)\n    &#123;\n        cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl;\n        cin&gt;&gt;n;\n    &#125;\n    for(i=1;i&lt;=n;i++)\n    &#123;\n        cin&gt;&gt;L.r[i].key;\n        L.length++;\n    &#125;\n&#125;\n\nvoid show(SqList L)\n&#123;\n    int i;\n    for(i=1;i&lt;=L.length;i++)\n        cout&lt;&lt;L.r[i].key&lt;&lt;endl;\n&#125;\n\nvoid main()\n&#123;\n    SqList L;\n    L.r=new ElemType[MAXSIZE+1];\n    L.length=0;\n    Create_Sq(L);\n    BubbleSort(L);\n    cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl;\n    show(L);\n&#125;\n\n例：\n冒泡排序特点：\n\n稳定排序。\n可用于链式存储结构。\n移动记录次数较多，算法平均时间性能比直接插人排序差。当初始记录无序，n较大时,此算法不宜采用。\n\n②.快速排序&#x3D;&#x3D;快速排序（ Quick Sort〉是由冒泡排序改进而得的。在冒泡排序过程中，只对相邻的两个记录进行比较，因此每次交换两个相邻记录时只能消除一个逆序。如果能通过两个(不相邻)记录的一次交换，消除多个逆序，则会大大加快排序的速度。快速排序方法中的一次交换可能消除多个逆序。&#x3D;&#x3D;\n快速排序算法步骤：\n\n选择待排序表中的第一个记录作为枢轴,将枢轴记录暂存在r[0]的位置上.附设两个指针 low和high，初始时分别指向表的下界和上界（第一趟时，low&#x3D; 1; high&#x3D; L.length; ).\n从表的最右侧位置依次向左搜索，找到第一个关键字小于枢轴关键字pivotkey 的记录,将其移到low处。具体操作是:当low&lt;high时，若high所指记录的关键字大于等于pivotkey，则向左移动指针high(执行操作–high);否则将high所指记录移到low所指记录。\n然后再从表的最左侧位置,依次向右搜索找到第一个关键字大于pivotkey的记录和枢轴记录交换。具体操作是:当low&lt;high时，若low所指记录的关键字小于等于pivotkey，则向右移动指针low(执行操作++low);否则将low所指记录与枢轴记录交换。\n重复步骤②和③，直至 low与high相等为止。此时low或high 的位置即为枢轴在此趟排序中的最终位置，原表被分成两个子表。\n\n在上述过程中，记录的交换都是与枢轴之间发生，每次交换都要移动3次记录，可以先将枢轴记录暂存在r[0]的位置上，排序过程中只移动要与枢轴交换的记录，即只做r[low]或r[high]的单向移动，直至一趟排序结束后再将枢轴记录移至正确位置上。\n//快速排序\n#include &lt;iostream&gt;\nusing namespace std;\n#define  MAXSIZE  20          \t\t\t//顺序表的最大长度\ntypedef struct\n&#123;\n    int key;\n    char *otherinfo;\n&#125;ElemType;\n//顺序表的存储结构                         \ntypedef struct\n&#123;\n    ElemType *r;\t         \t\t\t\t\t\t//存储空间的基地址\n    int  length;            \t\t\t\t\t\t//顺序表长度\n&#125;SqList;\t\t\t\t\t\t\t\t\t\t\t//顺序表类型\n\n\nint Partition(SqList &amp;L,int low,int high)\n&#123; \n    //对顺序表L中的子表r[low..high]进行一趟排序，返回枢轴位置\n    int pivotkey;\n    L.r[0]=L.r[low];                    \t//用子表的第一个记录做枢轴记录\n    pivotkey=L.r[low].key;\t\t   \t\t\t//枢轴记录关键字保存在pivotkey中\n    while(low&lt;high)\n    &#123;\t\t\t\t\t\t\t\t\t\t//从表的两端交替地向中间扫描\n        while(low&lt;high&amp;&amp;L.r[high].key&gt;=pivotkey) --high;\n        L.r[low]=L.r[high];\t\t\t\t\t//将比枢轴记录小的记录移到低端\n        while(low&lt;high&amp;&amp;L.r[low].key&lt;=pivotkey) ++low;\n        L.r[high]=L.r[low];\t\t\t\t\t//将比枢轴记录大的记录移到高端\n    &#125;//while\n    L.r[low]=L.r[0];\t\t\t\t\t\t//枢轴记录到位\n    return  low;\t\t\t\t\t\t\t//返回枢轴位置\n&#125;//Partition\n\nvoid QSort(SqList &amp;L,int low,int high)\n&#123;\t//调用前置初值：low=1; high=L.length;\n    //对顺序表L中的子序列L.r[low..high]做快速排序\n    int pivotloc;\n    if(low&lt;high)\n    &#123;\t\t\t\t\t\t\t\t\t\t//长度大于1\n       pivotloc=Partition(L,low,high); \t\t//将L.r[low..high]一分为二，pivotloc是枢轴位置\n       QSort(L,low,pivotloc-1);\t\t\t\t//对左子表递归排序\n       QSort(L,pivotloc+1,high);        \t//对右子表递归排序\n    &#125;\n&#125;\t\t\t\t\t\t\t\t\t\t\t//QSort\n\nvoid QuickSort(SqList &amp;L)\n&#123;\n   //对顺序表L做快速排序\n   QSort(L,1,L.length);\n&#125;\t\t\t\t\t\t\t\t\t\t\t//QuickSort\n                                \nvoid Create_Sq(SqList &amp;L)\n&#123;\n    int i,n;\n    cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl;\n    cin&gt;&gt;n;\t\t\t\t\t\t\t\t\t\t\t//输入个数\n    cout&lt;&lt;&quot;请输入待排序的数据:\\n&quot;;\n    while(n&gt;MAXSIZE)\n    &#123;\n        cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl;\n        cin&gt;&gt;n;\n    &#125;\n    for(i=1;i&lt;=n;i++)\n    &#123;\n        cin&gt;&gt;L.r[i].key;\n        L.length++;\n    &#125;\n&#125;\n\n\nvoid show(SqList L)\n&#123;\n    int i;\n    for(i=1;i&lt;=L.length;i++)\n        cout&lt;&lt;L.r[i].key&lt;&lt;endl;\n&#125;\n\n\nint main(void)\n&#123;\n    SqList L;\n    L.r=new ElemType[MAXSIZE+1];\n    L.length=0;\n    Create_Sq(L);\n    QuickSort(L);\n    cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl;\n    show(L);\n&#125;\n\n例：已知待排序记录的关键字序列为{49,38,65,97,76,13,27,49}，用快速排序法进行排序的过程。\n\n例：\n快速排序特点：\n\n记录非顺次的移动导致排序方法是不稳定的。\n排序过程中需要定位表的下界和上界，所以适合用于顺序结构，很难用于链式结构。\n当n较大时，在平均情况下快速排序是所有内部排序方法中速度最快的一种，所以其适合初始记录无序、n较大时的情况。\n\n\n4、选择排序&#x3D;&#x3D;选择排序的基本思想是:每一趟从待排序的记录中选出关键字最小的记录，按顺序放在已排序的记录序列的最后，直到全部排完为止。&#x3D;&#x3D;\n①.简单选择排序&#x3D;&#x3D;简单选择排序也称作直接选择排序&#x3D;&#x3D;\n简单选择排序算法步骤：\n\n设待排序的记录存放在数组r[l…n]中。第一趟从r[1]开始，通过n-1次比较，从n个记录中选出关键字最小的记录，记为r[k，交换r[1]和r[k]。\n第二趟从r[2]开始,通过n-2次比较,从n-l个记录中选出关键字最小的记录，记为r[k],交换r[2]和r[k]。\n依次类推，第i趟从r[i]开始，通过n-i次比较，从n-i+tl个记录中选出关键字最小的记录，记为r[k]，交换r[i]和r[k]。\n经过n-1趟，排序完成。\n\n//简单选择排序\n#include &lt;iostream&gt;\nusing namespace std;\n#define  MAXSIZE  20          \t\t\t\t\t\t//顺序表的最大长度\ntypedef struct\n&#123;\n    int key;\n    char *otherinfo;\n&#125;ElemType;\n//顺序表的存储结构                         \ntypedef struct\n&#123;\n    ElemType *r;\t         \t\t\t\t\t\t//存储空间的基地址\n    int  length;            \t\t\t\t\t\t//顺序表长度\n&#125;SqList;\t\t\t\t\t\t\t\t\t\t\t//顺序表类型\n\nvoid SelectSort(SqList &amp;L) \n&#123; \n   //对顺序表L做简单选择排序\n    int i,j,k;\n    ElemType t;\n    for(i=1;i&lt;L.length;++i) \n    &#123;  \t\t\t\t\t\t\t\t\t\t\t\t//在L.r[i..L.length] 中选择关键字最小的记录\n        k=i;                 \n        for(j=i+1;j&lt;=L.length;++j)\n            if(L.r[j].key&lt;L.r[k].key)  k=j;\t\t\t//k指向此趟排序中关键字最小的记录\n        if(k!=i) &#123;t=L.r[i];L.r[i]=L.r[k];L.r[k]=t;&#125; //交换r[i]与r[k]        \n     &#125;\t\t\t\t\t\t\t\t\t\t\t\t//for  \n&#125;\t\t\t\t\t\t\t\t\t\t\t\t\t// SelectSort\n                                \nvoid Create_Sq(SqList &amp;L)\n&#123;\n    int i,n;\n    cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl;\n    cin&gt;&gt;n;\t\t\t\t\t\t\t\t\t\t\t//输入个数\n    cout&lt;&lt;&quot;请输入待排序的数据:\\n&quot;;\n    while(n&gt;MAXSIZE)\n    &#123;\n        cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl;\n        cin&gt;&gt;n;\n    &#125;\n    for(i=1;i&lt;=n;i++)\n    &#123;\n        cin&gt;&gt;L.r[i].key;\n        L.length++;\n    &#125;\n&#125;\n\nvoid show(SqList L)\n&#123;\n    int i;\n    for(i=1;i&lt;=L.length;i++)\n        cout&lt;&lt;L.r[i].key&lt;&lt;endl;\n&#125;\n\nvoid main()\n&#123;\n    SqList L;\n    L.r=new ElemType[MAXSIZE+1];\n    L.length=0;\n    Create_Sq(L);\n    SelectSort(L);\n    cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl;\n    show(L);\n&#125;\n\n例：已知待排序记录的关键字序列为{ 49,38,65,97,49,13,27,76}，给出用简单选择排序法进行排序的过程。\n简单选择排序特点：\n\n就选择排序方法本身来讲，它是一种稳定的排序方法，但例子所表现出来的现象是不稳定的，这是因为上述实现选择排序的算法采用“交换记录”的策略所造成的，改变这个策略，可以写出不产生“不稳定现象”的选择排序算法。\n可用于链式存储结构。\n移动记录次数较少，当每一记录占用的空间较多时，此方法比直接插人排序快。\n\n②.树形选择排序&#x3D;&#x3D;树形选择排序(Tree Selection Sort):又称锦标赛排序，是一种按照锦标赛的思想进行选择排序的方法。借助有n个叶子结点的完全二叉树，两两比较选最小。这个过程可用一颗有n个叶子结点的完全二叉树表示。&#x3D;&#x3D;\n\n③.堆排序&#x3D;&#x3D;堆排序（Heap Sort）是一种树形选择排序，在排序过程中，将待排序的记录r[1..n]看成是一棵完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的内在关系，在当前无序的序列中选择关键字最大（或最小)的记录。&#x3D;&#x3D;\n堆的定义：\nn个元素的序列{k1,k2,…,kn}称之为堆，当且仅当满足以下条件时:\n\nki≥k2i且ki≥k2i+1(大顶堆)\n或ki≤k2i且 ki≤k2i+1(小顶堆)\n\n若将和此序列对应的一维数组(即以一维数组做此序列的存储结构)看成是一个完全二叉树，则堆实质上是满足如下性质的完全二叉树:树中所有非终端结点的值均不大于(或不小于)其左、右孩子结点的值。\n\n按堆的定义将待排序序列r[ 1..n]调整为大根堆（这个过程称为建初堆)，交换r[1]和r[n],则r[n]为关键字最大的记录。\n将r[ 1..n-1]重新调整为堆,交换r[1]和r[n-1]，则r[n-1]为关键字次大的记录。\n循环n-1次，直到交换了r[1]和r[2]为止，得到了一个非递减的有序序列r[ 1..n]。\n\n调整堆\n先看一个例子，图（ a)是个堆，将堆顶元素97和堆中最后–个元素38交换后，如图( b)所示。由于此时除根结点外，其余结点均满足堆的性质，由此仅需自上至下进行一条路径上的结点调整即可。首先以堆顶元素38和其左、右子树根结点的值进行比较，由于左子树根结点的值大于右子树根结点的值且大于根结点的值，则将38和76交换;由于38替代了76之后破坏了左子树的“堆”，则需进行和上述相同的调整，直至叶子结点，调整后的状态如图( c )所示。重复上述过程，将堆顶元素76和堆中最后一个元素27交换且调整，得到如图( d）所示新的堆。\n\n上述过程就像过筛子一样，把较小的关键字逐层筛下去，而将较大的关键字逐层选上来。因此，称此方法为“筛选法”。\n筛选法调整堆：从r[2s]和r[2s+I]中选出关键字较大者，假设r[2s]的关键字较大，比较r[s]和r[2s]的关键字。\n\n若r[s].key&gt; &#x3D;r[2s].key，说明以r[s]为根的子树已经是堆，不必做任何调整。\n若r[s].key&lt;r[2s].key，交换r[s]和r[2s]。交换后，以r[2s+I]为根的子树仍是堆,如果以r[2s]为根的子树不是堆，则重复上述过程，将以r[2s]为根的子树调整为堆，直至进行到叶子结点为止。\n\n//筛选法调整堆\n#include &lt;iostream&gt;\nusing namespace std;\n#define  MAXSIZE  20          \t\t\t\t\t\t//顺序表的最大长度\ntypedef struct\n&#123;\n    int key;\n    char *otherinfo;\n&#125;ElemType;\n//顺序表的存储结构                         \ntypedef struct\n&#123;\n    ElemType *r;\t         \t\t\t\t\t\t//存储空间的基地址\n    int  length;            \t\t\t\t\t\t//顺序表长度\n&#125;SqList;\t\t\t\t\t\t\t\t\t\t\t//顺序表类型\n\nvoid HeapAdjust(SqList &amp;L,int s,int m)\n&#123; \n   //假设r[s+1..m]已经是堆，将r[s..m]调整为以r[s]为根的大根堆\n    ElemType rc;\n    int j;\n    rc=L.r[s];\n    for(j=2*s;j&lt;=m;j*=2)\n    &#123;\t\t\t\t\t\t\t\t\t\t\t\t//沿key较大的孩子结点向下筛选\n        if(j&lt;m&amp;&amp;L.r[j].key&lt;L.r[j+1].key) ++j;\t\t//j为key较大的记录的下标\n        if(rc.key&gt;=L.r[j].key) break;      \t\t\t//rc应插入在位置s上\n        L.r[s]=L.r[j]; s=j; \n    &#125;\n    L.r[s]=rc;                          \t\t\t//插入\n&#125;\t\t\t\t\t\t\t\t\t\t\t\t\t//HeapAdjust\n                                \nvoid Create_Sq(SqList &amp;L)\n&#123;\n    int i,n;\n    cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl;\n    cin&gt;&gt;n;\t\t\t\t\t\t\t\t\t\t\t//输入个数\n    cout&lt;&lt;&quot;请输入待调整的数据:\\n&quot;;\n    while(n&gt;MAXSIZE)\n    &#123;\n        cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl;\n        cin&gt;&gt;n;\n    &#125;\n    for(i=1;i&lt;=n;i++)\n    &#123;\n        cin&gt;&gt;L.r[i].key;\n        L.length++;\n    &#125;\n&#125;\nvoid show(SqList L)\n&#123;\n    int i;\n    for(i=1;i&lt;=L.length;i++)\n        cout&lt;&lt;L.r[i].key&lt;&lt;endl;\n&#125;\nvoid main()\n&#123;\n    SqList L;\n    L.r=new ElemType[MAXSIZE+1];\n    L.length=0;\n    Create_Sq(L);\n    HeapAdjust(L,1,L.length);\n    cout&lt;&lt;&quot;调整后的结果为：&quot;&lt;&lt;endl;\n    show(L);\n&#125;\n\n建初堆\n要将一个无序序列调整为堆，就必须将其所对应的完全二叉树中以每一结点为根的子树都调整为堆。显然，只有一个结点的树必是堆，而在完全二叉树中，所有序号大于[n&#x2F;2]的结点都是叶子,因此以这些结点为根的子树均已是堆。这样，只需利用筛选法,从最后一个分支结点|n&#x2F;2]开始，依次将序号为|n&#x2F;2]、[n&#x2F;2]-1…、1的结点作为根的子树都调整为堆即可。对于无序序列r[1…n]，从i&#x3D;n&#x2F;2开始，反复调用筛选法HeapAdjust (L,in)，依次将以r团],r[i-1],…,r[1]为根的子树调整为堆。\n//建初堆\n#include &lt;iostream&gt;\nusing namespace std;\n#define  MAXSIZE  20          \t\t\t\t\t\t//顺序表的最大长度\ntypedef struct\n&#123;\n    int key;\n    char *otherinfo;\n&#125;ElemType;\n//顺序表的存储结构                         \ntypedef struct\n&#123;\n    ElemType *r;\t         \t\t\t\t\t\t//存储空间的基地址\n    int  length;            \t\t\t\t\t\t//顺序表长度\n&#125;SqList;\t\t\t\t\t\t\t\t\t\t\t//顺序表类型\n\n//用算法8.7 筛选法调整堆\nvoid HeapAdjust(SqList &amp;L,int s,int m)\n&#123; \n   //假设r[s+1..m]已经是堆，将r[s..m]调整为以r[s]为根的大根堆\n    ElemType rc;\n    int j;\n    rc=L.r[s];\n    for(j=2*s;j&lt;=m;j*=2)\n    &#123;\t\t\t\t\t\t\t\t\t\t\t\t//沿key较大的孩子结点向下筛选\n        if(j&lt;m&amp;&amp;L.r[j].key&lt;L.r[j+1].key) ++j;\t\t//j为key较大的记录的下标\n        if(rc.key&gt;=L.r[j].key) break;      \t\t\t//rc应插入在位置s上\n        L.r[s]=L.r[j]; s=j; \n    &#125;\n    L.r[s]=rc;                          \t\t\t//插入\n&#125;\t\t\t\t\t\t\t\t\t\t\t\t\t//HeapAdjust\n                                \nvoid Create_Sq(SqList &amp;L)\n&#123;\n    int i,n;\n    cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl;\n    cin&gt;&gt;n;\t\t\t\t\t\t\t\t\t\t\t//输入个数\n    cout&lt;&lt;&quot;请输入数据:\\n&quot;;\n    while(n&gt;MAXSIZE)\n    &#123;\n        cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl;\n        cin&gt;&gt;n;\n    &#125;\n    for(i=1;i&lt;=n;i++)\n    &#123;\n        cin&gt;&gt;L.r[i].key;\n        L.length++;\n    &#125;\n&#125;\n\nvoid CreatHeap(SqList &amp;L)\n&#123;\n    //把无序序列L.r[1..n]建成大根堆\n    int i,n;\n    n=L.length;\n    for(i=n/2;i&gt;0;--i)       \t\t\t\t\t//反复调用HeapAdjust \n        HeapAdjust(L,i,n);\n&#125;\t\t\t\t\t\t\t\t\t\t\t\t//CreatHeap\nvoid show(SqList L)\n&#123;\n    int i;\n    for(i=1;i&lt;=L.length;i++)\n        cout&lt;&lt;L.r[i].key&lt;&lt;endl;\n&#125;\n\nvoid main()\n&#123;\n    SqList L;\n    L.r=new ElemType[MAXSIZE+1];\n    L.length=0;\n    Create_Sq(L);\n    CreatHeap(L);\n    cout&lt;&lt;&quot;建立成堆的序列为：&quot;&lt;&lt;endl;\n    show(L);\n&#125;\n\n例：\n已知无序序列为{49,38,65,97,76,13,27,49}，用“筛选法”将其调整为一个大根堆,给出建堆的过程。堆排序算法的实现：\n//排序\n#include &lt;iostream&gt;\nusing namespace std;\n#define  MAXSIZE  20          \t\t\t\t\t\t//顺序表的最大长度\ntypedef struct\n&#123;\n    int key;\n    char *otherinfo;\n&#125;ElemType;\n//顺序表的存储结构                         \ntypedef struct\n&#123;\n    ElemType *r;\t         \t\t\t\t\t\t//存储空间的基地址\n    int  length;            \t\t\t\t\t\t//顺序表长度\n&#125;SqList;\t\t\t\t\t\t\t\t\t\t\t//顺序表类型\n\n//用算法8.7 筛选法调整堆\nvoid HeapAdjust(SqList &amp;L,int s,int m)\n&#123; \n   //假设r[s+1..m]已经是堆，将r[s..m]调整为以r[s]为根的大根堆\n    ElemType rc;\n    int j;\n    rc=L.r[s];\n    for(j=2*s;j&lt;=m;j*=2)\n    &#123;\t\t\t\t\t\t\t\t\t\t\t\t//沿key较大的孩子结点向下筛选\n        if(j&lt;m&amp;&amp;L.r[j].key&lt;L.r[j+1].key) ++j;\t\t//j为key较大的记录的下标\n        if(rc.key&gt;=L.r[j].key) break;      \t\t\t//rc应插入在位置s上\n        L.r[s]=L.r[j]; s=j; \n    &#125;\n    L.r[s]=rc;                          \t\t\t//插入\n&#125;\n                                                    //HeapAdjust\t\t\t\t\t\t\t\t\nvoid Create_Sq(SqList &amp;L)\n&#123;\n    int i,n;\n    cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl;\n    cin&gt;&gt;n;\t\t\t\t\t\t\t\t\t\t\t//输入个数\n    cout&lt;&lt;&quot;请输入待排序的数据:\\n&quot;;\n    while(n&gt;MAXSIZE)\n    &#123;\n        cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl;\n        cin&gt;&gt;n;\n    &#125;\n    for(i=1;i&lt;=n;i++)\n    &#123;\n        cin&gt;&gt;L.r[i].key;\n        L.length++;\n    &#125;\n&#125;\n\n//用算法8.8 建初堆\nvoid CreatHeap(SqList &amp;L)\n&#123;\n    //把无序序列L.r[1..n]建成大根堆\n    int i,n;\n    n=L.length;\n    for(i=n/2;i&gt;0;--i)       \t\t\t\t\t//反复调用HeapAdjust \n        HeapAdjust(L,i,n);\n&#125;\t\t\t\t\t\t\t\t\t\t\t\t//CreatHeap\n\nvoid HeapSort(SqList &amp;L) \n&#123; \n    //对顺序表L进行堆排序 \n    int i;\n    ElemType x;\n    CreatHeap(L);              \t\t\t\t\t//把无序序列L.r[1..L.length]建成大根堆 \n    for(i=L.length;i&gt;1;--i)\n    &#123; \n        x=L.r[1];               \t\t\t\t//将堆顶记录和当前未经排序子序列L.r[1..i]中最后一个记录互换 \n        L.r[1]=L.r[i];            \n        L.r[i]=x; \n        HeapAdjust(L,1,i-1);\t\t\t\t\t//将L.r[1..i-1]重新调整为大根堆 \n   &#125;//for \n&#125;//HeapSort\nvoid show(SqList L)\n&#123;\n    int i;\n    for(i=1;i&lt;=L.length;i++)\n        cout&lt;&lt;L.r[i].key&lt;&lt;endl;\n&#125;\nvoid main()\n&#123;\n    SqList L;\n    L.r=new ElemType[MAXSIZE+1];\n    L.length=0;\n    Create_Sq(L);\n    HeapSort(L);\n    cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl;\n    show(L);\n&#125;\n\n例：对建好的大根堆进行排序\n\n堆排序特点：\n\n是不稳定排序。\n只能用于顺序结构，不能用于链式结构。\n初始建堆所需的比较次数较多，因此记录数较少时不宜采用。堆排序在最坏情况下时间复杂度为O(nlog2n)，相对于快速排序最坏情况下的O(n^2^)而言是一个优点，当记录较多时较为高效。\n\n\n5、归并排序&#x3D;&#x3D;归并排序(Merging Sort)就是将两个或两个以上的有序表合并成一个有序表的过程。将两个有序表合并成一个有序表的过程称为⒉-路归并，2-路归并最为简单和常用。下面以2-路归并为例，介绍归并排序算法。&#x3D;&#x3D;\n归并排序算法的思想是:\n假设初始序列含有n个记录，则可看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到⌈n&#x2F;2⌉ 个长度为2或1的有序子序列;再两两归并，……，如此重复、直至得到一个长度为n的有序序列为止。\n归并排序算法步骤：\n2-路归并排序将R[low..high]中的记录归并排序后放入T[low.high]中。当序列长度等于1时，递归结束，否则:\n\n将当前序列一分为二，求出分裂点mid &#x3D;⌊(low+high)&#x2F;2⌋;\n对子序列R[low..mid]递归，进行归并排序，结果放入S[low..mid]中;\n对子序列R[mid + 1..high]递归，进行归并排序，结果放入S[mid + 1..high]中;\n调用算法Merge，将有序的两个子序列S[low..mid]和 S[mid +1..high]归并为一个有序的序列T[low..high]。\n\n//归并排序\n#include &lt;iostream&gt;\nusing namespace std;\n#define  MAXSIZE  20          \t\t\t\t\t\t//顺序表的最大长度\ntypedef struct\n&#123;\n    int key;\n    char *otherinfo;\n&#125;RedType;\n\ntypedef struct\n&#123;\n    RedType *r;\n    int length;\n&#125;SqList;\n                                                                        \nvoid Create_Sq(SqList &amp;L)\n&#123;\n    int i,n;\n    cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;个。&quot;&lt;&lt;endl;\n    cin&gt;&gt;n;\t\t\t\t\t\t\t\t\t\t\t//输入个数\n    cout&lt;&lt;&quot;请输入待排序的数据:\\n&quot;;\n    while(n&gt;MAXSIZE)\n    &#123;\n        cout&lt;&lt;&quot;个数超过上限，不能超过&quot;&lt;&lt;MAXSIZE&lt;&lt;&quot;，请重新输入&quot;&lt;&lt;endl;\n        cin&gt;&gt;n;\n    &#125;\n    for(i=1;i&lt;=n;i++)\n    &#123;\n        cin&gt;&gt;L.r[i].key;\n        L.length++;\n    &#125;\n&#125;\n\n//相邻两个有序子序列的归并\nvoid Merge(RedType R[],RedType T[],int low,int mid,int high)\n&#123; \n   //将有序表R[low..mid]和R[mid+1..high]归并为有序表T[low..high] \n    int i,j,k;\n    i=low; j=mid+1;k=low; \n    while(i&lt;=mid&amp;&amp;j&lt;=high)\n    &#123;                 \t\n        //将R中记录由小到大地并入T中 \n        if(R[i].key&lt;=R[j].key) T[k++]=R[i++]; \n        else T[k++]=R[j++]; \n    &#125; \n    while(i&lt;=mid)                            \t\t//将剩余的R[low..mid]复制到T中 \n        T[k++]=R[i++];                 \n    while(j&lt;=high)                           \t\t//将剩余的R[j.high]复制到T中 \n        T[k++]=R[j++];                       \n&#125;//Merge \n\nvoid MSort(RedType R[],RedType T[],int low,int high)\n&#123; \n    //R[low..high]归并排序后放入T[low..high]中 \n    int mid;\n    RedType *S=new RedType[MAXSIZE];\n    if(low==high) T[low]=R[low]; \n    else\n    &#123; \n        mid=(low+high)/2;       \t\t\t\t\t//将当前序列一分为二，求出分裂点mid \n        MSort(R,S,low,mid);\t\t\t\t\t\t\t//对子序列R[low..mid] 递归归并排序，结果放入S[low..mid] \n        MSort(R,S,mid+1,high);\t\t\t\t\t\t//对子序列R[mid+1..high] 递归归并排序，结果放入S[mid+1..high] \n        Merge(S,T,low,mid,high);\t\t\t\t\t//将S[low..mid]和S [mid+1..high]归并到T[low..high]  \n    &#125;//else \n&#125;// MSort \n \nvoid MergeSort(SqList &amp;L)\n&#123; \n    //对顺序表L做归并排序 \n    MSort(L.r,L.r,1,L.length); \n&#125;//MergeSort \nvoid show(SqList L)\n&#123;\n    int i;\n    for(i=1;i&lt;=L.length;i++)\n        cout&lt;&lt;L.r[i].key&lt;&lt;endl;\n&#125;\nvoid main()\n&#123;\n    SqList R;\n    R.r=new RedType[MAXSIZE+1];\n    R.length=0;\n    Create_Sq(R);\n    MergeSort(R);\n    cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl;\n    show(R);\n&#125;\n\n例：已知待排序记录的关键字序列为{49,38,65,97,76,13,27}，给出用2-路归并排序法进行排序的过程。\n\n归并排序特点：\n\n是稳定排序。\n可用于链式结构，且不需要附加存储空间，但递归实现时仍需要开辟相应的递归工作栈。\n\n\n6、基数排序&#x3D;&#x3D;借助多关键字排序的思想对单逻辑关键字进行排序。即:用关键字不同的位值进行排序。&#x3D;&#x3D;\n“多关键字”排序\n例:对一副扑克牌该如何排序?若规定花色和面值的顺序关系为:花色:面值:2&lt;3&lt;4&lt;5&lt;6&lt;7&lt;8&lt;9&lt;10&lt;J&lt;Q&lt;K&lt;A则可以先按花色排序，花色相同者再按面值排序;也可以先按面值排序，面值相同者再按花色排序。\n多关键字排序的实现方法通常有两种:\n最高位优先法MSD (Most Significant Digit first)最低位优先法LSD (Least Significant Digit first)\n//基数排序\n#include &lt;iostream.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;math.h&gt;\n#define MAXNUM_KEY 8                \t//关键字项数的最大值 \n#define RADIX 10                        //关键字基数，此时是十进制整数的基数 \n#define MAX_SPACE 10000 \ntypedef char KeysType;\t\t\t\t\t//定义关键字类型为字符型\ntypedef int InfoType;\t\t\t\t\t//定义其它数据项的类型\ntypedef struct\n&#123; \n    KeysType keys[MAXNUM_KEY];          //关键字 \n    InfoType otheritems;               \t//其他数据项 \n    int next; \n&#125;SLCell;\t\t\t\t\t\t    \t//静态链表的结点类型 \ntypedef struct\n&#123; \n    SLCell r[MAX_SPACE];\t\t        //静态链表的可利用空间，r[0]为头结点 \n    int keynum;\t\t\t\t         \t//记录的当前关键字个数 \n    int recnum;\t\t\t\t\t     \t//静态链表的当前长度 \n&#125;SLList;\t\t\t\t\t\t\t    //静态链表类型 \ntypedef int ArrType[RADIX];\t          \t//指针数组类型\n\nvoid InitList(SLList *L)\n&#123; \n    //初始化静态链表L（把数组D中的数据存于L中）\n    char c[MAXNUM_KEY],c1[MAXNUM_KEY];\n    int i,j,n,max;\t\t\t\t\t\t//max为关键字的最大值 \n    max=-10000;\n    cout&lt;&lt;&quot;请输入数据个数，不超过&quot;&lt;&lt;MAX_SPACE&lt;&lt;&quot;个。\\n&quot;;\n    cin&gt;&gt;n;\n    while(n&gt;MAX_SPACE)\n    &#123;\n        cout&lt;&lt;&quot;您输入的个数超过上限，请重新输入，不超过&quot;&lt;&lt;MAX_SPACE&lt;&lt;&quot;个。\\n&quot;;\n        cin&gt;&gt;n;\n    &#125;\n    int *D=new int[n];\n    cout&lt;&lt;&quot;请输入&quot;&lt;&lt;n&lt;&lt;&quot;个排排序的数据：\\n&quot;;\n    for(i=0;i&lt;n;i++)\n    &#123;\n        cin&gt;&gt;D[i];\n        if(max&lt;D[i])\n            max=D[i];\n    &#125;\n    (*L).keynum=(int)(ceil(log10(max)));\n    (*L).recnum=n;\n    for(i=1;i&lt;=n;i++)\n    &#123;\n        itoa(D[i-1],c,10);\t\t\t\t\t//将10进制整型转化为字符型,存入c \n        for(j=strlen(c);j&lt;(*L).keynum;j++)  //若c的长度&lt;max的位数,在c前补&#39;0&#39; \n        &#123;\n           strcpy(c1,&quot;0&quot;);\n           strcat(c1,c);\n           strcpy(c,c1);\n        &#125;\n        for(j=0;j&lt;(*L).keynum;j++)\n            (*L).r[i].keys[j]=c[(*L).keynum-1-j];\n    &#125;\n&#125;\n\nint ord(char c)\n&#123;\t\n    //返回k的映射(个位整数)\n    return c-&#39;0&#39;;\n&#125;\nvoid Distribute(SLCell *r,int i,ArrType &amp;f,ArrType &amp;e)\n&#123; \n    //静态链表L的r域中记录已按（keys[0], …, keys[i-1]）有序 \n    //本算法按第i个关键字keys[i]建立RADIX个子表，使同一子表中记录的keys[i]相同。 \n    //f[0..RADIX-1]和e[0..RADIX-1]分别指向各子表中第一个和最后一个记录\n    int j,p;\n    for(j=0;j&lt;RADIX;++j)  f[j]=0;        \t//各子表初始化为空表 \n    for(p=r[0].next;p;p=r[p].next)\n    &#123; \n        j=ord(r[p].keys[i]);                //ord将记录中第i个关键字映射到[0..RADIX-1] \n        if(!f[j])  f[j]=p; \n        else  r[e[j]].next=p; \n        e[j]=p;                          \t//将p所指的结点插入第j个子表中 \n    &#125;//for \n&#125;//Distribute \n\nint succ(int i)\n&#123; \n    //求后继函数\n    return ++i;\n&#125;\nvoid Collect (SLCell *r,int i,ArrType &amp;f,ArrType &amp;e)\n&#123; \n    //本算法按keys[i]自小至大地将f[0..RADIX-1]所指各子表依次链接成一个链表 \n    //e[0..RADIX-1]为各子表的尾指针\n    int j,t;\n    for(j=0;!f[j];j=succ(j));  \t\t\t//找第一个非空子表，succ为求后继函数 \n    r[0].next=f[j];t=e[j];   \t\t\t//r[0].next指向第一个非空子表中第一个结点 \n    while(j&lt;RADIX-1)\n    &#123; \n        for(j=succ(j);j&lt;RADIX-1&amp;&amp;!f[j];j=succ(j)) ;       \t//找下一个非空子表 \n        if(f[j])  &#123;r[t].next=f[j];t=e[j];&#125;\t\t        \t//链接两个非空子表 \n    &#125;//while \n    r[t].next=0;                \t\t//t指向最后一个非空子表中的最后一个结点 \n&#125;//Collect \n\nvoid RadixSort(SLList &amp;L)\n&#123; \n    //L是采用静态链表表示的顺序表 \n    //对L做基数排序，使得L成为按关键字自小到大的有序静态链表，L.r[0]为头结点\n    int i;\n    ArrType f,e;\n    for(i=0;i&lt;L.recnum;++i)  L.r[i].next=i+1; \n    L.r[L.recnum].next = 0;             \t//将L改造为静态链表 \n    for(i=0;i&lt;L.keynum;++i) \n    &#123;       \t\n        //按最低位优先依次对各关键字进行分配和收集 \n        Distribute(L.r,i,f,e);\t\t     \t//第i趟分配 \n        Collect(L.r,i,f,e);\t\t\t\t\t//第i趟收集 \n    &#125;//for \n&#125; // RadixSort\n \nvoid print(SLList L)\n&#123;  \n    //按数组序号输出静态链表\n    int i,j;\n    for(i=1;i&lt;=L.recnum;i++)\n    &#123;\n        for(j=L.keynum-1;j&gt;=0;j--)\n            cout&lt;&lt;L.r[i].keys[j];\n        cout&lt;&lt;endl;\n    &#125;\n&#125;\nvoid Sort(SLList L,int adr[]) \n&#123; \n    //求得adr[1..L.length]，adr[i]为静态链表L的第i个最小记录的序号\n    int i=1,p=L.r[0].next;\n    while(p)\n    &#123;\n        adr[i++]=p;\n        p=L.r[p].next;\n    &#125;\n&#125;\nvoid Rearrange(SLList *L,int adr[])\n&#123; \n    //adr给出静态链表L的有序次序，即L.r[adr[i]]是第i小的记录。\n    //本算法按adr重排L.r，使其有序。算法10.18(L的类型有变) \n    int i,j,k;\n    if(adr[i]!=i)\n    &#123;\n        j=i;\n        (*L).r[0]=(*L).r[i]; //暂存记录(*L).r[i]\n        while(adr[j]!=i)\n        &#123; \n            //调整(*L).r[adr[j]]的记录到位直到adr[j]=i为止\n            k=adr[j];\n            (*L).r[j]=(*L).r[k];\n            adr[j]=j;\n            j=k; //记录按序到位 \n        &#125;\n        (*L).r[j]=(*L).r[0];\n        adr[j]=j;\n    &#125;\n&#125;\n\nvoid main()\n&#123;\n    SLList l;\n    int *adr;\n    InitList(&amp;l);\n    RadixSort(l);\n    adr=new int[l.recnum];\n    Sort(l,adr);\n    Rearrange(&amp;l,adr);\n    cout&lt;&lt;&quot;排序后(重排记录):\\n&quot;;\n    print(l);\n&#125; \n\n\n7、总结\n\n8、例题与应用\n实现快速排序\n\n#include&lt;bits/stdc++.h&gt; \nusing namespace std;\n\ntypedef struct\n&#123;\n    int key;\n    char *otherinfo;\n&#125;ElemType;\n//顺序表的存储结构                         \ntypedef struct\n&#123;\n    ElemType *r;\n    int  length;\n&#125;SqList;\n//对顺序表的子表进行一趟排序，返回枢轴位置 \nint Division(SqList &amp;L,int low,int high)\n&#123; \n    int pivotkey;\n    L.r[0]=L.r[low];\n    pivotkey=L.r[low].key;\n    while(low&lt;high)\n    &#123;\n        while(low&lt;high&amp;&amp;L.r[high].key&gt;=pivotkey) --high;\n        L.r[low]=L.r[high];\n        while(low&lt;high&amp;&amp;L.r[low].key&lt;=pivotkey) ++low;\n        L.r[high]=L.r[low];\n    &#125;\n    L.r[low]=L.r[0];\n    return  low;\n&#125;\n//对顺序表做快速排序 \nvoid QSort(SqList &amp;L,int low,int high)\n&#123;  \n    int pivotloc;\n    if(low&lt;high)\n    &#123;\t\t\t\t\t\t\t\t\t\t\n       pivotloc=Division(L,low,high); \t\t\n       QSort(L,low,pivotloc-1);\t\t\t\n       QSort(L,pivotloc+1,high);\n    &#125;\n&#125;\n//进行快速排序 \nvoid QuickSort(SqList &amp;L)\n&#123;\n   QSort(L,1,L.length);\n&#125;\n//输入待排序的数据\t\t\t\t\t\t\t\t\nvoid Create_Sq(SqList &amp;L)\n&#123;\n    int i,n;\n    cout&lt;&lt;&quot;\\t源码实现\\t&quot;&lt;&lt;endl;\n    cout&lt;&lt;&quot;请输入待排序的10个数据:\\n&quot;;\n    for(i=1;i&lt;=10;i++)\n    &#123;\n        cin&gt;&gt;L.r[i].key;\n        L.length++;\n    &#125;\n&#125;\n//输出排序好的数据 \nvoid Show(SqList L)\n&#123;\n    int i;\n    for(i=1;i&lt;=L.length;i++)\n        cout&lt;&lt;L.r[i].key&lt;&lt;&quot; &quot;;\n&#125;\n\nint main(void)\n&#123;\n    SqList L;\n    L.r=new ElemType[11];\n    L.length=0;\n    Create_Sq(L);\n    QuickSort(L);\n    cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl;\n    Show(L);\n&#125;\n\n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main(void)\n&#123;\n    int L[10];\n    int i;\n    cout&lt;&lt;&quot;\\tSTL实现\\t&quot;&lt;&lt;endl;\n    cout&lt;&lt;&quot;请输入待排序的10个数据:\\n&quot;;\n    for(i=0;i&lt;10;i++)\n        cin&gt;&gt;L[i];\n    sort(L,L+10);\n    cout&lt;&lt;&quot;排序后的结果为：&quot;&lt;&lt;endl;\n    for(i=0;i&lt;10;i++)\n        cout&lt;&lt;L[i]&lt;&lt;&quot; &quot;;\n    return 0;\n &#125; \n\n","slug":"数据结构（C语言版）-- 排序笔记","date":"2022-02-20T13:06:27.000Z","categories_index":"前端","tags_index":"字节跳动青训营","author_index":"会思想的苇草i"},{"id":"c6ad7ccbed505349c9093570c864bff1","title":"查找","content":"\n1、查找的基本概念查找表\n&#x3D;&#x3D;查找表是由同―类型的数据元素（或记录）构成的集合。&#x3D;&#x3D;\n关键字\n&#x3D;&#x3D;关键字是数据元素(或记录）中某个数据项的值，用它可以标识一个数据元素（或记录)。若此关键字可以唯一地标识一个记录，则称此关键字为主关键字（对不同的记录，其主关键字均不同)。反之，称用以识别若干记录的关键字为次关键字。当数据元素只有一个数据项时，其关键字即为该数据元素的值。&#x3D;&#x3D;\n查找\n&#x3D;&#x3D;查找是指根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或数据元素。若表中存在这样的一个记录，则称查找成功，此时查找的结果可给出整个记录的信息，或指示该记录在查找表中的位置;若表中不存在关键字等于给定值的记录，则称查找不成功，此时查找的结果可给出一个“空”记录或“空”指针。&#x3D;&#x3D;\n动态查找表和静态查找表\n&#x3D;&#x3D;若在查找的同时对表做修改操作(如插入和删除)，则相应的表称之为动态查找表，否则称之为静态查找表。换句话说，动态查找表的表结构本身是在查找过程中动态生成的，即在创建表时，对于给定值，若表中存在其关键字等于给定值的记录，则查找成功返回;否则插入关键字等于给定值的记录。&#x3D;&#x3D;\n平均查找长度\n&#x3D;&#x3D;为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值，称为查找算法，在查找成功时的平均查找长度。( Average Search Length，ASL )。&#x3D;&#x3D;\n\n\n2、线性表的查找①.顺序查找顺序查找( Sequential Search )的查找过程为:从表的一端开始，依次将记录的关键字和给定值进行比较，若某个记录的关键字和给定值相等，则查找成功;反之，若扫描整个表后，仍未找到关键字和给定值相等的记录，则查找失败。\n顺序查找方法既适用于线性表的顺序存储结构，又适用于线性表的链式存储结构。\n\n//顺序查找\n#include&lt;iostream&gt;\nusing namespace std;\n#define MAXSIZE 100\n#define OK 1;\n\ntypedef struct&#123;\n    int key;//关键字域\n&#125;ElemType;\n\ntypedef struct&#123;\n    ElemType *R;\n    int length;\n&#125;SSTable;\n\nint InitList_SSTable(SSTable &amp;L)\n&#123;\n    L.R=new ElemType[MAXSIZE];\n    if (!L.R)\n    &#123;\n        cout&lt;&lt;&quot;初始化错误&quot;;\n        return 0;\n    &#125;\n    L.length=0;\n    return OK;\n&#125;\n\nint Insert_SSTable(SSTable &amp;L) \n&#123;\n    int j=0;\n    for(int i=0;i&lt;MAXSIZE;i++)\n    &#123;\n        L.R[i].key=j;\n        L.length++;\n        j++;\n    &#125;\n    return 1;\n&#125;\n\nint Search_Seq(SSTable ST, int key)&#123;\n    //在顺序表ST中顺序查找其关键字等于key的数据元素。若找到，则函数值为\n    //该元素在表中的位置，否则为0\n     for (int i=ST.length; i&gt;=1; --i)  \n             if (ST.R[i].key==key) return i;\t\t//从后往前找        \n     return 0;\n   &#125;// Search_Seq\n\nvoid Show_End(int result,int testkey)\n&#123;\n    if(result==0)\n        cout&lt;&lt;&quot;未找到&quot;&lt;&lt;testkey&lt;&lt;endl;\n    else\n        cout&lt;&lt;&quot;找到&quot;&lt;&lt;testkey&lt;&lt;&quot;位置为&quot;&lt;&lt;result&lt;&lt;endl;\n    return;\n&#125;\nvoid main()\n&#123;\n    SSTable ST;\n    InitList_SSTable(ST);\n    Insert_SSTable(ST);\n    int testkey1=7,testkey2=200;\n    int result;\n    result=Search_Seq(ST, testkey1);\n    Show_End(result,testkey1);\n    result=Search_Seq(ST, testkey2);\n    Show_End(result,testkey2);\n&#125;\n\n改进:把待查关键字key存入表头（“哨兵”），从后向前逐个比较，可免去查找过程中每一步都要检测是否查找完毕，加快速度。\n\n//设置监视哨的顺序查找\n#include&lt;iostream&gt;\nusing namespace std;\n#define MAXSIZE 100\n#define OK 1;\n\ntypedef struct&#123;\n    int key;//关键字域\n&#125;ElemType;\n\ntypedef struct&#123;\n    ElemType *R;\n    int length;\n&#125;SSTable;\n\nint InitList_SSTable(SSTable &amp;L)\n&#123;\n    L.R=new ElemType[MAXSIZE];\n    if (!L.R)\n    &#123;\n        cout&lt;&lt;&quot;初始化错误&quot;;\n        return 0;\n    &#125;\n    L.length=0;\n    return OK;\n&#125;\n\nint Insert_SSTable(SSTable &amp;L) \n&#123;\n    int j=1;//空出ST.R[0]的位置\n    for(int i=1;i&lt;MAXSIZE;i++)\n    &#123;\n        L.R[i].key=j;\n        L.length++;\n        j++;\n    &#125;\n    return 1;\n&#125;\n\nint Search_Seq(SSTable ST, int key)&#123;\n      //在顺序表ST中顺序查找其关键字等于key的数据元素。若找到，则函数值为\n      //该元素在表中的位置，否则为0\n     ST.R[0].key = key;                          \t\t\t//“哨兵”\n     for(int i = ST.length; ST.R[i].key!=key; --i)  ;\t\t//从后往前找\n     return i;                                         \n&#125;// Search_Seq\nvoid Show_End(int result,int testkey)\n&#123;\n    if(result==0)\n        cout&lt;&lt;&quot;未找到&quot;&lt;&lt;testkey&lt;&lt;endl;\n    else\n        cout&lt;&lt;&quot;找到&quot;&lt;&lt;testkey&lt;&lt;&quot;位置为&quot;&lt;&lt;result&lt;&lt;endl;\n    return;\n&#125;\nvoid main()\n&#123;\n    SSTable ST;\n    InitList_SSTable(ST);\n    Insert_SSTable(ST);\n    int testkey1=7,testkey2=200;\n    int result;\n    result=Search_Seq(ST, testkey1);\n    Show_End(result,testkey1);\n    result=Search_Seq(ST, testkey2);\n    Show_End(result,testkey2);\n&#125;\n\n顺序查找的时间复杂度为O（n）。\n顺序查找的优点是:算法简单，对表结构无任何要求，既适用于顺序结构，也适用于链式结构，无论记录是否按关键字有序均可应用。\n其缺点是:平均查找长度较大，查找效率较低，所以当n很大时，不官采用顺序查找。\n②.折半查找&#x3D;&#x3D;折半查找(Binary Search )也称二分查找，它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列（顺序有序）。&#x3D;&#x3D;\n折半查找的查找过程为:从表的中间记录开始，如果给定值和中间记录的关键字相等，则查找成功;如果给定值大于或者小于中间记录的关键字，则在表中大于或小于中间记录的那一半中查找，这样重复操作，直到查找成功，或者在某一步中查找区间为空，则代表查找失败。\n设表长为n, low、high和mid分别指向待查元素所在区间的上界、下界和中点，key为要查找的值\n\n初始时，令low&#x3D;1 , high&#x3D;n, mid&#x3D;⌊(1ow+high)&#x2F;2⌋\n让key与mid指向的记录比较- 若key&#x3D;&#x3D;R[ mid].key，查找成功- 若key&lt;R[mid].key，则high&#x3D;mid-1- 若key&gt;R[mid].key，则low&#x3D;mid+1\n重复上述操作，直至low&gt;high时，查找失败\n\n\n//折半查找\n#include&lt;iostream&gt;\nusing namespace std;\n#define MAXSIZE 100\n#define OK 1;\n\ntypedef struct&#123;\n    int key;//关键字域\n&#125;ElemType;\n\ntypedef struct&#123;\n    ElemType *R;\n    int length;\n&#125;SSTable;\n\nint InitList_SSTable(SSTable &amp;L)\n&#123;\n    L.R=new ElemType[MAXSIZE];\n    if (!L.R)\n    &#123;\n        cout&lt;&lt;&quot;初始化错误&quot;;\n        return 0;\n    &#125;\n    L.length=0;\n    return OK;\n&#125;\n\nint Insert_SSTable(SSTable &amp;L) \n&#123;\n    int j=1;\n    for(int i=1;i&lt;MAXSIZE;i++)\n    &#123;\n        L.R[i].key=j;\n        L.length++;\n        j++;\n    &#125;\n    return 1;\n&#125;\n\nint Search_Bin(SSTable ST,int key) &#123;\n   // 在有序表ST中折半查找其关键字等于key的数据元素。若找到，则函数值为\n   // 该元素在表中的位置，否则为0\n   int low=1,high=ST.length;\t\t\t\t\t\t\t//置查找区间初值\n   int  mid;\n   while(low&lt;=high) &#123;\n       mid=(low+high) / 2;\n      if (key==ST.R[mid].key)  return mid;      \t\t//找到待查元素\n      else if (key&lt;ST.R[mid].key)  high = mid -1;\t\t//继续在前一子表进行查找\n      else  low =mid +1;                       \t\t\t//继续在后一子表进行查找\n   &#125;//while\n   return 0;\t\t\t\t\t\t\t\t\t\t//表中不存在待查元素\n&#125;// Search_Bin\n\nvoid Show_End(int result,int testkey)\n&#123;\n    if(result==0)\n        cout&lt;&lt;&quot;未找到&quot;&lt;&lt;testkey&lt;&lt;endl;\n    else\n        cout&lt;&lt;&quot;找到&quot;&lt;&lt;testkey&lt;&lt;&quot;位置为&quot;&lt;&lt;result&lt;&lt;endl;\n    return;\n&#125;\n\nvoid main()\n&#123;\n    SSTable ST;\n    InitList_SSTable(ST);\n    Insert_SSTable(ST);\n    int testkey1=7,testkey2=200;\n    int result;\n    result=Search_Bin(ST, testkey1);\n    Show_End(result,testkey1);\n    result=Search_Bin(ST, testkey2);\n    Show_End(result,testkey2);\n&#125;\n\n折半查找的时间复杂度为O(log2n )。可见，折半查找的效率比顺序查找高，但折半查找只适用于有序表，且限于顺序存储结构。\n折半查找的优点是：比较次数少，查找效率高。\n其缺点是:对表结构要求高，只能用于顺序存储的有序表。查找前需要排序，而排序本身是一种费时的运算。同时为了保持顺序表的有序性，对有序表进行插人和删除时，平均比较和移动表中一半元素，这也是一种费时的运算。因此，折半查找不适用于数据元素经常变动的线性表。\n③.分块查找\n分块有序，即分成若干子表，要求每个子表中的数值都比后一块中数值小(但子表内部未必有序)。\n建立“索引表”，索引表包括:- 关键字项:各子表中的最大关键字。- 指针项:指示该子表的起始地址。\n\n\n\n先确定待查记录所在块- 对索引表使用折半查找法(因为索引表是有序表);\n确定了待查关键字所在的子表后，在子表内采用顺序查找法（因为各子表内部是无序表);\n\n分块查找的优点是:在表中插人和删除数据元素时，只要找到该元素对应的块，就可以在该块内进行插人和删除运算。由于块内是无序的，故插人和删除比较容易，无需进行大量移动。如果线性表既要快速查找又经常动态变化，则可采用分块查找。\n其缺点是:要增加一个索引表的存储空间并对初始索引表进行排序运算。\n\n3、树表的查找①.二叉排序树二叉排序树（Binary Sort Tree）又称二叉查找树，它是一种对排序和查找都很有用的特殊二叉树。\n二叉排序树的定义\n二叉排序树或者是一棵空树，或者是具有下列性质的二叉树:\n\n&#x3D;&#x3D;若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值;&#x3D;&#x3D;\n&#x3D;&#x3D;若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值;&#x3D;&#x3D;\n&#x3D;&#x3D;它的左、右子树也分别为二叉排序树。&#x3D;&#x3D;\n\n二叉排序树是递归定义的。由定义可以得出二叉排序树的一个重要性质:中序遍历一棵二叉树时可以得到一个结点值递增的有序序列。\n\n二叉树排序树的操作-查找\n\n若二叉排序树为空，则查找失败，返回空指针。\n若二叉排序树非空，将给定值key与根结点的关键字T-&gt;data.key进行比较:- 若key&#x3D;&#x3D;T-&gt;data.key，则查找成功，返回根结点地址;- 若keydata.key，则进一步查找左子树;- 若key&gt;T-&gt;data.key，则进一步查找右子树。\n\n二叉树排序树的操作-插入\n\n若二叉排序树为空，则待插入结点*S作为根结点插入到空树中。\n若二叉排序树非空，则将key与根结点的关键字T&gt;data.key进行比较:- 若key小于T-&gt;data.key，则将S插入左子树;- 若key大于T&gt;data,key，则将S插入右子树。\n\n二叉树排序树的操作-创建\n\n将二叉排序树T初始化为空树。\n读入一个关键字为key的结点。\n如果读入的关键字key不是输入结束标志，则循环执行以下操作:- 将此结点插入二叉排序树T中;- 读人一个关键字为key的结点。\n\n例：设关键字的输入次序为：45,24,53,45,12,24,90，写出二叉排序树的创建过程。\n\n二叉树排序树的操作-删除\n原则:删除后保持所有节点的中序遍历顺序不变删除一个结点，不能把以该结点为根的子树都删掉，将因删除结点而断开的二叉链表重新链接起来假设被删结点为p(即p指针指向的结点)，其双亲为f，p是f的左孩子(或右孩子)，分三种情况︰\n\n被删结点*p为叶子结点\n\n2. 被删结点*p只有左子树或右子树\n3. 被删结点*p既有左子树又有右子树\n\n//二叉排序树的综合操作\n#include&lt;iostream&gt;\nusing namespace std;\n#define ENDFLAG &#39;#&#39;\n//char a[10]=&#123;&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;2&#39;,&#39;1&#39;,&#39;9&#39;,&#39;8&#39;,&#39;10&#39;,&#39;3&#39;,&#39;4&#39;,&#39;#&#39;&#125;;//全局变量\ntypedef struct ElemType&#123;\t\n    char key;\n&#125;ElemType;\n\ntypedef struct BSTNode&#123;\n    ElemType data;\t//结点数据域\n    BSTNode *lchild,*rchild;\t//左右孩子指针\n&#125;BSTNode,*BSTree;\n\n\n//二叉排序树的递归查找\nBSTree SearchBST(BSTree T,char key) &#123;\n  //在根指针T所指二叉排序树中递归地查找某关键字等于key的数据元素\n  //若查找成功，则返回指向该数据元素结点的指针，否则返回空指针\n  if((!T)|| key==T-&gt;data.key) return T;       \t            \t//查找结束\n  else if (key&lt;T-&gt;data.key)  return SearchBST(T-&gt;lchild,key);\t//在左子树中继续查找\n  else return SearchBST(T-&gt;rchild,key);    \t\t   \t\t\t//在右子树中继续查找\n&#125; // SearchBST\n\n\n\n//二叉排序树的插入\nvoid InsertBST(BSTree &amp;T,ElemType e ) &#123;\n  //当二叉排序树T中不存在关键字等于e.key的数据元素时，则插入该元素\n  if(!T) &#123;                \t\t\t\t//找到插入位置，递归结束\n         BSTree S = new BSTNode;            \t\t//生成新结点*S\n         S-&gt;data = e;                  \t\t//新结点*S的数据域置为e   \n         S-&gt;lchild = S-&gt;rchild = NULL;\t//新结点*S作为叶子结点\n         T =S;            \t\t\t\t//把新结点*S链接到已找到的插入位置\n  &#125;\n  else if (e.key&lt; T-&gt;data.key) \n      InsertBST(T-&gt;lchild, e );\t\t\t//将*S插入左子树\n  else if (e.key&gt; T-&gt;data.key) \n      InsertBST(T-&gt;rchild, e);\t\t\t//将*S插入右子树\n&#125;// InsertBST\n\n\n\n//二叉排序树的创建\nvoid CreateBST(BSTree &amp;T ) &#123;\n  //依次读入一个关键字为key的结点，将此结点插入二叉排序树T中\n  T=NULL;\n  ElemType e;\n  cin&gt;&gt;e.key;        //???\n  while(e.key!=ENDFLAG)&#123;   \t//ENDFLAG为自定义常量，作为输入结束标志\n    InsertBST(T, e);          \t//将此结点插入二叉排序树T中\n    cin&gt;&gt;e.key;\t\t\t//???\n  &#125;//while            \n&#125;//CreatBST\n\nvoid DeleteBST(BSTree &amp;T,char key) &#123;\n  //从二叉排序树T中删除关键字等于key的结点\n  BSTree p=T;BSTree f=NULL;                     \t\t\t//初始化\n  BSTree q;\n  BSTree s;\n  /*------------下面的while循环从根开始查找关键字等于key的结点*p-------------*/\n  while(p)&#123;                  \n   if (p-&gt;data.key == key) break;  \t      \t//找到关键字等于key的结点*p，结束循环\n   f=p;                                \t\t\t//*f为*p的双亲结点\n   if (p-&gt;data.key&gt; key)  p=p-&gt;lchild;     \t//在*p的左子树中继续查找\n   else p=p-&gt;rchild;  \t                  \t\t//在*p的右子树中继续查找\n  &#125;//while\nif(!p) return;                         \t\t//找不到被删结点则返回\n/*―考虑三种情况实现p所指子树内部的处理：*p左右子树均不空、无右子树、无左子树―*/\nif ((p-&gt;lchild)&amp;&amp; (p-&gt;rchild)) &#123;     \t\t//被删结点*p左右子树均不空\n     q = p;\n     s = p-&gt;lchild;\n     while (s-&gt;rchild)                \t\t\t//在*p的左子树中继续查找其前驱结点，即最右下结点\n       &#123;q = s; s = s-&gt;rchild;&#125;\t         \t\t//向右到尽头\n     p-&gt;data = s-&gt;data;               \t\t\t//s指向被删结点的“前驱”\n     if(q!=p)&#123;\n         q-&gt;rchild = s-&gt;lchild;     \t//重接*q的右子树\n     &#125;\n     else q-&gt;lchild = s-&gt;lchild;        \t\t//重接*q的左子树\n     delete s;\n  &#125;//if\nelse&#123;\n    if(!p-&gt;rchild) &#123;               \t\t//被删结点*p无右子树，只需重接其左子树\n          q = p; p = p-&gt;lchild; \n      &#125;//else if\n    else if(!p-&gt;lchild) &#123;               \t\t//被删结点*p无左子树，只需重接其右子树\n         q = p; p = p-&gt;rchild;\n      &#125;//else if\n    /*――――――――――将p所指的子树挂接到其双亲结点*f相应的位置――――――――*/\n      if(!f) T=p;                       \t\t\t//被删结点为根结点\n      else if (q==f-&gt;lchild) f-&gt;lchild = p;   \t//挂接到*f的左子树位置\n      else f-&gt;rchild = p;                 \t\t//挂接到*f的右子树位置\n      delete q;\n    &#125;\n&#125;//DeleteBST\n\n//二叉排序树的删除\n\n//中序遍历\nvoid InOrderTraverse(BSTree &amp;T)\n&#123;\n    if(T)\n    &#123;\n    InOrderTraverse(T-&gt;lchild);\n    cout&lt;&lt;T-&gt;data.key;\n    InOrderTraverse(T-&gt;rchild);\n    &#125;\n&#125;\n\nvoid main()\n&#123;\n    BSTree T;\n    cout&lt;&lt;&quot;请输入若干字符，用回车区分，以#结束输入&quot;&lt;&lt;endl;\n    CreateBST(T);\n    cout&lt;&lt;&quot;当前有序二叉树中序遍历结果为&quot;&lt;&lt;endl;\n    InOrderTraverse(T);\n    char key;//待查找或待删除内容\n    cout&lt;&lt;&quot;请输入待查找字符&quot;&lt;&lt;endl;\n    cin&gt;&gt;key;\n    BSTree result=SearchBST(T,key);\n    if(result)\n    &#123;cout&lt;&lt;&quot;找到字符&quot;&lt;&lt;key&lt;&lt;endl;&#125;\n    else\n    &#123;cout&lt;&lt;&quot;未找到&quot;&lt;&lt;key&lt;&lt;endl;&#125;\n    cout&lt;&lt;&quot;请输入待删除的字符&quot;&lt;&lt;endl;\n    cin&gt;&gt;key;\n    DeleteBST(T,key);\n    cout&lt;&lt;&quot;当前有序二叉树中序遍历结果为&quot;&lt;&lt;endl;\n    InOrderTraverse(T);\n&#125;\n\n②.平衡二叉树平衡二叉树又称AVL树\n\n一棵AVL树或者是空树，或者是具有下列性质的二叉排序树:  - &#x3D;&#x3D;它的左子树和右子树都是AVL树，且左子树和右子树的深度之差的绝对值不超过1。&#x3D;&#x3D;  - &#x3D;&#x3D;左子树和右子树也是AVL树。&#x3D;&#x3D;\n\n每个结点附加一个数字，给出该结点平衡因子BF。\n&#x3D;&#x3D;BF:该结点的左子树深度和右子树深度之差。&#x3D;&#x3D;\n&#x3D;&#x3D;AVL树任一结点平衡因子只能取-1，0，1。&#x3D;&#x3D;\n\n平衡二叉树的平衡调整方法\n如果在一棵AVL树中插入一个新结点，就有可能造成失衡，此时必须重新调整树的结构，使之恢复平衡。\n调整方法:找到离插入点最近且平衡因子绝对值超过1的祖先结点，以该结点为根的子树称为最小不平衡子树，可将重新平衡的范围局限于这颗子树。\n平衡二叉树的插入\n在向一棵本来是AVL树中插入一个新结点时，如果树中某个结点的平衡因子的绝对值|balance| &gt; 1，则出现了不平衡，需要做平衡化处理。算法︰从一棵空树开始，通过输入一系列关键字，逐步建立AVL树。在插入新结点时使用平衡旋转方法进行平衡化处理。\n例：\n③.B-树B-树的概念\nB-树是由R.Bayer和E.Maccreight于1970年提出的，是一种特殊的多叉树，是一种在外存文件系统中常用的动态索引技术，是大型数据库文件的一种组织结构。B-树中的每个结点大小都相同。\nB-树的结点结构\n\n\nm称为B-树的阶,m≥3\npar为指向父亲结点的指针域\nK1、K2、…Kn为n个按从小到大顺序排列的关键字\n对非根结点⌈m&#x2F;2⌉-1≤n≤m-1\nP0、P1、P2,、…Pn为n+1个指针，分别指向该结点的n+1棵子树\n\n\n每个结点关键字最少&#x3D;⌈m&#x2F;2⌉-1&#x3D;2-1&#x3D;1;最多&#x3D;m-1&#x3D;3，每个结点的子树数目最少为⌈m&#x2F;2⌉&#x3D;2，最多为m&#x3D;4。不管每个结点实际使用了多少个关键字域和指针域，它都包含4个关键字域、4个指向记录存储位置的指针域、5个指向孩子结点的指针域、一个指向父亲结点的指针域和一个保存关键字个数的n域。\nB-树的特点\n\n一棵m阶B-树(m叉树)是一棵平衡的m路搜索树,它或者是空树,或者是满足下列性质的树:  - 根结点至少有2个子树。  - 除根结点以外的所有结点(不包括失败结点)至少有⌈m&#x2F;2⌉个子树。  - 所有的失败结点（叶子结点)都位于同一层。  - 每个结点最多有m棵子树。\n在B-树中的“失败”结点是当搜索值x不在树中时才能到达的结点。\n关键字的插入次序不同，将生成不同结构的B-树。\n一棵B-树是平衡的m路搜索树，但一棵平衡的m路搜索树不一定是B-树。\n\nB-树的搜索算法\n\nB-树的搜索过程是一个在结点内搜索和循某一条路径向下一层搜索交替进行的过程。\nB-树的搜索时间与B-树的阶数m和B-树的高度h直接有关,必须加以权衡。\n在B-树上进行搜索，搜索成功所需的时间取决于关键码所在的层次;搜索不成功所需的时间取决于树的高度。\n\n高度h与关键码个数N之间的关系\n设在m阶B-树中每层结点个数达到最少,则B-树的高度可能达到最大。设树中关键码个数为N，从B-树的定义知:h-1层至少有2⌈m&#x2F;2⌉^h-2^个结点。\nm值的选择\n如果提高B-树的阶数m,可以减少树的高度,从而减少读入结点的次数,因而可减少读磁盘的次数。事实上,m受到内存可使用空间的限制。当m很大超出内存工作区容量时,结点不能一次读入到内存，增加了读盘次数，也增加了结点内搜索的难度。&#x3D;&#x3D;m值的选择:应使得在B-树中找到关键码×的时间总量达到最小。&#x3D;&#x3D;这个时间由两部分组成:从磁盘中读入结点所用时间+在结点中搜索x所用时间。\nB-树的插入\n\n在B-树中查找给定关键字的记录，若查找成功，则插入操作失败;否则将新记录作为空指针p插入到查找失败的叶子结点的上一层结点（由q指向）中。\n若插人新记录和空指针后，q指向的结点的关键字个数未超过m-l，则插人操作成功，否则转入步骤③。\n以该结点的第⌈m&#x2F;2⌉个关键字K⌈m&#x2F;2⌉为拆分点，将该结点分成3个部分:K⌈m&#x2F;2⌉左边部分、K⌈m&#x2F;2⌉、K⌈m&#x2F;2⌉右边部分。K⌈m&#x2F;2⌉左边部分仍然保留在原结点中;K⌈m&#x2F;2⌉右边部分存放在一个新创建的结点(由p指向）中;关键字值为K⌈m&#x2F;2⌉的记录和指针p插人到q的双亲结点中。因q的双亲结点增加一个新的记录，所以必须对q的双亲结点重复②和③的操作，依次类推，直至由q指向的结点是根结点，转入步骤④。\n④由于根结点无双亲，则由其分裂产生的两个结点的指针p和q，以及关键字为K⌈m&#x2F;2⌉的记录构成一个新的根结点。此时，B-的高度增加1。\n\n\n\nB- 树的删除\n在B-树上删除一个关键码时，首先需要找到这个关键码所在的结点,从中删去这个关键码。若该结点不是叶结点,且被删关键码为Ki;,1 ≤i≤n,则在删去该关键码之后,应以该结点Pi;所指示子树中的最小关键码×来代替被删关键码Ki;所在的位置,然后在×所在的叶结点中删除x。\n//B-树的查找\n//B-树的插入\n\n\n#include&lt;iostream&gt;\nusing namespace std;\n#define FALSE 0\n#define TRUE 1\n#define OK 1\n#define m 3\t\t\t\t\t\t//B-树的阶，暂设为3\ntypedef struct BTNode&#123;\n    int keynum;\t\t\t\t\t//结点中关键字的个数，即结点的大小\n    BTNode *parent;\t\t\t\t//指向双亲结点\n    int key[m+1];\t\t\t\t//关键字矢量，0号单元未用\n    BTNode *ptr[m+1];\t\t\t//子树指针矢量\n&#125;BTNode,*BTree;\n\n//- - - - - B-树的查找结果类型定义- - - - -\nstruct Result&#123;\n  BTNode *pt;     \t\t\t\t\t\t\t//指向找到的结点\n  int i;           \t\t\t\t\t\t\t//1..m，在结点中的关键字序号\n  int tag;         \t\t\t\t\t\t\t//1：查找成功，0：查找失败\n&#125;; \t                           \n\n\nint Search(BTree T,int key)\n&#123;\n    BTree p=T;\t\n    int endnum;\n    if(p)\t\t\t\t\t\t//树不为空时\n    &#123;\n        endnum=p-&gt;keynum;\t\t//获得首节点包含的记录个数\n    &#125;\n    else\n    &#123;\n        return 0;\t\t\t\t//返回没找到\n    &#125;\n    int i=0;\n    if(endnum==0)\n    &#123;\n        return i;\t\t\t\t//树存在，但仅有一个为空根节点\n    &#125;\n    else if(key&gt;=p-&gt;key[endnum])//节点不为空，但当前值比最大的key还大\n    &#123;\n        i=endnum;\n        return i;\n    &#125;\n    else if(key&lt;=p-&gt;key[1])\t\t//节点不为空，但当前值比最小的key还小\n    &#123;\n        return i;&#125;\n    else\n    &#123;\n        for(i=1;i&lt;endnum;i++)\t//有合适的位置，即处于当前结点的最大和最小值之间，或找到了\n        &#123;\n            if(p-&gt;key[i]&lt;=key &amp;&amp; key&lt;p-&gt;key[i+1])\n                return i;\n        &#125;\n    &#125;\n&#125;\n\nvoid Insert(BTree &amp;q,int i,int x,BTree &amp;ap)\n&#123;//将x插入q结点的i+1位置中\n    int j;\n    for(j=m-1;j&gt;i;j--)\t\t\t\n    &#123;\n        //将插入位置之后的key全部后移一位\n        q-&gt;key[j+1]=q-&gt;key[j];\n    &#125;\n    for(j=m;j&gt;i;j--)\n    &#123;\n        //相应地也移动其后ptr的位置\n        q-&gt;ptr[j]=q-&gt;ptr[j-1];\n    &#125;\n    q-&gt;key[i+1]=x;//插入x到该位置\n    q-&gt;ptr[i+1]=ap;\n    q-&gt;keynum++;\n&#125;\n\nvoid split(BTree &amp;q,int s,BTree &amp;ap)\n&#123;\t//将q-&gt;key[s+1,..,m], q-&gt;ptr[s+1,..,m]移入新结点*ap作为右结点\n    //原结点作为新的左侧结点\n    //中间值被保存在ap[0]-&gt;key中，等待找到跳转回InsertBTree（）寻找到到合适的插入位置插入\n    int i;\n    ap=new BTNode;\n    for(i=s+1;i&lt;=m;i++)\n    &#123;\t//将q-&gt;key[s+1,..,m]保存到ap-&gt;key[0,..,m-s+1]中\n        //将q-&gt;ptr[s+1,..,m]保存到ap-&gt;ptr[0,..,m-s+1]中\n        ap-&gt;key[i-s-1]=q-&gt;key[i];\t\n        ap-&gt;ptr[i-s-1]=q-&gt;ptr[i];\n    &#125;\n    if(ap-&gt;ptr[0])\n    &#123;\n        //当ap有子树的时候\n        for(i=0;i&lt;=1;i++)\n        &#123;\n            //将ap的子树的父亲改为ap自己\n            ap-&gt;ptr[i]-&gt;parent=ap;\n        &#125;\n    &#125;\n    ap-&gt;keynum=(m-s)-1;\n    ap-&gt;parent=q-&gt;parent;//将ap的父亲改为q的父亲\n\n    q-&gt;keynum=q-&gt;keynum-(m-s);//修改q的记录个数\n&#125;\n\nvoid NewRoot(BTree &amp;T,BTree q,int x,BTree &amp;ap)//生成含信息（T, x, ap）的新的根结点*T，原T和ap为子树指针\n&#123;\n    BTree newT=new BTNode;//新建一个结点作为新的根\n    \n    newT-&gt;key[1]=x;//写入新根的key[1]\n    newT-&gt;ptr[0]=T;//将原来的树根作为新根的左子树\n    newT-&gt;ptr[1]=ap;//ap作为新根的右子树\n    newT-&gt;keynum=1;\n    newT-&gt;parent=NULL;//新根的父亲为空\n\n    ap-&gt;parent=newT;//ap的父亲为新根\n    T-&gt;parent=newT;//T的父亲为新根\n\n    T=newT;//树改成新根引导的\n&#125;\n\n//B-树的插入\nint InsertBTree(BTree &amp;T,int K,BTree q,int i)&#123;\n  int x=K;\n  BTree ap=NULL;\n  int finished=FALSE;//x表示新插入的关键字，ap为一个空指针\n  while(q&amp;&amp;!finished)&#123;\n    Insert(q,i,x,ap);      \t\t//将x和ap分别插入到q-&gt;key[i+1]和q-&gt;ptr[i+1]\n    if (q-&gt;keynum&lt;m)\n        finished=TRUE;   \t//插入完成\n    else&#123;                      \t//分裂结点*q\n     int s= m/2;\n     split(q,s,ap);\n    x=ap-&gt;key[0];//\t x=q-&gt;key[s];\n      //将q-&gt;key[s+1..m], q-&gt;ptr[s..m]和q-&gt;recptr[s+1..m] 移入新结点*ap\n      q=q-&gt;parent;\n      if(q)\n      &#123;\n          i=Search(q,x);\n      &#125;\t\t//在双亲结点*q中查找x的插入位置\n    &#125;\t\t\t\t\t\t//else\n  &#125;\t\t\t\t\t\t\t//while\n  if(!finished)    \t\t\t//T是空树（参数q初值为NULL）或者根结点已分裂为结点*q和*ap\n      NewRoot(T,q,x,ap);\t\t//生成含信息（T, x, ap）的新的根结点*T，原T和ap为子树指针\n  return  OK;\n&#125;\t\t\t\t\t\t\t//InsertBTree\t\t\t\t\t\t//InsertBTree\n\n//B-树的查找\nResult SearchBTree(BTree &amp;T, int key)&#123;\n    /*在m阶B-树T上查找关键字key，返回结果(pt,i,tag)。若查找成功，则特征值tag=1，指针pt所指结点中第i个关键字等于key；否则特征值tag=0，等于key的关键字应插入在指针pt所指结点中第i和第i+1个关键字之间*/\n    BTree p=T;\n    BTree q=NULL;\n    int found=FALSE;\n    int i=0;\t\t\t//初始化，p指向待查结点，q指向p的双亲\nwhile(p&amp;&amp;!found)&#123;\n    i=Search(p,key);               \t\n    //在p-＞key[1..keynum]中查找i，使得：p-＞key[i]＜=key＜p-＞key[i+1]\n    if(i&gt;0&amp;&amp;p-&gt;key[i]==key)\n        found=TRUE;\t\t//找到待查关键字\n    else\n    &#123;\n        q=p;\n        p=p-&gt;ptr[i];\n    &#125;\n  &#125;\n    Result result;\nif(found)\n&#123;\n    result.pt=p;\n    result.i=i;\n    result.tag=1;\n    return result;\n&#125;              \t\t//查找成功\nelse\n&#123;\n    result.pt=q;\n    result.i=i;\n    result.tag=0;\n    return result;\n&#125;              \t\t\t//查找不成功，返回K的插入位置信息\n&#125;//SearchBTree\n\nvoid InitialBTree(BTree &amp;T)\n&#123;\n    //初始化一个空的根\n    T-&gt;keynum=0;\t\t\n    T-&gt;parent=NULL;\t\n    for(int i=0;i&lt;m+1;i++)\n    &#123;\n        T-&gt;ptr[i]=NULL;\n    &#125;\n&#125;\n\n\n\nvoid main()\n&#123;\n    BTree T=new BTNode;\n    InitialBTree(T);\n    //先用SearchBTree()找到要插入的位置，得到一个Result结构体\n    //再用InsertBTree()插入数据\n    Result result;\n    int a[11]=&#123;45,24,53,90,3,12,50,61,70,100&#125;;\n    for(int i=0;i&lt;10;i++)\n    &#123;\n        result=SearchBTree(T,a[i]);\n        if(result.tag==0)\n        &#123;\n            InsertBTree(T,a[i],result.pt,result.i);\n        &#125;\n    &#125;\n    cout&lt;&lt;&quot;OK&quot;;\n&#125;\n\n④.B+树m阶B+树的定义\n\n树中每个非叶结点最多有m棵子树;\n根结点(非叶结点)至少有2棵子树。除根结点外，其它的非叶结点至少有⌈m&#x2F;2⌉棵子树;\n所有叶结点都处于同一层次上，包含了全部关键码及指向相应数据对象存放地址的指针，且叶结点本身按关键码从小到大顺序链接。\n\n\n\n在B+树中有两个头指针:一个指向B+树的根结点，一个指向关键码最小的叶结点。\n\n可对B+树进行两种搜索运算:\n循叶结点链顺序搜索另一种是从根结点开始,进行自顶向下,直至叶结点的随机搜索。在B+树上进行随机搜索、插入和删除的过程基本上与B-树类似。只是在搜索过程中，如果非叶结点上的关键码等于给定值，搜索并不停止，而是继续沿右指针向下，一直查到叶结点上的这个关键码。\nB+树的搜索分析\nB+树的插入仅在叶结点上进行。每插入一个(关键码-指针)索引项后都要判断结点中的子树棵数是否超出范围。当插入后结点中的子树棵数n &gt; m1 时，需要将叶结点分裂为两个结点，它们的关键码分别为⌈(m1+1)&#x2F;2⌉和⌊(m1+1)&#x2F;2⌋.它们的双亲结点中应同时包含这两个结点的最大关键码和结点地址。此后，问题归于在非叶结点中的插入了。\nB+树的删除\n仅在叶结点上进行。当在叶结点上删除一个(关键码-指针)索引项后,结点中的子树棵数仍然不少于⌈m1&#x2F;2⌉，这属于简单删除，其上层索引可以不改变。如果删除的关键码是该结点的最小关键码,但因在其上层的副本只是起了一个引导搜索的“分界关键码”的作用,所以上层的副本仍然可以保留。如果在叶结点中删除一个(关键码-指针)索引项后，该结点中的子树棵数n小于结点子树棵数的下限⌈m1&#x2F;2⌉，必须做结点的调整或合并工作。\n如果右兄弟结点的子树棵数已达到下限⌈m1&#x2F;2⌉ ，没有多余的关键码可以移入被删关键码所在的结点，必须进行两个结点的合并。将右兄弟结点中的所有(关键码-指针)索引项移入被删关键码所在结点，再将右兄弟结点删去。结点的合并将导致双亲结点中“分界关键码”的减少，有可能减到叶结点中子树棵数的下限⌈m&#x2F;2⌉以下。这样将引起非叶结点的调整或合并。如果根结点的最后两个子女结点合并，树的层数就会减少一层。\nB-树与B+树的差异\nB树分为B-树和B＋树，它们的树结构大致相同。一个m阶的B+树与B-树的差异是:\n\n在B-树中，每个结点含有n个关键字和n+1棵子树，而在B+树中，每个结点含有n个关键字和n棵子树;\n在B-树中，每个结点(除根结点外）中的关键字个数n的取值范围是:⌈m&#x2F;2⌉-1≤n≤m-1;在B+树中，每个结点（除根结点外）中的关键字个数n的取值范围是:⌈m&#x2F;2⌉ ≤n≤m，树根结点的取值范围是:1≤n≤m。\nB＋树中的所有叶子结点包含了全部关键字及指向对应记录的指针，且所有叶子结点按关键字从小到大的顺序依次链接;\nB＋树中所有非叶子结点仅起到索引的作用，即结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。\n\n\n4、散列表的查找①.散列表的基本概念&#x3D;&#x3D;散列表：是一个有限连续的地址空间，是一种存储结构。&#x3D;&#x3D;\n&#x3D;&#x3D;散列地址:数据元素（记录)的存储位置。&#x3D;&#x3D;\n通常情况下︰散列表是一维数组，散列地址是数组的下标。\n&#x3D;&#x3D;散列函数:在数据元素（记录)的存储位置p和关键字key之间建立一个确定的对应关系H，使p&#x3D;H(key)，称这个对应关系H为散列函数，p为散列地址。&#x3D;&#x3D;\n&#x3D;&#x3D;散列方法：选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放。查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键字进行比较，确定查找是否成功。&#x3D;&#x3D;\n&#x3D;&#x3D;冲突：不同的关键字映射到同一个散列地址，即key 1≠key2，而H(key1)&#x3D;H(key2)，这种现象称为冲突，key1和key2互称为同义词。&#x3D;&#x3D;\n②.散列函数的构造方法直接定址法\n即H(key)&#x3D;a·key + b (a、b为常数)。\n\n优点:这种散列函数计算简单，并且不可能有冲突发生。\n缺点:当关键字的分布基本连续时，可用直接定址法的散列函数;否则，若关键字分布不连续将造成内存单元的大量浪费。\n如:H(学号)&#x3D;学号-201816010101\n\n除留余数法\n设散列表长度为m，用关键字key除以一个不大于m的数p，所得的余数作为散列地址的方法。除留余数法的散列函数H(key)为:H(key)&#x3D;key mod p (mod为求余运算，p≤m)这个方法的关键是选取适当的p，一般情况下，可以选p为小于表长的最大质数。例如，表长m &#x3D; 100，可取p &#x3D;97。\n③.处理冲突的方法“处理冲突”的实际含义是:为产生冲突的地址寻找下一个散列地址。\n开放地址法\n基本方法:当冲突发生时，形成某个探测序列;按此序列逐个探测散列表中的其他地址，直到找到给定的关键字或一个空地址(开放的地址)为止，将发生冲突的记录放到该地址中。\n新的散列地址的计算公式是:Hi(key)&#x3D;(H(key)+di)MOD m, i&#x3D;1，2，…， k(k≤m-1)\n其中:\n\nH(key):散列函数;\nm:散列表长度;\ndi:第i次探测时的增量序列;\nHi(key) :经第i次探测后得到的散列地址。\n\n探测:是指寻找“下一个”空位的过程。\n对增量di有三种取法:\n\n线性探测法:依次循环探测d的下一个地址，即一旦冲突，就找附近（下一个）空地址存入。di &#x3D; 1,2,3,… . ..m-1\n二次探测法:发生冲突时前后查找空位置 di&#x3D;1^2^,-1^2^,2^2^,-2^3^,3^2^,……±k^2^ (k ≤ m&#x2F;2)\n随机探测法：di是一组伪随机数列或者 di &#x3D; i×H2(key)(又称双散列函数探测)\n\n\n链地址法\n基本思想:将具有相同散列地址的记录链成一个单链表，m个散列地址就设m个单链表，然后用一个数组将m个单链表的表头指针存储起来，形成一个动态的结构\n单链表中存放的是同义词，称为同义词链表。在这种方法中，散列表每个单元中存放的不再是记录本身，而是相应同义词单链表的头指针\n\n④.散列表的查找哈希表的查找过程和建表过程一致，以开放定址法为例:\n\n求出k的哈希地址\n若表中此位置上为空记录,则查找失败，返回;也可将关键字等于k的记录填入\n如果该分量不空且关键字&#x3D;k,则成功返回;否则按设定的处理冲突的方法找下一地址\n重复前两步\n\n#include&lt;stdio.h&gt;\n#include&lt;malloc.h&gt;\n#include&lt;string.h&gt;\n#define MaxSize 1000\ntypedef struct node\n&#123;\n    int key;\n    struct node *next;\n&#125;NodeType;\ntypedef struct\n&#123;\n    NodeType*first;\n&#125;HashTable;\nHashTable ha[MaxSize];//哈希表\nint keys[MaxSize];//存键值\nvoid Insert(HashTable ha[],int m,int key)\n&#123;\n    int adr;\n    adr=key%m;//关键字%哈希表长度\n    NodeType *q;\n    q=(NodeType*)malloc(sizeof(NodeType));\n    q-&gt;key=key;\n    q-&gt;next=NULL;\n    //通过链接形成某地址的哈希表\n    if(ha[adr].first==NULL)\n    &#123;\n        ha[adr].first=q;\n    &#125;else//头插法\n    &#123;\n        q-&gt;next=ha[adr].first;\n        ha[adr].first=q;\n    &#125;\n&#125;\nvoid Seek(HashTable ha[],int m,int k)\n&#123;\n    int i=0,adr;\n    adr=k%m;\n    //判断是哪一个地址的哈希表\n    NodeType *q;\n    q=ha[adr].first;\n    //q为当前地址的哈希表的头指针\n    while(q!=NULL)\n    &#123;\n        i++;\n        if(q-&gt;key==k) break;\n        q=q-&gt;next;\n    &#125;\n    if(q!=NULL)\n    printf(&quot;%d,%d&quot;,adr,i);\n    else\n    printf(&quot;-1&quot;);\n&#125;\nint main()\n&#123;\n    int m,n,k;\n    scanf(&quot;%d&quot;,&amp;m);//哈希表长度\n    scanf(&quot;%d&quot;,&amp;n);//关键字个数\n    for(int i=0;i&lt;n;i++)\n    &#123;\n        scanf(&quot;%d&quot;,&amp;keys[i]);//关键字集合\n    &#125;\n    for(int i=0;i&lt;m;i++)\n    &#123;\n        ha[i].first=NULL;\n    &#125;\n    for(int i=0;i&lt;n;i++)\n    &#123;\n        Insert(ha,m,keys[i]);///插入哈希表\n    &#125;\n    scanf(&quot;%d&quot;,&amp;k);\n    Seek(ha,m,k);\n&#125;\n\n\n例：\n\n\n5、总结查找是数据处理中经常使用的一种操作。本章主要介绍了对查找表的查找，查找表实际上仅仅是一个集合，为了提高查找效率，将查找表组织成不同的数据结构，主要包括3种不同结构的查找表:线性表、树表和散列表。\n( 1 ）线性表的查找。主要包括顺序查找、折半查找和分块查找。\n\n(2)树表的查找。树表的结构主要包括二叉排序树、平衡二叉树、B-树和B＋树。\n①二叉排序树的查找过程与折半查找过程类似。\n\n②二叉排序树在形态均匀时性能最好，而形态为单支树时其查找性能则退化为与顺序查找相同，因此，二叉排序树最好是一棵平衡二叉树。平衡二叉树的平衡调整方法就是确保二叉排序树在任何情况下的深度均为O(logzn )，平衡调整方法分为4种:LL型、RR型、LR型和RL型。\n③B-树是一种平衡的多叉查找树，是一种在外存文件系统中常用的动态索引技术。在B-树上进行查找的过程和二叉排序树类似，是一个顺指针查找结点和在结点内的关键字中查找交叉进行的过程。为了确保B-树的定义，在B-树中插人一个关键字，可能产生结点的“分裂”，而删除一个关键字，可能产生结点的“合并”。\n④B+树是一种B-树的变型树，更适合做文件系统的索引。在B+树上进行随机查找、插人和删除的过程基本上与B-树类似,但具体实现细节又有所区别。\n(3）散列表的查找。散列表也属线性结构，但它和线性表的查找有着本质的区别。它不是以关键字比较为基础进行查找的，而是通过一种散列函数把记录的关键字和它在表中的位置建立起对应关系，并在存储记录发生冲突时采用专门的处理冲突的方法。这种方式构造的散列表，不仅平均查找长度和记录总数无关，而且可以通过调节装填因子，把平均查找长度控制在所需的范围内。\n散列查找法主要研究两方面的问题:如何构造散列函数，以及如何处理冲突。\n①构造散列函数的方法很多,除留余数法是最常用的构造散列函数的方法。它不仅可以对关键字直接取模,也可在折叠、平方取中等运算之后取模。\n②处理冲突的方法通常分为两大类:开放地址法和链地址法，二者之间的差别类似于顺序表和单链表的差别。\n\n6、例题与应用采用除留余数法实现哈希表的创建，任意采用一种处理冲突的方法解决冲突，计算哈希表的平均查找长度。编程实现以下功能：已知一组关键字(19,14,23,1,68,20,84,27,55,11,10,79)，哈希函数定义为：H(key)&#x3D;key MOD 13, 哈希表长为m&#x3D;16。实现该哈希表的散列，并计算平均查找长度（设每个记录的查找概率相等）。（1）哈希表定义为定长的数组结构；（2）使用线性探测再散列或链地址法解决冲突；（3）散列完成后在屏幕上输出数组内容或链表；（4）输出等概率查找下的平均查找长度；（5）完成散列后，输入关键字完成查找操作，要分别测试查找成功与查找不成功两种情况。\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#define N 13\n#define Hashsize 16\n\nint sign = 2;\n\ntypedef struct Hash\n&#123;\n    int date;\n    int sign;\n&#125; HashNode;\n//线性冲突处理\nvoid compare(HashNode H[], int p, int i, int key[])\n&#123;\n    p++;\n    if (H[p].sign != 0)\n    &#123;\n        sign++;\n        compare(H, p, i, key);\n    &#125;\n    else\n    &#123;\n        H[p].date = key[i];\n        H[p].sign = sign;\n        sign = 2;\n    &#125;\n&#125;\n\nvoid Hashlist(HashNode H[], int key[])\n&#123;\n    int p;\n    for (int i = 0; i &lt; 12; i++)\n    &#123;\n        p = key[i] % N;\n\n        if (H[p].sign == 0)\n        &#123;\n            H[p].date = key[i];\n            H[p].sign = 1;\n        &#125;\n        else\n            compare(H, p, i, key);\n    &#125;\n&#125;\n//查找冲突处理\nint judge(HashNode H[], int num, int n)\n&#123;\n    n++;\n\n    if (n &gt;= Hashsize)\n        return 0;\n\n    if (H[n].date == num)\n    &#123;\n        printf(&quot;位置\\t数据\\n&quot;);\n        printf(&quot;%d\\t %d\\n\\n&quot;, n, H[n].date);\n        return 1;\n    &#125;\n    else\n    &#123;\n        judge(H, num, n);\n    &#125;\n&#125;\n//查找\nint search(char num, HashNode H[])\n&#123;\n    int n;\n    n = num % N;\n    if (H[n].sign == 0)\n    &#123;\n        printf(&quot;查找失败！&quot;);\n        return 0;\n    &#125;\n    if (H[n].sign != 0 &amp;&amp; H[n].date == num)\n    &#123;\n        printf(&quot;位置\\t数据\\n&quot;);\n        printf(&quot;%d\\t %d\\n&quot;, n, H[n].date);\n    &#125;\n    else if (H[n].sign != 0 &amp;&amp; H[n].date != num)\n    &#123;\n        if (judge(H, num, n) == 0)\n            return 0;\n    &#125;\n    return 1;\n&#125;\n\nint main(void)\n&#123;\n    int key[N] = &#123;19, 14, 23, 1, 68, 20, 84, 27, 55, 11, 10, 79&#125;;\n    float a = 0;\n    HashNode H[Hashsize];\n    for (int i = 0; i &lt; Hashsize; i++)\n        H[i].sign = 0;\n    Hashlist(H, key);\n    printf(&quot;建立好的哈希表如下所示:\\n位置\\t\\t数据\\n&quot;);\n    for (int i = 0; i &lt; Hashsize; i++)\n    &#123;\n        if (H[i].sign != 0)\n        &#123;\n            printf(&quot;%d\\t--&gt;\\t%d\\n&quot;, i, H[i].date);\n        &#125;\n        else\n        &#123;\n            H[i].date = 0;\n            printf(&quot;%d\\t--&gt;\\t%d\\n&quot;, i, H[i].date);\n        &#125;\n    &#125;\n    int num;\n    printf(&quot;输入查找数值(输入-1退出):\\n&quot;);\n    for (int i = 0;; i++)\n    &#123;\n        scanf(&quot;%d&quot;, &amp;num);\n        if (num == -1)\n            break;\n        if (search(num, H) == 0)\n            printf(&quot;该数值不存在！\\n&quot;);\n    &#125;\n    for (int i = 0; i &lt; Hashsize; i++)\n    &#123;\n        a = a + H[i].sign;\n    &#125;\n    printf(&quot;平均查找长度:%0.2f\\n&quot;, a / 12);\n    return 0;\n&#125;\n\n","slug":"数据结构（C语言版）-- 查找笔记","date":"2022-02-20T13:03:12.000Z","categories_index":"前端","tags_index":"字节跳动青训营","author_index":"会思想的苇草i"},{"id":"0b9c5318228023fdd1e179358a45ba07","title":"图","content":"\n1、图的定义和基本术语①.图的定义&#x3D;&#x3D;图(Graph )G由两个集合V和E组成，记为G&#x3D;(V,E)，其中V是顶点的有穷非空集合，E是V中顶点偶对的有穷集合，这些顶点偶对称为边&#x3D;&#x3D;。V(G)和E(G)通常分别表示图G的顶点集合和边集合，E(G)可以为空集。若E(G)为空，则图G只有顶点而没有边。\n有向图:\n每条边都是有方向的，边也称作弧，如G1\n无向图:\n每条边都是无方向的，如G2\n\n②.图的基本术语设n表示图中顶点数目，e表示边的数目\n&#x3D;&#x3D;完全图：任意两个点都有一条边相连&#x3D;&#x3D;\n\n&#x3D;&#x3D;稀疏图：如果边或弧的个数满足e &lt; n log2n ,则称作稀疏图，否则称作稠密图&#x3D;&#x3D;\n&#x3D;&#x3D;子图：设有两个图G&#x3D;(V，{E}) 、G1&#x3D; (V1，{E1})，若V1⊆ V，E1⊆ E，则称G1是G的子图。&#x3D;&#x3D;\n\n&#x3D;&#x3D;权与网：图中边或弧所具有的数称为权。表明从一个顶点到另一个顶点的距离或耗费。带权的图称为网。&#x3D;&#x3D;\n&#x3D;&#x3D;对无向图来说：邻接点:若顶点v和顶点w之间存在一条边a，则称顶点v和w互为邻接点。边a与顶点v和w相关联。度:与顶点v关联的边的数目，记为TD(v)&#x3D;&#x3D;\n&#x3D;&#x3D;对有向图来说：&lt;x,y&gt;为有向边（弧），x为有向边的起点（弧尾)，y为有向边的终点（弧头）顶点v的入度是以v为终点的有向边的条数,记作ID(v)顶点v的出度是以v为始点的有向边的条数,记作OD(v)&#x3D;&#x3D;\n&#x3D;&#x3D;路径:接续的边构成的顶点序列。&#x3D;&#x3D;\n&#x3D;&#x3D;路径长度:路径上边或弧的数目。&#x3D;&#x3D;\n&#x3D;&#x3D;简单路径:除路径起点和终点可以相同外，其余顶点均不相同的路径。&#x3D;&#x3D;\n&#x3D;&#x3D;简单回路(简单环):除路径起点和终点相同外，其余顶点均不相同的路径.&#x3D;&#x3D;\n\n&#x3D;&#x3D;若无向图中任意两个顶点之间都有路径相通，则称此图为连通图(G1);若无向图为非连通图，则图中各个连通子图称作此图的连通分量(G2)。&#x3D;&#x3D;\n&#x3D;&#x3D;若有向图中任意两个顶点之间都存在一条有向路径，则称此有向图为强连通图，否则，其各个强连通子图称作它的强连通分量。&#x3D;&#x3D;\n\n\n2、图的类型定义图的抽象数据类型定义：\n\n\n3、图的存储结构由于图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数据元素在存储区中的物理位置来表示元素之间的关系，即图没有顺序存储结构，但可以借助二维数组来表示元素之间的关系，即邻接矩阵表示法。另一方面，由于图的任意两个顶点间都可能存在关系，因此，用链式存储表示图是很自然的事，图的链式存储有多种，有邻接表、十字链表和邻接多重表，应根据实际需要的不同选择不同的存储结构。\n①.邻接矩阵邻接矩阵表示法\n邻接矩阵是表示顶点之间相邻关系的矩阵。设G（V，E）是具有n个顶点的图，则G的邻接矩阵是具有如下性质的n阶方阵。\n\n\n在有向图的邻接矩阵中，\n\n第i行含义︰以结点v;为起点的边(即出度边);\n第i列含义:以结点v;为终点的边(即入度边)。\n\n有向图的邻接矩阵可能是不对称的。\n\n顶点的出度-第i行元素之和\n顶点的入度-第i列元素之和\n顶点的度-第i行元素之和+第i列元素之和\n\n\n无向图的邻接矩阵是对称的;\n\n顶点i的度&#x3D;第i 行（列)中1的个数;\n图的边数&#x3D;所有非0元素之和的一半;\n完全图的邻接矩阵中，对角元素为0，其余1。\n\n若G是网，则邻接矩阵可以定义为：\n\n其中，wi,j表示边上的权值;∞表示计算机允许的、大于所有边上权值的数。\n邻接矩阵表示法的特点\n\n优点:容易实现图的操作。如:求某顶点的度、判断顶点之间是否有边、找顶点的邻接点……\n缺点:n个顶点需要n*n个单元存储边;空间效率为O(n^2^)。对稀疏图而言尤其浪费空间。\n\n//图的邻接矩阵存储表示\n#define MaxInt 32767     //表示极大值，即∞\n#define MVNum 100        //最大顶点数\ntypedef char VerTexType; //假设顶点的数据类型为字符型\ntypedef int ArcType;     //假设边的权值类型为整型\ntypedef struct\n&#123;\n    VerTexType vexs[MVNum];     //顶点表\n    ArcType arcs[MVNum][MVNum]; //邻接矩阵\n    int vexnum, arcnum;         //图的当前顶点数和边数\n&#125; AMGraph;\n\n采用邻接矩阵表示法创建无向网\n\n输入总顶点数和总边数。\n依次输入点的信息存入顶点表中。\n初始化邻接矩阵，使每个权值初始化为极大值。\n构造邻接矩阵。依次输人每条边依附的顶点和其权值，确定两个顶点在图中的位置之后，使相应边赋予相应的权值，同时使其对称边赋予相同的权值。\n\nStatus CreateUDN(AMGraph &amp;G)\n&#123;                                //采用邻接矩阵表示法，创建无向网G\n    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; //输入总顶点数，总边数\n    for (i = 0; i &lt; G.vexnum; ++i)\n        cin &gt;&gt; G.vexs[i];          //依次输入点的信息\n    for (i = 0; i &lt; G.vexnum; ++i) //初始化邻接矩阵，边的权值均置为极大值\n        for (j = 0; j &lt; G.vexnum; ++j)\n            G.arcs[i][j] = MaxInt;\n    for (k = 0; k &lt; G.arcnum; ++k) //构造邻接矩阵\n    &#123;\n        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w; //输入一条边依附的顶点及权值\n        i = LocateVex(G, v1);\n        j = LocateVex(G, v2);        //确定v1和v2在G中的位置\n        G.arcs[i][j] = w;            //边&lt;v1, v2&gt;的权值置为w\n        G.arcs[j][i] = G.arcs[i][j]; //置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w\n    &#125;                                // for\n    return OK;\n&#125; // CreateUDN\n\n该算法的时间复杂度是&#x3D;&#x3D;O(n^2^)&#x3D;&#x3D;。\n若要建立无向图，只需对上述算法做两处小的改动:一是初始化邻接矩阵时，将边的权值均初始化为0;二是构造邻接矩阵时，将权值w改为常量值1即可。同样，将该算法稍做修改即可建立一个有向网或有向图。\n②.邻接表邻接表(Adjacency List）是图的一种链式存储结构。在邻接表中，对图中每个顶点v;建立一个单链表，把与v相邻接的顶点放在这个链表中。邻接表中每个单链表的第一个结点存放有关顶点的信息，把这一结点看成链表的表头，其余结点存放有关边的信息，这样邻接表便由两部分组成:表头结点表和边表。\n\n无向图的邻接表表示\n\n有向图的邻接表表示\n\n//图的邻接表存储表示\n#define MVNum 100 //最大顶点数\ntypedef struct ArcNode\n&#123;\n    int adjvex;              // 该边所指向的顶点的位置\n    struct ArcNode *nextarc; // 指向下一条边的指针\n    OtherInfo info;          // 和边相关的信息\n&#125; ArcNode;\ntypedef struct VNode\n&#123;\n    VertexType data;     // 顶点信息\n    ArcNode *firstarc;   // 指向第一条依附该顶点的边\n&#125; VNode, AdjList[MVNum]; // AdjList表示邻接表类型\ntypedef struct\n&#123;\n    AdjList vertices;   // vertices—vertex的复数\n    int vexnum, arcnum; //图的当前顶点数和边数\n&#125; ALGraph;\n\n采用邻接表表示法创建无向图\n\n输人总顶点数和总边数。\n依次输入点的信息存入顶点表中，使每个表头结点的指针域初始化为NULL。\n创建邻接表。依次输入每条边依附的两个顶点，确定这两个顶点的序号i和j之后，将此边结点分别插入vi和vj对应的两个边链表的头部。\n\nStatus CreateUDG(ALGraph &amp;G)\n&#123;                                //采用邻接表表示法，创建无向图G\n    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; //输入顶点数和弧数\n    for (i = 0; i &lt; G.vexnum; ++i)\n    &#123;                                  //输入各点，构造表头结点表\n        cin &gt;&gt; G.vertices[i].data;     //输入顶点值\n        G.vertices[i].firstarc = NULL; //初始化表头结点的指针域为NULL\n    &#125;\n    for (k = 0; k &lt; G.arcnum; ++k) //输入各边，构造邻接表，头插法\n    &#123;\n        cin &gt;&gt; v1 &gt;&gt; v2; //输入一条边依附的两个顶点\n        i = LocateVex(G, v1);\n        j = LocateVex(G, v2);\n        p1 = new ArcNode; //生成一个新的边结点*p1\n        p1-&gt;adjvex = j;   //邻接点序号为j\n        p1-&gt;nextarc = G.vertices[i].firstarc;\n        G.vertices[i].firstarc = p1;          //将新结点*p1插入到顶点vi的边表头部\n        p2 = new ArcNode;                     //生成一个新的边结点*p2\n        p2-&gt;adjvex = i;                       //邻接点序号为j\n        p2-&gt;nextarc = G.vertices[j].firstarc; //插入弧结点到单链表\n        G.vertices[j].firstarc = p2;          //将新结点*p2插入到顶点vj的边表头部\n    &#125;                                         //头插法\n    return OK;\n&#125; // CreateUDG\n\n该算法的时间复杂度是&#x3D;&#x3D;O(n+e)&#x3D;&#x3D;。\n建立有向图的邻接表与此类似，只是更加简单，每读入一个顶点对序号&lt;i,j&gt;，仅需生成一个邻接点序号为j的边表结点，并将其插入到v的边链表头部即可。若要创建网的邻接表，可以将边的权值存储在info域中。\n邻接矩阵与邻接表的比较\n\n例1：\n\n例2：\n\n④.十字链表十字链表(Orthogonal List)是有向图的另一种链式存储结构。可以看成是将有向图的邻接表和逆邻接表结合起来得到的一种链表。在十字链表中，对应于有向图中每一条弧有一个结点，对应于每个顶点也有一个结点。\n在弧结点中有5个域:其中尾域( tailvex )和头域( headvex )分别指示弧尾和弧头这两个顶点在图中的位置，链域hlink指向弧头相同的下一条弧，而链域tlink 指向弧尾相同的下一条弧，info域指向该弧的相关信息。弧头相同的弧在同一链表上，弧尾相同的弧也在同一链表上。它们的头结点即为顶点结点，它由3个域组成:其中 data域存储和顶点相关的信息，如顶点的名称等;firstin和 firstout为两个链域，分别指向以该顶点为弧头或弧尾的第一个弧结点。\n\n\n\n名称\n解释\n\n\n\ntailvex\n指示弧尾顶点在图中的位置。\n\n\nheadtex\n指示弧头顶点在图中的位置。\n\n\nhlink\n是指向弧头相同的下一条弧的指针。\n\n\ntlink\n是指向弧尾相同的下一条弧的指针。\n\n\nInfo\n指向该弧的相关信息。\n\n\n\n//有向图的十字链表存储表示\n#define MAX_VERTEX_NUM 20\ntypedef struct ArcBox\n&#123;\n    int tailvex, headvex;\n    struct ArcBox *hlink, *tlink;\n    InfoType *info;\n&#125; ArcBox;\ntypedef struct VexNode // ArcBox为弧结点变量\n&#123;\n    VertexType data;\n    ArcBox *firstin, *firstout;\n&#125; VexNode;\ntypedef struct // VexNode为顶点变量\n&#123;\n    VexNode xlist[MAX_VERTEX_NUM]; // 表头向\n    int vexnum, arcnum;            // 有向图的当前顶点数和弧数\n&#125; OLGraph;\n\n例：\n\n④.邻接多重表邻接多重表是无向图的另一种链式存储结构，由于用邻接表存储无向图时，虽然容易求出顶点和边的各种信息，但在邻接表中每一条边有两个结点，分别在第i和第j个链表中，给图的某些操作带来不便。在邻接多重表中，每一条边只有一个边结点，为有关边的处理提供了方便。\n\n\n\n名称\n解释\n\n\n\nmark\n为标志域，可用以标记该条边是否被搜索过\n\n\nivex和jvex\n为该边依附的两个顶点在图中的位置;\n\n\nilnk\n指向下一条依附于顶点ivex的边;\n\n\njlink\n指向下一条依附于顶点jvex的边\n\n\ninfo\n为指向和边相关的各种信息的指针域。\n\n\n例：\n\n//无向图的邻接多重表存储表示\n#define MAX_VERTEX_NUM 20\ntypedef enum\n&#123;\n    unvisited,\n    viseited\n&#125; ViseitIF;\ntypedef struct EBox\n&#123;\n    VisitIf mark;               //访问标志域\n    int ivex, jvex;             //该边依附的两个顶点在表头数组中位置\n    struct EBox *ilink, *jlink; //分别指向依附于ivex和jvex的下一条边\n    InfoType *info;\n&#125; Ebox;\ntypedef struct VexBox\n&#123;\n    VertexType data; //存与顶点有关的信息\n    EBox *firstedge; //指向第一条依附于该顶点的边\n&#125; VexBox;\ntypedef struct\n&#123;\n    VexBox adjmulist[MAX_VERTEX_NUM]; // 表头向量\n    int vexnum, edgenum;              // 无向图的当前顶点数和弧数\n&#125; AMLGraph;\n\n例：画出无向图G的邻接多重表\n\n\n4、图的遍历从图中某个顶点V。出发，沿着一些边访问图中所有的顶点，且使每个顶点被访问一次且只访问一次，就叫做图的遍历。它是图的基本运算。\n①.深度优先搜索&#x3D;&#x3D;深度优先搜索( Depth First Search，DFS)遍历类似于树的先序遍历，是树的先序遍历的推广&#x3D;&#x3D;。对于一个连通图，深度优先搜索遍历的过程如下。\n\n从图中某个顶点v出发，访问v。\n找出刚访问过的顶点的第一个未被访问的邻接点，访问该顶点。以该顶点为新顶点，重复此步骤,直至刚访问过的顶点没有未被访问的邻接点为止。\n返回前一个访问过的且仍有未被访问的邻接点的顶点，找出该顶点的下一个未被访问的邻接点，访问该顶点。\n重复步骤（2）和（3)，直至图中所有顶点都被访问过，搜索结束。\n\n\n对无向连通图，如果将一次深度优先搜索时前进操作所经过的边保留下来则可构成一棵深度优先搜索生成树。\n\n深度优先搜索遍历的算法实现\n显然，深度优先搜索遍历连通图是一个递归的过程。为了在遍历过程中便于区分顶点是否已被访问，需附设访问标志数组visited[n]，其初值为“false”，一旦某个顶点被访问，则其相应的分量置为“true”。\n\n从图中某个顶点v出发，访问v，并置visited[y]的值为true。\n依次检查v的所有邻接点w，如果visited[w]的值为false，再从w出发进行递归遍历,直到图中所有顶点都被访问过。\n\n//深度优先搜索遍历连通图的递归算法\n\n#include &lt;iostream&gt;\nusing namespace std;\n\n#define MVNum 100        //最大顶点数\ntypedef char VerTexType; //假设顶点的数据类型为字符型\ntypedef int ArcType;     //假设边的权值类型为整型\n\ntypedef struct\n&#123;\n    VerTexType vexs[MVNum];     //顶点表\n    ArcType arcs[MVNum][MVNum]; //邻接矩阵\n    int vexnum, arcnum;         //图的当前点数和边数\n&#125; Graph;\n\nbool visited[MVNum];                   //访问标志数组，其初值为&quot;false&quot;\nint FirstAdjVex(Graph G, int v);       //返回v的第一个邻接点\nint NextAdjVex(Graph G, int v, int w); //返回v相对于w的下一个邻接点\n\nint LocateVex(Graph G, VerTexType v)\n&#123;\n    //确定点v在G中的位置\n    for (int i = 0; i &lt; G.vexnum; ++i)\n        if (G.vexs[i] == v)\n            return i;\n    return -1;\n&#125; // LocateVex\n\nvoid CreateUDN(Graph &amp;G)\n&#123;\n    //采用邻接矩阵表示法，创建无向网G\n    int i, j, k;\n    cout &lt;&lt; &quot;请输入总顶点数，总边数 , 以空格隔开:&quot;;\n    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; //输入总顶点数，总边数\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;输入点的名称，如 a：&quot; &lt;&lt; endl;\n\n    for (i = 0; i &lt; G.vexnum; ++i)\n    &#123;\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (i + 1) &lt;&lt; &quot;个点的名称:&quot;;\n        cin &gt;&gt; G.vexs[i]; //依次输入点的信息\n    &#125;\n    cout &lt;&lt; endl;\n\n    for (i = 0; i &lt; G.vexnum; ++i) //初始化邻接矩阵，边的权值均置为极大值MaxInt\n        for (j = 0; j &lt; G.vexnum; ++j)\n            G.arcs[i][j] = 0;\n    cout &lt;&lt; &quot;输入边依附的顶点，如：a b&quot; &lt;&lt; endl;\n    for (k = 0; k &lt; G.arcnum; ++k)\n    &#123; //构造邻接矩阵\n        VerTexType v1, v2;\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (k + 1) &lt;&lt; &quot;条边依附的顶点:&quot;;\n        cin &gt;&gt; v1 &gt;&gt; v2; //输入一条边依附的顶点及权值\n        i = LocateVex(G, v1);\n        j = LocateVex(G, v2);            //确定v1和v2在G中的位置，即顶点数组的下标\n        G.arcs[j][i] = G.arcs[i][j] = 1; //置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w\n    &#125;                                    // for\n&#125; // CreateUDN\n\nvoid DFS(Graph G, int v)\n&#123; //从第v个顶点出发递归地深度优先遍历图G\n    cout &lt;&lt; G.vexs[v] &lt;&lt; &quot;    &quot;;\n    visited[v] = true; //访问第v个顶点，并置访问标志数组相应分量值为true\n    int w;\n    for (w = FirstAdjVex(G, v); w &gt;= 0; w = NextAdjVex(G, v, w))\n        //依次检查v的所有邻接点w ，FirstAdjVex(G, v)表示v的第一个邻接点\n        // NextAdjVex(G, v, w)表示v相对于w的下一个邻接点，w≥0表示存在邻接点\n        if (!visited[w])\n            DFS(G, w); //对v的尚未访问的邻接顶点w递归调用DFS\n&#125; // DFS\n\nint FirstAdjVex(Graph G, int v)\n&#123;\n    int i;\n    for (i = 0; i &lt; G.vexnum; ++i)\n    &#123;\n        if (G.arcs[v][i] == 1 &amp;&amp; visited[i] == false)\n            return i;\n    &#125;\n    return -1;\n&#125; // FirstAdjVex\n\nint NextAdjVex(Graph G, int v, int w)\n&#123;\n    int i;\n    for (i = w; i &lt; G.vexnum; ++i)\n    &#123;\n        if (G.arcs[v][i] == 1 &amp;&amp; visited[i] == false)\n            return i;\n    &#125;\n    return -1;\n&#125; // NextAdjVex\n\nint main()\n&#123;\n    cout &lt;&lt; &quot;************深度优先搜索遍历连通图的递归算法**************&quot; &lt;&lt; endl\n         &lt;&lt; endl;\n    Graph G;\n    CreateUDN(G);\n    cout &lt;&lt; endl;\n    cout &lt;&lt; &quot;无向连通图G创建完成！&quot; &lt;&lt; endl\n         &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;请输入遍历连通图的起始点：&quot;;\n    VerTexType c;\n    cin &gt;&gt; c;\n\n    int i;\n    for (i = 0; i &lt; G.vexnum; ++i)\n    &#123;\n        if (c == G.vexs[i])\n            break;\n    &#125;\n    cout &lt;&lt; endl;\n    while (i &gt;= G.vexnum)\n    &#123;\n        cout &lt;&lt; &quot;该点不存在，请重新输入！&quot; &lt;&lt; endl;\n        cout &lt;&lt; &quot;请输入遍历连通图的起始点：&quot;;\n        cin &gt;&gt; c;\n        for (i = 0; i &lt; G.vexnum; ++i)\n        &#123;\n            if (c == G.vexs[i])\n                break;\n        &#125;\n    &#125;\n    cout &lt;&lt; &quot;深度优先搜索遍历连通图结果：&quot; &lt;&lt; endl;\n    DFS(G, i);\n\n    cout &lt;&lt; endl;\n    return 0;\n&#125; // main\n\n//深度优先搜索遍历非连通图\n\n#include &lt;iostream&gt;\nusing namespace std;\n\n#define MVNum 100        //最大顶点数\ntypedef char VerTexType; //假设顶点的数据类型为字符型\ntypedef int ArcType;     //假设边的权值类型为整型\n\n//-------------图的邻接矩阵-----------------\ntypedef struct\n&#123;\n    VerTexType vexs[MVNum];     //顶点表\n    ArcType arcs[MVNum][MVNum]; //邻接矩阵\n    int vexnum, arcnum;         //图的当前点数和边数\n&#125; Graph;\n\nbool visited[MVNum];                   //访问标志数组，其初值为&quot;false&quot;\nint FirstAdjVex(Graph G, int v);       //返回v的第一个邻接点\nint NextAdjVex(Graph G, int v, int w); //返回v相对于w的下一个邻接点\n\nint LocateVex(Graph G, VerTexType v)\n&#123;\n    //确定点v在G中的位置\n    for (int i = 0; i &lt; G.vexnum; ++i)\n        if (G.vexs[i] == v)\n            return i;\n    return -1;\n&#125; // LocateVex\n\nvoid CreateUDN(Graph &amp;G)\n&#123;\n    //采用邻接矩阵表示法，创建无向网G\n    int i, j, k;\n    cout &lt;&lt; &quot;请输入总顶点数，总边数，以空格隔开:&quot;;\n    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; //输入总顶点数，总边数\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;输入点的名称，如a&quot; &lt;&lt; endl;\n    for (i = 0; i &lt; G.vexnum; ++i)\n    &#123;\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (i + 1) &lt;&lt; &quot;个点的名称:&quot;;\n        cin &gt;&gt; G.vexs[i]; //依次输入点的信息\n    &#125;\n    cout &lt;&lt; endl;\n    for (i = 0; i &lt; G.vexnum; ++i) //初始化邻接矩阵，边的权值均置为极大值MaxInt\n        for (j = 0; j &lt; G.vexnum; ++j)\n            G.arcs[i][j] = 0;\n    cout &lt;&lt; &quot;输入边依附的顶点，如a b&quot; &lt;&lt; endl;\n    for (k = 0; k &lt; G.arcnum; ++k)\n    &#123; //构造邻接矩阵\n        VerTexType v1, v2;\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (k + 1) &lt;&lt; &quot;条边依附的顶点:&quot;;\n        cin &gt;&gt; v1 &gt;&gt; v2; //输入一条边依附的顶点及权值\n        i = LocateVex(G, v1);\n        j = LocateVex(G, v2);            //确定v1和v2在G中的位置，即顶点数组的下标\n        G.arcs[j][i] = G.arcs[i][j] = 1; //置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w\n    &#125;                                    // for\n&#125; // CreateUDN\n\nvoid DFS(Graph G, int v)\n&#123;\n    //从第v个顶点出发递归地深度优先遍历图G\n    cout &lt;&lt; G.vexs[v] &lt;&lt; &quot;    &quot;;\n    visited[v] = true; //访问第v个顶点，并置访问标志数组相应分量值为true\n    int w;\n    for (w = FirstAdjVex(G, v); w &gt;= 0; w = NextAdjVex(G, v, w))\n        //依次检查v的所有邻接点w ，FirstAdjVex(G, v)表示v的第一个邻接点\n        // NextAdjVex(G, v, w)表示v相对于w的下一个邻接点，w≥0表示存在邻接点\n        if (!visited[w])\n            DFS(G, w); //对v的尚未访问的邻接顶点w递归调用DFS\n&#125; // DFS\n\nvoid DFSTraverse(Graph G)\n&#123;\n    //对非连通图G做深度优先遍历\n    int v;\n    for (v = 0; v &lt; G.vexnum; ++v)\n        visited[v] = false;        //访问标志数组初始化\n    for (v = 0; v &lt; G.vexnum; ++v) //循环调用算法6.3\n        if (!visited[v])\n            DFS(G, v); //对尚未访问的顶点调用DFS\n&#125; // DFSTraverse\n\nint FirstAdjVex(Graph G, int v)\n&#123;\n    //返回v的第一个邻接点\n    int i;\n    for (i = 0; i &lt; G.vexnum; ++i)\n    &#123;\n        if (G.arcs[v][i] == 1 &amp;&amp; visited[i] == false)\n            return i;\n    &#125;\n    return -1;\n&#125; // FirstAdjVex\n\nint NextAdjVex(Graph G, int v, int w)\n&#123;\n    //返回v相对于w的下一个邻接点\n    int i;\n    for (i = w; i &lt; G.vexnum; ++i)\n    &#123;\n        if (G.arcs[v][i] == 1 &amp;&amp; visited[i] == false)\n            return i;\n    &#125;\n    return -1;\n&#125; // NextAdjVex\n\nint main()\n&#123;\n    cout &lt;&lt; &quot;************深度优先搜索遍历非连通图**************&quot; &lt;&lt; endl\n         &lt;&lt; endl;\n    Graph G;\n    CreateUDN(G);\n    cout &lt;&lt; endl;\n    cout &lt;&lt; &quot;无向图G创建完成！&quot; &lt;&lt; endl\n         &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;深度优先搜索遍历非连通图结果：&quot; &lt;&lt; endl;\n    DFSTraverse(G);\n\n    cout &lt;&lt; endl;\n    return 0;\n&#125; // main\n\n②.广度优先搜索&#x3D;&#x3D;广度优先搜索（ Breadth First Search，BFS）遍历类似于树的按层次遍历的过程。&#x3D;&#x3D;\n广度优先搜索遍历的过程如下。\n\n从图中某个顶点v出发，访问v。\n依次访问v的各个未曾访问过的邻接点。\n分别从这些邻接点出发依次访问它们的邻接点，并使“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接点”被访问。重复步骤3，直至图中所有已被访问的顶点的邻接点都被访问到。\n\n广度优先生成树：\n广度优先搜索遍历连通图\n\n从图中某个顶点v出发，访问v，并置 visited[y]的值为true，然后将v进队。\n只要队列不空，则重复下述操作:- 队头顶点u出队;- 依次检查u的所有邻接点w，如果visited[w]的值为false，则访问w，并置visited[w]的值为true，然后将w进队。\n\n//广度优先搜索遍历连通图\n\n#include &lt;iostream&gt;\nusing namespace std;\n\n#define MVNum 100                       \t//最大顶点数\n#define MAXQSIZE 100\t\t\t\t\t\t//最大队列长度\n                        \ntypedef char VerTexType;              \t\t//假设顶点的数据类型为字符型\ntypedef int ArcType;                  \t\t//假设边的权值类型为整型\nbool visited[MVNum];           \t\t\t\t//访问标志数组，其初值为&quot;false&quot; \n\n//-----图的邻接矩阵存储表示----- \ntypedef struct&#123; \n    VerTexType vexs[MVNum];            \t\t//顶点表\n    ArcType arcs[MVNum][MVNum];      \t\t//邻接矩阵\n    int vexnum,arcnum;                \t\t//图的当前点数和边数\n&#125;Graph;\n\n//----队列的定义及操作--------\ntypedef struct&#123;\n    ArcType *base;\t\t\t\t\t\t\t//初始化的动态分配存储空间\n    int front;\t\t\t\t\t\t\t\t//头指针，若队列不空，指向队头元素\n    int rear;\t\t\t\t\t\t\t\t//尾指针，若队列不空，指向队尾元素的下一个位置\n&#125;sqQueue;\n\nvoid InitQueue(sqQueue &amp;Q)&#123;\n    //构造一个空队列Q\n    Q.base = new ArcType[MAXQSIZE];\n    if(!Q.base)     exit(1);\t\t\t\t//存储分配失败\n    Q.front = Q.rear = 0;\n&#125;//InitQueue\n\nvoid EnQueue(sqQueue &amp;Q, ArcType e)&#123;\n    //插入元素e为Q的新的队尾元素\n    if((Q.rear + 1) % MAXQSIZE == Q.front)\n        return;\n    Q.base[Q.rear] = e;\n    Q.rear = (Q.rear + 1) % MAXQSIZE;\n&#125;//EnQueue\n\nbool QueueEmpty(sqQueue Q)&#123;\n    //判断是否为空队\n    if(Q.rear == Q.front)\n        return true;\n    return false;\n&#125;//QueueEmpty\n\nvoid DeQueue(sqQueue &amp;Q, ArcType &amp;u)&#123;\n    //队头元素出队并置为u \n    u = Q.base[Q.front];\n    Q.front = (Q.front + 1) % MAXQSIZE;\n&#125;//DeQueue   \t\t\t\t\t\t\t\t\n//--------------------------------------------------\n\nint LocateVex(Graph G , VerTexType v)&#123;\n    //确定点v在G中的位置\n    for(int i = 0; i &lt; G.vexnum; ++i)\n        if(G.vexs[i] == v)\n            return i;\n        return -1;\n&#125;//LocateVex\n\nvoid CreateUDN(Graph &amp;G)&#123; \n    //采用邻接矩阵表示法，创建无向网G \n    int i , j , k;\n    cout &lt;&lt;&quot;请输入总顶点数，总边数，以空格隔开:&quot;;\n    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;\t\t\t\t\t\t\t//输入总顶点数，总边数\n    cout &lt;&lt; endl;\n    cout &lt;&lt; &quot;输入点的名称，如a&quot; &lt;&lt; endl;\n    for(i = 0; i &lt; G.vexnum; ++i)&#123;   \n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (i+1) &lt;&lt; &quot;个点的名称:&quot;;\n        cin &gt;&gt; G.vexs[i];                        \t\t\t//依次输入点的信息 \n    &#125;\n    cout &lt;&lt; endl;\n    for(i = 0; i &lt; G.vexnum; ++i)                \t\t\t//初始化邻接矩阵，边的权值均置为极大值MaxInt \n        for(j = 0; j &lt; G.vexnum; ++j)   \n            G.arcs[i][j] = 0; \n    cout &lt;&lt; &quot;输入边依附的顶点，如a b&quot; &lt;&lt; endl;\n    for(k = 0; k &lt; G.arcnum;++k)&#123;\t\t\t\t\t\t\t//构造邻接矩阵 \n        VerTexType v1 , v2;\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (k + 1) &lt;&lt; &quot;条边依附的顶点:&quot;;\n        cin &gt;&gt; v1 &gt;&gt; v2;\t\t\t\t\t\t\t\t\t//输入一条边依附的顶点\n        i = LocateVex(G, v1);  j = LocateVex(G, v2);\t\t//确定v1和v2在G中的位置，即顶点数组的下标 \n        G.arcs[i][j] = 1;\t\t\t\t\t\t\t\t\t//边&lt;v1, v2&gt;的权值置为w \n        G.arcs[j][i] = G.arcs[i][j];\t\t\t\t\t\t//置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w \n    &#125;//for \n&#125;//CreateUDN\n\nint FirstAdjVex(Graph G , int v)&#123;\n    //返回v的第一个邻接点\n    int i;\n    for(i = 0 ; i &lt; G.vexnum ; ++i)&#123;\n        if(G.arcs[v][i] == 1 &amp;&amp; visited[i] == false)\n            return i;\n    &#125;\n    return -1;\n&#125;//FirstAdjVex\n\nint NextAdjVex(Graph G , int u , int w)&#123;\n    //返回v相对于w的下一个邻接点\n    int i;\n    for(i = w ; i &lt; G.vexnum ; ++i)&#123;\n        if(G.arcs[u][i] == 1 &amp;&amp; visited[i] == false)\n            return i;\n    &#125;\n    return -1;\n&#125;//NextAdjVex\n\nvoid BFS (Graph G, int v)&#123; \n    //按广度优先非递归遍历连通图G \n    sqQueue Q;\n    ArcType u;\n    ArcType w;\n\n    cout &lt;&lt; G.vexs[v] &lt;&lt; &quot;  &quot;;    visited[v] = true;     \t\t\t\t\t\t//访问第v个顶点，并置访问标志数组相应分量值为true \n    InitQueue(Q);              \t\t\t\t\t\t\t\t\t\t\t\t\t//辅助队列Q初始化，置空         \n    EnQueue(Q, v);            \t\t\t\t\t\t\t\t\t\t\t\t\t//v进队 \n    while(!QueueEmpty(Q))&#123;   \t\t\t\t\t\t\t\t\t\t\t\t\t//队列非空 \n        DeQueue(Q, u);       \t\t\t\t\t\t\t\t\t\t\t\t\t//队头元素出队并置为u\n        for(w = FirstAdjVex(G, u); w &gt;= 0; w = NextAdjVex(G, u, w))&#123;\n            //依次检查u的所有邻接点w ，FirstAdjVex(G, u)表示u的第一个邻接点 \n            //NextAdjVex(G, u, w)表示u相对于w的下一个邻接点，w≥0表示存在邻接点 \n            if(!visited[w])&#123;\t           \t\t\t\t\t\t\t\t\t\t//w为u的尚未访问的邻接顶点 \n                cout &lt;&lt; G.vexs[w] &lt;&lt; &quot;  &quot;;   visited[w] = true;\t\t\t\t\t//访问w，并置访问标志数组相应分量值为true \n                EnQueue(Q, w);\t\t\t\t\t\t\t\t\t\t\t\t\t//w进队 \n            &#125;//if \n        &#125;//for\n    &#125;//while \n&#125;//BFS \n\nint main()&#123;\n    cout &lt;&lt; &quot;************算法广度优先搜索遍历连通图**************&quot; &lt;&lt; endl &lt;&lt; endl;\n    Graph G;\n    CreateUDN(G);\n    cout &lt;&lt; endl;\n    cout &lt;&lt; &quot;无向连通图G创建完成！&quot; &lt;&lt; endl &lt;&lt; endl;\n    \n    cout &lt;&lt; &quot;请输入遍历连通图的起始点：&quot;;\n    VerTexType c;\n    cin &gt;&gt; c;\n    \n    int i;\n    for(i = 0 ; i &lt; G.vexnum ; ++i)&#123;\n        if(c == G.vexs[i])\n            break;\n    &#125;\n    cout &lt;&lt; endl;\n    while(i &gt;= G.vexnum)&#123;\n        cout &lt;&lt; &quot;该点不存在，请重新输入！&quot; &lt;&lt; endl;\n        cout &lt;&lt; &quot;请输入遍历连通图的起始点：&quot;;\n        cin &gt;&gt; c;\n        for(i = 0 ; i &lt; G.vexnum ; ++i)&#123;\n            if(c == G.vexs[i])\n                break;\n        &#125;\n    &#125;\n    cout &lt;&lt; &quot;深度优先搜索遍历连通图结果：&quot; &lt;&lt; endl;\n    BFS(G , i);\n    \n    cout &lt;&lt;endl;\n    return 0;\n&#125;//main\n\n\n5、图的应用①.最小生成树&#x3D;&#x3D;极小连通子图:该子图是G的连通子图，在该子图中删除任何一条边，子图不再连通。&#x3D;&#x3D;\n&#x3D;&#x3D;生成树:包含图G所有顶点的极小连通子图&#x3D;&#x3D;\n生成树的顶点集合与图的顶点集合相等，顶点数为n；不存在回路，边数为n-1\n\n在网的多个生成树中，寻找一个各边权值之和最小的生成树，即最小生成树\n构造最小生成树的准则：\n\n必须只使用该网中的边来构造最小生成树;\n必须使用且仅使用n-1条边来联结网络中的n个顶点\n不能使用产生回路的边\n\n普里姆算法（加点法）\n假设N&#x3D;(V,E)是连通网，TE是N上最小生成树中边的集合。\n\nU&#x3D; {u0}(u0∈V)，TE&#x3D;{}。\n在所有u∈U，v∈V-U的边(u,v)∈E中找一条权值最小的边(u0, v0)并入集合TE，同时v0并人U。\n重复②，直至U&#x3D;V为止。\n\n此时TE中必有n-1条边，则T&#x3D;(V，TE)为N的最小生成树。\n普里姆算法构造最小生成树的过程：图采用邻接矩阵存储，二维数组closedeg，记录从U到V-U具有最小代价的边。对每个顶点vi, v-U在辅助数组存在一个相应的分量closedge[i-1]，它包括两个域:\ntypedef struct\n&#123;\n    VertexType adjvex; // 最小边的顶点\n    VRType lowcost;    // 最小边的权值\n&#125; closedge[MAX_VERTEX_NUM];\n\nadjvex:依附于这条最小代价边的另一个顶点。\n\n等于0表示顶点i已在U中;\n大于0表示顶点i还在V-U中。\n\n所以，每次循环须在lowcost &gt;0(在集合V-U中)的那些顶点中选择lowcost最小的顶点加入到集合U中，同时将相关顶点的closedge作相应的调整。\n//普里姆算法\n#include &lt;iostream&gt;\nusing namespace std;\n\ntypedef char VerTexType;\ntypedef int ArcType;\n#define MVNum 100\n#define MaxInt 32767                    \t//表示极大值，即∞\n\n//辅助数组的定义，用来记录从顶点集U到V-U的权值最小的边\nstruct&#123;\n    VerTexType adjvex;\t\t\t\t\t\t//最小边在U中的那个顶点\n    ArcType lowcost;\t\t\t\t\t\t//最小边上的权值\n&#125;closedge[MVNum];\n\n//- - - - -图的邻接表存储表示- - - - - \t\t\t\t\t\t\ntypedef char VerTexType;              \t\t//假设顶点的数据类型为字符型 \ntypedef int ArcType;                  \t\t//假设边的权值类型为整型 \ntypedef struct&#123; \n    VerTexType vexs[MVNum];            \t\t//顶点表 \n    ArcType arcs[MVNum][MVNum];      \t\t//邻接矩阵 \n    int vexnum,arcnum;                \t\t//图的当前点数和边数 \n&#125;AMGraph;\n\nint LocateVex(AMGraph G , VerTexType v)&#123;\n    //确定点v在G中的位置\n    for(int i = 0; i &lt; G.vexnum; ++i)\n        if(G.vexs[i] == v)\n            return i;\n        return -1;\n&#125;//LocateVex\n\nvoid CreateUDN(AMGraph &amp;G)&#123; \n    //采用邻接矩阵表示法，创建无向网G \n    int i , j , k;\n    cout &lt;&lt;&quot;请输入总顶点数，总边数，以空格隔开:&quot;;\n    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;\t\t\t\t\t\t\t//输入总顶点数，总边数\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;输入点的名称，如a&quot; &lt;&lt; endl;\n\n    for(i = 0; i &lt; G.vexnum; ++i)&#123;   \n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (i+1) &lt;&lt; &quot;个点的名称:&quot;;\n        cin &gt;&gt; G.vexs[i];                        \t\t\t//依次输入点的信息 \n    &#125;\n    cout &lt;&lt; endl;\n    for(i = 0; i &lt; G.vexnum; ++i)                \t\t\t//初始化邻接矩阵，边的权值均置为极大值MaxInt \n        for(j = 0; j &lt; G.vexnum; ++j)   \n            G.arcs[i][j] = MaxInt;\n    cout &lt;&lt; &quot;输入边依附的顶点及权值，如a b 5&quot; &lt;&lt; endl;\n    for(k = 0; k &lt; G.arcnum;++k)&#123;\t\t\t\t\t\t\t//构造邻接矩阵 \n        VerTexType v1 , v2;\n        ArcType w;\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (k + 1) &lt;&lt; &quot;条边依附的顶点及权值:&quot;;\n        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;\t\t\t\t\t\t\t\t//输入一条边依附的顶点及权值\n        i = LocateVex(G, v1);  j = LocateVex(G, v2);\t\t//确定v1和v2在G中的位置，即顶点数组的下标 \n        G.arcs[i][j] = w;\t\t\t\t\t\t\t\t\t//边&lt;v1, v2&gt;的权值置为w \n        G.arcs[j][i] = G.arcs[i][j];\t\t\t\t\t\t//置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w \n    &#125;//for\n&#125;//CreateUDN \n\nint Min(AMGraph G)&#123;\n    //返回权值最小的点\n    int i;\n    int index = -1;\n    int min = MaxInt;\n    for(i = 0 ; i &lt; G.vexnum ; ++i)&#123;\n        if(min &gt; closedge[i].lowcost &amp;&amp; closedge[i].lowcost != 0)&#123;\n            min = closedge[i].lowcost;\n            index = i;\n        &#125;\n    &#125;//for\n    return index;\n&#125;//Min\n\nvoid MiniSpanTree_Prim(AMGraph G, VerTexType u)&#123; \n    //无向网G以邻接矩阵形式存储，从顶点u出发构造G的最小生成树T，输出T的各条边  \n    int k , j , i;\n    VerTexType u0 , v0;\n    k =LocateVex(G, u);           \t\t\t\t\t\t\t\t\t\t//k为顶点u的下标 \n    for(j = 0; j &lt; G.vexnum; ++j)&#123;     \t\t\t\t\t\t\t\t\t//对V-U的每一个顶点vi，初始化closedge[i] \n        if(j != k)&#123;  \n            closedge[j].adjvex = u;\n            closedge[j].lowcost = G.arcs[k][j];\t\t\t\t\t\t\t//&#123;adjvex, lowcost&#125;\n        &#125;//if\n    &#125;//for\n    closedge[k].lowcost = 0;        \t\t\t\t\t\t\t\t\t//初始，U = &#123;u&#125;\n    for(i = 1; i &lt; G.vexnum; ++i)&#123;     \t\t\t\t\t\t\t\t\t//选择其余n-1个顶点，生成n-1条边(n= G.vexnum) \n        k = Min(G);  \n        //求出T的下一个结点：第k个顶点，closedge[k]中存有当前最小边 \n        u0 = closedge[k].adjvex;     \t\t\t\t\t\t\t\t\t//u0为最小边的一个顶点，u0∈U \n        v0 = G.vexs[k];            \t\t\t\t\t\t\t\t\t\t//v0为最小边的另一个顶点，v0∈V-U \n        cout &lt;&lt; &quot;边  &quot; &lt;&lt;u0 &lt;&lt; &quot;---&gt;&quot; &lt;&lt; v0 &lt;&lt; endl;           \t\t\t//输出当前的最小边(u0, v0) \n        closedge[k].lowcost = 0;   \t\t//第k个顶点并入U集 \n        for(j = 0; j &lt; G.vexnum; ++j) \n            if(G.arcs[k][j] &lt; closedge[j].lowcost)&#123;\t\t\t\t\t\t//新顶点并入U后重新选择最小边 \n                closedge[j].adjvex = G.vexs[k];\n                closedge[j].lowcost = G.arcs[k][j];\n            &#125;//if \n    &#125;//for \n&#125;//MiniSpanTree_Prim \n\nint main()&#123;\n    cout &lt;&lt; &quot;************普里姆算法**************&quot; &lt;&lt; endl &lt;&lt; endl;\n    AMGraph G;\n    CreateUDN(G);\n    cout &lt;&lt; endl;\n    cout &lt;&lt; &quot;无向图G创建完成！&quot; &lt;&lt; endl;\n    cout &lt;&lt;endl;\n\n    cout &lt;&lt; &quot;******利用普里姆算法构造最小生成树结果：******&quot; &lt;&lt; endl;\n    MiniSpanTree_Prim(G , &#39;a&#39;);\n    cout &lt;&lt;endl;\n    return 0;\n&#125;//main\n\n例：\n\n\n克鲁斯卡尔算法（加边法）\n假设连通网N&#x3D;(V,E)，将Ⅳ中的边按权值从小到大的顺序排列。\n\n初始状态为只有n个顶点而无边的非连通图T&#x3D;(V, {),图中每个顶点自成一个连通分量。\n在E中选择权值最小的边，若该边依附的顶点落在T中不同的连通分量上（即不形成回路)，则将此边加人到T中，否则舍去此边而选择下一条权值最小的边。\n重复②，直至T中所有顶点都在同一连通分量上为止。\n\n克鲁斯卡尔算法构造最小生成树的过程：\n\n算法的实现要引人以下辅助的数据结构。\n\n结构体数组Edge:存储边的信息，包括边的两个顶点信息和权值。\n\n//辅助数组Edges的定义\nstruct\n&#123;\n    VerTexType Head; //边的始点\n    VerTexType Tail; //边的终点\n    ArcType lowcost; //边上的权值\n&#125; Edge[arcnnum];\n\n\nVexset[i]:标识各个顶点所属的连通分量。对每个顶点v,EV，在辅助数组中存在一个相应元素Vexset[i]表示该顶点所在的连通分量。初始时Vexset[i]&#x3D;i，表示各顶点自成一个连通分量。\n\n//辅助数组Vexset的定义\nint Vexset[MVNum];\n\n\n将数组Edge中的元素按权值从小到大排序。\n依次查看数组Edge中的边,循环执行以下操作:\n\n\n依次从排好序的数组 Edge 中选出一条边(U1,U2);\n在Vexset中分别查找v1和v2所在的连通分量vs1和 vs2，进行判断:  - 如果vs1,和vs2不等、表明所选的两个顶点分属不同的连通分量,输出此边,并合并vs1,和 vs2两个连通分量;  - 如果vs1,和 vs2相等，表明所选的两个顶点属于同一个连通分量，舍去此边而选择下一条权值最小的边。\n\n//克鲁斯卡尔算法\n\n#include &lt;iostream&gt;\nusing namespace std;\n\ntypedef char VerTexType;              \t\t//假设顶点的数据类型为字符型 \ntypedef int ArcType;   \n#define MVNum 100                       \t//最大顶点数\n#define MaxInt 32767                    \t//表示极大值，即∞\n\n//----------------图的邻接矩阵---------------------\ntypedef struct&#123; \n    VerTexType vexs[MVNum];            \t\t//顶点表 \n    ArcType arcs[MVNum][MVNum];      \t\t//邻接矩阵 \n    int vexnum,arcnum;                \t\t//图的当前点数和边数 \n&#125;AMGraph;\n\n//辅助数组Edges的定义\nstruct&#123;\n    VerTexType Head;\t\t\t\t\t\t//边的始点\n    VerTexType Tail;\t\t\t\t\t\t//边的终点\n    ArcType lowcost;\t\t\t\t\t\t//边上的权值\n&#125;Edge[(MVNum * (MVNum - 1)) / 2];\n\nint Vexset[MVNum];\t\t\t\t\t\t\t//辅助数组Vexset的定义\n\nint LocateVex(AMGraph G , VerTexType v)&#123;\n    //确定点v在G中的位置\n    for(int i = 0; i &lt; G.vexnum; ++i)\n        if(G.vexs[i] == v)\n            return i;\n        return -1;\n&#125;//LocateVex\n\nvoid CreateUDN(AMGraph &amp;G)&#123; \n    //采用邻接矩阵表示法，创建无向网G \n    int i , j , k;\n    cout &lt;&lt;&quot;请输入总顶点数，总边数，以空格隔开:&quot;;\n    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;\t\t\t\t\t\t//输入总顶点数，总边数\n    cout &lt;&lt; endl;\n    \n    cout &lt;&lt; &quot;输入点的名称，如a&quot; &lt;&lt; endl;\n\n    for(i = 0; i &lt; G.vexnum; ++i)&#123;   \n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (i+1) &lt;&lt; &quot;个点的名称:&quot;;\n        cin &gt;&gt; G.vexs[i];                        \t\t//依次输入点的信息 \n    &#125;\n    cout &lt;&lt; endl;\n    for(i = 0; i &lt; G.vexnum; ++i)                \t\t//初始化邻接矩阵，边的权值均置为极大值MaxInt \n        for(j = 0; j &lt; G.vexnum; ++j) \n            G.arcs[i][j] = MaxInt; \n    cout &lt;&lt; &quot;输入边依附的顶点及权值，如a b 6&quot; &lt;&lt; endl;\n    for(k = 0; k &lt; G.arcnum;++k)&#123;\t\t\t\t\t\t//构造邻接矩阵 \n        VerTexType v1 , v2;\n        ArcType w;\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (k + 1) &lt;&lt; &quot;条边依附的顶点及权值:&quot;;\n        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;                           //输入一条边依附的顶点及权值\n        i = LocateVex(G, v1);  j = LocateVex(G, v2);\t//确定v1和v2在G中的位置，即顶点数组的下标 \n        G.arcs[i][j] = w;\t\t\t\t\t\t\t\t//边&lt;v1, v2&gt;的权值置为w \n        G.arcs[j][i] = G.arcs[i][j];\t\t\t\t\t//置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w \n        Edge[k].lowcost = w;\n        Edge[k].Head = v1;\n        Edge[k].Tail = v2;\n    &#125;//for\n&#125;//CreateUDN \n\n//----------冒泡排序-------------------\nvoid Sort(AMGraph G)&#123;\n    int m = G.arcnum - 2;\n    int flag = 1;\n    while((m &gt; 0) &amp;&amp; flag == 1)&#123;\n        flag = 0;\n        for(int j = 0 ; j &lt;= m ; j++)&#123;\n            if(Edge[j].lowcost &gt; Edge[j+ 1].lowcost)&#123;\n                flag = 1;\n\n                VerTexType temp_Head = Edge[j].Head;\n                Edge[j].Head = Edge[j+ 1].Head;\n                Edge[j + 1].Head = temp_Head;\n                \n\n                VerTexType temp_Tail = Edge[j].Tail;\n                Edge[j].Tail = Edge[j+ 1].Tail;\n                Edge[j + 1].Tail = temp_Tail;\n                \n                ArcType temp_lowcost = Edge[j].lowcost;\n                Edge[j].lowcost = Edge[j+ 1].lowcost;\n                Edge[j + 1].lowcost = temp_lowcost;\n            &#125;//if\n        &#125;//for\n        --m;\n    &#125;//while\n&#125;//Sort\n\nvoid MiniSpanTree_Kruskal(AMGraph G)&#123; \n    //无向网G以邻接矩阵形式存储，构造G的最小生成树T，输出T的各条边     \n    int i , j , v1 , v2 , vs1 , vs2;\n    Sort(G);                 \t\t\t\t\t\t\t//将数组Edge中的元素按权值从小到大排序 \n    for(i = 0; i &lt; G.vexnum; ++i)     \t\t\t\t\t//辅助数组，表示各顶点自成一个连通分量 \n        Vexset[i] = i;\n    for(i = 0; i &lt; G.arcnum; ++i)&#123;      \n        //依次查看排好序的数组Edge中的边是否在同一连通分量上     \n        v1 =LocateVex(G, Edge[i].Head);     \t\t\t//v1为边的始点Head的下标 \n        v2 =LocateVex(G, Edge[i].Tail);     \t\t\t//v2为边的终点Tail的下标 \n        vs1 = Vexset[v1];       \t\t\t\t\t\t//获取边Edge[i]的始点所在的连通分量vs1 \n        vs2 = Vexset[v2];       \t\t\t\t\t\t//获取边Edge[i]的终点所在的连通分量vs2 \n        if(vs1 != vs2)&#123;         \t\t\t\t\t\t//边的两个顶点分属不同的连通分量 \n            cout &lt;&lt; Edge[i].Head &lt;&lt; &quot;--&gt;&quot; &lt;&lt; Edge[i].Tail &lt;&lt; endl;\t\t//输出此边 \n            for(j = 0; j &lt; G.vexnum; ++j)      \t\t\t//合并vs1和vs2两个分量，即两个集合统一编号 \n                if(Vexset[j] == vs2) Vexset[j] = vs1;\t//集合编号为vs2的都改为vs1 \n        &#125;//if \n    &#125;//for \n&#125;//MiniSpanTree_Kruskal\n\nvoid main()&#123;\n    cout &lt;&lt; &quot;************克鲁斯卡尔算法**************&quot; &lt;&lt; endl &lt;&lt; endl;\n    AMGraph G;\n    CreateUDN(G);\n    \n    cout &lt;&lt;endl;\n    cout &lt;&lt; &quot;*****无向网G创建完成！*****&quot; &lt;&lt; endl;\n\n    cout &lt;&lt;endl;\n    MiniSpanTree_Kruskal(G);\n&#125;///main\n\n\n②.最短路径&#x3D;&#x3D;对于图来说，从一个顶点到另一个顶点可能存在多条路径，每条路径的所包含的边数可能不同。把所包含的边数最少的那条称为最短路径。&#x3D;&#x3D;\n最短路径:对于网(带权的图)来说，从一个顶点到另一个顶点所经过的边的权值之和称为带权路径长度，把带权路径长度最短的那条称为最短路径\n从某个源点到其余各顶点的最短路径——迪杰斯特拉(Dijkstra)算法\n\n初始化:先找出从源点v0到各终点v的直达路径(v0,vk)，即通过一条弧到达的路径。\n选择:从这些路径中找出一条长度最短的路径(v0,u) 。\n更新:然后对其余各条路径进行适当调整。\n\n若在图中存在弧(u，vk) ，(v0，u) +(u，vk)&lt; (v0，vk) ,则以路径(v0,u,vk)代替（v0，vk)。在调整后的各条路径中，再找长度最短的路径。\n主要存储结构︰邻接矩阵G [n][n] (或者邻接表)\n辅助存储结构︰\n数组S[n]:记录相应顶点是否已被确定最短距离true:确定 false:未确定\n数组D[n]:记录源点到相应顶点路径长度初值:如果v0到vi有弧，则D[i]为弧上权值;否则为∞\n数组Path[n]:记录相应顶点的前驱顶点初值:如果v0到vi有弧，则Path[i]为v0，否则为-1\n\n\n初始化:将源点v0加到S中，即S[v0] &#x3D; true;将v0到各个终点的最短路径长度初始化为权值，即D[i]&#x3D; G.arcs[v0][vi]，(vi∈V -S);如果v0和顶点vi之间有弧，则将vi的前驱置为v0，即Path[i] &#x3D; v0，否则Path[i] &#x3D; -1。\n\n循环n-1次，执行以下操作:选择下一条最短路径的终点vk，使得:D[k]&#x3D;Min{D[i]viEV-S}将vk加到S中，即S[vk] &#x3D; true。更新从v0出发到集合V-S上任一顶点的最短路径的长度，同时更改vi的前驱为vk。若S[i]&#x3D;false 且D[k]+G.arcs[k][i]&lt;D[i]，则更新D[i]-D[k]+ G.arcs[k][i; Path [i]&#x3D;k;。\n\n\n//最短路径--迪杰斯特拉算法\n#include &lt;iostream&gt;\nusing namespace std;\n\n#define MaxInt 32767                    \t\t\t\t\t//表示极大值，即∞\n#define MVNum 100                       \t\t\t\t\t//最大顶点数\ntypedef char VerTexType;              \t\t\t\t\t\t//假设顶点的数据类型为字符型 \ntypedef int ArcType;                  \t\t\t\t\t\t//假设边的权值类型为整型\n\nint *D=new int[MVNum];\t                    \t\t\t\t//用于记录最短路的长度\nbool *S=new bool[MVNum];          \t\t\t\t\t\t\t//标记顶点是否进入S集合\nint *Path=new int[MVNum];\t\t\t\t\t\t\t\t\t//用于记录最短路顶点的前驱\n\n//------------图的邻接矩阵-----------------\ntypedef struct&#123; \n    VerTexType vexs[MVNum];            \t\t\t\t\t\t//顶点表 \n    ArcType arcs[MVNum][MVNum];      \t\t\t\t\t\t//邻接矩阵 \n    int vexnum,arcnum;                \t\t\t\t\t\t//图的当前点数和边数 \n&#125;AMGraph;\n\nint LocateVex(AMGraph G , VerTexType v)&#123;\n    //确定点v在G中的位置\n    for(int i = 0; i &lt; G.vexnum; ++i)\n        if(G.vexs[i] == v)\n            return i;\n   return -1;\n&#125;//LocateVex\n\nvoid CreateUDN(AMGraph &amp;G)&#123; \n    //采用邻接矩阵表示法，创建无向网G \n    int i , j , k;\n    cout &lt;&lt;&quot;请输入总顶点数，总边数，以空格隔开:&quot;;\n    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;\t\t\t\t\t\t\t//输入总顶点数，总边数\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;输入点的名称:，如a&quot; &lt;&lt; endl;\n\n    for(i = 0; i &lt; G.vexnum; ++i)&#123;   \n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (i+1) &lt;&lt; &quot;个点的名称:&quot;;\n        cin &gt;&gt; G.vexs[i];                        \t\t\t//依次输入点的信息 \n    &#125;\n    cout &lt;&lt; endl;\n    for(i = 0; i &lt; G.vexnum; ++i)                \t\t\t//初始化邻接矩阵，边的权值均置为极大值MaxInt \n        for(j = 0; j &lt; G.vexnum; ++j)   \n            G.arcs[i][j] = MaxInt; \n    cout &lt;&lt; &quot;输入边依附的顶点及权值，如a b 7&quot; &lt;&lt; endl;\n    for(k = 0; k &lt; G.arcnum;++k)&#123;\t\t\t\t\t\t\t//构造邻接矩阵 \n        VerTexType v1 , v2;\n        ArcType w;\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (k + 1) &lt;&lt; &quot;条边依附的顶点及权值:&quot;;\n        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;\t\t\t\t\t\t\t\t//输入一条边依附的顶点及权值\n        i = LocateVex(G, v1);  j = LocateVex(G, v2);\t\t//确定v1和v2在G中的位置，即顶点数组的下标 \n        G.arcs[i][j] = w;\t\t\t\t\t\t\t\t\t//边&lt;v1, v2&gt;的权值置为w \n        G.arcs[j][i] = G.arcs[i][j];\t\t\t\t\t\t//置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w \n    &#125;//for\n&#125;//CreateUDN\n\nvoid ShortestPath_DIJ(AMGraph G, int v0)&#123; \n    //用Dijkstra算法求有向网G的v0顶点到其余顶点的最短路径 \n    int v , i , w , min;\n    int n = G.vexnum;                    \t\t\t\t\t//n为G中顶点的个数 \n\n    for(v = 0; v &lt; n; ++v)&#123;             \t\t\t\t\t//n个顶点依次初始化 \n        S[v] = 0;                  \t\t\t\t\t\t//S初始为空集 \n        D[v] = G.arcs[v0][v];           \t\t\t\t\t//将v0到各个终点的最短路径长度初始化为弧上的权值 \n        if(D[v] &lt; MaxInt)  Path [v] = v0;  \t\t\t\t\t//如果v0和v之间有弧，则将v的前驱置为v0 \n        else Path [v] = -1;               \t\t\t\t\t//如果v0和v之间无弧，则将v的前驱置为-1 \n    &#125;//for \n\n    S[v0]=true;                    \t\t\t\t\t\t\t//将v0加入S \n    D[v0]=0;                      \t\t\t\t\t\t\t//源点到源点的距离为0 \n\n    /*―初始化结束，开始主循环，每次求得v0到某个顶点v的最短路径，将v加到S集―*/ \n    for(i = 1;i &lt; n; ++i)&#123;\t\t\t\t\t\t\t\t\t//对其余n-1个顶点，依次进行计算 \n        min= MaxInt; \n        for(w = 0; w &lt; n; ++w) \n            if(!S[w] &amp;&amp; D[w] &lt; min)&#123;\t\t\t\t\t\t//选择一条当前的最短路径，终点为v \n                v = w; \n                min = D[w];\n            &#125;//if         \t\n        S[v]=true;                   \t\t\t\t\t\t//将v加入S \n        for(w = 0;w &lt; n; ++w)           \t\t\t\t\t//更新从v0出发到集合V?S上所有顶点的最短路径长度 \n            if(!S[w] &amp;&amp; (D[v] + G.arcs[v][w] &lt; D[w]))&#123; \n                D[w] = D[v] + G.arcs[v][w];   \t\t\t\t//更新D[w] \n                Path [w] = v;              \t\t\t\t\t//更改w的前驱为v \n            &#125;//if \n    &#125;//for  \n&#125;//ShortestPath_DIJ\n\nvoid DisplayPath(AMGraph G , int begin ,int temp )&#123;\n    //显示最短路\n    if(Path[temp] != -1)&#123;\n        DisplayPath(G , begin ,Path[temp]);\n        cout &lt;&lt; G.vexs[Path[temp]] &lt;&lt; &quot;--&gt;&quot;;\n    &#125;\n&#125;//DisplayPath\n\nint main()\n&#123;\n    cout &lt;&lt; &quot;************迪杰斯特拉算法**************&quot; &lt;&lt; endl &lt;&lt; endl;\n    AMGraph G; \n    int i , j ,num_start , num_destination;\n    VerTexType start , destination;\n    CreateUDN(G);\n    cout &lt;&lt;endl;\n    cout &lt;&lt; &quot;*****无向网G创建完成！*****&quot; &lt;&lt; endl;\n    \n    for(i = 0 ; i &lt; G.vexnum ; ++i)&#123;\n        for(j = 0; j &lt; G.vexnum; ++j)&#123;\n            if(j != G.vexnum - 1)&#123;\n                if(G.arcs[i][j] != MaxInt)\n                    cout &lt;&lt; G.arcs[i][j] &lt;&lt; &quot;\\t&quot;;\n                else\n                    cout &lt;&lt; &quot;∞&quot; &lt;&lt; &quot;\\t&quot;;\n            &#125;\n            else&#123;\n                if(G.arcs[i][j] != MaxInt)\n                    cout &lt;&lt; G.arcs[i][j] &lt;&lt;endl;\n                else\n                    cout &lt;&lt; &quot;∞&quot; &lt;&lt;endl;\n            &#125;\n        &#125;\n    &#125;//for\n    cout &lt;&lt; endl;\n    cout &lt;&lt; &quot;请依次输入起始点、终点名称：&quot;;\n    cin &gt;&gt; start &gt;&gt; destination;\n    num_start = LocateVex(G , start);\n    num_destination = LocateVex(G , destination);\n    ShortestPath_DIJ(G , num_start);\n    cout &lt;&lt; endl &lt;&lt;&quot;最短路径为：&quot;;\n    DisplayPath(G , num_start , num_destination);\n    cout &lt;&lt; G.vexs[num_destination]&lt;&lt;endl;\n&#125;//main\n\n\n\n每一对顶点之间的最短路径——弗洛伊德(Floyd)算法\n从图的带权邻接矩阵G.arcs出发，假设求顶点Vi到Vj的最短路径。如果从Vi到Vj有弧，则从Vi到Vj存在—条长度为G.arcs[i]i]的路径，但该路径是否一定是最短路径，还需要进行n次试探。\n\n第一次，判别( Vi, V0 ）和( V0, Vj ) ，即判别(Vi, V0 , Vj)是否存在，若存在，则比较（Vi,Vj）和(Vi, V0 , Vj)的长度，取长度较短的为从Vi到Vj的中间顶点序号不大于0的最短路径。\n第二次，再加一个顶点V1，如果(Vi,… , V1)和(V1,…,Vj)分别是当前找到的中间顶点序号不大于0的最短路径，那么(Vi,… ,V1,…,Vj）就有可能是从Vi到Vj的中间顶点序号不大于1的最短路径。将它和已经得到的从Vi到Vj之间顶点序号不大于0的最短路径相比较，取较短者为从Vi到Vj的中间顶点序号不大于1的最短路径。\n第三次，再加一个顶点V2，继续进行试探。\n\n求最短路径步骤:\n\n初始时设置一个n阶方阵,令其对角线元素为0，若存在弧&lt;Vi，Vj &gt;，则对应元素为权值;否则为无穷大。\n逐步试着在原直接路径中增加中间顶点，若加入中间顶点后路径变短，则修改之;否则，维持原值。所有顶点试探完毕，算法结束。\n\n\n//弗洛伊德算法\n\n#include &lt;iostream&gt;\nusing namespace std;\n\n#define MaxInt 32767                    \t//表示极大值，即∞\n#define MVNum 100                       \t//最大顶点数\n\ntypedef char VerTexType;              \t\t//假设顶点的数据类型为字符型 \ntypedef int ArcType;                  \t\t//假设边的权值类型为整型 \n\nint Path[MVNum][MVNum];\t\t\t\t\t\t//最短路径上顶点vj的前一顶点的序号\nint D[MVNum][MVNum];\t\t\t\t\t\t//记录顶点vi和vj之间的最短路径长度\n\n//------------图的邻接矩阵---------------\ntypedef struct&#123; \n    VerTexType vexs[MVNum];            \t\t//顶点表 \n    ArcType arcs[MVNum][MVNum];      \t\t//邻接矩阵 \n    int vexnum,arcnum;                \t\t//图的当前点数和边数 \n&#125;AMGraph;\n\nint LocateVex(AMGraph G , VerTexType v)&#123;\n    //确定点v在G中的位置\n    for(int i = 0; i &lt; G.vexnum; ++i)\n        if(G.vexs[i] == v)\n            return i;\n        return -1;\n&#125;//LocateVex\n\nvoid CreateUDN(AMGraph &amp;G)&#123; \n    //采用邻接矩阵表示法，创建有向网G \n    int i , j , k;\n    cout &lt;&lt;&quot;请输入总顶点数，总边数，以空格隔开:&quot;;\n    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;\t\t\t\t\t\t\t//输入总顶点数，总边数\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;输入点的名称，如a&quot; &lt;&lt; endl;\n\n    for(i = 0; i &lt; G.vexnum; ++i)&#123;   \n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (i+1) &lt;&lt; &quot;个点的名称:&quot;;\n        cin &gt;&gt; G.vexs[i];                        \t\t\t//依次输入点的信息 \n    &#125;\n    cout &lt;&lt; endl;\n    for(i = 0; i &lt; G.vexnum; ++i)&#123;                \t\t\t//初始化邻接矩阵，边的权值均置为极大值MaxInt \n        for(j = 0; j &lt; G.vexnum; ++j)&#123;  \n            if(j != i)\n                G.arcs[i][j] = MaxInt;  \n            else\n                G.arcs[i][j] = 0;\n        &#125;//for\n    &#125;//for\n\n    cout &lt;&lt; &quot;输入边依附的顶点及权值，如a b 3&quot; &lt;&lt; endl;\n    for(k = 0; k &lt; G.arcnum;++k)&#123;\t\t\t\t\t\t//构造邻接矩阵 \n        VerTexType v1 , v2;\n        ArcType w;\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (k + 1) &lt;&lt; &quot;条边依附的顶点及权值:&quot;;\n        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;                           //输入一条边依附的顶点及权值\n        i = LocateVex(G, v1);  j = LocateVex(G, v2);\t//确定v1和v2在G中的位置，即顶点数组的下标 \n        G.arcs[i][j] = w;\t\t\t\t\t\t\t\t//边&lt;v1, v2&gt;的权值置为w \n    &#125;//for\n&#125;//CreateUDN \n\nvoid ShortestPath_Floyed(AMGraph G)&#123; \n    //用Floyd算法求有向网G中各对顶点i和j之间的最短路径 \n    int i , j , k ;\n    for (i = 0; i &lt; G.vexnum; ++i)          \t\t//各对结点之间初始已知路径及距离 \n        for(j = 0; j &lt; G.vexnum; ++j)&#123; \n            D[i][j] = G.arcs[i][j]; \n            if(D[i][j] &lt; MaxInt &amp;&amp; i != j)  Path[i][j]=i;  \t//如果i和j之间有弧，则将j的前驱置为i \n            else Path [i][j] = -1;              \t\t//如果i和j之间无弧，则将j的前驱置为-1 \n        &#125;//for\n        for(k = 0; k &lt; G.vexnum; ++k) \n            for(i = 0; i &lt; G.vexnum; ++i) \n                for(j = 0; j &lt; G.vexnum; ++j)\n                    if(D[i][k] + D[k][j] &lt; D[i][j])&#123;   \t\t//从i经k到j的一条路径更短 \n                        D[i][j] = D[i][k]+D[k][j];    \t\t//更新D[i][j] \n                        Path[i][j] = Path[k][j];       \t\t\t//更改j的前驱为k \n                    &#125;//if \n&#125;//ShortestPath_Floyed\n\nvoid DisplayPath(AMGraph G , int begin ,int temp )&#123;\n    //显示最短路径\n    if(Path[begin][temp] != -1)&#123;\n        DisplayPath(G , begin ,Path[begin][temp]);\n        cout &lt;&lt; G.vexs[Path[begin][temp]] &lt;&lt; &quot;--&gt;&quot;;\n    &#125;\n&#125;//DisplayPath\n\nvoid main()&#123;\n    cout &lt;&lt; &quot;************弗洛伊德算法**************&quot; &lt;&lt; endl &lt;&lt; endl;\n    AMGraph G;\n    char start , destination;\n    int num_start , num_destination;\n\n    CreateUDN(G);\n    \n    cout &lt;&lt;endl;\n    cout &lt;&lt; &quot;有向网G创建完成！&quot; &lt;&lt; endl;\n    ShortestPath_Floyed(G);\n\n    cout &lt;&lt; &quot;请依次输入路径的起点与终点的名称：&quot;;\n    cin &gt;&gt; start &gt;&gt; destination;\n    num_start = LocateVex(G , start);\n    num_destination = LocateVex(G , destination);\n\n    DisplayPath(G , num_start , num_destination);\n    cout &lt;&lt; G.vexs[num_destination] &lt;&lt; endl;\n    cout &lt;&lt; &quot;最短路径的长度为：&quot; &lt;&lt; D[num_start][num_destination] &lt;&lt; endl;\n    cout &lt;&lt;endl;\n&#125;//main\n\n③.拓扑排序对一项工程，我们最关心两个问题:\n\n工程能否顺利完成;(拓扑排序)\n整个工程完成所必需的最短工期。(关键路径)\n\n&#x3D;&#x3D;有向无环图—-无环的有向图，简称DAG图( directed acycling graph)&#x3D;&#x3D;\n&#x3D;&#x3D;AOV网:用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以顶点表示活动，弧表示活动之间的优先制约关系，称这种有向图为顶点表示活动的网，简称AOV网。&#x3D;&#x3D;\n&#x3D;&#x3D;AOV网应该是一个有向无环图即DAG图。&#x3D;&#x3D;\n拓扑排序：\n就是将AOV网中所有顶点排成一个线性序列(称为拓扑序列)，该序列满足∶若在AOV网中由顶点vi到vj有一条路径，则在该线性序列中的顶点vi必定在vj之前\n\n在有向图中选一个无前驱的顶点且输出它（即入度为0)\n从图中删除该顶点和所有以它为起点的边\n重复(1)(2)，直至不存在无前驱的顶点\n若此时输出的顶点数小于有向图的顶点数，则说明有向图中存在环，否则输出的顶点序列为一个拓扑序列\n\n\n拓扑排序实现\n\n求出个顶点的入度存入数组indegree[i]中，并将入度为0的顶点入栈。\n\n只要栈不空，重复以下操作- 将栈顶顶点vi出栈并保存在拓扑序列数组topo中;- 对顶点vi的每个邻接点vk的入度减1，如果vk的入度变为0，则将vk入栈\n\n如果输出顶点个数少于AOV网的顶点个数，则网址存在有向环，无法进行拓扑排序，否则拓扑排序成功。\n\n\n//拓扑排序\n\n#include &lt;iostream&gt;\nusing namespace std;\n\n#define MVNum 100                       \t//最大顶点数\n#define OK 1\t\n#define ERROR 0 \n\ntypedef char VerTexType;\n\n//- - - - -图的邻接表存储表示- - - - - \ntypedef struct ArcNode&#123;                \t\t//边结点 \n    int adjvex;                          \t//该边所指向的顶点的位置 \n    struct ArcNode *nextarc;          \t\t//指向下一条边的指针 \n&#125;ArcNode; \n\ntypedef struct VNode&#123; \n    VerTexType data;                    \t//顶点信息 \n    ArcNode *firstarc;                \t\t//指向第一条依附该顶点的边的指针 \n&#125;VNode, AdjList[MVNum];               \t\t//AdjList表示邻接表类型 \n\ntypedef struct&#123; \n    AdjList vertices;                 \t\t//邻接表 \n    AdjList converse_vertices;\t\t\t\t//逆邻接表\n    int vexnum, arcnum;              \t\t//图的当前顶点数和边数 \n&#125;ALGraph;\n//- - - - - - - - - - - - - - - -\n\n//- - - - -顺序栈的定义- - - - -\ntypedef struct&#123;\n    int *base;\n    int *top;\n    int stacksize;\n&#125;spStack;\n//- - - - - - - - - - - - - - - -\n\nint indegree[MVNum];\t\t\t\t\t\t//数组indegree存放个顶点的入度\nspStack S;\n\n//------------栈的相关操作----------------------\nvoid InitStack(spStack &amp;S)&#123;\n    //初始化栈\n    S.base = new int[MVNum];\n    if(!S.base)\n        exit(1);\n    S.top = S.base;\n    S.stacksize = MVNum;\n&#125;//InitStack\n\nvoid Push(spStack &amp;S , int i)&#123;\n    //进栈\n    if(S.top - S.base == S.stacksize)\n        return;\n    *S.top++ = i;\n&#125;//Push\n\nvoid Pop(spStack &amp;S , int &amp;i)&#123;\n    //出栈\n    if(S.top == S.base)\n        return;\n    i = *--S.top;\n&#125;//Pop\n\nbool StackEmpty(spStack S)&#123;\n    //判断栈是否为空\n    if(S.top == S.base)\n        return true;\n    return false;\n&#125;//StackEmpty\n//-------------------------------------------------\n\nint LocateVex(ALGraph G , VerTexType v)&#123;\n    //确定点v在G中的位置\n    for(int i = 0; i &lt; G.vexnum; ++i)\n        if(G.vertices[i].data == v)\n            return i;\n        return -1;\n&#125;//LocateVex\n\nint CreateUDG(ALGraph &amp;G)&#123; \n    //创建有向图G的邻接表、逆邻接表\n    int i , k;\n    \n    cout &lt;&lt;&quot;请输入总顶点数，总边数，以空格隔开:&quot;;\n    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;\t\t\t\t//输入总顶点数，总边数 \n    cout &lt;&lt; endl;\n    \n    cout &lt;&lt; &quot;输入点的名称，如a&quot; &lt;&lt; endl;\n    \n    for(i = 0; i &lt; G.vexnum; ++i)&#123;          \t//输入各点，构造表头结点表\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (i+1) &lt;&lt; &quot;个点的名称:&quot;;\n        cin &gt;&gt; G.vertices[i].data;           \t//输入顶点值\n        G.converse_vertices[i].data = G.vertices[i].data;\n        //初始化表头结点的指针域为NULL \n        G.vertices[i].firstarc=NULL;\t\t\t\n        G.converse_vertices[i].firstarc=NULL;\n    &#125;//for\n    cout &lt;&lt; endl;\n    cout &lt;&lt; &quot;输入边依附的顶点，如a b&quot; &lt;&lt; endl;\n    for(k = 0; k &lt; G.arcnum;++k)&#123;        \t\t//输入各边，构造邻接表\n        VerTexType v1 , v2;\n        int i , j;\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (k + 1) &lt;&lt; &quot;条边依附的顶点:&quot;;\n        cin &gt;&gt; v1 &gt;&gt; v2;                \t\t//输入一条边依附的两个顶点\n        i = LocateVex(G, v1);  j = LocateVex(G, v2);\n        //确定v1和v2在G中位置，即顶点在G.vertices中的序号 \n\n        ArcNode *p1=new ArcNode;               \t//生成一个新的边结点*p1 \n        p1-&gt;adjvex=j;                   \t\t//邻接点序号为j\n        p1-&gt;nextarc = G.vertices[i].firstarc;  G.vertices[i].firstarc=p1;\n        //将新结点*p1插入顶点vi的边表头部\n\n        ArcNode *p2=new ArcNode;               \t//生成一个新的边结点*p1 \n        p2-&gt;adjvex=i;                   \t\t//逆邻接点序号为i\n        p2-&gt;nextarc = G.converse_vertices[j].firstarc;  G.converse_vertices[j].firstarc=p2;\n        //将新结点*p1插入顶点vi的边表头部\n    &#125;//for \n    return OK; \n&#125;//CreateUDG\n\nvoid FindInDegree(ALGraph G)&#123;\n    //求出各顶点的入度存入数组indegree中 \n    int i , count;\n\n    for(i = 0 ; i &lt; G.vexnum ; i++)&#123;\n        count = 0;\n        ArcNode *p = G.converse_vertices[i].firstarc;\n        if(p)&#123;\n            while(p)&#123;\n                p = p-&gt;nextarc;\n                count++;\n            &#125;\n        &#125;\n        indegree[i] = count;\n    &#125;\n&#125;//FindInDegree\n\nint TopologicalSort(ALGraph G , int topo[])&#123; \n    //有向图G采用邻接表存储结构 \n    //若G无回路，则生成G的一个拓扑序列topo[]并返回OK，否则ERROR \n    int i , m;\n    FindInDegree(G);              \t\t\t\t//求出各顶点的入度存入数组indegree中 \n    InitStack(S);                          \t\t//栈S初始化为空 \n    for(i = 0; i &lt; G.vexnum; ++i)\n        if(!indegree[i]) Push(S, i);     \t\t//入度为0者进栈 \n    m = 0;                               \t\t//对输出顶点计数，初始为0 \n    while(!StackEmpty(S))&#123;                \t\t//栈S非空 \n        Pop(S, i);                          \t//将栈顶顶点vi出栈\n        topo[m]=i;                         \t\t//将vi保存在拓扑序列数组topo中 \n        ++m;                             \t\t//对输出顶点计数 \n        ArcNode *p = G.vertices[i].firstarc;    //p指向vi的第一个邻接点 \n        while(p)&#123;\n            int k = p-&gt;adjvex;\t\t\t\t\t//vk为vi的邻接点   \n            --indegree[k];                   \t//vi的每个邻接点的入度减1 \n            if(indegree[k] ==0)  Push(S, k);\t//若入度减为0，则入栈 \n            p = p-&gt;nextarc;                \t\t//p指向顶点vi下一个邻接结点 \n        &#125;//while \n    &#125;//while\n    \n    if(m &lt; G.vexnum)  return ERROR;    \t\t\t//该有向图有回路 \n    else return OK;\n&#125;//TopologicalSort \n\nint main()&#123;\n    cout &lt;&lt; &quot;************拓扑排序**************&quot; &lt;&lt; endl &lt;&lt; endl;\n    ALGraph G;\n    CreateUDG(G);\n    int *topo = new int [G.vexnum];\n    \n    cout &lt;&lt; endl;\n    cout &lt;&lt; &quot;有向图的邻接表、逆邻接表创建完成!&quot; &lt;&lt; endl &lt;&lt; endl;\n\n    if(TopologicalSort(G , topo))&#123;\n        cout &lt;&lt; &quot;该有向图的拓扑有序序列为：&quot;;\n        for(int j = 0 ; j &lt; G.vexnum; j++)&#123;\n            if(j != G.vexnum - 1)\n                cout &lt;&lt; G.vertices[topo[j]].data &lt;&lt; &quot; , &quot;;\n            else\n                cout &lt;&lt; G.vertices[topo[j]].data &lt;&lt; endl &lt;&lt; endl;\n        &#125;//for\n    &#125;\n    else\n        cout &lt;&lt; &quot;网中存在环，无法进行拓扑排序！&quot; &lt;&lt;endl &lt;&lt; endl;\n    return OK;\n&#125;//main\n\n④.关键路径AOE网(Activity On Edges)—用边表示活动的网络用一个有向图表示一个工程的各子工程及其相互制约的关系，弧表示活动，权表示活动持续的时间，顶点表示事件（活动的开始或结束时间)，称这种有向图为边表示活动的网，简称AOE网;AOE网用来估算工程的完成时间。\n\n\n\n名称\n解释\n\n\n\n源点\n入度为0的顶点（只有1个)\n\n\n汇点\n出度为0的顶点(只有1个)\n\n\n路径长度\n路径上各活动持续时间之和\n\n\n整个工程完成的时间\n从有向图的源点到汇点的最长路径\n\n\n关键路径\n路径长度最长的路径\n\n\n关键活动\n关键路径上的活动，边上的权值增加将使有向图上的最长路径的长度增加。\n\n\nve(j)\n表示事件V的最早发生时间\n\n\nvl(j)\n表示事件V,的最迟发生时间\n\n\ne(i)\n表示活动ai的最早开始时间\n\n\nl(i)\n表示活动ai的最迟开始时间\n\n\nl(i)-e(i)\n表示完成活动ai的时间余量\n\n\n注意:在一个AOE网中，可以有不止一条的关键路径。\n关键路径\n\n//关键路径算法\n\n#include &lt;iostream&gt;\nusing namespace std;\n\n#define MVNum 100                       \t//最大顶点数\n#define BDNum MVNum * (MVNum - 1)\t\t\t//最大边数\n#define OK 1\t\n#define ERROR 0 \n\ntypedef char VerTexType;\n\n//- - - - -图的邻接表存储表示- - - - - \ntypedef struct ArcNode&#123;                \t\t//边结点 \n    int adjvex;                          \t//该边所指向的顶点的位置\n    int weight;\t\t\t\t\t\t\t\t//权值\n    struct ArcNode *nextarc;          \t\t//指向下一条边的指针 \n&#125;ArcNode; \n\ntypedef struct VNode&#123; \n    VerTexType data;                    \t//顶点信息\n    ArcNode *firstarc;                \t\t//指向第一条依附该顶点的边的指针 \n&#125;VNode, AdjList[MVNum];               \t\t//AdjList表示邻接表类型 \n\ntypedef struct&#123; \n    AdjList vertices;                 \t\t//邻接表 \n    AdjList converse_vertices;\t\t\t\t//逆邻接表\n    int vexnum, arcnum;              \t\t//图的当前顶点数和边数 \n&#125;ALGraph;\n//- - - - - - - - - - - - - - - -\n\n//- - - - -顺序栈的定义- - - - -\ntypedef struct&#123;\n    int *base;\n    int *top;\n    int stacksize;\n&#125;spStack;\n//- - - - - - - - - - - - - - - -\n\nint indegree[MVNum];\t\t\t\t\t\t//数组indegree存放个顶点的入度\nint ve[BDNum];\t\t\t\t\t\t\t\t//事件vi的最早发生时间\nint vl[BDNum];\t\t\t\t\t\t\t\t//事件vi的最迟发生时间\nint topo[MVNum];\t\t\t\t\t\t\t//记录拓扑序列的顶点序号\nspStack S;\n\n//----------------栈的操作--------------------\nvoid InitStack(spStack &amp;S)&#123;\n    //栈的初始化\n    S.base = new int[MVNum];\n    if(!S.base)\n        exit(1);\n    S.top = S.base;\n    S.stacksize = MVNum;\n&#125;//InitStack\n\nvoid Push(spStack &amp;S , int i)&#123;\n    //入栈\n    if(S.top - S.base == S.stacksize)\n        return;\n    *S.top++ = i;\n&#125;//Push\n\nvoid Pop(spStack &amp;S , int &amp;i)&#123;\n    //出栈\n    if(S.top == S.base)\n        return;\n    i = *--S.top;\n&#125;//Pop\n\nbool StackEmpty(spStack S)&#123;\n    //判断栈是否为空\n    if(S.top == S.base)\n        return true;\n    return false;\n&#125;//StackEmpty\n//---------------------------------------\n\nint LocateVex(ALGraph G , VerTexType v)&#123;\n    //确定点v在G中的位置\n    for(int i = 0; i &lt; G.vexnum; ++i)\n        if(G.vertices[i].data == v)\n            return i;\n        return -1;\n&#125;//LocateVex\n\nint CreateUDG(ALGraph &amp;G)&#123; \n    //创建有向图G的邻接表、逆邻接表\n    int i , k;\n    \n    cout &lt;&lt;&quot;请输入总顶点数，总边数，以空格隔开:&quot;;\n    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;\t\t\t\t//输入总顶点数，总边数 \n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;输入点的名称，如a&quot; &lt;&lt; endl;\n    \n    for(i = 0; i &lt; G.vexnum; ++i)&#123;          \t\t//输入各点，构造表头结点表\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (i+1) &lt;&lt; &quot;个点的名称:&quot;;\n        cin &gt;&gt; G.vertices[i].data;           \t\t//输入顶点值\n        G.converse_vertices[i].data = G.vertices[i].data;\n        //初始化表头结点的指针域为NULL \n        G.vertices[i].firstarc=NULL;\t\t\t\n        G.converse_vertices[i].firstarc=NULL;\n    &#125;//for\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;输入边依附的顶点及其权值，如a b 3&quot; &lt;&lt; endl;\n\n    for(k = 0; k &lt; G.arcnum;++k)&#123;        \t\t\t//输入各边，构造邻接表\n        VerTexType v1 , v2;\n        int i , j , w;\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (k + 1) &lt;&lt; &quot;条边依附的顶点及其权值:&quot;;\n        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;                \t\t//输入一条边依附的两个顶点\n        i = LocateVex(G, v1);  j = LocateVex(G, v2);\n        //确定v1和v2在G中位置，即顶点在G.vertices中的序号 \n\n        ArcNode *p1=new ArcNode;               \t\t//生成一个新的边结点*p1 \n        p1-&gt;adjvex=j;                   \t\t\t//邻接点序号为j\n        p1-&gt;nextarc = G.vertices[i].firstarc;  G.vertices[i].firstarc=p1;\n        p1-&gt;weight = w;\n        //将新结点*p1插入顶点vi的边表头部\n\n        ArcNode *p2=new ArcNode;               \t\t//生成一个新的边结点*p1 \n        p2-&gt;adjvex=i;                   \t\t\t//逆邻接点序号为i\n        p2-&gt;nextarc = G.converse_vertices[j].firstarc;  G.converse_vertices[j].firstarc=p2;\n        p2-&gt;weight = w;\n        //将新结点*p1插入顶点vi的边表头部\n    &#125;//for \n    return OK; \n&#125;//CreateUDG\n\nvoid FindInDegree(ALGraph G)&#123;\n    //求出各顶点的入度存入数组indegree中 \n    int i , count;\n\n    for(i = 0 ; i &lt; G.vexnum ; i++)&#123;\n        count = 0;\n        ArcNode *p = G.converse_vertices[i].firstarc;\n        if(p)&#123;\n            while(p)&#123;\n                p = p-&gt;nextarc;\n                count++;\n            &#125;\n        &#125;//if\n        indegree[i] = count;\n    &#125;//for\n&#125;//FindInDegree\n\nint TopologicalOrder(ALGraph G , int topo[])&#123; \n    //有向图G采用邻接表存储结构 \n    //若G无回路，则生成G的一个拓扑序列topo[]并返回OK，否则ERROR \n    int i , m;\n    FindInDegree(G);              \t\t\t\t//求出各顶点的入度存入数组indegree中 \n    InitStack(S);                          \t\t//栈S初始化为空 \n    for(i = 0; i &lt; G.vexnum; ++i)\n        if(!indegree[i]) Push(S, i);     \t\t//入度为0者进栈 \n    m = 0;                               \t\t//对输出顶点计数，初始为0 \n    while(!StackEmpty(S))&#123;                \t\t//栈S非空 \n        Pop(S, i);                          \t//将栈顶顶点vi出栈\n        topo[m]=i;                         \t\t//将vi保存在拓扑序列数组topo中 \n        ++m;                             \t\t//对输出顶点计数 \n        ArcNode *p = G.vertices[i].firstarc;    //p指向vi的第一个邻接点 \n        while(p)&#123;\n            int k = p-&gt;adjvex;\t\t\t\t\t//vk为vi的邻接点   \n            --indegree[k];                   \t//vi的每个邻接点的入度减1 \n            if(indegree[k] ==0)  Push(S, k);\t//若入度减为0，则入栈 \n            p = p-&gt;nextarc;                \t\t//p指向顶点vi下一个邻接结点 \n        &#125;//while \n    &#125;//while\n    \n    if(m &lt; G.vexnum)  return ERROR;    \t\t\t//该有向图有回路 \n    else return OK;\n&#125;//TopologicalOrder\n\nint CriticalPath(ALGraph G)&#123; \n    //G为邻接表存储的有向网，输出G的各项关键活动\n    int n , i , k , j , e , l;\n    if (!TopologicalOrder(G, topo))  return ERROR; \n    //调用拓扑排序算法，使拓扑序列保存在topo中，若调用失败，则存在有向环，返回ERROR \n    n = G.vexnum;                  \t\t\t\t//n为顶点个数 \n    for(i = 0; i &lt; n; i++)               \t\t//给每个事件的最早发生时间置初值0 \n        ve[i] = 0; \n\n\n    /*――――――――――按拓扑次序求每个事件的最早发生时间－――――－―――――*/ \n    for(i = 0;i &lt; n; i++)&#123;                 \n        k = topo[i];                   \t\t\t//取得拓扑序列中的顶点序号k             \n        ArcNode *p = G.vertices[k].firstarc;    //p指向k的第一个邻接顶点  \n        while(p != NULL)&#123;            \t\t\t//依次更新k的所有邻接顶点的最早发生时间   \n            j = p-&gt;adjvex;               \t\t//j为邻接顶点的序号                   \n            if(ve[j] &lt; ve[k] + p-&gt;weight)    \t//更新顶点j的最早发生时间ve[j] \n                ve[j] = ve[k] + p-&gt;weight;     \n            p = p-&gt;nextarc;              \t\t//p指向k的下一个邻接顶点  \n        &#125; //while \n    &#125; //for \n\n    for(i=0;i&lt;n;i++)                 \t\t\t//给每个事件的最迟发生时间置初值ve[n-1] \n        vl[i]=ve[n-1];\n    \n    /*――――――――――按逆拓扑次序求每个事件的最迟发生时间－――――－―――――*/ \n    for(i = n - 1;i &gt;= 0; i--)&#123;               \n        k = topo[i];                   \t\t\t//取得拓扑序列中的顶点序号k             \n        ArcNode *p = G.vertices[k].firstarc;    //p指向k的第一个邻接顶点  \n        while(p != NULL)&#123;            \t\t\t//根据k的邻接点，更新k的最迟发生时间   \n            j = p-&gt;adjvex;              \t\t//j为邻接顶点的序号                   \n            if(vl[k] &gt; vl[j] - p-&gt;weight)    \t//更新顶点k的最迟发生时间vl[k] \n                vl[k] = vl[j] - p-&gt;weight;       \n            p = p-&gt;nextarc;              \t\t//p指向k的下一个邻接顶点  \n        &#125;//while \n    &#125;//for \n\n    /*――――――――――――判断每一活动是否为关键活动－――――――－―――――*/\n    cout &lt;&lt; endl;\n    cout &lt;&lt; &quot;关键活动路径为:&quot;;\n    for(i = 0;i &lt; n; i++)&#123;                \t\t//每次循环针对vi为活动开始点的所有活动 \n        ArcNode *p = G.vertices[i].firstarc;    //p指向i的第一个邻接顶点  \n        while(p != NULL) &#123;    \n            j = p-&gt;adjvex;             \t\t\t//j为i的邻接顶点的序号    \n            e = ve[i];                 \t\t\t//计算活动&lt;vi, vj&gt;的最早开始时间 \n            l = vl[j] - p-&gt;weight;      \t\t//计算活动&lt;vi, vj&gt;的最迟开始时间 \n            if(e == l)               \t\t\t//若为关键活动，则输出&lt;vi, vj&gt; \n                cout &lt;&lt; G.vertices[i].data &lt;&lt; &quot;--&gt;&quot; &lt;&lt; G.vertices[j].data &lt;&lt; &quot; &quot;;\n            p = p-&gt;nextarc;              \t\t//p指向i的下一个邻接顶点  \n        &#125; //while \n    &#125; //for  \n    return OK;\n&#125;//CriticalPath\n\nint main()&#123;\n    cout &lt;&lt; &quot;************关键路径算法**************&quot; &lt;&lt; endl &lt;&lt; endl;\n    ALGraph G;\n    CreateUDG(G);\n    int *topo = new int [G.vexnum];\n    \n    cout &lt;&lt; endl;\n    cout &lt;&lt; &quot;有向图创建完成!&quot; &lt;&lt; endl &lt;&lt; endl;\n    \n    if(!CriticalPath(G))\n        cout &lt;&lt; &quot;网中存在环，无法进行拓扑排序！&quot; &lt;&lt;endl &lt;&lt; endl;\n    cout &lt;&lt; endl;\n    return OK;\n&#125;//main\n\n例：\n\n\n6、总结\n(1)根据不同的分类规则,图分为多种类型:无向图、有向图、完全图、连通图、强连通图、带权图(网)、稀疏图和稠密图等。邻接点、路径、回路、度、连通分量、生成树等是在图的算法设计中常用到的重要术语。\n(2)图的存储方式有两大类:以边集合方式的表示法和以链接方式的表示法。其中，以边集合方式表示的为邻接矩阵，以链接方式表示的包括邻接表、十字链表和邻接多重表。邻接矩阵表示法借助二维数组来表示元素之间的关系，实现起来较为简单;邻接表、十字链表和邻接多重表都属于链式存储结构，实现起来较为复杂。在实际应用中具体采取哪种存储表示，可以根据图的类型和实际算法的基本思想进行选择。其中，邻接矩阵和邻接表是两种常用的存储结构，二者之间的比较如下图所示。\n\n( 3 )图的遍历算法是实现图的其他运算的基础，图的遍历方法有两种:深度优先搜索遍历和广度优先搜索遍历。深度优先搜索遍历类似于树的先序遍历，借助于栈结构来实现(递归);广度优先搜索遍历类似于树的层次遍历，借助于队列结构来实现。两种遍历方法的不同之处仅仅在于对顶点访问的顺序不同，所以时间复杂度相同。当用邻接矩阵存储时，时间复杂度为均O(n^2^)，用邻接表存储时，时间复杂度均为O(n+e)。\n(4)图的很多算法与实际应用密切相关，比较常用的算法包括构造最小生成树算法、求解最短路径算法、拓扑排序和求解关键路径算法。①构造最小生成树有普里姆算法和克鲁斯卡尔算法,两者都能达到同一目的。但前者算法思想的核心是归并点,时间复杂度是O(n^2^),适用于稠密网;后者是归并边,时间复杂度是O(elog2e),适用于稀疏网。②最短路径算法:一种是迪杰斯特拉算法，求从某个源点到其余各顶点的最短路径，求解过程是按路径长度递增的次序产生最短路径，时间复杂度是O(n^2^);另一种是弗洛伊德算法，求每一对顶点之间的最短路径，时间复杂度是O(n^3^)，从实现形式上来说，这种算法比以图中的每个顶点为源点n次调用迪杰斯特拉算法更为简洁。③拓扑排序和关键路径都是有向无环图的应用。拓扑排序是基于用顶点表示活动的有向图，即AOV-网。对于不存在环的有向图，图中所有顶点一定能够排成一个线性序列，即拓扑序列，拓扑序列是不唯一的。用邻接表表示图，拓扑排序的时间复杂度为O(n+e)。④关键路径算法是基于用弧表示活动的有向图，即AOE-网。关键路径上的活动叫做关键活动，这些活动是影响工程进度的关键，它们的提前或拖延将使整个工程提前或拖延。关键路径是不唯一的。关键路径算法的实现是在拓扑排序的基础上，用邻接表表示图，关键路径算法的时间复杂度为O(n+e)。\n\n7、例题与应用\n\n编程实现如下功能：（1）输入无向图的顶点数、边数及各条边的顶点对，建立用邻接矩阵表示的无向图。（2）对图进行深度优先搜索和广度优先搜索遍历，并分别输出其遍历序列。\n\n测试样例无向图运行结果\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define MVNum 100\n#define MAXQSIZE 100\ntypedef char VerTexType;\ntypedef int ArcType;\n//图的邻接矩阵存储表示\ntypedef struct\n&#123;\n    VerTexType vexs[MVNum];\n    ArcType arcs[MVNum][MVNum];\n    int vexnum, arcnum;\n&#125; Graph;\n//队列的定义及操作\ntypedef struct\n&#123;\n    ArcType *base;\n    int front;\n    int rear;\n&#125; sqQueue;\nbool visited[MVNum];\nbool visited1[MVNum];\nint FirstAdjVex(Graph G, int v);\nint NextAdjVex(Graph G, int v, int w);\n//构建空队列Q\nvoid InitQueue(sqQueue &amp;Q)\n&#123;\n    Q.base = new ArcType[MAXQSIZE];\n    if (!Q.base)\n        exit(1);\n    Q.front = Q.rear = 0;\n&#125;\n//插入元素e为Q的新的队尾元素\nvoid EnQueue(sqQueue &amp;Q, ArcType e)\n&#123;\n    if ((Q.rear + 1) % MAXQSIZE == Q.front)\n        return;\n    Q.base[Q.rear] = e;\n    Q.rear = (Q.rear + 1) % MAXQSIZE;\n&#125;\n//判断是否为空队\nbool QueueEmpty(sqQueue Q)\n&#123;\n    if (Q.rear == Q.front)\n        return true;\n    return false;\n&#125;\n//队头元素出队并置为u\nvoid DeQueue(sqQueue &amp;Q, ArcType &amp;u)\n&#123;\n    u = Q.base[Q.front];\n    Q.front = (Q.front + 1) % MAXQSIZE;\n&#125;\n//确定点v在G中的位置\nint LocateVex(Graph G, VerTexType v)\n&#123;\n    for (int i = 0; i &lt; G.vexnum; ++i)\n        if (G.vexs[i] == v)\n            return i;\n    return -1;\n&#125;\n//采用邻接矩阵表示法，创建无向网G\nvoid CreateUDN(Graph &amp;G)\n&#123;\n    int i, j, k;\n    cout &lt;&lt; &quot;输入总顶点数，总边数，以空格隔开:（例：3 2）&quot;;\n    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;输入点的名称（例：a）&quot; &lt;&lt; endl;\n\n    for (i = 0; i &lt; G.vexnum; ++i)\n    &#123;\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (i + 1) &lt;&lt; &quot;个点的名称:&quot;;\n        cin &gt;&gt; G.vexs[i];\n    &#125;\n    cout &lt;&lt; endl;\n\n    for (i = 0; i &lt; G.vexnum; ++i)\n        for (j = 0; j &lt; G.vexnum; ++j)\n            G.arcs[i][j] = 0;\n    cout &lt;&lt; &quot;输入边依附的顶点（例a b）&quot; &lt;&lt; endl;\n    for (k = 0; k &lt; G.arcnum; ++k)\n    &#123;\n        VerTexType v1, v2;\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (k + 1) &lt;&lt; &quot;条边依附的顶点:&quot;;\n        cin &gt;&gt; v1 &gt;&gt; v2;\n        i = LocateVex(G, v1);\n        j = LocateVex(G, v2);\n        G.arcs[j][i] = G.arcs[i][j] = 1;\n    &#125;\n&#125;\n// DFS\nvoid DFS(Graph G, int v)\n&#123;\n    int w;\n    cout &lt;&lt; G.vexs[v] &lt;&lt; &quot;    &quot;;\n    visited[v] = true;\n    for (w = 0; w &lt; G.vexnum; w++)\n        if ((G.arcs[v][w] != 0) &amp;&amp; (!visited[w]))\n            DFS(G, w);\n&#125;\n// BFS\nvoid BFS(Graph G, int v)\n&#123;\n    sqQueue Q;\n    ArcType u;\n    ArcType w;\n\n    cout &lt;&lt; G.vexs[v] &lt;&lt; &quot;    &quot;;\n    visited[v] = true;\n    InitQueue(Q);\n    EnQueue(Q, v);\n    while (!QueueEmpty(Q))\n    &#123;\n        DeQueue(Q, u);\n        for (w = FirstAdjVex(G, u); w &gt;= 0; w = NextAdjVex(G, u, w))\n        &#123;\n            if (!visited[w])\n            &#123;\n                cout &lt;&lt; G.vexs[w] &lt;&lt; &quot;    &quot;;\n                visited[w] = true;\n                EnQueue(Q, w);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n//返回v的第一个邻接点\nint FirstAdjVex(Graph G, int v)\n&#123;\n    int i;\n    for (i = 0; i &lt; G.vexnum; ++i)\n    &#123;\n        if (G.arcs[v][i] == 1 &amp;&amp; visited[i] == false)\n            return i;\n    &#125;\n    return -1;\n&#125;\n//返回v相对于w的下一个邻接点\nint NextAdjVex(Graph G, int v, int w)\n&#123;\n    int i;\n    for (i = w; i &lt; G.vexnum; ++i)\n    &#123;\n        if (G.arcs[v][i] == 1 &amp;&amp; visited[i] == false)\n            return i;\n    &#125;\n    return -1;\n&#125;\nint main()\n&#123;\n    Graph G;\n    CreateUDN(G);\n    cout &lt;&lt; endl;\n    cout &lt;&lt; &quot;无向图G创建完成！&quot; &lt;&lt; endl\n         &lt;&lt; endl;\n    cout &lt;&lt; &quot;输入遍历无向图G的起始点：&quot;;\n    VerTexType c;\n    cin &gt;&gt; c;\n    int i;\n    for (i = 0; i &lt; G.vexnum; ++i)\n    &#123;\n        if (c == G.vexs[i])\n            break;\n    &#125;\n    cout &lt;&lt; endl;\n    while (i &gt;= G.vexnum)\n    &#123;\n        cout &lt;&lt; &quot;该点不存在，请重新输入！&quot; &lt;&lt; endl;\n        cout &lt;&lt; &quot;请输入遍历连通图的起始点：&quot;;\n        cin &gt;&gt; c;\n        for (i = 0; i &lt; G.vexnum; ++i)\n        &#123;\n            if (c == G.vexs[i])\n                break;\n        &#125;\n    &#125;\n    cout &lt;&lt; &quot;深度优先搜索遍历无向图G结果：&quot; &lt;&lt; endl;\n    DFS(G, i);\n\n    for (int j = 1; j &lt;= G.vexnum; j++)\n        visited[j] = false;\n\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;广度优先搜索遍历无向图G结果：&quot; &lt;&lt; endl;\n    BFS(G, i);\n\n    cout &lt;&lt; endl;\n    return 0;\n&#125;\n\n","slug":"数据结构（C语言版）-- 图笔记","date":"2022-02-20T12:59:01.000Z","categories_index":"前端","tags_index":"字节跳动青训营","author_index":"会思想的苇草i"},{"id":"50552977e0ec8094596ba83ac872ee52","title":"树和二叉树","content":"\n1、树和二叉树的定义①.树的定义树( Tree)是n(n≥0)个结点的有限集，它或为空树(n&#x3D;0)；或为非空树，对于非空树T：\n&#x3D;&#x3D;1. 有且仅有一个称之为根的结点;&#x3D;&#x3D;&#x3D;&#x3D;2. 除根结点以外的其余结点可分为m (m&gt;0)个互不相交的有限集T1，T2,…，Tm，其中每一个集合本身又是一棵树，并且称为根的子树( SubTree)。&#x3D;&#x3D;\n在下图中，(a)是只有一个根结点的树；(b)是有13个结点的树，其中A是根，其余结点分成3个互不相交的子集:T1&#x3D;{B,E,F,K,L}，T2 &#x3D;{C,G}，T3(D,H,I,J,M})。T1、T2和T3都是根A 的子树，且本身也是一棵树。例如T1，其根为B，其余结点分为两个互不相交的子集:T11&#x3D;{E,K,L}，T12&#x3D;{F}。T11和T12都是B的子树。而T11中E是根，{K}和(L}是E的两棵互不相交的子树,其本身又是只有一个根结点的树。\n\n树的结构定义是一个递归的定义，即在树的定义中又用到树的定义，它道出了树的固有特性。\n\n\n\n线性结构\n树型结构\n\n\n\n第一个数据元素（无前驱）\n根结点（无前驱）\n\n\n最后一个数据元素（无后继）\n多个叶子结点（无后继）\n\n\n其他数据元素（一个前驱，一个后继）\n树中其它结点（一个前驱，一个后继）\n\n\n②.树的基本术语\n\n\n\n术语\n解释\n\n\n\n结点\n树的数据元素；如A、B、C、D等\n\n\n根\n根节点（没有前驱）；如A\n\n\n叶子\n终端结点（没有后继）；结点K、L、F、G、M、I、J都是树的叶子\n\n\n森林\nm棵不相交的树的集合（例如删除A后的子树个数）\n\n\n有序树\n结点各子树从左到右有序，不能互换（左为第一）\n\n\n无序树\n结点各子树可互换位置\n\n\n双亲\n上层的结点（直接前驱）；B的双亲为A\n\n\n孩子\n下层结点子树的根（直接后继）；B的孩子有E和F\n\n\n兄弟\n同一双亲下的同层结点（孩子之间互称兄弟）；H、I和J互为兄弟\n\n\n堂兄弟\n双亲位于同一层的结点（并非同一双亲）；结点G与E、F和H、I、J互为堂兄弟\n\n\n祖先\n根到该结点所经分支的所有结点；M的祖先为A、D和H\n\n\n子孙\n该结点下层子树中任一结点；B的子孙为E、K、L和F\n\n\n结点的度\n结点拥有的子树数；A的度为3，C的度为1，F的度为0\n\n\n树的度\n所有结点度中的最大值；该树的度为3\n\n\n结点的层次\n根到该结点的层数（根结点算第一层)\n\n\n终端结点\n度为0的结点，即叶子\n\n\n分支结点\n度不为0的结点\n\n\n树的深度\n所有结点中最大的层数；该树的深度为4\n\n\n③.二叉树的定义二叉树（Binary Tree)是n ( n≥0)个结点所构成的集合，它或为空树(n&#x3D;0)；或为非空树，对于非空树T:\n &#x3D;&#x3D;1. 有且仅有一个称之为根的结点;&#x3D;&#x3D; &#x3D;&#x3D;2. 除根结点以外的其余结点分为两个互不相交的子集T1,和T2,分别称为T的左子树和右子树，且T1和T2本身又都是二叉树。&#x3D;&#x3D;\n二叉树与树—样具有递归性质，二叉树与树的区别主要有以下两点:\n 1. 二叉树每个结点至多只有两棵子树(即二叉树中不存在度大于2的结点); 2. 二叉树的子树有左右之分，其次序不能任意颠倒。\n二叉树的5种基本形态:\n\n\n2、树和二叉树的抽象数据类型定义树的抽象数据类型定义：\n二叉树的抽象数据类型定义：\n\n\n3、二叉树的性质和存储结构①.二叉树的性质&#x3D;&#x3D;性质1：在二叉树的第i层上至多有2^i-1^个结点（i≥1）&#x3D;&#x3D;\n 证明：i&#x3D;1时，只有一个根结点，2^i-1^&#x3D;1成立﹔假设第i-1层至多有2^i-2^个结点，又二叉树每个结点的度至多为2;所以，第i层上最大结点数是第i-1层的2倍，即2^i-1^个结点。\n &#x3D;&#x3D;性质2：深度为k的二叉树至多有2^k-1^个结点（k≥1）&#x3D;&#x3D;\n 证明：由性质1，可得深度为k的二叉树最大结点数是2^k-1^\n&#x3D;&#x3D;性质3：对任何一棵二叉树T，如果其终端(叶子)结点个数为n0，度为2的结点数为n2，则n0&#x3D;n2+1。&#x3D;&#x3D;\n证明：n1为二叉树T中度为1的结点数，二叉树中所有结点的度均小于或等于2，其结点总数n&#x3D;n0+n1+n2；二叉树中，除根结点外，其余结点都只有一个分支进入，设: B为分支总数，则n&#x3D;B+1；分支由度为1和度为2的结点射出，B&#x3D;n1+2n2于是n&#x3D;B+1&#x3D;n1+2n2+1&#x3D;n0+n1+n2，所以no&#x3D;n2+1\n这里引入两个概念：满二叉树和完全二叉树\n满二叉树:深度为k且含有2^k^-1个结点的二叉树。满二叉树的特点是:每一层上的结点数都是最大结点数，即每一层i的结点数都具有最大值2^i^-1。\n完全二叉树:深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点—一对应时，称之为完全二叉树。完全二叉树的特点是:叶子结点只可能在层次最大的两层上出现;对任一结点，若其右分支下的子孙的最大层次为l，则其左分支下的子孙的最大层次必为l或l+1。\n\n&#x3D;&#x3D;性质4：具有n个结点的完全二叉树的深度为⌊log2n⌋+1&#x3D;&#x3D;\n证明：2^k-1^-1 &lt;n ≤2^k^-1 或2^k-1^≤ n &lt;2^k^，k-1≤ log2n &lt;k，因为k是整数所以: k &#x3D; log2n+ 1\n&#x3D;&#x3D;性质5：如果对一棵有n个结点的完全二叉树从上至下、从左至右编号，则编号为i (1≤ i≤ n)的结点:若i&#x3D;1，则该结点是二叉树的根，无双亲，否则，其双亲结点编号为⌊i&#x2F;2⌋；若2i &gt; n，则该结点无左孩子，否则，其左孩子结点编号为2i ;若2i+1 &gt;n，则该结点无右孩子结点，否则，其右孩子结点编号为2i+1。&#x3D;&#x3D;\n证明：\n\n②.二叉树的存储结构顺序存储结构\n//二叉树的顺序存储表示\n#define MAXTSIZE 100\ntypedef TElemType SqBiTree[MAXTSIZE];\nSqBiTree bt;\n\n顺序存储结构使用一组地址连续的存储单元来存储数据元素，为了能够在存储结构中反映出结点之间的逻辑关系，必须将二叉树中的结点依照―定的规律安排在这组单元中。\n对于完全二叉树，只要从根起按层序存储即可，依次自上而下、自左至右存储结点元素，即将完全二叉树上编号为i的结点元素存储在如上定义的一维数组中下标为i-1的分量中。\n对于一般二叉树，则应将其每个结点与完全二叉树上的结点相对照,存储在一维数组的相应分量中，图中以“0”表示不存在此结点。\n\n这种顺序结构只适合完全二叉树，所以对于一般二叉树，更适合采用链式存储结构。\n链式存储结构\n由二叉树的定义可知，二叉树的结点有一个数据元素和分别指向其左、右子树的两个分支构成，则表示二叉树的链表中的结点至少包含3个域：数据域和左、右指针域。 有时为了方便找到结点的双亲，还可以在结点结构中增加一个指向其双亲结点的指针域。利用这两种结点结构所得二叉树的存储结构分别称之为二叉链表和三叉链表。\n\n\n//二叉树的二叉链表存储表示\ntypedef struct BiTNode\n&#123;\n    TElemType data;                 //结点数据域\n    struct BiTNode *lchild, *rchild; //左右孩子指针\n&#125; BiTNode, *BiTree;                  //二叉树结点\n\n\n4、遍历二叉树和线索二叉树①.遍历二叉树遍历二叉树算法描述\n遍历二叉树( traversing binary tree）是指按某条搜索路径巡访树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。\n二叉树是由3个基本单元组成:根结点、左子树和右子树。因此，若能依次遍历这三部分，便是遍历了整个二叉树。假如从L、D、R分别表示遍历左子树、访问根结点和遍历右子树，则可有DLR、LDR、LRD、DRL、RDL、RLD这6种遍历二叉树的方案。若限定先左后右，则只有前3种情况，分别称之为&#x3D;&#x3D;先(根）序遍历、中(根）序遍历和后（根)序遍历。&#x3D;&#x3D;\n\n\nvoid PreOrderTraverse(BiTree T)\n&#123;\n    if (T) //非空二叉树\n    &#123;\n        cout &lt;&lt; T-&gt;data;             //访问根结点\n        PreOrderTraverse(T-&gt;lchild); //递归遍历左子树\n        PreOrderTraverse(T-&gt;rchild); //递归遍历右子树\n    &#125;\n&#125;\n\n\nvoid InOrderTraverse(BiTree T)\n&#123;\n    if (T) //非空二叉树\n    &#123;\n        InOrderTraverse(T-&gt;lchild); //递归遍历左子树\n        cout &lt;&lt; T-&gt;data;            //访问根结点\n        InOrderTraverse(T-&gt;rchild); //递归遍历右子树\n    &#125;\n&#125;\n\n\n\nvoid PostOrderTraverse(BiTree T)\n&#123;\n    if (T) //非空二叉树\n    &#123;\n        PostOrderTraverse(T-&gt;lchild); //递归遍历左子树\n        PostOrderTraverse(T-&gt;rchild); //递归遍历右子树\n        cout &lt;&lt; T-&gt;data;              //访问根结点\n    &#125;\n&#125;\n\n用二叉树表示算术表达式\n\n根据遍历序列确定二叉树\n&#x3D;&#x3D;由二叉树的先序序列和中序序列，或由其后序序列和中序序列均能唯一地确定一棵二叉树。但是由一颗二叉树的先序序列和后序序列不能唯一确定一颗二叉树。&#x3D;&#x3D;\n例：已知一棵二叉树的中序序列和后序序列分别是 BDCEAFHG和DECBHGFA，请画出这棵二叉树。\n\n由后序遍历特征，根结点必在后序序列尾部，即根结点是A;\n由中序遍历特征，根结点必在其中间，而且其左部必全部是左子树子孙(BDCE)，其右部必全部是右子树子孙(FHG );\n继而，根据后序中的DECB子树可确定B为A的左孩子，根据HGF子串可确定F为A的右孩子;依此类推，可以唯一地确定一棵二叉树，如下图所示。\n\n\n例：\n\n先序遍历的顺序建立二叉链表\n\n扫描字符序列，读人字符ch。\n如果ch是一个“#”字符，则表明该二叉树为空树，即T为NULL;否则执行以下操作:- 申请一个结点空间T;- 将ch赋给T-&gt; data;- 递归创建T的左子树;- 递归创建T的右子树;\n\nvoid CreateBiTree(BiTree &amp;T）\n&#123;\n    cin &gt;&gt; ch;\n    if (ch ==’#’)\n        T = NULL; //递归结束，建空树\n    else\n    &#123;\n        T = new BiTNode;\n        T - ＞data = ch;            //生成根结点\n        CreateBiTree(T - ＞lchild); //递归创建左子树\n        CreateBiTree(T - ＞rchild); //递归创建右子树\n    &#125;\n&#125;\n\n复制二叉树\n如果是空树，递归结束,否则执行以下操作:\n\n申请一个新结点空间，复制根结点;\n递归复制左子树;\n递归复制右子树。\n\nvoid Copy(BiTree T, BiTree &amp;NewT)\n&#123;\n    if (T = NULL)\n    &#123;\n        NewT = NULL;\n        return;\n    &#125;\n    else\n    &#123;\n        NewT = new BiTNode;\n        NewT-&gt;data = T-&gt;data;\n        Copy(T-&gt;lchild, NewT-&gt;lchild);\n        Copy(T-&gt;rchild, NewT-&gt;rchild);\n    &#125;\n&#125;\n\n计算二叉树的深度\n如果是空树，递归结束，深度为0，否则执行以下操作:\n\n递归计算左子树的深度记为m;\n递归计算右子树的深度记为n;\n如果m大于n，二叉树的深度为m+1，否则为n+1。\n\nint Depth(BiTree T)\n&#123; // 返回二叉树的深度\n    if (!T)\n        return 0;\n    else\n    &#123;\n        m = Depth(T-&gt;lchild);\n        n = Depth(T-&gt;rchild);\n        if (m &gt; n)\n            return (m + 1);\n        else return (n+1）;\n    &#125;\n&#125; \n\n统计二叉树中结点的个数\nint NodeCount(BiTree T)\n&#123;\n    if (T == NULL)\n        return 0;\n    else\n        return NodeCount(T-&gt;lchild) + NodeCount(T-&gt;rchild) + 1;\n&#125;\n\n统计二叉树中叶子结点个数\nint CountLeaf(BiTree T)\n&#123; // 返回指针T所指二叉树中的叶子结点的个数\n    if (!T)\n        return 0;\n    if (!T-&gt;lchild &amp;&amp; !T-&gt;rchild)\n        return 1;\n    else\n    &#123;\n        m = CountLeaf(T-&gt;lchild);\n        n = CountLeaf(T-&gt;rchild);\n        return (m + n);\n    &#125; // else\n&#125; // CountLeaf\n\n②.线索二叉树当以二叉链表作为存储结构时，只能找到结点的左、右孩子信息，而不能直接得到结点在任一序列中的前驱和后继信息，这种信息只有在遍历的动态过程中才能得到，为此引人线索二叉树来保存这些在动态过程中得到的有关前驱和后继的信息。\n线索:指向前驱或后继结点的指针称为线索\n线索二叉树:加上线索的二叉链表表示的二叉树叫线索二叉树\n线索化:对二叉树按某种遍历次序使其变为线索二叉树的过程叫线索化\n试做如下规定：若结点有左子树，则其lchild域指示其左孩子，否则令lchild域指示其前驱;若结点有右子树，则其rchild域指示其右孩子，否则令rchild域指示其后继。为了避免混淆，尚需改变结点结构，增加两个标志域。\n\n\n二叉树的二叉线索存储表示\ntypedef struct BiThrNode\n&#123;\n    TElemType data;\n    struct BiThrNode *lchild, *rchild;//左右孩子标志\n    int LTag, RTag;//左右标志\n&#125; BiThrNode, *BiThrTree;\n\n以结点p为根的子树中序线索化\n算法中有一全局变量:pre，在主调程序中初值为空，在整个线索化算法中pre始终指向当前结点p的前驱。\n\n如果p非空，左子树递归线索化。\n如果p的左孩子为空，则给p加上左线索，将其LTag置为1，让p的左孩子指针指向pre(前驱)﹔否则将p的LTag置为0。\n如果pre的右孩子为空，则给pre加上右线索，将其RTag置为1，让pre的右孩子指针指向p(后继)﹔否则将pre的RTag置为0。\n将pre指向刚访问过的结点p，即pre&#x3D;p。\n右子树递归线索化。\n\nvoid InThreading(BiThrTree p)\n&#123; // pre是全局变量，初始化时其右孩子指针为空，便于在树的最左点开始建线索\n    if (p)\n    &#123;\n        InThreading(p-&gt;lchild); //左子树递归线索化\n        if (!p-&gt;lchild)         // p的左孩子为空\n        &#123;\n            p-&gt;LTag = 1;     //给p加上左线索\n            p-&gt;lchild = pre; // p的左孩子指针指向pre（前驱）\n        &#125;\n        else\n            p-&gt;LTag = 0;\n        if (!pre-&gt;rchild) // pre的右孩子为空\n        &#123;\n            pre-&gt;RTag = 1;   //给pre加上右线索\n            pre-&gt;rchild = p; // pre的右孩子指针指向p（后继）\n        &#125;\n        else\n            pre-&gt;RTag = 0;\n        pre = p;                //保持pre指向p的前驱\n        InThreading(p-&gt;rchild); //右子树递归线索化\n    &#125;\n\n&#125; \n\n带头结点的二叉树中序线索化\nvoid InOrderThreading(BiThrTree &amp;Thrt, BiThrTree T)\n&#123;                         //中序遍历二叉树T，并将其中序线索化，Thrt指向头结点\n    Thrt = new BiThrNode; //建头结点\n    Thrt-&gt;LTag = 0;       //头结点有左孩子，若树非空，则其左孩子为树根\n    Thrt-&gt;RTag = 1;       //头结点的右孩子指针为右线索\n    Thrt-&gt;rchild = Thrt;  //初始化时右指针指向自己\n    if (!T)\n        Thrt-&gt;lchild = Thrt; //若树为空，则左指针也指向自己\n    else\n    &#123;\n        Thrt-&gt;lchild = T;\n        pre = Thrt;         //头结点的左孩子指向根，pre初值指向头结点\n        InThreading(T);     //对以T为根的二叉树进行中序线索化\n        pre-&gt;rchild = Thrt; //算法5.7结束后，pre为最右结点，pre的右线索指向头结点\n        pre-&gt;RTag = 1;\n        Thrt-&gt;rchild = pre; //头结点的右线索指向pre\n    &#125;\n&#125;\n\n遍历中序线索二叉树\n\n指针p指向根结点。\np为非空树或遍历未结束时，循环执行以下操作:- 沿左孩子向下，到达最左下结点p，它是中序的第一个结点;- 访问p;- 沿右线索反复查找当前结点*p的后继结点并访问后继结点，直至右线索为0或者遍历结束;- 转向p的右子树。\n\nvoid InOrderTraverse_Thr(BiThrTree T)\n&#123; // T指向头结点，头结点的左链lchild指向根结点，可参见线索化算法5.8。\n  //中序遍历二叉线索树T的非递归算法，对每个数据元素直接输出\n    p = T-&gt;lchild; // p指向根结点\n    while (p != T) //空树或遍历结束时，p==T\n    &#123;\n        while (p-&gt;LTag == 0) //沿左孩子向下\n            p = p-&gt;lchild;   //访问其左子树为空的结点\n        cout &lt;&lt; p-&gt;data;\n        while (p-&gt;RTag == 1 &amp;&amp; p-&gt;rchild != T)\n        &#123;\n            p = p-&gt;rchild; //沿右线索访问后继结点\n            cout &lt;&lt; p-&gt;data;\n        &#125;\n        p = p-&gt;rchild;\n    &#125;\n&#125;\n\n\n\n\n5、树和森林①.树的存储结构双亲表示法\n这种表示方法中，以一组连续的存储单元存储树的结点，每个结点除了数据域data外，还附设一个parent域用以指示其双亲结点的位置。\n\n#defin MAX_TREE_SIZE 100\ntypedef struct PTNode\n&#123; //结点结构\n    ElemType data;\n    int parent; //保存双亲位置\n&#125; PTNode;\n\ntypedef struct\n&#123; //树结构\n    PTNode nodes[MAX_TREE_SIZE];\n    int r, n; //根的位置和结点数\n&#125; PTree;\n\n孩子表示法\n由于树中每个结点可能有多棵子树，则可用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点。\n\n//树结构\ntypedef struct\n&#123;\n    CTBox nodes[MAX_TREE_SIZE];\n    int n, r; // 结点数和根结点的位置\n&#125; CTree;\n//孩子链表表示法的类型描述\ntypedef struct CTNode\n&#123;\n    int child;\n    struct CTNode *nextchild;\n&#125; * ChildPtr;\n//双亲结点结构\ntypedef struct\n&#123;\n    ElemType data;\n    int parent; //保存双亲位置\n    ChildPtr firstchild;\n    // 孩子链的头指针\n&#125; CTBox;\n\n孩子兄弟法\n又称二叉树表示法，或二叉链表表示法，即以二叉链表做树的存储结构。链表中结点的两个链域分别指向该结点的第一个孩子结点和下一个兄弟结点，分别命名为firstchild域和nextsibling域。\n\ntypedef struct CSNode\n&#123;\n    ElemType data;\n    struct CSNode *firstchild, *nextsibling;\n&#125; CSNode, *CSTree;\n\n②.森林与二叉树的转换从树的二叉链表表示的定义可知，任何一棵和树对应的二叉树，其根结点的右子树必空。若把森林中第二棵树的根结点看成是第一棵树的根结点的兄弟，则同样可导出森林和二叉树的对应关系。\n树转换成二叉树的方法\n\n二叉树转换为树的方法\n\n森林转换成二叉树的方法\n\n二叉树转换成森林的方法\n\n例：\n\n③.树和森林的遍历树的遍历：\n&#x3D;&#x3D;先根(序)遍历:先访问树的根结点，然后依次先根遍历根的每棵子树后根(序)遍历:先依次后根遍历每棵子树，然后访问根结点。&#x3D;&#x3D;\n&#x3D;&#x3D;按层次遍历:先访问第一层上的结点，然后依次遍历第二层，…..，第n层的结点。&#x3D;&#x3D;\n森林的遍历：\n\n先序遍历森林- 访问森林中第一棵树的根结点- 先序遍历第一棵树中根结点的子树森林- 先序遍历除去第一棵树之后剩余的树构成森林\n\n中序遍历森林- 中序遍历森林中第一棵树的根结点的子树森林- 访问第一棵树的根结点- 中序遍历除去第一棵树之后剩余的树构成的森林\n\n\n\n\n6、哈夫曼树及其应用①.哈夫曼树的基本概念&#x3D;&#x3D;哈夫曼(Huffman )树又称最优树，是一类带权路径长度最短的树，在实际中有广泛的用途。&#x3D;&#x3D;\n路径:从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。\n路径长度:路径上的分支数目称作路径长度。\n树的路径长度:从树根到每一结点的路径长度之和。\n权:赋予某个实体的一个量，是对实体的某个或某些属性的数值化描述。\n结点的带权路径长度:从该结点到树根之间的路径长度与结点上权的乘积。\n树的带权路径长度:树中所有叶子结点的带权路径长度之和。\n哈夫曼树:假设有m个权值{w1，w2…，wm}，可以构造一棵含n个叶子结点的二叉树，每个叶子结点的权为wi，则其中带权路径长度WPL最小的二叉树称做最优二叉树或哈夫曼树。\n\n②.哈夫曼树的构造算法哈夫曼树的构造过程\n&#x3D;&#x3D;核心思想：使权值大的结点靠近根。&#x3D;&#x3D;\n\n根据给定的n个权值{w1,w2…….wn}，构造n棵只有根结点的二叉树，这n棵二叉树构成一个森林F。\n在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。\n在森林中删除这两棵树，同时将新得到的二叉树加入森林中。\n重复上述两步，直到只含一棵树为止，这棵树即哈夫曼树。\n\n哈夫曼算法的实现\n哈夫曼树是―种二叉树，当然可以采用前面介绍过的通用存储方法，而由于哈夫曼树中没有度为1的结点,则一棵有n个叶子结点的哈夫曼树共有2n-1个结点,可以存储在一个大小为2n-1的一维数组中。\ntypedef struct\n&#123;\n    int weight;                 //结点的权值\n    int parent, lchild, rchild; //双亲、左孩子、右孩子的下标\n&#125; HTnode, *HuffmanTree;\n\n构造哈夫曼树\n\n初始化:首先动态申请2n个单元;然后循环2n-1次，从1号单元开始，依次将1至2n-1所有单元中的双亲、左孩子、右孩子的下标都初始化为0;最后再循环n次，输人前n个单元中叶子结点的权值。\n创建树:循环n-1次，通过n-1次的选择、删除与合并来创建哈夫曼树。选择是从当前森林中选择双亲为0且权值最小的两个树根结点s1和s2;删除是指将结点sl和s2的双亲改为非0;合并就是将s1和s2的权值和作为一个新结点的权值依次存入到数组的第n+1之后的单元中，同时记录这个新结点左孩子的下标为s1，右孩子的下标为s2。\n\nvoid CreatHuffmanTree(HuffmanTree HT, int n)\n&#123; //构造哈夫曼树HT\n    if (n &lt;= 1)\n        return;\n    m = 2 * n - 1;\n    HT = new HTNode[m + 1];  // 0号单元未用，HT[m]表示根结点\n    for (i = 1; i &lt;= m; ++i) //初始化：双亲、左孩子，右孩子的下标都为0\n    &#123;\n        HT[i].parent = 0;\n        HT[i].lchild = 0;\n        HT[i].rchild = 0;\n    &#125;\n    for (i = 1; i &lt;= n; ++i) //输入前n个单元中叶子结点的权值\n        cin &gt;&gt; HT[i].weight;\n    /*―――初始化工作结束，下面开始创建哈夫曼树――――*/\n    for (i = n + 1; i &lt;= m; ++i)\n    &#123;                              //通过n-1次的选择、删除、合并来创建哈夫曼树\n        Select(HT, i - 1, s1, s2); //选择两个其双亲域为0且权值最小的结点，\n        HT[s1].parent = i;\n        HT[s2].parent = i; //得到新结点i, 将s1和s2的双亲域由0改为i\n        HT[i].lchild = s1;\n        HT[i].rchild = s2;                            // s1,s2分别作为i的左右孩子\n        HT[i].weight = HT[s1].weight + HT[s2].weight; // i 的权值为左右孩子权值之和\n    &#125;                                                 // for\n&#125;\n\n例：\n\n③.哈夫曼编码下面给出有关编码的两个概念。\n 前缀编码: 如果在一个编码方案中，任一个编码都不是其他任何编码的前缀(最左子串),则称编码是前缀编码。\n哈夫曼编码: 对一棵具有n个叶子的哈夫曼树，若对树中的每个左分支赋予0，右分支赋予1，则从根到每个叶子的路径上，各分支的赋值分别构成一个二进制串，该二进制串就称为哈夫曼编码。\n哈夫曼编码满足下面的两个性质：\n&#x3D;&#x3D;哈夫曼编码是前缀码&#x3D;&#x3D;&#x3D;&#x3D;哈夫曼编码是最优前缀编码&#x3D;&#x3D;\n哈夫曼编码的算法实现\n在构造哈夫曼树之后，求哈夫曼编码的主要思想是:依次以叶子为出发点，向上回溯至根结点为止。回溯时走左分支则生成代码0，走右分支则生成代码1。由于每个哈夫曼编码是变长编码，因此使用一个指针数组来存放每个字符编码串的首地址。\n\n分配存储n个字符编码的编码表空间HC，长度为n +1;分配临时存储每个字符编码的动态数组空间cd, cd[n-1]置为‘\\0’\n逐个求解n个字符的编码，循环n次，执行以下操作:设置变量start 用于记录编码在cd中存放的位置，start初始时指向最后，即编码结束符位置n -1;设置变量c用于记录从叶子结点向上回溯至根结点所经过的结点下标，c初始时为当前待编码字符的下标i，f 用于记录i的双亲结点的下标;从叶子结点向上回溯至根结点，求得字符i的编码，当f没有到达根结点时，循环执行以下操作:回溯一次start向前指一个位置，即–start;若结点c是f的左孩子，则生成代码0，否则生成代码1，生成的代码0或1保存在cd[start]中;继续向上回溯，改变c和f的值。根据数组cd的字符串长度为第i个字符编码分配空间HC[i]，然后将数组cd中的编码复制到HC[i]中。\n释放临时空间cd。\n\nvoid CreatHuffmanCode(HuffmanTree HT, HuffmanCode &amp;HC, int n)\n&#123;                           //从叶子到根逆向求每个字符的赫夫曼编码，存储在编码表HC中\n    HC = new char *[n + 1]; //分配n个字符编码的头指针矢量\n    cd = new char[n];       //分配临时存放编码的动态数组空间\n    cd[n - 1] = &#39;\\0&#39;;       //编码结束符\n    for (i = 1; i &lt;= n; ++i)\n    &#123;                  // 逐个字符求赫夫曼编码\n        start = n - 1; // start开始时指向最后，即编码结束符位置\n        c = i;\n        f = HT[i].parent; // f指向结点c的双亲结点\n        while (f != 0)\n        &#123;            //从叶子结点开始向上回溯，直到根结点\n            --start; //回溯一次start向前指一个位置\n            if (HT[f].lchild == c)\n                cd[start] =’0’; //结点c是f的左孩子，则生成代码0\n            else\n                cd[start] =‘1’; //结点c是f的右孩子，则生成代码1\n            c = f;\n            f = HT[f].parent;        //继续向上回溯\n        &#125;                            //求出第i个字符的编码\n        HC[i] = new char[n - start]; // 为第i 个字符编码分配空间\n        strcpy(HC[i], &amp;cd[start]);   //将求得的编码从临时空间cd复制到HC的当前行中\n    &#125;\n    delete cd; //释放临时空间\n&#125;\n\n例：\n\n\n7、总结\n二叉树是―种最常用的树形结构，二叉树具有一些特殊的性质，而满二叉树和完全二叉树又是两种特殊形态的二叉树。\n二叉树有两种存储表示:顺序存储和链式存储。顺序存储就是把二叉树的所有结点按照层次顺序存储到连续的存储单元中，这种存储更适用于完全二叉树。链式存储又称二叉链表，每个结点包括两个指针，分别指向其左孩子和右孩子。链式存储是二叉树常用的存储结构。\n树的存储结构有三种:双亲表示法、孩子表示法和孩子兄弟表示法，孩子兄弟表示法是常用的表示法，任意一棵树都能通过孩子兄弟表示法转换为二叉树进行存储。森林与二叉树之间也存在相应的转换方法，通过这些转换，可以利用二叉树的操作解决一般树的有关问题。\n二叉树的遍历算法是其他运算的基础，通过遍历得到了二叉树中结点访问的线性序列，实现了非线性结构的线性化。根据访问结点的次序不同可得三种遍历:先序遍历、中序遍历、后序遍历，时间复杂度均为O(n)。\n在线索二叉树中，利用二叉链表中的n+1个空指针域来存放指向某种遍历次序下的前驱结点和后继结点的指针，这些附加的指针就称为“线索”。引人二叉线索树的目的是加快查找结点前驱或后继的速度。\n哈夫曼树在通信编码技术上有广泛的应用，只要构造了哈夫曼树，按分支情况在左路径上写代码0，右路径上写代码1,然后从上到下叶结点相应路径上的代码序列就是该叶结点的最优前缀码，即哈夫曼编码。\n\n\n8、例题与应用\n\n编程实现如下功能：（1）假设二叉树的结点值是字符型，根据输入的一棵二叉树的完整先序遍历序列（子树空用’#’表示），建立一棵以二叉链表存储表示的二叉树。（2）对二叉树进行先序、中序和后序遍历操作，并输出遍历序列，观察输出的序列是否与逻辑上的序列一致。（3）主程序中要求设计一个菜单，允许用户通过菜单来多次选择执行哪一种遍历操作。\n\n测试样例：ABC##DE#G##F###\n\n\n\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n//二叉树的二叉线索存储表示\ntypedef struct BiNode\n&#123;\n    char data;\n    struct BiNode *lchild, *rchild;\n&#125; BiTNode, *BiTree;\n\n//先序遍历的的顺序建立二叉链表\nvoid CreateBiTree(BiTree &amp;T)\n&#123;\n    char ch;\n    cin &gt;&gt; ch;\n    if (ch == &#39;#&#39;)\n    &#123;\n        T = NULL;\n    &#125;\n    else\n    &#123;\n        T = new BiTNode;\n        T-&gt;data = ch;\n        CreateBiTree(T-&gt;lchild);\n        CreateBiTree(T-&gt;rchild);\n    &#125;\n&#125;\n\n//先序遍历的递归算法\nvoid PreOrderTraverse(BiTree T)\n&#123;\n    if (T)\n    &#123;\n        cout &lt;&lt; T-&gt;data;\n        PreOrderTraverse(T-&gt;lchild);\n        PreOrderTraverse(T-&gt;rchild);\n    &#125;\n&#125;\n\n//中序遍历的递归算法\nvoid InOrderTraverse(BiTree T)\n&#123;\n    if (T)\n    &#123;\n        InOrderTraverse(T-&gt;lchild);\n        cout &lt;&lt; T-&gt;data;\n        InOrderTraverse(T-&gt;rchild);\n    &#125;\n&#125;\n\n//后序遍历的递归算法\nvoid PostOrderTraverse(BiTree T)\n&#123;\n    if (T)\n    &#123;\n        PostOrderTraverse(T-&gt;lchild);\n        PostOrderTraverse(T-&gt;rchild);\n        cout &lt;&lt; T-&gt;data;\n    &#125;\n&#125;\nint main(void)\n&#123;\n    BiTree tree;\n    int select;\n\n    while (1)\n    &#123;\n        cout &lt;&lt; &quot;1、建立二叉树\\n&quot;;\n        cout &lt;&lt; &quot;2、先序遍历\\n&quot;;\n        cout &lt;&lt; &quot;3、中序遍历\\n&quot;;\n        cout &lt;&lt; &quot;4、后序遍历\\n&quot;;\n        cout &lt;&lt; &quot;0、退出程序\\n&quot;;\n\n        cout &lt;&lt; &quot;\\n请选择:&quot;;\n        cin &gt;&gt; select;\n\n        switch (select)\n        &#123;\n        case 1:\n            cout &lt;&lt; &quot;请输入建立二叉链表的序列：\\n&quot;;\n            CreateBiTree(tree);\n            cout &lt;&lt; endl;\n            break;\n        case 2:\n            cout &lt;&lt; &quot;所建立的二叉链表先序序列：\\n&quot;;\n            PreOrderTraverse(tree);\n            cout &lt;&lt; endl\n                 &lt;&lt; endl;\n            break;\n        case 3:\n            cout &lt;&lt; &quot;所建立的二叉链表中序序列：\\n&quot;;\n            InOrderTraverse(tree);\n            cout &lt;&lt; endl\n                 &lt;&lt; endl;\n            break;\n        case 4:\n            cout &lt;&lt; &quot;所建立的二叉链表后序序列：\\n&quot;;\n            PostOrderTraverse(tree);\n            cout &lt;&lt; endl;\n            break;\n        case 0:\n            return 0;\n            break;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n\n\n编程实现如下功能：（1）建立由英文字符组成的文件f1（字符种类≥10，长度≥100），并统计不同字符出现的次数；（2）按字符出现的次数对其建立哈夫曼树，并求出各个字符的哈夫曼编码；（3）读入要编码的文件f1，编码后存入另一个文件f2；（4）接着再调出编码后的文件f2，对其进行译码输出，最后存入文件f3。\n\n\n\n\nf1.txt\n\n\n\nTherearemomentsinlifewhenyoumisssomeonesomuchthatyoujustwanttopickthemfromyourdreamsandhugthemforrealDreamwhatyouwanttodreamgowhereyouwanttogobewhatyouwanttobebecauseyouhaveonlyonelifeandonechancetodoallthethingsyouwanttodo\n\n\n\n\n\nf2.txt\n\n\n\n110000011010011111010111111111010110011100001101110110001110001001101101000010011101000111101110100111011110011000101001101001111001110011100100001101110010110111110010000110101110101101000010101111000110011000101110000000101111000001101111111011000000100110000110100111010111000010000101001100111101001110110000111100110001011110100101111010111111001111100111110110010110100101110001000101001100111101001001110111101011111101000001000111101011111100111101110101111000110011000101110111111101100000010000101111010111111001111000110011011101001111101011110011000101110111111101100000010011000110000100101111011101011110001100110001011101111111011000000100001001011001001011110101111101011110001111001100010110101111001000001110010110100011001100101101101000010011101000111111101100101100101101111010110101111101111010101100010000101100111101000010000001010011000101001001101111000111100110011000101110111111101100000010000101100\n\n\n\n\n\nf3.txt\n\n\n\nTherearemomentsinlifewhenyoumisssomeonesomuchthatyoujustwanttopickthemfromyourdreamsandhugthemforrealDreamwhatyouwanttodreamgowhereyouwanttogobewhatyouwanttobebecauseyouhaveonlyonelifeandonechancetodoallthethingsyouwanttodo\n\n\n\n\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\ntypedef struct //定义哈夫曼树的结构\n&#123;\n    int weight;\n    int parent, lchild, rchild;\n&#125; HTNode, *HuffmanTree;\n\ntypedef char **HuffmanCode;\n\ntypedef struct //存储数据扫描统计结果\n&#123;\n    char *data;    //字符\n    int *quantity; //次数\n    int length;    //总长度\n&#125; TNode;\n\nvoid InitList(TNode &amp;N) //初始化TNode定义的结点\n&#123;\n    N.data = new char[256];\n    N.quantity = new int[256];\n    if (!N.data || !N.quantity)\n        exit(1);\n    N.length = 0;\n&#125;\n\nint Find(TNode N, char ch)\n&#123;\n    for (int i = 0; i &lt; N.length; i++)\n        if (ch == N.data[i])\n            return true;\n    return false;\n&#125;\n\nvoid ReadFile(vector&lt;char&gt; &amp;f) //读取文件\n&#123;\n    char ch;\n    ifstream infile(&quot;f1.txt&quot;, ios::in);\n    if (!infile) //文件不存在\n    &#123;\n        cout &lt;&lt; &quot;打开文件失败！&quot; &lt;&lt; endl;\n        exit(1);\n    &#125;\n    while (infile.peek() != EOF)\n    &#123;\n        infile.get(ch);\n        f.push_back(ch); //把字符ch推入vector\n    &#125;\n    infile.close(); //关闭文件\n    cout &lt;&lt; &quot;读取完成&quot; &lt;&lt; endl;\n    system(&quot;pause&quot;);\n&#125;\n\nvoid WriteTNode(vector&lt;char&gt; v, TNode &amp;N) //将vector中的数据存入TNode结构体中\n&#123;\n    char ch;\n    int len = v.size(), j = 0;\n    for (int i = 0; i &lt; len; i++)\n    &#123;\n        ch = v[i];\n        if (!Find(N, ch))\n        &#123;\n            N.data[j] = ch;\n            N.quantity[j] = count(v.begin(), v.end(), ch);\n            j++;\n            N.length++;\n        &#125;\n    &#125;\n    cout &lt;&lt; &quot;写入完成&quot; &lt;&lt; endl;\n    system(&quot;pause&quot;);\n&#125;\n\nvoid Select(HuffmanTree &amp;HT, int n, int &amp;min1, int &amp;min2) //查找HT中未被使用的权值最小的两个点的下标\n&#123;\n    min1 = min2 = 0; //初始化\n    for (int i = 1; i &lt; n; i++)\n    &#123;\n        if (HT[i].parent != 0)\n            continue; //略过已经加入的结点\n        if (min1 == 0)\n            min1 = min2 = i; //赋初值\n        else if (HT[i].weight &lt;= HT[min1].weight)\n        &#123; //min1是最小值\n            min2 = min1;\n            min1 = i;\n        &#125;\n        else if (HT[i].weight &lt; HT[min2].weight)\n        &#123; //min2是次小值\n            min2 = i;\n        &#125;\n        else if (HT[i].weight &gt; HT[min2].weight)\n        &#123; //防止两个值相等\n            if (min1 == min2)\n                min2 = i;\n        &#125;\n    &#125;\n&#125;\n\nvoid HuffmanCoding(HuffmanTree &amp;HT, HuffmanCode &amp;HC, TNode N) //建树函数\n&#123;\n    int m, start, n = N.length;\n    char *cd;\n    unsigned int c, f;\n    if (n &lt;= 1)\n        return;\n    m = 2 * n - 1;\n    HT = (HuffmanTree)malloc((m + 1) * sizeof(HTNode)); //0号单元未用 从1开始\n    for (int i = 1; i &lt;= n; i++)\n    &#123; //利用TNode将叶节点初始化\n        HT[i].parent = 0;\n        HT[i].lchild = HT[i].rchild = 0;\n        HT[i].weight = N.quantity[i - 1];\n    &#125;\n    for (int i = n + 1; i &lt;= m; i++)\n    &#123; //初始化非叶节点\n        HT[i].parent = HT[i].weight = 0;\n        HT[i].lchild = HT[i].rchild = 0;\n    &#125;\n    for (int i = n + 1; i &lt;= m; i++)\n    &#123;                   //构建赫夫曼树\n        int min1, min2; //选出最小的两个结点合并\n        Select(HT, i, min1, min2);\n        HT[i].weight = HT[min1].weight + HT[min2].weight;\n        HT[i].lchild = min1;\n        HT[i].rchild = min2;\n        HT[min1].parent = HT[min2].parent = i;\n    &#125;\n    //从叶子到根逆向求每个字符的赫夫曼编码\n    HC = (HuffmanCode)malloc((n + 1) * sizeof(char *)); //分配n个字符编码的头指针向量\n    cd = (char *)malloc(n * sizeof(char));              //分配求编码的工作空间\n    cd[n - 1] = &#39;\\0&#39;;                                   //编码结束符\n    for (int i = 1; i &lt;= n; i++)\n    &#123;                  //逐个字符求赫夫曼编码\n        start = n - 1; //编码结束符位置\n        for (c = i, f = HT[i].parent; f != 0; c = f, f = HT[f].parent)\n        &#123; //从叶子到根逆向求编码\n            if (HT[f].lchild == c)\n                cd[--start] = &#39;0&#39;;\n            else\n                cd[--start] = &#39;1&#39;;\n        &#125;\n        HC[i] = (char *)malloc((n - start) * sizeof(char)); //为第i个字符编码分配空间\n        strcpy(HC[i], &amp;cd[start]);                          //从cd复制编码（串）到HC\n    &#125;\n    free(cd); //释放工作空间\n    cout &lt;&lt; &quot;完成哈夫曼建树！&quot; &lt;&lt; endl;\n    system(&quot;pause&quot;);\n&#125;\n\nvoid ZipFile(HuffmanCode HC, vector&lt;char&gt; v, TNode N) //压缩文件\n&#123;\n    int i = 0, j = 0, k = 0;\n    ofstream outfile(&quot;f2.txt&quot;, ios::out);\n    if (!outfile)\n    &#123; //文件为空\n        cerr &lt;&lt; &quot;wrong open!!&quot; &lt;&lt; endl;\n        exit(1);\n    &#125;\n    for (i = 0; i &lt; v.size(); i++)\n    &#123; //遍历vector容器\n        for (j = 0; j &lt; N.length; j++)\n            if (N.data[j] == v[i])\n                break;\n        for (k = 0; HC[j + 1][k] != &#39;\\0&#39;; k++)\n            outfile &lt;&lt; HC[j + 1][k];\n    &#125;\n    outfile.close();\n    cout &lt;&lt; &quot;压缩完成！&quot; &lt;&lt; endl;\n    system(&quot;pause&quot;);\n&#125;\n\nvoid RZipFile(HuffmanCode HC, TNode N)\n&#123; //解压文件\n    int flag, flag2 = 0, m = 0, i, j;\n    char ch;\n    char ch2[55];\n    ofstream outfile(&quot;f3.txt&quot;, ios::out);\n    ifstream infile(&quot;f2.txt&quot;, ios::in);\n    if (!outfile)\n    &#123; //文件打开失败\n        cerr &lt;&lt; &quot;打开错误!&quot; &lt;&lt; endl;\n        exit(1); //运行错误，返回值1\n    &#125;\n    if (!infile)\n    &#123;\n        cerr &lt;&lt; &quot;打开错误!&quot; &lt;&lt; endl;\n        exit(1); //运行错误，返回值1\n    &#125;\n    while (infile.peek() != EOF)\n    &#123;\n        flag = 0;\n        char *cd = new char[N.length];\n        for (i = 0;; i++)\n        &#123;\n            infile &gt;&gt; ch;\n            cd[i] = ch;\n            cd[i + 1] = &#39;\\0&#39;;\n            for (int j = 1; j &lt;= N.length; j++)\n            &#123;\n                if (strcmp(HC[j], cd) == 0)\n                &#123;\n                    if (flag2 == 1)\n                    &#123;\n                        ch2[m] = N.data[j - 1];\n                        flag = 1;\n                        m++;\n                        delete cd;\n                        break;\n                    &#125;\n                    if (flag2 == 0)\n                    &#123;\n                        outfile &lt;&lt; N.data[j - 1];\n                        flag = 1;\n                        delete cd;\n                        break;\n                    &#125;\n                &#125;\n            &#125;\n            if (flag == 1)\n                break;\n        &#125;\n    &#125;\n    cout &lt;&lt; &quot;解压缩完成！&quot; &lt;&lt; endl; //提示完成解压缩\n    system(&quot;pause&quot;);\n&#125;\n\nvoid OutPutFile(vector&lt;char&gt; &amp;f)\n&#123;\n    char path[200];\n    char ch;\n    cout &lt;&lt; &quot;请输入您所要查询的文件路径&quot; &lt;&lt; endl;\n    cin &gt;&gt; path;\n\n    ifstream infile(path, ios::in);\n    if (!infile)\n    &#123; //文件不存在\n        cout &lt;&lt; &quot;打开错误!&quot; &lt;&lt; endl;\n        exit(1);\n    &#125;\n    while (infile.peek() != EOF)\n    &#123;\n        infile.get(ch);  //读取字符赋值给ch\n        f.push_back(ch); //把字符ch推入vector\n    &#125;\n    infile.close();\n    cout &lt;&lt; &quot;路径：&quot; &lt;&lt; path &lt;&lt; &quot;的文件如下&quot; &lt;&lt; endl;\n    for (int i = 0; i &lt; f.size(); i++)\n        cout &lt;&lt; f.at(i);\n    cout &lt;&lt; endl;\n    f.clear();\n    system(&quot;pause&quot;);\n&#125;\n\nint main(void)\n&#123;\n    int choose;\n    vector&lt;char&gt; V, Vr;\n    HuffmanTree HT;\n    HuffmanCode HC;\n    TNode N;\n    InitList(N);\n    while (1)\n    &#123;\n        system(&quot;cls&quot;);\n        cout &lt;&lt; &quot;1、压缩文件&quot; &lt;&lt; endl;\n        cout &lt;&lt; &quot;2、解压文件&quot; &lt;&lt; endl;\n        cout &lt;&lt; &quot;3、输出文件&quot; &lt;&lt; endl;\n        cout &lt;&lt; &quot;0、  退出  &quot; &lt;&lt; endl;\n        cout &lt;&lt; &quot;请输入您的操作:&quot; &lt;&lt; endl;\n        cin &gt;&gt; choose;\n        switch (choose)\n        &#123;\n        case 1:\n            cout &lt;&lt; &quot;*****进行压缩文件操作*****&quot; &lt;&lt; endl;\n            ReadFile(V);              //从文件读取数据存入vector容器\n            WriteTNode(V, N);         //将vector中的数据存储到NTode结构中\n            HuffmanCoding(HT, HC, N); //将TNode中的数据存到哈夫曼树中并生成哈夫曼编码\n            ZipFile(HC, V, N);        //压缩文件\n            break;\n        case 2:\n            cout &lt;&lt; &quot;*****进行解压缩文件操作*****&quot; &lt;&lt; endl;\n            RZipFile(HC, N); //对文件内容进行解码\n            break;\n        case 3:\n            cout &lt;&lt; &quot;*****进行输出文件操作*****&quot; &lt;&lt; endl;\n            OutPutFile(Vr); //将文件内容借助vector输出到终端\n            break;\n        case 0:\n            return 0;\n        default:\n            cout &lt;&lt; &quot;请正确输入！&quot;;\n            system(&quot;pause&quot;);\n            break;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n\n","slug":"数据结构（C语言版）-- 树和二叉树笔记","date":"2022-02-16T04:56:11.000Z","categories_index":"前端","tags_index":"字节跳动青训营","author_index":"会思想的苇草i"},{"id":"1d7c86a35a2f9ff3da1b325afe7a5b86","title":"串、数组和广义表","content":"\n1、串①.串的定义&#x3D;&#x3D;串(String)—-零个或多个字符组成的有限序列，是一种特殊的线性表，其数据元素为一个字符，即内容受限的线性表。&#x3D;&#x3D;\n\n子串：\n串中任意个连续的字符组成的子序列\n主串：\n 包含子串的串\n字符位置：\n 字符在序列中的序号\n子串位置：\n 以子串的第一个字符在主串中的位置来表示\n空格串：\n 一个或多个空格组成的串 \n\n&#x3D;&#x3D;两个串是相等的，当且仅当这两个串的值相等。也就是说，只有当两个串的长度相等，并且各个对应位置的字符都相等时才相等&#x3D;&#x3D;。例如，上例中的串a、b、c和d彼此都不相等。\n串的抽象数据类型的定义：\n\n与线性表类似，串也有两种基本存储结构：顺序存储和链式存储。但考虑到存储效率和算法的方便性,串多采用顺序存储结构。\n②.串的顺序存储类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区，则可用定长数组如下描述:\ntypedef struct\n&#123;\n    char ch[MAXLEN + 1]; // MAXLEN为串的最大长度\n                         //存储串的一维数组\n    int length; //串长度\n&#125; SString;\n\n而多数情况下，串的操作是以串的整体形式参与的，串变量之间的长度相差较大，在操作中串值长度的变化也较大，这样为串变量设定固定大小的空间不尽合理。因此最好是根据实际需要，在程序执行过程中动态地分配和释放字符数组空间。在C语言中，存在一个称之为“堆”(Heap）的自由存储区，可以为每个新产生的串动态分配一块实际串长所需的存储空间，若分配成功，则返回一个指向起始地址的指针，作为串的基址，同时为了以后处理方便，约定串长也作为存储结构的一部分。\ntypedef struct\n&#123;\n    char *ch;   //若串非空，则按串长分配存储区,否则ch为NULL\n    int length; //串长度\n&#125; HString;\n\n③.串的链式存储顺序串的插人和删除操作不方便，需要移动大量的字符。因此，可采用单链表方式存储串。\n#define CHUNKSIZE 80 //可由用户定义的块大小\ntypedef struct Chunk\n&#123;\n    char ch[CHUNKSIZE]; //存储串的一维\n    struct Chunk *next;\n&#125; Chunk;\n\ntypedef struct\n&#123;\n    Chunk *head, *tail; //串的头指针和尾指针\n    int curlen;         //串的当前长度\n&#125; LString;\n\n串值的链式存储结构对某些串操作，如联接操作等，有一定方便之处，但总地说来，不如顺序存储结构灵活，它占用存储量大且操作复杂。\n④.串的模式匹配算法&#x3D;&#x3D;子串的定位运算通常称为串的模式匹配或串匹配，主串称为正文串，子串称为模式串，该算法目的是确定主串中缩含子串第一次出现的位置（定位）&#x3D;&#x3D;。此运算的应用非常广泛,比如在搜索引擎、拼写检查、语言翻译、数据压缩等应用中，都需要进行串匹配。\nBF（Brute-Force）算法\n模式匹配不一定是从主串的第一个位置开始，可以指定主串中查找的起始位置pos。如果采用字符串顺序存储结构，可以写出不依赖于其他串操作的匹配算法。\n\n分别利用计数指针i和j指示主串S和模式T中当前正待比较的字符位置，i初值为pos,j初值为1。\n\n如果两个串均未比较到串尾，即i和j均分别小于等于S和T的长度时，则循环执行以下操作:\n- S[i].ch和T[j].ch 比较，若相等，则i和j分别指示串中下个位置，继续比较后续字符;\n\n- 若不等，指针后退重新开始匹配，从主串的下一个字符( i=i-j+2）起再重新和模式的第一个字符(j=1 )比较。\n\n\n③如果j&gt;T.length，说明模式T中的每个字符依次和主串S中的一个连续的字符序列相等，则匹配成功，返回和模式T中第一个字符相等的字符在主串S中的序号( i-T.length );否则称匹配不成功，返回0。\n\n\n\nint Index(SString S, SString T, int pos)\n&#123;\n    i = pos;\n    j = 1;                              //初始化\n    while (i &lt;= S[0] &amp;&amp; j &lt;= T[0])\t\t//两个串均未比较到串尾\n    &#123;\n        if (S[i] = T[j])\n        &#123;\n            ++i;\n            ++j;\n        &#125; //继续比较后继字符\n        else\n        &#123;\n            i = i - j + 2;\n            j = 1;\n        &#125; //指针后退重新开始匹配\n    &#125;\n    if (j &gt; T[0])\n        return i-T[0]; //匹配成功\n    else\n        return 0; //匹配失败\n&#125;\n\nBF算法实例：\n/***字符串匹配算法***/\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\n#define OK 1\n#define ERROR 0\n#define OVERFLOW -2\ntypedef int Status;\n#define MAXSTRLEN 255                //用户可在255以内定义最长串长\ntypedef char SString[MAXSTRLEN + 1]; // 0号单元存放串的长度\n\nStatus StrAssign(SString T, char *chars)\n&#123; //生成一个其值等于chars的串T\n    int i;\n    if (strlen(chars) &gt; MAXSTRLEN)\n        return ERROR;\n    else\n    &#123;\n        T[0] = strlen(chars);\n        for (i = 1; i &lt;= T[0]; i++)\n            T[i] = *(chars + i - 1);\n        return OK;\n    &#125;\n&#125;\n\n// BF算法\nint Index(SString S, SString T, int pos)\n&#123;\n    //返回模式T在主串S中第pos个字符之后第s一次出现的位置。若不存在，则返回值为0\n    //其中，T非空，1≤pos≤StrLength(S)\n    int i = pos;\n    int j = 1;\n    while (i &lt;= S[0] &amp;&amp; j &lt;= T[0])\n    &#123;\n        if (S[i] == T[j])\n        &#123;\n            ++i;\n            ++j;\n        &#125; //继续比较后继字符\n        else\n        &#123;\n            i = i - j + 2;\n            j = 1;\n        &#125; //指针后退重新开始匹配\n    &#125;\n    if (j &gt; T[0])\n        return i - T[0];\n    else\n        return 0;\n    return 0;\n&#125; // Index\n\nint main()\n&#123;\n    SString S;\n    StrAssign(S, &quot;bbaaabbaba&quot;);\n    SString T;\n    StrAssign(T, &quot;abb&quot;);\n    cout &lt;&lt; &quot;主串和子串在第&quot; &lt;&lt; Index(S, T, 1) &lt;&lt; &quot;个字符处首次匹配\\n&quot;;\n    return 0;\n&#125;\n\n&#x3D;&#x3D;该算法时间复杂度为：O（n*m）&#x3D;&#x3D;\nKMP算法\n这种改进算法是由Knuth、Morris和 Pratt同时设计实现的，因此简称KMP算法。此算法可以在O(n + m)的时间数量级上完成串的模式匹配操作。其改进在于:每当一趟匹配过程中出现字符比较不等时，不需回溯i指针，而是利用已经得到的“部分匹配”的结果将模式向右“滑动”尽可能远的一段距离后，继续进行比较。\n\n分别利用计数指针i和j指示主串S和模式T中当前正待比较的字符位置，i初值为pos,j初值为1。\n\n如果两个串均未比较到串尾，即i和j均分别小于等于S和T的长度时，则循环执行以下操作:\n- S[i].ch 和T[i].ch 比较，若相等，则i和j分别指示串中下个位置，继续比较后续字符;\n- 若不等，指针后退重新开始匹配，从主串的下一个字符(i=i-j+2）起再重新和模式的第一个字符(j=1)比较。\n\n\n如果j&gt;T.length，说明模式T中的每个字符依次和主串S中的一个连续的字符序列相等，则匹配成功，返回和模式T中第一个字符相等的字符在主串S中的序号(i-T.length);否则称匹配不成功，返回0。\n\n\n该算法思想感兴趣可观看天勤公开课讲解视频，个人认为讲解比较透彻：\n「天勤公开课」KMP算法易懂版\n以下对其进行简单阐述：\n&#x3D;&#x3D;kmp算法作用是快速的从一个主串中找到想要的子串，kmp算法可以做到仅仅后移模式串，比较指针不回溯。&#x3D;&#x3D;\n\n&#x3D;&#x3D;找出模式串不匹配处最长但不长于不匹配处左端的公共前后缀，直接移动模式串，使得前缀直接来到后缀的位置。&#x3D;&#x3D;\n\n\n\nint Index_KMP(SString S, SString T, int pos)\n&#123;\n    i = pos;\n    j = 1;                                 //初始化\n    while (i &lt;= S.length &amp;&amp; j &lt;= S.length) //两个串均未比较到串尾\n    &#123;\n        if (j == 0 || S[i] == T[j])\n        &#123;\n            ++i;\n            ++j;\n        &#125; //继续比较后继字符\n        else\n        &#123;\n            j = next[j];\n        &#125; //模式串向右移动\n    &#125;\n    if (j &gt; T[0])\n        return i - T[0]; //匹配成功\n    else\n        return 0; //匹配失败\n&#125;\n\nvoid get_next(SString T, int next[])\n&#123; //求模式串T的next函数值并存入数组next\n    i = 1;\n    next[1] = 0;\n    j = 0;\n    while (i &lt; T[0])\n    &#123;\n        if (j == 0 || T[i])\n        &#123;\n            ++i;\n            ++j;\n            next[i] = j;\n        &#125;\n        else\n        &#123;\n            j = next[j];\n        &#125;\n    &#125;\n&#125;\n\nKMP算法实例：\n/***字符串匹配算法***/\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\n#define OK 1\n#define ERROR 0\n#define OVERFLOW -2\ntypedef int Status;\n#define MAXSTRLEN 255                //用户可在255以内定义最长串长\ntypedef char SString[MAXSTRLEN + 1]; // 0号单元存放串的长度\n\nStatus StrAssign(SString T, char *chars)\n&#123; //生成一个其值等于chars的串T\n    int i;\n    if (strlen(chars) &gt; MAXSTRLEN)\n        return ERROR;\n    else\n    &#123;\n        T[0] = strlen(chars);\n        for (i = 1; i &lt;= T[0]; i++)\n            T[i] = *(chars + i - 1);\n        return OK;\n    &#125;\n&#125;\n//算法4.3　计算next函数值\nvoid get_next(SString T, int next[])\n&#123; //求模式串T的next函数值并存入数组next\n    int i = 1, j = 0;\n    next[1] = 0;\n    while (i &lt; T[0])\n        if (j == 0 || T[i] == T[j])\n        &#123;\n            ++i;\n            ++j;\n            next[i] = j;\n        &#125;\n        else\n            j = next[j];\n&#125; // get_next\n\n// KMP算法\nint Index_KMP(SString S, SString T, int pos, int next[])\n&#123; // 利用模式串T的next函数求T在主串S中第pos个字符之后的位置的KMP算法\n    //其中，T非空，1≤pos≤StrLength(S)\n    int i = pos, j = 1;\n    while (i &lt;= S[0] &amp;&amp; j &lt;= T[0])\n        if (j == 0 || S[i] == T[j]) // 继续比较后继字\n        &#123;\n            ++i;\n            ++j;\n        &#125;\n        else\n            j = next[j]; // 模式串向右移动\n    if (j &gt; T[0])        // 匹配成功\n        return i - T[0];\n    else\n        return 0;\n&#125; // Index_KMP\n\nint main()\n&#123;\n    SString S;\n    StrAssign(S, &quot;aaabbaba&quot;);\n    SString T;\n    StrAssign(T, &quot;abb&quot;);\n    int *p = new int[T[0] + 1]; // 生成T的next数组\n    get_next(T, p);\n    cout &lt;&lt; &quot;主串和子串在第&quot; &lt;&lt; Index_KMP(S, T, 1, p) &lt;&lt; &quot;个字符处首次匹配\\n&quot;;\n    return 0;\n&#125;\n\n&#x3D;&#x3D;时间复杂度：O（n+m）&#x3D;&#x3D;\n\n2、数组①.数组的定义数组是由类型相同的数据元素构成的有序集合，每个元素称为数组元素，每个元素受n(n≥1 )个线性关系的约束，每个元素在n个线性关系中的序号i1，i2，…，in称为该元素的下标，可以通过下标访问该数据元素。因为数组中每个元素处于n (n≥1)个关系中，故称该数组为n维数组。数组可以看成是线性表的推广，其特点是结构中的元素本身可以是具有某种结构的数据，但属于同一数据类型。\n\n②.数组的顺序存储由于数组一般不做插人或删除操作，也就是说;一旦建立了数组，则结构中的数据元素个数和元素之间的关系就不再发生变动。因此，采用顺序存储结构表示数组比较合适。二维数组可有两种存储方式：一种是以列序为主序的存储方式；一种是以行序为主序的存储方式。\n\n\n三维数组的顺序存储：\n\n③.特殊矩阵的压缩存储特殊矩阵: 值相同的元素或0元素在矩阵中的分布有一定的规律。如:对称矩阵、三角矩阵、对角矩阵等。\n压缩存储: 压缩存储是指为多个值相同的元只分配一个存储空间,且对零元不分配存储空间。目的是节省大量存储空间。\n什么样的矩阵能够压缩?特殊矩阵、稀疏矩阵等。\n对称矩阵\n若n阶矩阵A中的元满足aij &#x3D; aji  1≤i，j≤ n 则称为n阶对称矩阵。对于对称矩阵,可以为每一对对称元分配一个存储空间,则可将n^2^个元压缩存储到n(n+1)&#x2F;2个元的空间中，不失一般性，可以行序为主序存储其下三角（包括对角线）中的元。假设以一维数组sa[r(n+1)&#x2F;2]作为n阶对称矩阵A的存储结构,则 sa[k]和矩阵元aj之间存在着一一对应的关系:\n\n三角矩阵\n以主对角线划分,三角矩阵有上三角矩阵和下三角矩阵两种。上三角矩阵是指矩阵下三角(不包括对角线）中的元均为常数c或零的n阶矩阵，下三角矩阵与之相反。对三角矩阵进行压缩存储时，除了和对称矩阵一样，只存储其上(下)三角中的元素之外，再加一个存储常数c的存储空间即可。\n上三角矩阵sa[k]和矩阵元aij之间的对应关系为：\n下三角矩阵sa[k]和矩阵元aij之间的对应关系为:\n对角矩阵\n对角矩阵所有的非零元都集中在以主对角线为中心的带状区域中，即除了主对角线上和直接在对角线上、下方若干条对角线上的元之外，所有其他的元皆为零。\n\n3、广义表①.广义表的定义&#x3D;&#x3D;广义表：n ( ≥0)个表元素组成的有限序列,记作LS&#x3D;（a1，a2，…，an）。LS是表名，ai是表元素，它可以是表(称为子表)，可以是数据元素(称为原子)。n为表的长度，n&#x3D;0的广义表称为空表。&#x3D;&#x3D;\n&#x3D;&#x3D;求表头GetHead(L):非空广义表的第一个元素，可以是一个原子,也可以是一个子表。&#x3D;&#x3D;&#x3D;&#x3D;求表尾GetTail(L):非空广义表除去表头元素以外其它所有元素所构成的表。表尾一定是一个表。&#x3D;&#x3D;\n\n②.广义表的存储结构由于广义表中的数据元素可以有不同的结构(或是原子，或是列表)，因此难以用顺序存储结构表示，通常采用链式存储结构。\n头尾链表的存储结构\n由于广义表中的数据元素可能为原子或广义表，由此需要两种结构的结点:一种是表结点，用以表示广义表;一种是原子结点，用以表示原子。从上节得知:若广义表不空，则可分解成表头和表尾，因此，一对确定的表头和表尾可唯一确定广义表。一个表结点可由3个域组成:标志域、指示表头的指针域和指示表尾的指针域。而原子结点只需两个域:标志域和值域。\n\ntypedef enum\n&#123;\n    ATOM,\n    LIST\n&#125; ElemTag;\n// ATOM==0:原子,LIST==1:子表\ntypedef struct GLNode\n&#123;\n    ElemTag tag; //公共部分,用于区分原子结点和表结点\n    union        //原子结点和表结点的联合部分\n    &#123;\n        AtomType atom; // atom是原子结点的值域,AtomType由用户定义\n        struct\n        &#123;\n            struct GLNode *hp, *tp;\n        &#125; ptr;\n        // ptr是表结点的指针域,prt.hp和ptr.tp分别指向表头和表尾\n    &#125;;\n&#125; * GList, GLNode; /* 广义表类型 */\n\n扩展线性链表的存储结构\n在这种结构中，无论是原子结点还是表结点均由三个域组成\n\ntypedef struct glnode\n&#123;\n    int tag; // 0 原子结点；1 子表结点\n    union\n    &#123;\n        atomtype atom;     //原子结点的值域\n        struct glnode *hp; //子表表头指针\n    &#125; struct glnode *tp;   //下一元素指针\n&#125; * glist;\n\n\n4、总结\n串是内容受限的线性表，它限定了表中的元素为字符。串有两种基本存储结构:顺序存储和链式存储，但多采用顺序存储结构。串的常用算法是模式匹配算法，主要有BF算法和KMP算法。BF算法实现简单，但存在回溯，效率低，时间复杂度为O(m ×n)。KMP算法对BF算法进行改进，消除回溯，提高了效率，时间复杂度为O(m+n)。\n\n多维数组可以看成是线性表的推广,其特点是结构中的元素本身可以是具有某种结构的数据，但属于同一数据类型。一个n维数组实质上是n个线性表的组合，其每一维都是一个线性表。数组一般采用顺序存储结构，故存储多维数组时，应先将其确定转换为一维结构，有按“行”转换和按“列”转换两种。科学与工程计算中的矩阵通常用二维数组来表示，为了节省存储空间，对于几种常见形式的特殊矩阵，比如对称矩阵、三角矩阵和对角矩阵，在存储时可进行压缩存储，即为多个值相同的元只分配一个存储空间，对零元不分配空间。\n\n广义表是另外一种线性表的推广形式，表中的元素可以是称为原子的单个元素，也可以是一个子表，所以线性表可以看成广义表的特例。广义表的结构相当灵活，在某种前提下，它可以兼容线性表、数组、树和有向图等各种常用的数据结构。广义表的常用操作有取表头和取表尾。广义表通常采用链式存储结构:头尾链表的存储结构和扩展线性链表的存储结构。\n\n\n\n5、例题与应用\n","slug":"数据结构（C语言版）-- 串、数组和广义表笔记","date":"2022-02-16T04:53:52.000Z","categories_index":"前端","tags_index":"字节跳动青训营","author_index":"会思想的苇草i"},{"id":"32e8754bc216ad5a6afe6dae9987332f","title":"栈和队列","content":"\n1、栈和队列的定义和特点①.栈的定义和特点栈( stack）是限定仅在表尾进行插人或删除操作的线性表。因此，对栈来说，表尾端有其特殊含义，称为栈顶( top )，相应地，表头端称为栈底（ bottom )。不含元素的空表称为空栈。&#x3D;&#x3D;后进先出( Last In First Out，LIFO）&#x3D;&#x3D;\n\n在日常生活中，有很多类似栈的例子。例如，洗干净的盘子总是逐个往上叠放在已经洗好的盘子上面，而用时从上往下逐个取用。栈的操作特点正是上述实际应用的抽象。\n\n②.队列的定义和特点和栈相反，**队列( queue)是一种 &#x3D;&#x3D;先进先出(First In First Out，FIFO)&#x3D;&#x3D; 的线性表。它只允许在表的一端进行插入，而在另一端删除元素。这和日常生活中的排队是一致的，最早进人队列的元素最早离开。在队列中，允许插入的一端称为队尾( rear )，允许删除的一端则称为队头(front )**。\n\n队列在程序设计中也经常出现,一个最典型的例子就是操作系统中的作业排队。在允许多道程序运行的计算机系统中，同时有几个作业运行。如果运行的结果都需要通过通道输出，那就要按请求输入的先后次序排队。每当通道传输完毕可以接受新的输出任务时，队头的作业先从队列中退出做输出操作。凡是申请输出的作业都从队尾进入队列。\n\n2、栈的表示和操作的实现①.栈的类型定义栈的抽象数据类型定义：\n\n②.顺序栈的表示和实现顺序栈是指利用顺序存储结构实现的栈，即利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设指针 top指示栈顶元素在顺序栈中的位置。base为栈底指针，stacksize指示栈可使用的最大容量。&#x3D;&#x3D;若base &#x3D; NULL,表示栈结构不存在，base &#x3D; &#x3D; top是栈空标志，top-base &#x3D; &#x3D; stacksize是栈满标志&#x3D;&#x3D;\n//顺序栈的存储结构\n#define MAXSIZE 100\ntypedef struct\n&#123;\n    SElemType *base; //栈底指针\n    SElemType *top;  //栈顶指针\n    int stacksize;   //可使用的最大容量\n&#125; SqStack;\n\n顺序栈中数据元素和栈指针之间的对应关系：\n\n顺序栈的初始化\n\n为顺序栈动态分配-个最大容量为MAXSIZE的数组空间，使base指向这段空间的基地址，即栈底。\n栈顶指针top初始为base,表示栈为空。\nstacksize置为栈的最大容量MAXSIZE\n\nStatus InitStack(SqStack &amp;S)\n&#123;\n    S.base = new SElemType[MAXSIZE];\n    if (!S.base)\n        exit(OVERFLOW);\n    S.top = S.base;\n    S.stacksize = MAXSIZE;\n    return OK;\n&#125;\n\n顺序栈的入栈\n\n判断栈是否满,若满则返回ERROR。\n将新元素压入栈顶,栈顶指针加 1。\n\n\nStatus Push(SqStack &amp;S, SElemType e)\n&#123; // 插入元素e为新的栈顶元素\n    if (S.top - S.base == S.stacksize)\n        return ERROR; //栈满\n    *S.top++ = e;     // 新元素e压入栈顶，然后栈顶指针加1(*S.top=e;S.top++;)\n    return OK;\n&#125;\n\n顺序栈的出栈\n\n判断栈是否空,若空则返回 ERROR。\n栈顶指针减1，栈顶元素出栈。\n\n\nStatus Pop(SqStack &amp;S, SElemType &amp;e)\n&#123; // 删除S的栈顶元素，用e返回其值\n    if (S.top == S.base)\n        return ERROR; //栈空报错\n    e = *--S.top;     //栈顶指针减1，然后获取栈顶元素e(--S.top;e=*S.top;)\n    return OK;\n&#125;\n\n顺序栈的实现\n测试样例：SqStack.txt测试内容：ABCD\n/***顺序栈的实现***/\n\n#include&lt;iostream&gt;\n#include&lt;fstream&gt;\nusing namespace std;\n\n//顺序栈定义\n#define OK 1\n#define ERROR 0\n#define OVERFLOW -2\n#define MAXSIZE  100//顺序栈存储空间的初始分配量\ntypedef int Status;\ntypedef char SElemType;\n\ntypedef struct &#123;\n    SElemType *base;//栈底指针\n    SElemType *top;//栈顶指针\n    int stacksize;//栈可用的最大容量\n&#125; SqStack;\n\n//顺序栈的初始化\nStatus InitStack(SqStack &amp;S) &#123;\n    //构造一个空栈S\n    S.base = new SElemType[MAXSIZE];//为顺序栈动态分配一个最大容量为MAXSIZE的数组空间\n    if (!S.base)\n        exit(OVERFLOW); //存储分配失败\n    S.top = S.base; //top初始为base，空栈\n    S.stacksize = MAXSIZE; //stacksize置为栈的最大容量MAXSIZE\n    return OK;\n&#125;\n//顺序栈的入栈\nStatus Push(SqStack &amp;S, SElemType e) &#123;\n    // 插入元素e为新的栈顶元素\n    if (S.top - S.base == S.stacksize)\n        return ERROR; //栈满\n    *(S.top++) = e; //元素e压入栈顶，栈顶指针加1\n    return OK;\n&#125;\n//顺序栈的出栈\nStatus Pop(SqStack &amp;S, SElemType &amp;e) &#123;\n    //删除S的栈顶元素，用e返回其值\t\n    if (S.base == S.top)\n        return ERROR;//栈空\n    e = *(--S.top); //栈顶指针减1，将栈顶元素赋给e\n    return OK;\n&#125;\n//取顺序栈的栈顶元素\nchar GetTop(SqStack S) &#123;//返回S的栈顶元素，不修改栈顶指针\n    if (S.top != S.base) //栈非空\n        return *(S.top - 1); //返回栈顶元素的值，栈顶指针不变\n&#125;\n\nint main() &#123;\n    SqStack s;\n    int choose, flag = 0;\n    SElemType j, e, t;\n    cout &lt;&lt; &quot;1.初始化\\n&quot;;\n    cout &lt;&lt; &quot;2.入栈\\n&quot;;\n    cout &lt;&lt; &quot;3.读栈顶元素\\n&quot;;\n    cout &lt;&lt; &quot;4.出栈\\n&quot;;\n    cout &lt;&lt; &quot;0.退出\\n\\n&quot;;\n\n    choose = -1;\n    while (choose != 0) &#123;\n        cout &lt;&lt; &quot;请选择:&quot;;\n        cin &gt;&gt; choose;\n        switch (choose) &#123;\n        case 1://顺序栈的初始化\n            if (InitStack(s)) &#123;\n                flag = 1;\n                cout &lt;&lt; &quot;成功对栈进行初始化\\n\\n&quot;;\n            &#125; else\n                cout &lt;&lt; &quot;初始化栈失败\\n\\n&quot;;\n            break;\n        case 2: &#123;//顺序栈的入栈\n            fstream file;\n            file.open(&quot;SqStack.txt&quot;);//\n            if (!file) &#123;\n                cout &lt;&lt; &quot;错误！未找到文件！\\n\\n&quot; &lt;&lt; endl;\n                exit(ERROR);\n            &#125;\n            if (flag) &#123;\n                flag = 1;\n                cout &lt;&lt; &quot;进栈元素依次为：\\n&quot;;\n                while (!file.eof()) &#123;\n                    file &gt;&gt; j;\n                    if (file.fail())\n                        break;\n                    else &#123;\n                        Push(s, j);\n                        cout &lt;&lt; j &lt;&lt; &quot;  &quot;;\n                    &#125;\n                &#125;\n                cout &lt;&lt; endl &lt;&lt; endl;\n            &#125; else\n                cout &lt;&lt; &quot;栈未建立，请重新选择\\n\\n&quot;;\n            file.close();\n        &#125;\n            break;\n        case 3://顺序栈的出栈\n            if(flag != -1 &amp;&amp; flag != 0)\n                cout &lt;&lt; &quot;栈顶元素为：\\n&quot; &lt;&lt; GetTop(s) &lt;&lt; endl &lt;&lt; endl;\n            else\n                cout &lt;&lt; &quot;栈中无元素，请重新选择\\n&quot; &lt;&lt; endl;\n            break;\n        case 4://取顺序栈的栈顶元素\n            cout &lt;&lt; &quot;依次弹出的栈顶元素为:\\n&quot;;\n            while (Pop(s, t))&#123;\n                flag = -1;\n                cout &lt;&lt; t &lt;&lt; &quot;  &quot;;\n            &#125;\n            cout &lt;&lt; endl &lt;&lt; endl;\n            break;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n\n②.链栈的表示和实现链栈是指采用链式存储结构实现的栈，通常链栈用单链表来表示，链栈的结点结构与单链表的结构相同。\n\n//链栈的存储结构\ntypedef struct StackNode\n&#123;\n    ElemType data;\n    struct StackNode *next;\n&#125; StackNode, *LinkStack;\n\nLinkStack S;\n\n由于栈的主要操作是在栈顶插人和删除，显然以链表的头部作为栈顶是最方便的，而且没必要像单链表那样为了操作方便附加一个头结点。\n链栈的初始化\n链栈的初始化操作就是构造一个空栈，因为没必要设头结点，所以直接将栈顶指针置空即可。\nStatus InitStack(LinkStack &amp;S)\n&#123; // 构造一个空栈 S，栈顶指针置空\n    S = NULL;\n    return OK;\n&#125;\n\n链栈的入栈\n\n为入栈元素e分配空间，用指针p指向。\n将新结点数据域置为e。\n将新结点插人栈顶。\n修改栈顶指针为p。\n\n\nStatus Push(LinkStack &amp;S, SElemType e)\n&#123;                      //在栈顶插入元素e\n    p = new StackNode; //生成新结点\n    p-&gt;data = e;       //将新结点数据域置为e\n    p-&gt;next = S;       //将新结点插入栈顶\n    S = p;             //修改栈顶指针为p\n    return OK;\n&#125;\n\n链栈的出栈\n\n判断栈是否为空，若空则返回ERROR。\n将栈顶元素赋给e。\n临时保存栈顶元素的空间，以备释放。\n修改栈顶指针,指向新的栈顶元素。\n释放原栈顶元素的空间。\n\n\nStatus Pop(LinkStack &amp;S, SElemType &amp;e)\n&#123; //删除S的栈顶元素，用e返回其值\n    if (S == NULL)\n        return ERROR; //栈空\n    e = S-&gt;data;      //将栈顶元素赋给e\n    p = S;            //用p临时保存栈顶元素空间，以备释放\n    S = S-&gt;next;      //修改栈顶指针\n    delete p;         //释放原栈顶元素的空间\n    return OK;\n&#125;\n\n取链栈的栈顶元素\n与顺序栈—样，当栈非空时，此操作返回当前栈顶元素的值，栈顶指针S保持不变。\n\nSElemType GetTop(LinkStack S)\n&#123;\n    if (S != NULL)\n        return S–&gt; data;\n&#125;\n\n链栈的实现\n测试样例：SqStack.txt测试内容：ABCD\n/***链栈的实现***/\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define OK 1\n#define ERROR 0\ntypedef int Status;\ntypedef int SElemType;\n//链栈定义\ntypedef struct StackNode\n&#123;\n    SElemType data;\n    struct StackNode *next;\n&#125; StackNode, *LinkStack;\n//链栈的初始化\nStatus InitStack(LinkStack &amp;S)\n&#123; // 构造一个空栈 S，栈顶指针置空\n    S = NULL;\n    return OK;\n&#125;\n//链栈的入栈\nStatus Push(LinkStack &amp;S, SElemType e)\n&#123; //在栈顶插入元素e\n    LinkStack p;\n    p = new StackNode; //生成新结点\n    p-&gt;data = e;       //将新结点数据域置为e\n    p-&gt;next = S;       //将新结点插入栈顶\n    S = p;             //修改栈顶指针为p\n    return OK;\n&#125;\n//链栈的出栈\nStatus Pop(LinkStack &amp;S, SElemType &amp;e)\n&#123; //删除S的栈顶元素，用e返回其值\n    LinkStack p;\n    if (S == NULL)\n        return ERROR; //栈空\n    e = S-&gt;data;      //将栈顶元素赋给e\n    p = S;            //用p临时保存栈顶元素空间，以备释放\n    S = S-&gt;next;      //修改栈顶指针\n    delete p;         //释放原栈顶元素的空间\n    return OK;\n&#125;\n//取链栈的栈顶元素\nSElemType GetTop(LinkStack S)\n&#123;                       //返回S的栈顶元素，不修改栈顶指针\n    if (S != NULL)      //栈非空\n        return S-&gt;data; //返回栈顶元素的值，栈顶指针不变\n&#125;\nint main()\n&#123;\n    LinkStack s;\n    int select, flag = 0, i,j,n, t;\n    cout &lt;&lt; &quot;1.初始化链栈\\n&quot;;\n    cout &lt;&lt; &quot;2.链栈的入栈\\n&quot;;\n    cout &lt;&lt; &quot;3.读栈顶元素\\n&quot;;\n    cout &lt;&lt; &quot;4.链栈的出栈\\n&quot;;\n    cout &lt;&lt; &quot;0.退出\\n\\n&quot;;\n\n    while (1)\n    &#123;\n        cout &lt;&lt; &quot;请选择:&quot;;\n        cin &gt;&gt; select;\n        switch (select)\n        &#123;\n        case 1: //链栈的初始化\n            if (InitStack(s))\n            &#123;\n                flag = 1;\n                cout &lt;&lt; &quot;成功对栈进行初始化\\n\\n&quot;;\n            &#125;\n            else\n                cout &lt;&lt; &quot;初始化栈失败\\n\\n&quot;;\n            break;\n        case 2:\n         //链栈的入栈\n            cout &lt;&lt; &quot;请输入元素个数：&quot;;\n            cin &gt;&gt; n;\n            cout &lt;&lt; &quot;请输入&quot; &lt;&lt; n &lt;&lt; &quot;个元素：&quot;;\n            for (j = 1; j &lt;= n; ++j)\n            &#123;\n                cin &gt;&gt; i;\n                if (Push(s, i))\n                &#123;\n                    flag = 1;\n                &#125;\n            &#125;\n            if (flag = 1)\n            &#123;\n                cout &lt;&lt; &quot;入栈操作成功！\\n\\n&quot;;\n            &#125;\n            break;\n        case 3: //取链栈的栈顶元素\n            if (flag != -1 &amp;&amp; flag != 0)\n                cout &lt;&lt; &quot;栈顶元素为：\\n&quot;\n                     &lt;&lt; GetTop(s) &lt;&lt; endl\n                     &lt;&lt; endl;\n            else\n                cout &lt;&lt; &quot;栈中无元素，请重新选择\\n&quot;\n                     &lt;&lt; endl;\n            break;\n        case 4: //链栈的出栈\n            if (flag)\n            &#123;\n                cout &lt;&lt; &quot;依次弹出的栈顶元素为:\\n&quot;;\n                while (Pop(s, t))\n                    cout &lt;&lt; t &lt;&lt; &quot;  &quot;;\n                cout &lt;&lt; endl\n                     &lt;&lt; endl;\n            &#125;\n            else\n                cout &lt;&lt; &quot;栈未建立，请重新选择\\n\\n&quot;;\n            break;\n        case 0:\n            return 0;\n        default:\n            cout &lt;&lt; &quot;请重新输入！\\n\\n&quot;;\n            break;\n        &#125;\n        &#125;\n        return 0;\n    &#125;\n\n④.栈与递归递归的定义\n若一个对象部分地包含它自己，或用它自己给自己定义，则称这个对象是递归的;若一个过程直接或间接地调用自己，则称这个过程是递归的。\n递归实例\n过程的嵌套定义\n分治法\nlong Fact(long n)\n&#123;\n    if (n == 1)\n        return 1; //基本项\n    else\n        temp = n * Fact(n - 1); //归纳项\n    return temp;\n&#125;\n\n\n⑤.思考问：根据栈的特性，如果进栈序列为A,B,C,D,E，能否得到D,C,E,A,B和A,C,E,D,B的出栈序列，如果不能得到请说明原因，如果可以得到请写出入栈、出栈的过程。\n答：出栈序列D,C,E,A,B不可能，因为D先出栈，表明这时A、B已经入栈，A为栈底，出栈时A肯定在B之后。出栈序列A,C,E,D,B可能，入栈、出栈的过程:PUSH(S,A);POP(S);PUSH(S,B);PUSH(S,C);POP(S);PUSH(S,D);PUSH(S,E);POP(S);POP(S); POP(S)。\n\n3、队列的表示和操作的实现①.队列的类型定义队列的抽象数据类型定义：\n\n②.队列的顺序表示和实现和顺序栈相类似，在队列的顺序存储结构中，除了用一组地址连续的存储单元依次存放从队列头到队列尾的元素之外,尚需附设两个整型变量 front和rear分别指示队列头元素及队列尾元素的位置（后面分别称为头指针和尾指针)。队列的顺序存储结构表示如下:\n#define MAXQSIZE 100 //最大队列长度\nTypedef struct\n&#123;\n    QElemType *base; //存储空间的基地址\n    int front;       //头指针\n    int rear;        //尾指针\n&#125; SqQueue;\n\n顺序分配的队列中头、尾指针和元素之间的关系：\n\n假设当前队列分配的最大空间为6，则当队列处于上图（d）所示的状态时不可再继续插入新的队尾元素，否则会出现溢出现象，即因数组越界而导致程序的非法操作错误。事实上，此时队列的实际可用空间并未占满，所以这种现象称为&#x3D;&#x3D;“假溢出”&#x3D;&#x3D;。这是由“队尾入队，队头出队”这种受限制的操作造成的。解决这种“假溢出”问题一个较巧妙的办法是将顺序队列变为一个环状的空间，如下图所示，称之为循环队列。\n头、尾指针以及队列元素之间的关系不变，只是在循环队列中，头、尾指针“依环状增1”的操作可用“模”运算来实现。通过取模,头指针和尾指针就可以在顺序表空间内以头尾衔接的方式“循环”移动。循环队列中队空和队满的条件是：\n队空的条件:Q.front &#x3D; &#x3D; Q.rear队满的条件:(Qrear + 1)%MAXQSIZE &#x3D; &#x3D; Q.front\n循环队列的初始化\n为队列分配一个最大容量为MAXSIZE的数组空间，base指向数组空间的首地址。头指针和尾指针置为零，表示队列为空。\nStatus InitQueue(SqQueue &amp;Q)\n&#123;\n    Q.base = new QElemType[MAXQSIZE];\n    if (!Q.base)\n        exit(OVERFLOW);\n    Q.front = Q.rear = 0;\n    return OK;\n&#125;\n\n求循环队列的长度\n对于非循环队列，尾指针和头指针的差值便是队列长度，而对于循环队列,差值可能为负数所以需要将差值加上MAXQSIZE，然后与MAXQSIZE求余。\nint QueueLength(SqQueue Q)\n&#123;\n    return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE\n&#125;\n\n循环队列的入队\n\n判断队列是否满，若满则返回ERROR。\n将新元素插入队尾。\n队尾指针加1。\n\nStatus EnQueue(SqQueue &amp;Q，QElemType e)\n&#123;\n    if ((Q.rear + 1) % MAXQSIZE == Q.front)\n        return ERROR; //队满\n    Q.base[Q.rear] = e;\n    Q.rear = (Q.rear + 1) % MAXQSIZE;\n    return OK;\n&#125;\n\n循环队列的出队\n\n判断队列是否为空，若空则返回ERROR。\n保存队头元素。\n队头指针加1。\n\nStatus DeQueue(LinkQueue &amp;Q，QElemType &amp;e)\n&#123;\n    if (Q.front == Q.rear)\n        return ERROR; //队空\n    e = Q.base[Q.front];\n    Q.front = (Q.front + 1) % MAXQSIZE;\n    return OK;\n&#125;\n\n取循环队列的队头元素\n当队列非空时，此操作返回当前队头元素的值，队头指针保持不变。\nSElemType GetHead(SqQueue Q)\n&#123;\n    if (Q.front != Q.rear)     //队列非空\n        return Q.base[Q.front] //返回队头元素的值，队头指针不变\n&#125;\n\n循环队列的实现：\n测试样例：QNode.txt测试内容：ABCD\n/***循环队列基本操作***/\n\n#include&lt;iostream&gt;\n#include&lt;fstream&gt;\nusing namespace std;\n\n#define MAXQSIZE 100\n#define OK 1\n#define ERROR 0\n#define OVERFLOW -2\ntypedef char QElemType;\ntypedef char SElemType;\ntypedef int Status;\n\ntypedef struct &#123;\n    QElemType *base;//初始化时动态分配存储空间\n    int front;//头指针\n    int rear;//尾指针\n&#125; SqQueue;\n\n//循环队列的初始化\nStatus InitQueue(SqQueue &amp;Q) &#123;//构造一个空队列Q\n    Q.base = new QElemType[MAXQSIZE]; //为队列分配一个最大容量为MAXSIZE的数组空间\n    if (!Q.base)\n        exit(OVERFLOW); //存储分配失败\n    Q.front = Q.rear = 0; //头指针和尾指针置为零，队列为空\n    return OK;\n&#125;\n\n//求循环队列的长度\nint QueueLength(SqQueue Q) &#123;//返回Q的元素个数，即队列的长度\n    return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;\n&#125;\n\n//循环队列的入队\nStatus EnQueue(SqQueue &amp;Q, QElemType e) &#123;//插入元素e为Q的新的队尾元素\n    if ((Q.rear + 1) % MAXQSIZE == Q.front) //尾指针在循环意义上加1后等于头指针，表明队满\n        return ERROR;\n    Q.base[Q.rear] = e; //新元素插入队尾\n    Q.rear = (Q.rear + 1) % MAXQSIZE; //队尾指针加1\n    return OK;\n&#125;\n\n//循环队列的出队\nStatus DeQueue(SqQueue &amp;Q, QElemType &amp;e) &#123;//删除Q的队头元素，用e返回其值\n    if (Q.front == Q.rear)\n        return ERROR; //队空\n    e = Q.base[Q.front]; //保存队头元素\n    Q.front = (Q.front + 1) % MAXQSIZE; //队头指针加1\n    return OK;\n&#125;\n\n//取循环队列的队头元素\nSElemType GetHead(SqQueue Q) &#123;//返回Q的队头元素，不修改队头指针\n    if (Q.front != Q.rear) //队列非空\n        return Q.base[Q.front]; //返回队头元素的值，队头指针不变\n&#125;\n\nint main() &#123;\n    int choose, flag = 0;\n    SqQueue Q;\n    QElemType e, j;\n    cout &lt;&lt; &quot;1.初始化\\n&quot;;\n    cout &lt;&lt; &quot;2.入队\\n&quot;;\n    cout &lt;&lt; &quot;3.读队头元素\\n&quot;;\n    cout &lt;&lt; &quot;4.出队\\n&quot;;\n    cout &lt;&lt; &quot;0.退出\\n\\n&quot;;\n\n    choose = -1;\n    while (choose != 0) &#123;\n        cout &lt;&lt; &quot;请选择:&quot;;\n        cin &gt;&gt; choose;\n        switch (choose) &#123;\n        case 1://链队的初始化\n            if (InitQueue(Q)) &#123;\n                flag = 1;\n                cout &lt;&lt; &quot;成功对队列进行初始化\\n\\n&quot;;\n            &#125; else\n                cout &lt;&lt; &quot;初始化队列失败\\n\\n&quot;;\n            break;\n        case 2: &#123;//链队的入队\n            fstream file;\n            file.open(&quot;QNode.txt&quot;);\n            if (!file) &#123;\n                cout &lt;&lt; &quot;错误！未找到文件！\\n\\n&quot; &lt;&lt; endl;\n                exit(ERROR);\n            &#125;\n            if (flag) &#123;\n                flag = 1;\n                cout &lt;&lt; &quot;入队的元素依次为：\\n&quot;;\n                while (!file.eof()) &#123;\n                    file &gt;&gt; j;\n                    if (file.fail())\n                        break;\n                    else &#123;\n                        EnQueue(Q, j);\n                        cout &lt;&lt; j &lt;&lt; &quot;  &quot;;\n                    &#125;\n                &#125;\n                cout &lt;&lt; endl &lt;&lt; endl;\n            &#125; else\n                cout &lt;&lt; &quot;队列未建立，请重新选择\\n\\n&quot;;\n            file.close();\n        &#125;\n            break;\n        case 3://取链队的队头元素\n            if (flag != -1 &amp;&amp; flag != 0)\n                cout &lt;&lt; &quot;队头元素为：\\n&quot; &lt;&lt; GetHead(Q) &lt;&lt; endl &lt;&lt; endl;\n            else\n                cout &lt;&lt; &quot;队列中无元素，请重新选择\\n&quot; &lt;&lt; endl;\n            break;\n        case 4://链队的出队\n            cout &lt;&lt; &quot;依次弹出的队头元素为:\\n&quot;;\n            while (DeQueue(Q, e)) &#123;\n                flag = -1;\n                cout &lt;&lt; e &lt;&lt; &quot;  &quot;;\n            &#125;\n            cout &lt;&lt; endl &lt;&lt; endl;\n            break;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n\n③.队列的链式表示和实现链队是指采用链式存储结构实现的队列。通常链队用单链表来表示，一个链队显然需要两个分别指示队头和队尾的指针(分别称为头指针和尾指针)才能唯一确定。这里和线性表的单链表一样，为了操作方便起见，给链队添加一个头结点，并令头指针始终指向头结点。\ntypedef struct Qnode\n&#123;\n    QElemType data;\n    struct Qnode *next;\n&#125; Qnode, *QueuePtr;\ntypedef struct\n&#123;\n    QueuePtr front; //队头指针\n    QueuePtr rear;  //队尾指针\n&#125; LinkQueue;\n\n链队的初始化\n\n生成新结点作为头结点，队头和队尾指针指向此结点。\n头结点的指针域置空。\n\nStatus InitQueue(LinkQueue &amp;Q)\n&#123;\n    Q.front = Q.rear = new QNode;\n    Q.front-&gt;next = NULL;\n    return OK;\n&#125;\n\n链队的入队\n\n为入队元素分配结点空间，用指针p指向。\n将新结点数据域置为e。\n将新结点插入到队尾。\n修改队尾指针为p。\n\nStatus EnQueue(LinkQueue &amp;Q, QElemType e)\n&#123;\n    p = new QNode;\n    if (!p)\n        exit(OVERFLOW);\n    p-&gt;data = e;\n    p-&gt;next = NULL;\n    Q.rear-&gt;next = p;\n    Q.rear = p;\n    return OK;\n&#125;\n\n链队的出队\n\n判断队列是否为空，若空则返回ERROR。\n临时保存队头元素的空间，以备释放。\n修改队头指针，指向下一个结点。\n判断出队元素是否为最后一个元素，若是，则将队尾指针重新赋值，指向头结点。\n释放原队头元素的空间。\n\nStatus DeQueue(LinkQueue &amp;Q，QElemType &amp;e)\n&#123;\n    if (Q.front == Q.rear)\n        return ERROR;        //若队列空，则返回ERROR\n    p = Q.front-&gt;next;       // p指向队头元素\n    e = p-&gt;data;             // e保存队头元素的值\n    Q.front-&gt;next = p-&gt;next; //修改头指针\n    if (Q.rear == p)\n        Q.rear = Q.front; //如果最后一个元素被删，则\n                          //队尾指针指向头结点\n    delete p;             //释放原队头元素的空间\n    return OK;\n&#125;\n\n取链队的队头元素\n与循环队列一样，当队列非空时，此操作返回当前队头元素的值，队头指针保持不变。\nSElemType GetHead(LinkQueue Q)\n&#123;\n    if (Q.front != Q.rear)\n        return Q.front-&gt;next-&gt;data; //返回队头元素的值，队头指针不变\n&#125;\n\n链队的实现：\n测试样例：QNode.txt测试内容：ABCD\n/***链队的基本操作***/\n\n#include&lt;iostream&gt;\n#include&lt;fstream&gt;\nusing namespace std;\n\n#define OK 1\n#define ERROR 0\n#define OVERFLOW -2\ntypedef char QElemType;\ntypedef int Status;\ntypedef char SElemType;\n\n//- - - - - 队列的链式存储结构- - - - - \ntypedef struct QNode &#123;\n    QElemType data;\n    struct QNode *next;\n&#125; QNode, *QueuePtr;\ntypedef struct &#123;\n    QueuePtr front; //队头指针\n    QueuePtr rear; //队尾指针\n&#125; LinkQueue;\n\n//链队的初始化\nStatus InitQueue(LinkQueue &amp;Q) &#123;//构造一个空队列Q\n    Q.front = Q.rear = new QNode; //生成新结点作为头结点，队头和队尾指针指向此结点\n    Q.front-&gt;next = NULL; //头结点的指针域置空\n    return OK;\n&#125;\n\n//链队的入队\nStatus EnQueue(LinkQueue &amp;Q, QElemType e) &#123;//插入元素e为Q的新的队尾元素\n    QueuePtr p;\n    p = new QNode; //为入队元素分配结点空间，用指针p指向\n    p-&gt;data = e; //将新结点数据域置为e\n    p-&gt;next = NULL;\n    Q.rear-&gt;next = p; //将新结点插入到队尾\n    Q.rear = p; //修改队尾指针\n    return OK;\n&#125;\n\n//链队的出队\nStatus DeQueue(LinkQueue &amp;Q, QElemType &amp;e) &#123;//删除Q的队头元素，用e返回其值 \n    QueuePtr p;\n    if (Q.front == Q.rear)\n        return ERROR; //若队列空，则返回ERROR\n    p = Q.front-&gt;next; //p指向队头元素\n    e = p-&gt;data; //e保存队头元素的值\n    Q.front-&gt;next = p-&gt;next; //修改头指针\n    if (Q.rear == p)\n        Q.rear = Q.front; //最后一个元素被删，队尾指针指向头结点\n    delete p; //释放原队头元素的空间\n    return OK;\n&#125;\n\n//取链队的队头元素\nSElemType GetHead(LinkQueue Q) &#123;//返回Q的队头元素，不修改队头指针\n    if (Q.front != Q.rear) //队列非空\n        return Q.front-&gt;next-&gt;data; //返回队头元素的值，队头指针不变\n&#125;\n\nint main() &#123;\n    int choose, flag = 0;\n    LinkQueue Q;\n    QElemType e, j;\n    cout &lt;&lt; &quot;1.初始化\\n&quot;;\n    cout &lt;&lt; &quot;2.入队\\n&quot;;\n    cout &lt;&lt; &quot;3.读队头元素\\n&quot;;\n    cout &lt;&lt; &quot;4.出队\\n&quot;;\n    cout &lt;&lt; &quot;0.退出\\n\\n&quot;;\n\n    choose = -1;\n    while (choose != 0) &#123;\n        cout &lt;&lt; &quot;请选择:&quot;;\n        cin &gt;&gt; choose;\n        switch (choose) &#123;\n        case 1://链队的初始化\n            if (InitQueue(Q)) &#123;\n                flag = 1;\n                cout &lt;&lt; &quot;成功对队列进行初始化\\n\\n&quot;;\n            &#125; else\n                cout &lt;&lt; &quot;初始化队列失败\\n\\n&quot;;\n            break;\n        case 2: &#123;//链队的入队\n            fstream file;\n            file.open(&quot;QNode.txt&quot;);\n            if (!file) &#123;\n                cout &lt;&lt; &quot;错误！未找到文件！\\n\\n&quot; &lt;&lt; endl;\n                exit(ERROR);\n            &#125;\n            if (flag) &#123;\n                flag = 1;\n                cout &lt;&lt; &quot;入队的元素依次为：\\n&quot;;\n                while (!file.eof()) &#123;\n                    file &gt;&gt; j;\n                    if (file.fail())\n                        break;\n                    else &#123;\n                        EnQueue(Q, j);\n                        cout &lt;&lt; j &lt;&lt; &quot;  &quot;;\n                    &#125;\n                &#125;\n                cout &lt;&lt; endl &lt;&lt; endl;\n            &#125; else\n                cout &lt;&lt; &quot;队列未建立，请重新选择\\n\\n&quot;;\n            file.close();\n        &#125;\n            break;\n        case 3://取链队的队头元素\n            if (flag != -1 &amp;&amp; flag != 0)\n                cout &lt;&lt; &quot;队头元素为：\\n&quot; &lt;&lt; GetHead(Q) &lt;&lt; endl &lt;&lt; endl;\n            else\n                cout &lt;&lt; &quot;队列中无元素，请重新选择\\n&quot; &lt;&lt; endl;\n            break;\n        case 4://链队的出队\n            cout &lt;&lt; &quot;依次弹出的队头元素为:\\n&quot;;\n            while (DeQueue(Q, e)) &#123;\n                flag = -1;\n                cout &lt;&lt; e &lt;&lt; &quot;  &quot;;\n            &#125;\n            cout &lt;&lt; endl &lt;&lt; endl;\n            break;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n\n\n4、栈和队列总结\n\n5、例题与应用\n\n编程实现栈的如下功能：（1）根据输入的栈中元素个数n和各元素值建立一个顺序栈，并输出栈中各元素值。（2）将数据元素e入栈，并输出入栈后的顺序栈中各元素值。（3）将顺序栈中的栈顶元素出栈，并输出出栈元素的值和出栈后顺序栈中各元素值。\n\n\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define OK 1\n#define ERROR 0\n#define MAXSIZE 100\ntypedef int Status;\ntypedef int SElemType;\n//顺序栈定义\ntypedef struct\n&#123;\n    SElemType *base;\n    SElemType *top;\n    int stacksize;\n&#125; SqStack;\n//顺序栈的初始化\nStatus InitStack(SqStack &amp;S)\n&#123;\n    S.base = new SElemType[MAXSIZE];\n    if (!S.base)\n        exit(OVERFLOW);\n    S.top = S.base;        //top初始为base，空栈\n    S.stacksize = MAXSIZE; //stacksize置为栈的最大容量MAXSIZE\n    return OK;\n&#125;\n//顺序栈的遍历\nStatus StackTraverse(SqStack S)\n&#123;\n    cout &lt;&lt; &quot;顺序栈中元素如下：\\n&quot;;\n    if (S.top == S.base)\n    &#123;\n        return false;\n    &#125;\n    while (S.top != S.base)\n    &#123;\n        cout &lt;&lt; *S.base++ &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n    return OK;\n&#125;\n//顺序栈的入栈\nStatus Push(SqStack &amp;S, SElemType e)\n&#123;\n    if (S.top - S.base == S.stacksize)\n        return ERROR;\n    *(S.top++) = e; //元素e压入栈顶，栈顶指针加1\n    return OK;\n&#125;\n//顺序栈的出栈\nStatus Pop(SqStack &amp;S, SElemType &amp;e)\n&#123;\n    if (S.base == S.top)\n        return ERROR;\n    e = *(--S.top); //栈顶指针减1，将栈顶元素赋给e\n    return OK;\n&#125;\nint main()\n&#123;\n    SqStack s;\n    int select, flag = 0, i, j, n, e, t;\n\n    cout &lt;&lt; &quot;1.初始化顺序栈\\n&quot;;\n    cout &lt;&lt; &quot;2.顺序栈的入栈\\n&quot;;\n    cout &lt;&lt; &quot;3.取出栈顶元素\\n&quot;;\n    cout &lt;&lt; &quot;4.顺序栈的出栈\\n&quot;;\n    cout &lt;&lt; &quot;0.退出\\n\\n&quot;;\n\n    while (1)\n    &#123;\n        cout &lt;&lt; &quot;\\n请选择:&quot;;\n        cin &gt;&gt; select;\n        switch (select)\n        &#123;\n        case 1:\n            if (InitStack(s))\n            &#123;\n                flag = 1;\n                cout &lt;&lt; &quot;初始化栈成功\\n\\n&quot;;\n            &#125;\n            else\n            &#123;\n                cout &lt;&lt; &quot;初始化栈失败\\n\\n&quot;;\n            &#125;\n            StackTraverse(s);\n            break;\n        case 2:\n            cout &lt;&lt; &quot;请输入元素个数：&quot;;\n            cin &gt;&gt; n;\n            cout &lt;&lt; &quot;请输入&quot; &lt;&lt; n &lt;&lt; &quot;个元素：&quot;;\n            for (j = 1; j &lt;= n; ++j)\n            &#123;\n                cin &gt;&gt; i;\n                if (Push(s, i))\n                &#123;\n                    flag = 1;\n                &#125;\n            &#125;\n            if (flag = 1)\n            &#123;\n                cout &lt;&lt; &quot;入栈操作成功！\\n\\n&quot;;\n            &#125;\n            StackTraverse(s);\n            break;\n        case 3:\n            cout &lt;&lt; &quot;取出的栈顶元素为：\\n&quot;;\n            if (Pop(s, t))\n            &#123;\n                cout &lt;&lt; t &lt;&lt; endl;\n            &#125;\n            StackTraverse(s);\n            break;\n        case 4:\n            cout &lt;&lt; &quot;依次弹出的栈顶元素为:\\n&quot;;\n            while (Pop(s, t))\n            &#123;\n                flag = -1;\n                cout &lt;&lt; t &lt;&lt; &quot;  &quot;;\n            &#125;\n            cout &lt;&lt; endl\n                 &lt;&lt; endl;\n            StackTraverse(s);\n            break;\n        case 0:\n            return 0;\n        default:\n            cout &lt;&lt; &quot;请重新输入！\\n\\n&quot;;\n            break;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n\n\n编程实现队列的如下功能：（1）根据输入的队列长度n和各元素值建立一个循环顺序表表示的队列（循环队列），并输出队列中各元素值。（2）将数据元素e入队，并输出入队后的队列中各元素值。（3）将循环队列的队首元素出队，并输出出队元素的值和出队后队列中各元素值\n\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define OK 1\n#define ERROR 0\n#define MAXQSIZE 100\ntypedef int QElemType;\ntypedef int SElemType;\ntypedef int Status;\n//顺序队列定义\ntypedef struct\n&#123;\n    QElemType *base;\n    int front;\n    int rear;\n&#125; SqQueue;\n//循环队列的初始化\nStatus InitQueue(SqQueue &amp;Q)\n&#123;\n    Q.base = new QElemType[MAXQSIZE];\n    if (!Q.base)\n        exit(OVERFLOW);\n    Q.front = Q.rear = 0; //头指针和尾指针置为零，队列为空\n    return OK;\n&#125;\n//顺序队列遍历队列\nStatus TarverseQueue(SqQueue Q)\n&#123;\n    int cur = Q.front;\n    cout &lt;&lt; &quot;顺序队列中元素如下：\\n&quot;;\n    while (cur != Q.rear)\n    &#123;\n        cout &lt;&lt; Q.base[cur] &lt;&lt; &quot; &quot;;\n        cur = (cur + 1) % MAXQSIZE; // 当前指针向后推移\n    &#125;\n    cout &lt;&lt; endl;\n    return OK;\n&#125;\n//求循环队列的长度\nint QueueLength(SqQueue Q)\n&#123;\n    return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;\n&#125;\n//循环队列的入队\nStatus EnQueue(SqQueue &amp;Q, QElemType e)\n&#123;\n    if ((Q.rear + 1) % MAXQSIZE == Q.front)\n        return ERROR;\n    Q.base[Q.rear] = e;               //新元素插入队尾\n    Q.rear = (Q.rear + 1) % MAXQSIZE; //队尾指针加1\n    return OK;\n&#125;\n//循环队列的出队\nStatus DeQueue(SqQueue &amp;Q, QElemType &amp;e)\n&#123;\n    if (Q.front == Q.rear)\n        return ERROR;\n    e = Q.base[Q.front];                //保存队头元素\n    Q.front = (Q.front + 1) % MAXQSIZE; //队头指针加1\n    return OK;\n&#125;\nint main()\n&#123;\n    SqQueue Q;\n    int select, flag = 0, i, n, j, e;\n    cout &lt;&lt; &quot;1.初始化顺序队列\\n&quot;;\n    cout &lt;&lt; &quot;2.顺序队列的入队\\n&quot;;\n    cout &lt;&lt; &quot;3.取出队头的元素\\n&quot;;\n    cout &lt;&lt; &quot;4.顺序队列的出队\\n&quot;;\n    cout &lt;&lt; &quot;0.退出\\n\\n&quot;;\n\n    while (1)\n    &#123;\n        cout &lt;&lt; &quot;\\n请选择:&quot;;\n        cin &gt;&gt; select;\n        switch (select)\n        &#123;\n        case 1: //链队的初始化\n            if (InitQueue(Q))\n            &#123;\n                flag = 1;\n                cout &lt;&lt; &quot;初始化对列成功\\n\\n&quot;;\n            &#125;\n            else\n                cout &lt;&lt; &quot;初始化队列失败\\n\\n&quot;;\n            TarverseQueue(Q);\n            break;\n        case 2:\n            cout &lt;&lt; &quot;请输入元素个数：&quot;;\n            cin &gt;&gt; n;\n            cout &lt;&lt; &quot;请输入&quot; &lt;&lt; n &lt;&lt; &quot;个元素：&quot;;\n            for (j = 1; j &lt;= n; j++)\n            &#123;\n                cin &gt;&gt; i;\n                if (EnQueue(Q, i))\n                &#123;\n                    flag = 1;\n                &#125;\n            &#125;\n            if (flag = 1)\n            &#123;\n                cout &lt;&lt; &quot;入队操作成功！\\n\\n&quot;;\n            &#125;\n            TarverseQueue(Q);\n            break;\n        case 3: //取出链队的队头元素\n            cout &lt;&lt; &quot;取出的队头元素为：\\n&quot;;\n            if (DeQueue(Q, e))\n            &#123;\n                cout &lt;&lt; e &lt;&lt; endl;\n            &#125;\n            TarverseQueue(Q);\n            break;\n        case 4: //链队的出队\n            cout &lt;&lt; &quot;依次弹出的队头元素为:\\n&quot;;\n            while (DeQueue(Q, e))\n            &#123;\n                flag = -1;\n                cout &lt;&lt; e &lt;&lt; &quot;  &quot;;\n            &#125;\n            cout &lt;&lt; endl\n                 &lt;&lt; endl;\n            TarverseQueue(Q);\n            break;\n        case 0:\n            return 0;\n        default:\n            cout &lt;&lt; &quot;请重新输入！\\n\\n&quot;;\n            break;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n\n","slug":"数据结构（C语言版）-- 栈和队列笔记","date":"2022-02-13T02:39:25.000Z","categories_index":"前端","tags_index":"字节跳动青训营","author_index":"会思想的苇草i"},{"id":"b96df039eaa03d2a5634c2cc83e5cad0","title":"线性表","content":"\n1、线性表的定义与特点线性结构特性：\n若结构是非空有限集，除第一个数据元素无直接前驱，最后一个数据元素无直接后继之外，其他每个数据元素都有一个直接前趋和一个直接后继。\n典型线性结构：\n线性表、堆栈、队列、字符串、数组等等。\n线性表：\n数据元素虽然不同，但同一线性表中的元素必定具有相同的特性，即属于同一数据对象，相邻数据元素之间存在着序偶关系。诸如此类由n (n≥0)个数据特性相同的元素构成的有限序列称为线性表。线性表中元素的个数n (n≥0)定义为线性表的长度，n &#x3D;0时称为空表。\n对于非空的线性表或线性结构，其特点是:\n\n存在唯一的一个被称作“第一个”的数据元素;\n存在唯一的一个被称作“最后一个”的数据元素;\n除第一个之外，结构中的每个数据元素均只有一个前驱;\n除最后一个之外，结构中的每个数据元素均只有一个后继。\n\n\n2、线性表的类型定义线性表的抽象数据类型定义：\n\n\n3、线性表的顺序实现和表示①.线性表的顺序存储表示线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素，这种表示也称作线性表的顺序存储结构或顺序映像。通常，称这种存储结构的线性表为**顺序表(Sequent ialList)**。其特点是：逻辑上相邻的数据元素，其物理次序也是相邻的。\n如果线性表的每个元素需占用L个存储单元：\n\nLOC(ai)表示ai的存储地址\nLOC(a1)表示a1的存储地址，称为线性表的起始位置或基地址\nLOC(ai+1) &#x3D; LOC(ai)+L \nLOC(ai) &#x3D; LOC(a1)+(i-1)*L\n\n确定了存储线性表的起始位置，线性表中任一数据元素都可随机存取。&#x3D;&#x3D;线性表的顺序存储结构是一种随机存取的存储结构。&#x3D;&#x3D;\n\n//顺序表的存储结构\n#define MAXSIZE 100  //顺序表最大长度 \ntypedef struct\n&#123;\n    ElemType *elem;  //存储空间的基地址 \n    int Length;\t\t //当前长度 \n &#125; SqList;           //顺序表的结构类型为 SqList\n\n②.顺序表中基本操作的实现顺序表的初始化\n\n为顺序表L动态分配一个预定义大小的数组空间，使elem指向这段空间的基地址。\n将表的当前长度设为0。\n\nStatus InitList(SqList &amp;L)         //构造一个空的顺序表L\n&#123;\n    L.elem=new ElemType[MAXSIZE];  //为顺序表分配空间\n    if(!L.elem) exit(OVERFLOW);    //存储分配失败\n    L.length=0;\t\t\t\t       //空表长度为0\n    return OK;\n&#125;\n\n顺序表的取值\n\n判断指定的位置序号i值是否合理( 1≤i≤L.length )，若不合理，则返回ERROR。\n若i值合理，则将第i个数据元素L.elem[i-1]赋给参数e，通过e返回第i个数据元素的传值。\n\nStatus GetElem(SqList L,int i,ElemType &amp;e)\n&#123;\n    if(i&lt;1||i&gt;L.length)\n        return ERROR;\n    e = L.elme[i-1];\n    return OK;\n&#125;\n\n顺序表的查找\n\n从第一个元素起，依次和e相比较，若找到与e相等的元素L.elem[i]，则查找成功，返回该元素的序号i+1。\n若查遍整个顺序表都没有找到，则查找失败,返回0。\n\n\nint LocateElem(SqList L,ElemType e)\n&#123;        \n    for (i=0;i&lt; L.length;i++)  //i为下标序号\n        if (L.elem[i]==e) \n            return i+1;  //查找成功，返回序号i+1                \n    return 0;  //查找失败，返回0\n&#125;\n\n在查找时，为确定元素在顺序表中的位置，需和给定值进行比较的数据元素个数的期望值称为查找算法在查找成功时的平均查找长度(Average Search L ength, ASL)。\n顺序表的插入\n\n判断插入位置i是否合法（ i值的合法范围是1≤i≤n+1)，若不合法则返回ERROR。\n判断顺序表的存储空间是否已满,若满则返回ERROR。\n将第n个至第i个位置的元素依次向后移动一个位置，空出第i个位置(i&#x3D;n+1时无需移动）\n将要插入的新元素e放入第i个位置。\n表长加1。\n\n\n\nStatus ListInsert(SqList &amp;L，int i，ElemType e)\n&#123;\n    if (i &lt; 1 || i &gt; L.length + 1)\n        return ERROR;\n    if (L.length == MAXSIZE)\n        return ERROR;\n    for (j = L.length - 1; j &gt;= i - 1; j--)\n        L.elem[j + 1] = L.elem[j];\n    L.elem[i - 1] = e;\n    ++L.length;\n    return OK;\n&#125;\n\n\n顺序表的删除\n\n判断删除位置i是否合法(合法值为1≤i≤n),若不合法则返回ERROR。\n将第i+1个至第n个的元素依次向前移动一个位置( i&#x3D;n时无需移动)。\n表长减1。\n\n\nStatus ListDelete(SqList &amp;L, int i)\n&#123;\n    if (i &lt; 1 || i &gt; L.length)\n        return ERROR;\n    for (j = i; j &lt;= L.length - 1; j++)\n        L.elem[j - 1] = L.elem[j];\n    --L.length;\n    return OK;\n&#125;\n\n\n③.顺序表的顺序表示和实现实例测试样例：book.txt\n\n#include&lt;iostream&gt;\n#include&lt;fstream&gt;\n#include&lt;string&gt;\n#include&lt;iomanip&gt;\nusing namespace std;\n#define OK 1\n#define ERROR 0\n#define OVERFLOW -2\ntypedef int Status; //Status 是函数返回值类型，其值是函数结果状态代码。\ntypedef int ElemType; //ElemType 为可定义的数据类型，此设为int类型\n\n#define MAXSIZE 100\t\t\t//顺序表可能达到的最大长度\nstruct Book &#123;\n    string id;//ISBN\n    string name;//书名\n    double price;//定价\n&#125;;\ntypedef struct &#123;\n    Book *elem; //存储空间的基地址\n    int length; //当前长度\n&#125; SqList;\n\nStatus InitList_Sq(SqList &amp;L) &#123; //顺序表的初始化\n    //构造一个空的顺序表L\n    L.elem = new Book[MAXSIZE]; //为顺序表分配一个大小为MAXSIZE的数组空间\n    if (!L.elem)\n        exit(OVERFLOW); //存储分配失败退出\n    L.length = 0; //空表长度为0\n    return OK;\n&#125;\n\nStatus GetElem(SqList L, int i, Book &amp;e) &#123;//顺序表的取值\n    if (i &lt; 1 || i &gt; L.length)\n        return ERROR; //判断i值是否合理，若不合理，返回ERROR\n    e = L.elem[i - 1]; //elem[i-1]单元存储第i个数据元素\n    return OK;\n&#125;\n\nint LocateElem_Sq(SqList L, double e) &#123; //顺序表的查找\n    //顺序表的查找\n    for (int i = 0; i &lt; L.length; i++)\n        if (L.elem[i].price == e)\n            return i + 1;//查找成功，返回序号i+1\n    return 0;//查找失败，返回0\n&#125;\n\nStatus ListInsert_Sq(SqList &amp;L, int i, Book e) &#123; //顺序表的插入\n    //在顺序表L中第i个位置之前插入新的元素e\n    //i值的合法范围是1&lt;=i&lt;=L.length+1\n    if ((i &lt; 1) || (i &gt; L.length + 1))\n        return ERROR; //i值不合法\n    if (L.length == MAXSIZE)\n        return ERROR; //当前存储空间已满\n    for (int j = L.length - 1; j &gt;= i - 1; j--)\n        L.elem[j + 1] = L.elem[j]; //插入位置及之后的元素后移\n    L.elem[i - 1] = e; //将新元素e放入第i个位置\n    ++L.length; //表长增1\n    return OK;\n&#125;\n\nStatus ListDelete_Sq(SqList &amp;L, int i) &#123; //顺序表的删除\n    //在顺序表L中删除第i个元素，并用e返回其值\n    //i值的合法范围是1&lt;=i&lt;=L.length\n    if ((i &lt; 1) || (i &gt; L.length))\n        return ERROR; //i值不合法\n    for (int j = i; j &lt;= L.length; j++)\n        L.elem[j - 1] = L.elem[j]; //被删除元素之后的元素前移\n    --L.length; //表长减1\n    return OK;\n&#125;\n\nint main() &#123;\n    SqList L;\n    int i = 0, temp, a, c, choose;\n    double price;\n    Book e;\n    string head_1, head_2, head_3;\n    cout &lt;&lt; &quot;1. 建立\\n&quot;;\n    cout &lt;&lt; &quot;2. 输入\\n&quot;;\n    cout &lt;&lt; &quot;3. 取值\\n&quot;;\n    cout &lt;&lt; &quot;4. 查找\\n&quot;;\n    cout &lt;&lt; &quot;5. 插入\\n&quot;;\n    cout &lt;&lt; &quot;6. 删除\\n&quot;;\n    cout &lt;&lt; &quot;7. 输出\\n&quot;;\n    cout &lt;&lt; &quot;0. 退出\\n\\n&quot;;\n\n    choose = -1;\n    while (choose != 0) &#123;\n        cout &lt;&lt; &quot;请选择:&quot;;\n        cin &gt;&gt; choose;\n        switch (choose) &#123;\n        case 1://创建顺序表\n            if (InitList_Sq(L))\n                cout &lt;&lt; &quot;成功建立顺序表\\n\\n&quot;;\n            else\n                cout &lt;&lt; &quot;顺序表建立失败\\n\\n&quot;;\n            break;\n        case 2: &#123;//顺序表信息输入\n            i = 0;\n            L.elem = new Book[MAXSIZE];\n            if (!L.elem)\n                exit(OVERFLOW);\n            L.length = 0;\n            fstream file;\n            file.open(&quot;book.txt&quot;);\n            if (!file) &#123;\n                cout &lt;&lt; &quot;错误！未找到文件！&quot; &lt;&lt; endl;\n                exit(ERROR);\n            &#125;\n            file &gt;&gt; head_1 &gt;&gt; head_2 &gt;&gt; head_3;\n            while (!file.eof()) &#123;\n                file &gt;&gt; L.elem[i].id &gt;&gt; L.elem[i].name &gt;&gt; L.elem[i].price;\n                i++;\n            &#125;\n            cout &lt;&lt; &quot;输入 book.txt 信息完毕\\n\\n&quot;;\n            L.length = i;\n            file.close();\n        &#125;\n            break;\n        case 3://顺序表的取值\n            cout &lt;&lt; &quot;请输入一个位置用来取值：\\n&quot;;\n            cin &gt;&gt; i;\n            temp = GetElem(L, i, e);\n            if (temp != 0) &#123;\n                cout &lt;&lt; &quot;查找成功\\n&quot;;\n                cout &lt;&lt; &quot;第&quot; &lt;&lt; i &lt;&lt; &quot;本图书的信息是：\\n&quot;;\n                cout &lt;&lt; left &lt;&lt; setw(15) &lt;&lt; e.id &lt;&lt; &quot;\\t&quot; &lt;&lt; left &lt;&lt; setw(50)\n                        &lt;&lt; e.name &lt;&lt; &quot;\\t&quot; &lt;&lt; left &lt;&lt; setw(5) &lt;&lt; e.price &lt;&lt; endl\n                        &lt;&lt; endl;\n            &#125; else\n                cout &lt;&lt; &quot;查找失败！位置超出范围\\n\\n&quot;;\n            break;\n        case 4: //顺序表的查找\n            cout &lt;&lt; &quot;请输入所要查找价格:&quot;;\n            cin &gt;&gt; price;\n            temp = LocateElem_Sq(L, price);\n            if (temp != 0) &#123;\n                cout &lt;&lt; &quot;查找成功\\n&quot;;\n                cout &lt;&lt; &quot;该价格对应的书名为：&quot; &lt;&lt; L.elem[temp - 1].name &lt;&lt; endl &lt;&lt; endl;\n            &#125; else\n                cout &lt;&lt; &quot;查找失败！没有这个价格对应的书籍\\n\\n&quot;;\n            break;\n        case 5: //顺序表的插入\n            cout &lt;&lt; &quot;请输入插入的位置和书本信息，包括：编号 书名 价格（用空格隔开）:&quot;;\n            cin &gt;&gt; a;\n            cin &gt;&gt; e.id &gt;&gt; e.name &gt;&gt; e.price; //输入a和b，a代表插入的位置，b代表插入的数值（书本信息）\n            if (ListInsert_Sq(L, a, e))\n                cout &lt;&lt; &quot;插入成功.\\n\\n&quot;;\n            else\n                cout &lt;&lt; &quot;插入失败.\\n\\n&quot;;\n            break;\n        case 6: //顺序表的删除\n            cout &lt;&lt; &quot;请输入所要删除的书籍的位置:&quot;;\n            cin &gt;&gt; c;\n            if (ListDelete_Sq(L, c))\n                cout &lt;&lt; &quot;删除成功.\\n\\n&quot;;\n            else\n                cout &lt;&lt; &quot;删除失败.\\n\\n&quot;;\n            break;\n        case 7: //顺序表的输出\n            cout &lt;&lt; &quot;当前图书系统信息（顺序表）读出:\\n&quot;;\n            for (i = 0; i &lt; L.length; i++)\n                cout &lt;&lt; left &lt;&lt; setw(15) &lt;&lt; L.elem[i].id &lt;&lt; &quot;\\t&quot; &lt;&lt; left\n                        &lt;&lt; setw(50) &lt;&lt; L.elem[i].name &lt;&lt; &quot;\\t&quot; &lt;&lt; left\n                        &lt;&lt; setw(5) &lt;&lt; L.elem[i].price &lt;&lt; endl;\n            cout &lt;&lt; endl;\n            break;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n\n\n4、线性表的链式表示和实现①.单链表的定义和表示线性表链式存储结构的特点：\n用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。\n结点:\n数据元素的存储映像。由&#x3D;&#x3D;数据域&#x3D;&#x3D;和&#x3D;&#x3D;指针域&#x3D;&#x3D;两部分组成。\n数据域:\n存储数据元素信息。\n指针域:\n存储反映元素关系的存储位置，称作指针或链。\n头指针:\n指向第一个结点的指针。\n链表:\nn个结点由指针链组成一个链表。称为线性表的链式存储结构。\n结点只有一个指针域的链表，称为单链表或线性链。最后一个结点的指针域为空，逻辑上相邻的元素在物理上不一定相邻，链表链接的顺序和数据元素的逻辑顺序一致，结点的物理位置可任意安排，不能出现“断链”现象。\n\n\n//单链表的存储结构\ntypedef struct LNode\n&#123;\n    ElemType data;      //结点的数据域\n    sturct LNode *next; //结点的指针域\n&#125; LNode, *LinkList;     // LinkList为指向结构体LNode的指针类型\n\n头指针、头结点和首元结点\n\n问：头结点的作用？\n答：便于首元结点的处理；便于空表和非空表的统一处理（无头结点：L&#x3D;&#x3D;NULL;有头结点：L-&gt;next&#x3D;NULL）\n问：头结点的数据域内装的是什么？\n答：头结点的数据域可以为空，也可以存放线性表长度等附加信息，但此结点不能计入链表长度值。\n②.单链表基本操作的实现单链表的初始化\n\n生成新结点作为头结点，用头指针L指向头结点。 \n头结点的指针域置空。\n\nStatus InitList_L(LinkList &amp;L)\n&#123;                   //构造一个空的单链表L\n    L = new LNode;  //生成新结点作为头结点，用头指针L指向头结点\n    L-&gt;next = NULL; //头结点的指针域置空\n    return OK;\n&#125;\n\n单链表的取值\n\n用指针p指向首元结点,用j做计数器初值赋为1。\n\n从首元结点开始依次顺着链域next向下访问，只要指向当前结点的指针 p 不为空(NULL)，并且没有到达序号为i的结点，则循环执行以下操作:\n\np指向下一个结点。\n计数器j相应加1。\n\n\n退出循环时，如果指针p为空，或者计数器j大于i，说明指定的序号i值不合法(i大于表长n或i小于等于0)，取值失败返回ERROR;否则取值成功，此时j&#x3D;i时，p所指的结点就是要找的第i个结点，用参数e保存当前结点的数据域，返回OK。\n\n\nStatus GetElem(LinkList L, int i, ElemType &amp;e)\n&#123;\n    p = L-&gt;next;\n    j = 1;\n    while（p &amp;&amp;j &lt; i）\n    &#123;\n        p = p-&gt;next;\n        ++j;\n    &#125;\n    if（ !p || j &gt; i） \n        return ERROR；\n    e = p-&gt;data;\n    return OK;\n&#125;\n\n单链表的按值查找\n\n用指针p指向首元结点。\n从首元结点开始依次顺着链域next向下查找，只要指向当前结点的指针p不为空，并且p所指结点的数据域不等于给定值e，则循环执行以下操作:p指向下一个结点。\n返回p。若查找成功，p此时即为结点的地址值，若查找失败，p的值即为NULL。\n\nLNode *LocateElem(LinkList L, Elemtype e)\n&#123;\n    p = L-&gt;next;\n    while (p &amp;&amp; p-&gt;next != e)\n        p = p-&gt;next;\n    return p;\n&#125;\n\n单链表的插入\n\n查找结点ai-1并由指针p指向该结点。\n生成一个新结点*s。\n将新结点*s的数据域置为e。\n将新结点*s 的指针域指向结点ai。（s-&gt;next &#x3D; p-&gt;next）\n将结点p的指针域指向新结点s。（p-&gt;next &#x3D; s）\n\n（&#x3D;&#x3D;步骤4、5不能互换，若掉换顺序，后结点丢失，找不到结点并造成内存泄露&#x3D;&#x3D;）\n\nStatus ListInsert(LinkList &amp;L, int i, ElemType &amp;e)\n&#123; //在带头结点的单链表L中第i个位置之前插入元素e\n    p = L;\n    j = 0;\n    while (p &amp;&amp; j &lt; i - 1)\n    &#123;\n        p = p-&gt;next;\n        ++j;\n    &#125;\n    if (!p || j &gt; i - 1)\n        return ERROR;\n    s = new LNode;\n    s-&gt;data = e;\n    s-&gt;next = p-&gt;next;\n    p-&gt;next = s;\n    return OK;\n&#125;\n\n单链表的删除\n\n查找结点ai-1并由指针p指向该结点。\n临时保存待删除结点ai的地址在q中，以备释放。\n将结点*p的指针域指向ai的直接后继结点。\n释放结点ai的空间。\n\n\nStatus ListDelete（LinkList &amp;L, int i）\n&#123; //在带头结点的单链表 L 中，删除第 i 个元素\n    p = L;\n    j = 0;\n    while ((p-&gt;next) &amp;&amp; (j &lt; i - 1))\n          \n        &#123;\n            p = p-&gt;next;\n            ++j;\n        &#125;\n    if (!(p-&gt;next) || (j &gt; i - 1))\n         return ERROR;\n    q = p-&gt;next;\n    p-&gt;next = q-&gt;next;\n    delete q;\n    return OK;\n     \n&#125;\n\n前插法单链表\n前插法是通过将新结点逐个插入链表的头部(头结点之后)来创建链表，每次申请一个新结点，读入相应的数据元素值，然后将新结点插入到头结点之后。\n\n\n创建一个只有头结点的空链表。\n根据待创建链表包括的元素个数n，循环n次执行以下操作: - 生成一个新结点p;- 输人元素值赋给新结点p 的数据域;- 将新结点*p插人到头结点之后。\n\nvoid CreateList_H(LinkList &amp;L, int n)\n&#123; //逆位序输入 n 个元素的值，建立带表头结点的单链表 L\n    L = new LNode;\n    L-&gt;next = NULL;\n    for (i = 0; i &lt; n; ++i)\n    &#123;\n        p = new LNode;\n        cin &gt;&gt; p-&gt;data;\n        p-&gt;next = L-&gt;next;\n        L-&gt;next = p;\n    &#125;\n&#125;\n\n尾插法单链表\n尾插法是通过将新结点逐个插入到链表的尾部来创建链表。同前插法样，每次申请一个新结点，读入相应的数据元素值。不同的是，为了使新结点能够插入到表尾，需要增加一个尾指针r指向链表的尾结点。\n\n\n创建一个只有头结点的空链表。\n尾指针r初始化，指向头结点。\n根据创建链表包括的元素个数n,循环n次执行以下操作:- 生成一个新结点p;- 输人元素值赋给新结点p的数据域;- 将新结点p插入到尾结点r之后;- 尾指针r指向新的尾结点*p。\n\nvoid CreateList_L(LinkList &amp;L, int n)\n&#123; //正位序输入n个元素的值，建立带表头结点的单链表L\n    L = new LNode;\n    L-&gt;next = NULL;\n    r = L;\n    for (i = 0; i &lt; n; ++i)\n    &#123;\n        p = new LNode;\n        cin &gt;&gt; p-&gt;data;\n        p-&gt;next = NULL;\n        r-&gt;next = p;\n        r = p;\n    &#125;\n&#125;\n\n循环列表\n表中最后一个结点的指针域指向头结点，整个链表形成一个环。\n\n循环列表的任何一个位置可以找到其他所有结点。\n循环列表的合并\n双向链表\n结点有两个指针域的链表，称为双向链表。\ntypedef struct DuLNode\n&#123;\n    ElemType data;\n    struct DuLNode *prior;\n    struct DuLNode *next;\n&#125; DuLNode, *DuLinkList\n\n双向链表的插入\n\nStatus ListInsert_DuL(DuLinkList &amp;L, int i, ElemType e)\n&#123;\n    if (!(p = GetElem_Dul(L, i)))\n        return ERROR;\n    s = new DuLNode;\n    s-&gt;date = e;\n    s-&gt;prior = p-&gt;prior;\n    p-&gt;prior-&gt;next = s;\n    s-&gt;next = p;\n    p-&gt;prior = s;\n    return OK;\n&#125;\n\n双向链表的删除\n\nStatus ListInsert_DuL(DuLinkList &amp;L, int i)\n&#123;\n    if (!(p = GetElem_Dul(L, i)))\n        return ERROR;\n    p-&gt;prior-&gt;next = p-&gt;next;\n    p-&gt;next-&gt;prior = p-&gt;prior;\n    delete p;\n    return OK;\n&#125;\n\n③.单链表的顺序表示和实现实例测试样例：book.txt\n\n#include&lt;iostream&gt;\n#include&lt;string&gt;\n#include&lt;iomanip&gt;\n#include&lt;fstream&gt;\nusing namespace std;\n\n#define OK 1\n#define ERROR 0\n#define OVERFLOW -2\ntypedef int Status; //Status 是函数返回值类型，其值是函数结果状态代码。\ntypedef int ElemType; //ElemType 为可定义的数据类型，此设为int类型\n\nstruct Book &#123;\n    string id;//ISBN\n    string name;//书名\n    double price;//定价\n&#125;;\ntypedef struct LNode &#123;\n    Book data; //结点的数据域\n    struct LNode *next; //结点的指针域\n&#125; LNode, *LinkList; //LinkList为指向结构体LNode的指针类型\n\nstring head_1, head_2, head_3;\nint length;\n\nStatus InitList_L(LinkList &amp;L) &#123; //单链表的初始化\n    //构造一个空的单链表L\n    L = new LNode; //生成新结点作为头结点，用头指针L指向头结点\n    L-&gt;next = NULL; //头结点的指针域置空\n    return OK;\n&#125;\n\nStatus GetElem_L(LinkList L, int i, Book &amp;e) &#123; //单链表的取值\n    //在带头结点的单链表L中查找第i个元素\n    //用e返回L中第i个数据元素的值\n    int j;\n    LinkList p;\n    p = L-&gt;next;\n    j = 1; //初始化，p指向第一个结点，j为计数器\n    while (j &lt; i &amp;&amp; p) &#123; //顺链域向后扫描，直到p指向第i个元素或p为空\n        p = p-&gt;next; //p指向下一个结点\n        ++j; //计数器j相应加1\n    &#125;\n    if (!p || j &gt; i)\n        return ERROR; //i值不合法i＞n或i&lt;=0\n    e = p-&gt;data; //取第i个结点的数据域\n    return OK;\n&#125; //GetElem_L\n\nLNode *LocateElem_L(LinkList L, int e) &#123; //按值查找\n    //在带头结点的单链表L中查找值为e的元素\n    LinkList p;\n    p = L-&gt;next;\n    while (p &amp;&amp; p-&gt;data.price != e)//顺链域向后扫描，直到p为空或p所指结点的数据域等于e\n        p = p-&gt;next; //p指向下一个结点\n    return p; //查找成功返回值为e的结点地址p，查找失败p为NULL \n&#125; //LocateElem_L\n\nStatus ListInsert_L(LinkList &amp;L, int i, Book &amp;e) &#123; //单链表的插入\n    //在带头结点的单链表L中第i个位置插入值为e的新结点\n    int j;\n    LinkList p, s;\n    p = L;\n    j = 0;\n    while (p &amp;&amp; j &lt; i - 1) &#123;\n        p = p-&gt;next;\n        ++j;\n    &#125;//查找第i?1个结点，p指向该结点\n    if (!p || j &gt; i - 1)\n        return ERROR; //i＞n+1或者i＜1\n    s = new LNode; //生成新结点*s \n    s-&gt;data = e; //将结点*s的数据域置为e\n    s-&gt;next = p-&gt;next; //将结点*s的指针域指向结点ai\n    p-&gt;next = s; //将结点*p的指针域指向结点*s\n    ++length;\n    return OK;\n&#125; //ListInsert_L\n\nStatus ListDelete_L(LinkList &amp;L, int i) &#123; //单链表的删除\n    //在带头结点的单链表L中，删除第i个位置\t\n    LinkList p, q;\n    int j;\n    p = L;\n    j = 0;\n    while ((p-&gt;next) &amp;&amp; (j &lt; i - 1)) //查找结点，p指向该结点\n    &#123;\n        p = p-&gt;next;\n        ++j;\n    &#125;\n    if (!(p-&gt;next) || (j &gt; i - 1))\n        return ERROR; //当i&gt;n或i&lt;1时，删除位置不合理 \n    q = p-&gt;next; //临时保存被删结点的地址以备释放 \n    p-&gt;next = q-&gt;next; //改变删除结点前驱结点的指针域 \n    delete q; //释放删除结点的空间 \n    --length;\n    return OK;\n&#125; //ListDelete_L\n\nvoid CreateList_H(LinkList &amp;L, int n) &#123; //前插法创建单链表\n    //逆位序输入n个元素的值，建立到头结点的单链表L\n    LinkList p;\n    L = new LNode;\n    L-&gt;next = NULL; //先建立一个带头结点的空链表\n    length = 0;\n    fstream file;\n    file.open(&quot;book.txt&quot;);\n    if (!file) &#123;\n        cout &lt;&lt; &quot;未找到相关文件，无法打开！&quot; &lt;&lt; endl;\n        exit(ERROR);\n    &#125;\n    file &gt;&gt; head_1 &gt;&gt; head_2 &gt;&gt; head_3;\n    while (!file.eof()) &#123;\n        p = new LNode; //生成新结点*p\n        file &gt;&gt; p-&gt;data.id &gt;&gt; p-&gt;data.name &gt;&gt; p-&gt;data.price; //输入元素值赋给新结点*p的数据域\n        p-&gt;next = L-&gt;next;\n        L-&gt;next = p; //将新结点*p插入到头结点之后\n        length++;//同时对链表长度进行统计\n    &#125;\n    file.close();\n&#125; //CreateList_F\n\nvoid CreateList_R(LinkList &amp;L, int n) &#123; //后插法创建单链表\n    //正位序输入n个元素的值，建立带表头结点的单链表L \n    LinkList p, r;\n    L = new LNode;\n    L-&gt;next = NULL; //先建立一个带头结点的空链表\n    r = L; //尾指针r指向头结点\n    length = 0;\n    fstream file; //打开文件进行读写操作\n    file.open(&quot;book.txt&quot;);\n    if (!file) &#123;\n        cout &lt;&lt; &quot;未找到相关文件，无法打开！&quot; &lt;&lt; endl;\n        exit(ERROR);\n    &#125;\n    file &gt;&gt; head_1 &gt;&gt; head_2 &gt;&gt; head_3;\n    while (!file.eof()) &#123; //将文件中的信息运用后插法插入到链表中\n        p = new LNode;//生成新结点\n        file &gt;&gt; p-&gt;data.id &gt;&gt; p-&gt;data.name &gt;&gt; p-&gt;data.price;//输入元素值赋给新结点*p的数据域\n        p-&gt;next = NULL;\n        r-&gt;next = p;//将新结点*p插入尾结点*r之后 \t\t\n        r = p;//r指向新的尾结点*p\n        length++; //同时对链表长度进行统计\n    &#125;\n    file.close();\n&#125; //CreateList_L\n\nint main() &#123;\n    int a, n, choose;\n    double price;\n    Book e;\n    LinkList L, p;\n    cout &lt;&lt; &quot;1. 建立\\n&quot;;\n    cout &lt;&lt; &quot;2. 输入\\n&quot;;\n    cout &lt;&lt; &quot;3. 取值\\n&quot;;\n    cout &lt;&lt; &quot;4. 查找\\n&quot;;\n    cout &lt;&lt; &quot;5. 插入\\n&quot;;\n    cout &lt;&lt; &quot;6. 删除\\n&quot;;\n    cout &lt;&lt; &quot;7. 输出\\n&quot;;\n    cout &lt;&lt; &quot;0. 退出\\n\\n&quot;;\n\n    choose = -1;\n    while (choose != 0) &#123;\n        cout &lt;&lt; &quot;请选择:&quot;;\n        cin &gt;&gt; choose;\n        switch (choose) &#123;\n        case 1: //建立一个单链表\n            if (InitList_L(L))\n                cout &lt;&lt; &quot;成功建立链表!\\n\\n&quot;;\n            break;\n        case 2: //使用后插法创建单链表\n            CreateList_R(L, length);\n            cout &lt;&lt; &quot;输入 book.txt 信息完毕\\n\\n&quot;;\n            break;\n        case 3: //单链表的按序号取值\n            cout &lt;&lt; &quot;请输入一个位置用来取值:&quot;;\n            cin &gt;&gt; a;\n            if (GetElem_L(L, a, e)) &#123;\n                cout &lt;&lt; &quot;查找成功\\n&quot;;\n                cout &lt;&lt; &quot;第&quot; &lt;&lt; a &lt;&lt; &quot;本图书的信息是：\\n&quot;;\n                cout &lt;&lt; left &lt;&lt; setw(15) &lt;&lt; e.id &lt;&lt; &quot;\\t&quot; &lt;&lt; left &lt;&lt; setw(50)\n                        &lt;&lt; e.name &lt;&lt; &quot;\\t&quot; &lt;&lt; left &lt;&lt; setw(5) &lt;&lt; e.price &lt;&lt; endl\n                        &lt;&lt; endl;\n            &#125; else\n                cout &lt;&lt; &quot;查找失败\\n\\n&quot;;\n            break;\n        case 4: //单链表的按值查找\n            cout &lt;&lt; &quot;请输入所要查找价格:&quot;;\n            cin &gt;&gt; price;\n            if (LocateElem_L(L, price) != NULL) &#123;\n                cout &lt;&lt; &quot;查找成功\\n&quot;;\n                cout &lt;&lt; &quot;该价格对应的书名为：&quot; &lt;&lt; LocateElem_L(L, price)-&gt;data.name\n                        &lt;&lt; endl &lt;&lt; endl;\n            &#125; else\n                cout &lt;&lt; &quot;查找失败! 定价&quot; &lt;&lt; price &lt;&lt; &quot; 没有找到\\n\\n&quot;;\n            break;\n        case 5: //单链表的插入\n            cout &lt;&lt; &quot;请输入插入的位置和书的信息，包括：编号 书名 价格（用空格隔开）:&quot;;\n            cin &gt;&gt; a;\n            cin &gt;&gt; e.id &gt;&gt; e.name &gt;&gt; e.price;\n            if (ListInsert_L(L, a, e))\n                cout &lt;&lt; &quot;插入成功.\\n\\n&quot;;\n            else\n                cout &lt;&lt; &quot;插入失败!\\n\\n&quot;;\n            break;\n        case 6: //单链表的删除\n            cout &lt;&lt; &quot;请输入所要删除的书籍的位置:&quot;;\n            cin &gt;&gt; a;\n            if (ListDelete_L(L, a))\n                cout &lt;&lt; &quot;删除成功!\\n\\n&quot;;\n            else\n                cout &lt;&lt; &quot;删除失败!\\n\\n&quot;;\n            break;\n        case 7: //单链表的输出\n            cout &lt;&lt; &quot;当前图书系统信息（链表）读出:\\n&quot;;\n            p = L-&gt;next;\n            while (p) &#123;\n                cout &lt;&lt; left &lt;&lt; setw(15) &lt;&lt; p-&gt;data.id &lt;&lt; &quot;\\t&quot; &lt;&lt; left &lt;&lt; setw(\n                        50) &lt;&lt; p-&gt;data.name &lt;&lt; &quot;\\t&quot; &lt;&lt; left &lt;&lt; setw(5)\n                        &lt;&lt; p-&gt;data.price &lt;&lt; endl;\n                p = p-&gt;next;\n            &#125;\n            cout &lt;&lt; endl;\n            break;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n\n\n5、顺序表和链表的比较\n\n6、例题与应用线性表的典型算法实现：\n\n   假设有两个按元素值递增有序排列的线性表A和B，均以单链表作为存储结构，请编写算法将A表和B表归并成一个按元素值递减有序（即非递增有序，允许表中含有值相同的元素）排列的线性表C，并要求利用原表（即A表和B表）的结点空间构造C表。\n   编程实现如下功能：（1）根据输入的一系列整数，以0标志结束，用头插法建立单链表，并输出单链表中各元素值，观察输入的内容与输出的内容是否一致。（2）在单链表的第i个元素之前插入一个值为x的元素，并输出插入后的单链表中各元素值。（3）删除单链表中第i个元素，并输出删除后的单链表中各元素值。（4）在单链表中查找第i个元素，如果查找成功，则显示该元素的值，否则显示该元素不存在。\n\n\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\ntypedef struct Node\n&#123;\n    int data;\n    struct Node *next;\n&#125; LNode, *LinkList;\n\nLinkList CreateList() //创建单链表\n&#123;\n    LinkList L;\n    LNode *p;\n    int c;\n    L = new LNode;\n    L-&gt;next = NULL; //建立带头结点的空链表\n    cin &gt;&gt; c;\n    while (c != 0)\n    &#123;\n        p = new LNode;\n        p-&gt;data = c;\n        p-&gt;next = L-&gt;next; //将新结点插入到头结点之后\n        L-&gt;next = p;\n        cin &gt;&gt; c;\n    &#125;\n    return L;\n&#125;\n\nvoid ShowList(LinkList L) //显示单链表\n&#123;\n    LNode *p;\n    p = L-&gt;next;      //指向首元结点\n    while (p != NULL) //对单链表进行遍历\n    &#123;\n        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;\n        p = p-&gt;next;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid ReverseList(LinkList L) //逆置单链表\n&#123;\n    LNode *p, *q;\n    p = L-&gt;next;\n    L-&gt;next = NULL; //将已有的数据元素再次插入，实现逆序\n    while (p != NULL)\n    &#123;\n        q = p-&gt;next;\n        p-&gt;next = L-&gt;next;\n        L-&gt;next = p;\n        p = q;\n    &#125;\n&#125;\n\nLinkList MergeList(LinkList LA, LinkList LB) //合并单链表\n&#123;\n    ReverseList(LA); //逆置链表LA\n    ReverseList(LB); //逆置链表LB\n    LinkList LC;\n    LNode *pa, *pb, *r;\n    pa = LA-&gt;next;\n    pb = LB-&gt;next;\n    LC = LA;\n    LC-&gt;next = NULL;\n    r = LC;\n    while (pa != NULL &amp;&amp; pb != NULL)\n    &#123;\n        if (pa-&gt;data &lt;= pb-&gt;data) //比较数据元素大小\n        &#123;\n            r-&gt;next = pb;\n            r = pb;\n            pb = pb-&gt;next;\n        &#125;\n        else\n        &#123;\n            r-&gt;next = pa;\n            r = pa;\n            pa = pa-&gt;next;\n        &#125;\n\n        if (pa)\n        &#123;\n            r-&gt;next = pa;\n        &#125;\n        else\n        &#123;\n            r-&gt;next = pb;\n        &#125;\n    &#125;\n    return LC;\n&#125;\n\nint Insert(LinkList &amp;L, int i, int e) //插入数据元素\n&#123;\n    LinkList t, p;\n    int j = 1;\n    t = L;\n    if (i &lt; 1)\n    &#123;\n        cout &lt;&lt; &quot;插入错误&quot; &lt;&lt; endl;\n        return 0;\n    &#125;\n    if (i == 1) //插入位置在表头\n    &#123;\n        p = new LNode;\n        p-&gt;data = e;\n        p-&gt;next = t-&gt;next;\n        L-&gt;next = p;\n        cout &lt;&lt; &quot;插入成功&quot; &lt;&lt; endl;\n        return 0;\n    &#125;\n    while (j &lt; i - 1 &amp;&amp; L) //异常判断\n    &#123;\n        t = t-&gt;next;\n        j++;\n        if (t == NULL)\n        &#123;\n            cout &lt;&lt; &quot;插入错误&quot; &lt;&lt; endl;\n            return 0;\n        &#125;\n    &#125;\n    t = t-&gt;next; //插在非表头\n    p = new LNode;\n    p-&gt;data = e;\n    p-&gt;next = t-&gt;next;\n    t-&gt;next = p;\n    cout &lt;&lt; &quot;插入成功&quot; &lt;&lt; endl;\n&#125;\n\nint Delete(LinkList &amp;L, int i) //删除数据元素\n&#123;\n    LinkList p, t;\n    int j = 0;\n    p = L;\n    if (i &lt; 1)\n    &#123;\n        cout &lt;&lt; &quot;删除失败&quot; &lt;&lt; endl;\n        return 0;\n    &#125;\n    while (j &lt; i - 1 &amp;&amp; L)\n    &#123;\n        p = p-&gt;next;\n        j++;\n        if (p == NULL)\n        &#123;\n            cout &lt;&lt; &quot;删除失败&quot; &lt;&lt; endl;\n            return 0;\n        &#125;\n    &#125;\n    t = p-&gt;next;\n    p-&gt;next = t-&gt;next;\n    cout &lt;&lt; &quot;删除成功&quot; &lt;&lt; endl;\n    delete t;\n&#125;\n\nint SecrchList(LinkList &amp;L, int i) //查找数据元素\n&#123;\n    LinkList p;\n    int j = 0, e;\n    p = L;\n    if (i &lt; 1)\n    &#123;\n        cout &lt;&lt; &quot;查找失败，该元素不存在&quot; &lt;&lt; endl;\n        return 0;\n    &#125;\n    while (j &lt; i &amp;&amp; L)\n    &#123;\n        p = p-&gt;next;\n        j++;\n        if (p == NULL)\n        &#123;\n            cout &lt;&lt; &quot;查找失败，该元素不存在&quot; &lt;&lt; endl;\n            return 0;\n        &#125;\n    &#125;\n    e = p-&gt;data;\n    cout &lt;&lt; &quot;查找成功，第&quot; &lt;&lt; i &lt;&lt; &quot;个元素为&quot; &lt;&lt; e &lt;&lt; endl;\n&#125;\n\nint main(void)\n&#123;\n    int i, e, select;\n\n    LinkList LA;\n    cout &lt;&lt; &quot;请输入单链表A的数据元素：&quot; &lt;&lt; endl;\n    LA = CreateList();\n    getchar();\n    cout &lt;&lt; &quot;请输入单链表B的数据元素：&quot; &lt;&lt; endl;\n    LinkList LB;\n    LB = CreateList();\n\n    cout &lt;&lt; &quot;单链表LA:&quot; &lt;&lt; endl;\n    ShowList(LA);\n    cout &lt;&lt; &quot;单链表LB:&quot; &lt;&lt; endl;\n    ShowList(LB);\n\n    LinkList LC;\n    LC = MergeList(LA, LB);\n    cout &lt;&lt; &quot;合并单链表LA和单链表LB:&quot; &lt;&lt; endl;\n    ShowList(LC);\n    while (1)\n    &#123;\n        cout &lt;&lt; &quot;\\n*****1.插入  2.删除  3.查找  4.退出*****\\n&quot;;\n        cin &gt;&gt; select;\n        switch (select)\n        &#123;\n        case 1:\n            cout &lt;&lt; &quot;输入位置和要插入的元素:&quot; &lt;&lt; endl;\n            cin &gt;&gt; i &gt;&gt; e;\n            Insert(LC, i, e);\n            ShowList(LC);\n            break;\n        case 2:\n            cout &lt;&lt; &quot;输入要删除的元素的位置&quot; &lt;&lt; endl;\n            cin &gt;&gt; i;\n            Delete(LC, i);\n            ShowList(LC);\n            break;\n        case 3:\n            cout &lt;&lt; &quot;输入要查找的元素的位置&quot; &lt;&lt; endl;\n            cin &gt;&gt; i;\n            SecrchList(LC, i);\n            break;\n        case 4:\n            return 0;\n            break;\n        default:\n            cout &lt;&lt; &quot;输入错误，请重新输入！&quot; &lt;&lt; endl;\n            break;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n\n","slug":"数据结构（C语言版）-- 线性表笔记","date":"2022-02-10T01:41:07.000Z","categories_index":"前端","tags_index":"字节跳动青训营","author_index":"会思想的苇草i"},{"id":"aaa9ceedcc6e20da90d5782857e132e7","title":"小游戏开发","content":"1、游戏发展历史广义：一种有组织的玩耍，一般是以娱乐为目的，有时也有教育目的。在英语中，体育比赛(Game)也是游戏，只要其活动本质带有目的、规则、挑战和互动，我们都可以把其归为游戏。狭义：通过游戏引擎制作的电子游戏。\n\n2、前端场景下的游戏开发开发链路和角色为什么要用游戏引擎\n游戏引擎最大的游戏:渲染引擎的诞生就是因为一家公司做了一款游戏，做下一款游戏时复用了上一款游戏的代码，后来发现这些代码几乎每个游戏都会用到，抽离出来就成了一个引擎。所以游戏引擎更像是一套解决方案，让你在制作某一类型的产品的时候能够提高你的开发效率。使用游戏引擎，你想要的它能够给你一套完整的实现方案，不需要你再自己去拼凑、封装，让你花更少的时间做出更好的效果，特别是关于渲染效率和性能优化。它提供游戏开发时需要的常见功能:引擎会提供许多组件，使用这些组件能缩短开发时间，让游戏开发变得更简单;专业引擎通常会能比自制引擎表现出更好的性能。游戏引擎通常会包含渲染器，2D&#x2F;3D图形元素，碰撞检测，物理引擎，声音，控制器支持，动画等部分。\n前端场景下的游戏开发需要先有一个明确的认知:前端开发和游戏开发不是相斥的。现在市场上很多H5游戏、小游戏都是Web前端开发制作的，而不是专门的游戏开发团队、专业的游戏研发同学开发。其原因可能在于:\n\n接触前端开发的研发数量远大于接触游戏开发的数量(招聘成本高)\n2d游戏引擎的上手门槛已经足够低(易上手)\n活动H5中的游戏玩法的实现方式比较模糊(开发界限模糊)\n\n现在很多主流的2d游戏引擎都支持使用Javascript进行开发同时使用相关的工程化能力，也是游戏开发向web前端开发靠拢的一种表现。因此，以web前端开发的视角看2d游戏引擎，无非是一套框架、一套解决方案而已。但是开发理念上还是有差别的:游戏开发更关注内容。\n\n3、游戏引擎The NVL Maker——文字冒险游戏制作器No Code形式的开发，只需要写文字脚本加上一定的配置就可以生成一个文字冒险游戏。当然，由于缺乏迭代和运营，该游戏引擎算是比较小众的。RPG MakerRPG Maker可以Low Code搭建一个关卡类型的游戏，适合代码能力不强但是想发挥自己的创意的开发者。Web游戏引擎利用Canvas和 WebGL为底层技术抽象的图像绘制库（往往还附带一些其他的功能)Web游戏引擎的通用能力:\n\n预加载:游戏中往往存在大量的静态素材，包括场景、元素、声音、动画、模型、贴图等，如果以原生JS进行请求，并统筹请求时间和加载的时机，将会非常麻烦。游戏引擎中的预加载引擎将加载时机、加载过程加以抽象，解决加载编码中的效率问题。\n展示与图层、组合系统:对于Web游戏编程而言，往往选择Canvas或 WebGL作为渲染方式(大家可以想想为什么不用DOM作为渲染方式?）。而Canvas和 WebGL 作为底层的API，接口非常基础，需要用大量的编码来编写简单的展示。而且图形之间没有组合和图层，很难处理元素组合和图层问题。渲染引擎和图层、组合系统应运而生。\n动画系统︰动画往往被分为缓动动画和逐帧动画，这里讨论缓动动画系统。缓动动画系统在原生JS 中需要搭配帧渲染进行考量而进行书写，代码量和思考量巨大，抽象程度低，所以需要游戏引擎动画系统。\n音效和声音系统︰游戏相较于普通的Web前端而言需要更加立体、及时的反馈，声音和音效是反馈的重要组成部分。所以声音和音效系统往往包含了声音的播放、音量、截止、暂停等功能的集成。\n\nWeb游戏引擎-Cocos\nWeb游戏引擎-Laya\nWeb游戏引擎-Egret\n\nWeb游戏引擎-CreateJS &amp; Phaser功能引擎大型游戏引擎往往是由小的功能引擎组装成的，一个大型游戏引擎往往包含渲染引擎、物理引擎、UI系统、声音系统、动画系统、粒子系统、骨骼系统、网络系统等组合而成。其中最重要的便是渲染引擎和物理引擎。功能引擎是专注某个方向能力的引擎，其特点是体积小、功能完善。特别是Pixi.js和Three.js这两个渲染引擎，通常被误以为是一个完整的游戏引擎，但它们是专注渲染能力的渲染引擎。下面介绍几种可能会经常接触的功能引擎:web游戏引擎的渲染原理\n\n4、游戏开发入门技能树\n\n5、PixiJS+Web开发Pixi简介：本质上还是一个渲染引擎，它不仅仅能做游戏，还能使用这个技术去创建任何交互式内容，比如APP，还能够在它的基础上做自己的游戏引擎。(AVG.js和 Phaser.js 的渲染引擎就是Pixi)。\n\n\n6、Cocos Creator编辑器开发Cocos Creator介绍：一个完整的游戏开发解决方案，包含了轻量高效的跨平台游戏引擎，以及能让你更快速开发游戏所需要的各种图形界面工具。\n\n\n7、扩展游戏发布平台的差异性：游戏开发的重要理念：激发创造！把游戏开发过程当作一个游戏，在规则的约束下通过创意和技术力挑战一个高质量游戏开发。\n","slug":"青训营--小游戏开发","date":"2022-02-08T02:41:06.000Z","categories_index":"前端","tags_index":"字节跳动青训营","author_index":"会思想的苇草i"},{"id":"4fde660230560945997cb0c9305b7a1e","title":"前端设计模式应用","content":"\n什么是设计模式软件设计中常见问题的解决方案模型:\n\n历史经验的总结\n与特定语言无关\n\n设计模式背景\n\n模式语言:城镇、建筑、建造 (A Pattern Language:Towns, Buildings,Construction)1977\n设计模式:可复用面向对象软件的基础 (Design Patterns: Elements ofReusableObject-Oriented Software)1994\n\n设计模式趋势设计模式分类\n23种设计模式\n\n创建型-如何创建一个对象 \n结构型-如何灵活的将对象组装成较大的结构 \n行为型-负责对象间的高效通信和职责划分\n\n\n浏览器中的设计模式单例模式\n定义:全局唯一访问对象 \n应用场景: 缓存， 全局状态管理等。\n单例模式请求缓存\n//定义api，500m后返回\nimport &#123; api &#125; from”./utils&quot; ;\n\nexport cLass Requset &#123;//定义请求实例\n    static instance: Requset;//定义缓存\n    private cache: Recordestring, string&gt;;\n\n    constructor() &#123;//初始化缓存内容\n        this.cache = &#123;&#125;;\n    &#125;\n    \n    static getInstance() &#123;\n        if ( this. instance) &#123;\n            return this. instance;\n        &#125;\n        \n        this. instance = new Requset();\n        return this. instance;\n    &#125;\n    \n    pubLic async request(url: string) &#123; \n        if (this . cache[urU])&#123; \n            return this . cache[urL];\n        &#125;\n        const response = await api(urL); \n        this . cache[urL] = response;\n        \n        return response;\n    &#125;\n&#125;\n\ntest(&quot;should response more than 500ms with class&quot;, async () = &#123;\n    const request = Requset. getInstance();\n\n    const startTime = Date . now();\n    await request . request(&quot; /user/1&quot;);\n    const endTime = Date. now();\n\n    const costTime = endTime - startTime;\n    expect ( costTime) . toBeGreaterThanOrEquaL(500);\n&#125;);\n\n\ntest(&quot;should response quickly second time with class&quot;, async () = &#123;\n    const request1 = Requset . getInstance();\n    await request1 . request(&quot; /user/1&quot;);\n\n    const startTime = Date now();\n    const request2 = Requset . getInstance();\n    await request2 . request(&quot; /user/1&quot;);\n    const endTime = Date . now();\n\n    const costTime = endTime - startTime;\n    expect ( costTime) . toBeLessThan(50);\n&#125;);\n\n    import &#123; api &#125; from &quot;./utils&quot;;\n\n    const cache: Record&lt;string, string&gt; = &#123;&#125;;\n    \n    export const request = async (urT: string) →&#123;\n        if (cache[urL]) &#123;\n            return cache[urL];\n        &#125;\n    \n    const response = await api(urL);\n    \n    cache[urL] = response;\n    return response;\n&#125;;\n\n    test(&quot; should response quickly second time&quot;, async 0) = &#123; \n        await request(&quot; /user/1&quot;);\n        const startTime = Date. now() ;\n        await request(&quot; /user/1&quot;);\n        const endTime = Date. now() ;\n        \n        const costTime = endTime - startTime;\n\n        expect (costTime) . toBeLessThan(50) ;\n&#125;);\n\n发布订阅模式\n定义: 一种订阅机制， 可在被订阅对象发生变化 时通知订阅者。\n应用场景: 从系统架构之间的解耦，到业务中一-些实 现模式，像邮件订阅，上线订阅等等，应用广泛。\ntype Notify = (user: User) =&gt; void;\n\nexport class User &#123;\n  name: string;\n  status: &quot;offline&quot; | &quot;online&quot;;\n  // user 订阅自己的人，notify 上线时的通知函数\n  followers: &#123; user: User; notify: Notify &#125;[];\n\n  constructor(name: string) &#123;\n    this.name = name;\n    this.status = &quot;offline&quot;;\n    this.followers = [];\n  &#125;\n\n  // 订阅参数中的 user\n  subscribe(user: User, notify: Notify) &#123;\n    user.followers.push(&#123; user, notify &#125;);\n  &#125;\n\n  // 上线\n  online() &#123;\n    // 状态改为 online\n    this.status = &quot;online&quot;;\n    // 通知所有订阅自己的人\n    this.followers.forEach((&#123; notify &#125;) =&gt; &#123;\n      notify(this);\n    &#125;);\n  &#125;\n&#125;\n\ntest(&quot;should notify followers when user is online for multiple users&quot;, () =&gt; &#123;\n  // 创建三个用户\n  const user1 = new User(&quot;user1&quot;);\n  const user2 = new User(&quot;user2&quot;);\n  const user3 = new User(&quot;user3&quot;);\n\n  // 通知 user1 和 user2 的函数\n  const mockNotifyUser1 = jest.fn();\n  const mockNotifyUser2 = jest.fn();\n\n  // user1 订阅了 user3 的上线，传入通知 user1 的函数\n  user1.subscribe(user3, mockNotifyUser1);\n  user2.subscribe(user3, mockNotifyUser2);\n\n  // user3 上线\n  user3.online();\n\n  // user3 会调用通知 user1 的函数\n  expect(mockNotifyUser1).toBeCalledWith(user3);\n  expect(mockNotifyUser2).toBeCalledWith(user3);\n&#125;);\n\n\nJavascript中的设计模式原型模式\n定义 :复制已有对象来创建新的对象\n应用场景 :JS中对象创建的基本模式\n用原型模式创建上线订阅中的用户\nconst baseUser: User = &#123;\n  name: &quot;&quot;,\n  status: &quot;offline&quot;,\n  followers: [],\n\n  subscribe(user, notify) &#123;\n    user.followers.push(&#123; user, notify &#125;);\n  &#125;,\n\n  online() &#123;\n    this.status = &quot;online&quot;;\n    this.followers.forEach((&#123; notify &#125;) =&gt; &#123;\n      notify(this);\n    &#125;);\n  &#125;,\n&#125;;\n\nexport const createUser = (name: string) =&gt; &#123;\n  // Object.create(obj) 会根据已有的对象返回一个新的对象\n  // baseUser 是原型，与新创建的对象是继承关系\n  const user: User = Object.create(baseUser);\n\n  user.name = name;\n  user.followers = [];\n\n  return user;\n&#125;;\n\ntest(&quot;should notify followers when user is online for multiple users&quot;, () =&gt; &#123;\n  const user1 = createUser(&quot;user1&quot;);\n  const user2 = createUser(&quot;user2&quot;);\n  const user3 = createUser(&quot;user3&quot;);\n\n  const mockNotifyUser1 = jest.fn();\n  const mockNotifyUser2 = jest.fn();\n\n  user1.subscribe(user3, mockNotifyUser1);\n  user2.subscribe(user3, mockNotifyUser2);\n\n  user3.online();\n\n  expect(mockNotifyUser1).toBeCalledWith(user3);\n  expect(mockNotifyUser2).toBeCalledWith(user3);\n&#125;);\n\n代理模式\n定义：可以自定义控制对原对象的访问方式，并且允许在更新后做一些额外处理\n应用场景：监控，代理工具，前端框架实现\n用代理模式实现用户状态订阅\ntype Notify = (user: User) =&gt; void;\n\nexport class User &#123;\n  name: string;\n  status: &quot;offline&quot; | &quot;online&quot;;\n  followers: &#123; user: User; notify: Notify &#125;[];\n\n  constructor(name: string) &#123;\n    this.name = name;\n    this.status = &quot;offline&quot;; this.followers = [];\n  &#125;\n\n  subscribe(user: User, notify: Notify) &#123;\n    user.followers.push(&#123; user, notify &#125;);\n  &#125;\n\n  // 添加新功能时，代码不好维护\n  // online() &#123;\n  //   this.status = &quot;online&quot;;\n  //   this.followers.forEach((&#123; notify &#125;) =&gt; &#123;\n  //     notify(this);\n  //   &#125;);\n  // &#125;\n\n  // online 只做上线一件事情，单一职责原则\n  online() &#123;\n    this.status = &#39;online&#39;\n  &#125;\n&#125;\n\n// 实现通知\nexport const createProxyUser = (name: string) =&gt; &#123;\n  const user = new User(name);\n\n  // 使用 new Proxy() 实现代理\n  const proxyUser = new Proxy(user, &#123;\n    set: (target, prop: keyof User, value) =&gt; &#123;\n      target[prop] = value;\n      if (prop === &quot;status&quot;) &#123;\n        notifyStatusHandlers(target, value);\n      &#125;\n      return true;\n    &#125;,\n  &#125;);\n\n  const notifyStatusHandlers = (user: User, status: &quot;online&quot; | &quot;offline&quot;) =&gt; &#123;\n    if (status === &quot;online&quot;) &#123;\n      user.followers.forEach((&#123; notify &#125;) =&gt; &#123;\n        notify(user);\n      &#125;);\n    &#125;\n  &#125;;\n\n  return proxyUser;\n&#125;;\n\n迭代器模式\n定义：在不暴露数据类型的情况下访问集合的数据\n应用场景：数据结构中有多种数据类型，列表，树等，提供通用的操作接口\n用 for of 迭代所有组件\n// 浏览器中的 DOM 结构\nclass MyDomElement &#123;\n  tag: string;\n  children: MyDomElement[];\n\n  constructor(tag: string) &#123;\n    this.tag = tag;\n    this.children = [];\n  &#125;\n\n  addChildren(component: MyDomElement) &#123;\n    this.children.push(component);\n  &#125;\n\n  // 使组件可迭代\n  [Symbol.iterator]() &#123;\n    const list = [...this.children];\n    let node;\n\n    return &#123;\n      // for...of 迭代时调用的函数\n      next: () =&gt; &#123;\n        while ((node = list.shift())) &#123;\n          // 层序遍历\n          node.children.length &gt; 0 &amp;&amp; list.push(...node.children);\n          // value 是迭代出的值，done 是指迭代是否完成\n          return &#123; value: node, done: false &#125;;\n        &#125;\n        return &#123; value: null, done: true &#125;;\n      &#125;,\n    &#125;;\n  &#125;\n&#125;\n\ntest(&quot;can iterate root element&quot;, () =&gt; &#123;\n  const body = new MyDomElement(&quot;body&quot;);\n  const header = new MyDomElement(&quot;header&quot;);\n  const main = new MyDomElement(&quot;main&quot;);\n  const banner = new MyDomElement(&quot;banner&quot;);\n  const content = new MyDomElement(&quot;content&quot;);\n  const footer = new MyDomElement(&quot;footer&quot;);\n\n  body.addChildren(header);\n  body.addChildren(main);\n  body.addChildren(footer);\n\n  main.addChildren(banner);\n  main.addChildren(content);\n\n  const expectTags: string[] = [];\n  for (const element of body) &#123;\n    if (element) &#123;\n      expectTags.push(element.tag);\n    &#125;\n  &#125;\n\n  expect(expectTags.length).toBe(5);\n&#125;);\n\n前端框架中的设计模式Vue 组件实现计数器\n&lt;template&gt;\n  &lt;button @click=&quot;count++&quot;&gt;count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=&quot;ts&quot;&gt;\nimport &#123; ref &#125; from &quot;vue &quot;;\nconst count = ref(0);\n&lt;/script&gt;\n\n没有框架之前，我们通过监听 click 事件，通过 innerText 手动改变 DOM 的属性。前端框架对 DOM 操作进行代理，模板中的 DOM 都是 Proxy 代理后的虚拟 DOM，我们的操作的 DOM 是虚拟 DOM，之后通过 Diff 对视图更新。\n组合模式\n定义：可多个对象组合使用成为一个单独的对象，也可以单个对象独立使用\n应用场景：DOM，前端组件，文件目录\nReact 的组件结构\nexport const Count = () =&gt; &#123;\n  const [count, setCount] = useState(0);\n  return (\n    &lt;button onClick=&#123;() =&gt; setCount((count) =&gt; count + 1)&#125; &gt;\n      count is: &#123;count&#125;\n    &lt;/button &gt;\n  );\n&#125;;\n\nfunction App() &#123;\n  return (\n    &lt;div className=&quot;App&quot;&gt;\n      &lt;Header /&gt;\n      &lt;Count /&gt;\n      &lt;Footer /&gt;\n    &lt;/div&gt;\n  );\n&#125;\n\n\n总结设计模式不是银弹。\n\n总结出抽象的设计模式比较简单，但是套用到场景中却非常困难。\n现代编程语言的多编程范式能带来更多的可能性。\n要从真正优秀的开源项目中学习设计模式并不断实现。\n\n","slug":"青训营--前端设计模式应用","date":"2022-02-07T02:42:27.000Z","categories_index":"前端","tags_index":"字节跳动青训营","author_index":"会思想的苇草i"},{"id":"fc3331da72f382869606f6a944c6cf7d","title":"Typescript快速入门","content":"第一章 快速入门0、TypeScript简介\nTypeScript是JavaScript的超集。\n它对JS进行了扩展，向JS中引入了类型的概念，并添加了许多新的特性。\nTS代码需要通过编译器编译为JS，然后再交由JS解析器执行。\nTS完全兼容JS，换言之，任何的JS代码都可以直接当成JS使用。\n相较于JS而言，TS拥有了静态类型，更加严格的语法，更强大的功能；TS可以在代码执行前就完成代码的检查，减小了运行时异常的出现的几率；TS代码可以编译为任意版本的JS代码，可有效解决不同JS运行环境的兼容问题；同样的功能，TS的代码量要大于JS，但由于TS的代码结构更加清晰，变量类型更加明确，在后期代码的维护中TS却远远胜于JS。\n\n1、TypeScript 开发环境搭建\n下载Node.js\n\n64位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi\n32位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi\n\n\n安装Node.js\n\n使用npm全局安装typescript\n\n进入命令行\n输入：npm i -g typescript\n\n\n创建一个ts文件\n\n使用tsc对ts文件进行编译\n\n进入命令行\n\n进入ts文件所在目录\n\n执行命令：tsc xxx.ts\n\n\n\n\n2、基本类型\n类型声明\n\n类型声明是TS非常重要的一个特点\n\n通过类型声明可以指定TS中变量（参数、形参）的类型\n\n指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错\n\n简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值\n\n语法：\n  let 变量: 类型;\n  let a: number;\n  \n  let 变量: 类型 = 值;\n  let a: number = 10;\n  \n  function fn(参数: 类型, 参数: 类型): 类型&#123;\n      ...\n  &#125;\n   function sum(a: number, b: number): number &#123;\n      return a + b;\n  &#125;\n\n\n\n\n自动类型判断\n\nTS拥有自动的类型判断机制\n当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型\n所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明\n\n\n类型：\n\n\n\n类型\n例子\n描述\n\n\n\nnumber\n1, -33, 2.5\n任意数字\n\n\nstring\n‘hi’, “hi”, hi\n任意字符串\n\n\nboolean\ntrue、false\n布尔值true或false\n\n\n字面量\n其本身\n限制变量的值就是该字面量的值\n\n\nany\n*\n任意类型\n\n\nunknown\n*\n类型安全的any\n\n\nvoid\n空值（undefined）\n没有值（或undefined）\n\n\nnever\n没有值\n不能是任何值\n\n\nobject\n{name:’孙悟空’}\n任意的JS对象\n\n\narray\n[1,2,3]\n任意JS数组\n\n\ntuple\n[4,5]\n元素，TS新增类型，固定长度数组\n\n\nenum\nenum{A, B}\n枚举，TS中新增类型\n\n\n\nnumber\n\n\n    let decimal: number = 6;\n    let hex: number = 0xf00d;\n    let binary: number = 0b1010;\n    let octal: number = 0o744;\n    let big: bigint = 100n;\n\n\nboolean\nlet isDone: boolean = false;\n\n\nstring\nlet color: string = &quot;blue&quot;;\ncolor = &#39;red&#39;;\n\nlet fullName: string = `Bob Bobbington`;\nlet age: number = 37;\nlet sentence: string = `Hello, my name is $&#123;fullName&#125;.\n\nI&#39;ll be $&#123;age + 1&#125; years old next month.`;\n\n\n字面量\n\n也可以使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围(类似于常量，限定值或范围)\nlet color: &#39;red&#39; | &#39;blue&#39; | &#39;black&#39;;\nlet num: 1 | 2 | 3 | 4 | 5;\n\n\n\n\nany\n\n相当于对该变量关闭了TS的类型检测\n\nlet d: any = 4;\nd = &#39;hello&#39;;\nd = true;\n//隐式\nlet e;\n\n\nunknown\n\nunknown类型的变量，不能直接赋值给其他变量\n\nlet notSure: unknown = 4;\nnotSure = &#39;hello&#39;;\n\n//类型检查\nlet s:string;\nif(typeof e === &quot;string&quot;)&#123;\n    s = e;\n&#125;\n\n//类型断言\n/*\n语法：\n变量 as 类型\n&lt;类型&gt;变量\n*/\ns = e as string;\n//s = &lt;string&gt;e;\n\n\nvoid\nlet unusable: void = undefined;\n\n//没写void，没写return，默认为void\nfunction fn(): void &#123;\n&#125;\n\n\nnever\n\n表示永远不会返回结果\n\nfunction error(message: string): never &#123;\n  throw new Error(message);\n&#125;\n\n\nobject（没啥用）\nlet obj: object = &#123;&#125;;\n\n// &#123;&#125; 用来指定对象中可以包含哪些属性\n// 语法：&#123;属性名:属性值,属性名:属性值&#125;\n// 在属性名后边加上?，表示属性是可选的\nlet b: &#123; name: string, age?: number &#125;;\nb = &#123; name: &#39;孙悟空&#39;, age: 18 &#125;;\n\n//定义对象结构\n// [propName: string]: any 表示任意类型的属性\nlet c: &#123; name: string, [propName: string]: any &#125;;\nc = &#123; name: &#39;猪八戒&#39;, age: 18, gender: &#39;男&#39; &#125;;\n\n//定义函数结构\n/*\n  设置函数结构的类型声明：\n  语法：(形参:类型, 形参:类型 ...) =&gt; 返回值\n*/\nlet d: (a: number, b: number) =&gt; number;\n// d = function (n1: string, n2: string): number&#123;\n//     return 10;\n// &#125;\n\n\narray\n//类型[]\nlet list: number[] = [1, 2, 3];\n\n//Array&lt;类型&gt;\nlet list: Array&lt;number&gt; = [1, 2, 3];\n\n\ntuple\nlet x: [string, number];\nx = [&quot;hello&quot;, 10]; \n\n\nenum\nenum Color &#123;\n  Red,\n  Green,\n  Blue,\n&#125;\nlet c: Color = Color.Green;\n\nenum Color &#123;\n  Red = 1,\n  Green,\n  Blue,\n&#125;\nlet c: Color = Color.Green;\n\nenum Color &#123;\n  Red = 1,\n  Green = 2,\n  Blue = 4,\n&#125;\nlet c: Color = Color.Green;\n\n// &amp;表示同时\nlet j: &#123; name: string &#125; &amp; &#123; age: number &#125;;\n// j = &#123;name: &#39;孙悟空&#39;, age: 18&#125;;\n\n// 类型的别名\ntype myType = 1 | 2 | 3 | 4 | 5;\nlet k: myType;\nlet l: myType;\nlet m: myType;\n\nk = 2;\n\n\n类型断言\n\n有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：\n\n第一种\nlet someValue: unknown = &quot;this is a string&quot;;\nlet strLength: number = (someValue as string).length;\n\n\n第二种\nlet someValue: unknown = &quot;this is a string&quot;;\nlet strLength: number = (&lt;string&gt;someValue).length;\n\n\n\n\n\n\n\n3、编译选项\n自动编译文件\n\n编译文件时，使用 -w  指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。\n\n示例：\ntsc xxx.ts -w\n\n\n\n\n自动编译整个项目\n\n如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。\n\n但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json(tsc --init)\n\ntsconfig.json是一个JSON文件，添加配置文件后，只需只需 tsc 命令即可完成对整个项目的编译tsc -w自动监视所有文件\n\n配置选项：\n\ninclude\n\n定义希望被编译文件所在的目录\n\n默认值：[“**&#x2F;*“]    (** 表示任意目录 *表示任意文件)\n\n示例：\n&quot;include&quot;:[&quot;src/**/*&quot;, &quot;tests/**/*&quot;]\n\n\n上述示例中，所有src目录和tests目录下的文件都会被编译\n\n\n\n\nexclude\n\n定义需要排除在外的目录\n\n默认值：[“node_modules”, “bower_components”, “jspm_packages”]\n\n示例：\n&quot;exclude&quot;: [&quot;./src/hello/**/*&quot;]\n\n\n上述示例中，src下hello目录下的文件都不会被编译\n\n\n\n\nextends\n\n定义被继承的配置文件\n\n示例：\n&quot;extends&quot;: &quot;./configs/base&quot;\n\n\n上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息\n\n\n\n\nfiles\n\n指定被编译文件的列表，只有需要编译的文件少时才会用到\n\n示例：\n&quot;files&quot;: [\n    &quot;core.ts&quot;,\n    &quot;sys.ts&quot;,\n    &quot;types.ts&quot;,\n    &quot;scanner.ts&quot;,\n    &quot;parser.ts&quot;,\n    &quot;utilities.ts&quot;,\n    &quot;binder.ts&quot;,\n    &quot;checker.ts&quot;,\n    &quot;tsc.ts&quot;\n  ]\n\n\n列表中的文件都会被TS编译器所编译\n\n\ncompilerOptions\n\n编译选项是配置文件中非常重要也比较复杂的配置选项\n\n在compilerOptions中包含多个子选项，用来完成对编译的配置\n\n项目选项\n\ntarget\n\n设置ts代码编译的目标版本\n\n可选值：\n\nES3（默认）、ES5、ES6&#x2F;ES2015、ES7&#x2F;ES2016、ES2017、ES2018、ES2019、ES2020、ESNext(ES最新版本)\n\n\n示例：\n&quot;compilerOptions&quot;: &#123;\n    &quot;target&quot;: &quot;ES6&quot;\n&#125;\n\n\n如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码\n\n\n\n\nlib\n\n指定代码运行时所包含的库（宿主环境）\n\n可选值：\n\nES5、ES6&#x2F;ES2015、ES7&#x2F;ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ……\n\n\n示例：\n&quot;compilerOptions&quot;: &#123;\n    &quot;target&quot;: &quot;ES6&quot;,\n    &quot;lib&quot;: [&quot;ES6&quot;, &quot;DOM&quot;],\n    &quot;outDir&quot;: &quot;dist&quot;,\n    &quot;outFile&quot;: &quot;dist/aa.js&quot;\n&#125;\n\n\n\n\nmodule\n\n设置编译后代码使用的模块化系统\n\n可选值：\n\nCommonJS、UMD、AMD、System、ES2020、ESNext、None\n\n\n示例：\n&quot;compilerOptions&quot;: &#123;\n    &quot;module&quot;: &quot;CommonJS&quot;\n&#125;\n\n\n\n\noutDir\n\n编译后文件的所在目录\n\n默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置\n\n示例：\n&quot;compilerOptions&quot;: &#123;\n    &quot;outDir&quot;: &quot;dist&quot;\n&#125;\n\n\n设置后编译后的js文件将会生成到dist目录\n\n\n\n\noutFile\n\n将所有的文件编译为一个js文件\n\n默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中\n\n示例：\n&quot;compilerOptions&quot;: &#123;\n    &quot;outFile&quot;: &quot;dist/app.js&quot;\n&#125;\n\n\n\n\nrootDir\n\n指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录\n\n示例：\n&quot;compilerOptions&quot;: &#123;\n    &quot;rootDir&quot;: &quot;./src&quot;\n&#125;\n\n\n\n\nallowJs\n\n是否对js文件编译\n\n\ncheckJs\n\n是否对js文件进行检查\n\n示例：\n&quot;compilerOptions&quot;: &#123;\n    &quot;allowJs&quot;: true,\n    &quot;checkJs&quot;: true\n&#125;\n\n\n\n\nremoveComments\n\n是否删除注释\n默认值：false\n\n\nnoEmit\n\n不对代码进行编译\n默认值：false\n\n\nsourceMap\n\n是否生成sourceMap\n默认值：false\n\n\n\n\n严格检查\n\nstrict\n启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查\n\n\nalwaysStrict\n总是以严格模式对代码进行编译\n\n\nnoImplicitAny\n禁止隐式的any类型\n\n\nnoImplicitThis\n禁止类型不明确的this\n\n\nstrictBindCallApply\n严格检查bind、call和apply的参数列表\n\n\nstrictFunctionTypes\n严格检查函数的类型\n\n\nstrictNullChecks\n严格的空值检查\n\n\nstrictPropertyInitialization\n严格检查属性是否初始化\n\n\n\n\n额外检查\n\nnoFallthroughCasesInSwitch\n检查switch语句包含正确的break\n\n\nnoImplicitReturns\n检查函数没有隐式的返回值\n\n\nnoUnusedLocals\n检查未使用的局部变量\n\n\nnoUnusedParameters\n检查未使用的参数\n\n\n\n\n高级\n\nallowUnreachableCode\n检查不可达代码\n可选值：\ntrue，忽略不可达代码\nfalse，不可达代码将引起错误\n\n\n\n\nnoEmitOnError\n有错误的情况下不进行编译\n默认值：false\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4、webpack\n通常情况下，实际开发中我们都需要使用构建工具对代码进行打包，TS同样也可以结合构建工具一起使用，下边以webpack为例介绍一下如何结合构建工具使用TS。\n\n步骤：\n\n初始化项目\n\n进入项目根目录，执行命令 npm init -y\n主要作用：创建package.json文件\n\n\n\n\n下载构建工具\n\nnpm i -D webpack webpack-cli webpack-dev-server typescript ts-loader clean-webpack-plugin\n共安装了7个包\nwebpack\n构建工具webpack\n\n\nwebpack-cli\nwebpack的命令行工具\n\n\nwebpack-dev-server\nwebpack的开发服务器\n\n\ntypescript\nts编译器\n\n\nts-loader\nts加载器，用于在webpack中编译ts文件\n\n\nhtml-webpack-plugin\nwebpack中html插件，用来自动创建html文件\n\n\nclean-webpack-plugin\nwebpack中的清除插件，每次构建都会先清除目录\n\n\n\n\n\n\n\n\n根目录下创建webpack的配置文件webpack.config.js\nconst path = require(&quot;path&quot;);\nconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);\nconst &#123; CleanWebpackPlugin &#125; = require(&quot;clean-webpack-plugin&quot;);\n\nmodule.exports = &#123;\n    optimization:&#123;\n        minimize: false // 关闭代码压缩，可选\n    &#125;,\n\n    entry: &quot;./src/index.ts&quot;,\n    \n    devtool: &quot;inline-source-map&quot;,\n    \n    devServer: &#123;\n        contentBase: &#39;./dist&#39;\n    &#125;,\n\n    output: &#123;\n        path: path.resolve(__dirname, &quot;dist&quot;),\n        filename: &quot;bundle.js&quot;,\n        environment: &#123;\n            arrowFunction: false // 关闭webpack的箭头函数，可选\n        &#125;\n    &#125;,\n\n    resolve: &#123;\n        extensions: [&quot;.ts&quot;, &quot;.js&quot;]\n    &#125;,\n    \n    module: &#123;\n        rules: [\n            &#123;\n                test: /\\.ts$/,\n                use: &#123;\n                   loader: &quot;ts-loader&quot;     \n                &#125;,\n                exclude: /node_modules/\n            &#125;\n        ]\n    &#125;,\n\n    plugins: [\n        new CleanWebpackPlugin(),\n        new HtmlWebpackPlugin(&#123;\n            title:&#39;TS测试&#39;\n        &#125;),\n    ]\n\n&#125;\n\n\n根目录下创建tsconfig.json，配置可以根据自己需要\n&#123;\n    &quot;compilerOptions&quot;: &#123;\n        &quot;target&quot;: &quot;ES2015&quot;,\n        &quot;module&quot;: &quot;ES2015&quot;,\n        &quot;strict&quot;: true\n    &#125;\n&#125;\n\n\n修改package.json添加如下配置\n&#123;\n  ...略...\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,\n    &quot;build&quot;: &quot;webpack&quot;,\n    &quot;start&quot;: &quot;webpack serve --open chrome.exe&quot;\n  &#125;,\n  ...略...\n&#125;\n\n\n在src下创建ts文件，并在并命令行执行npm run build对代码进行编译，或者执行npm start来启动开发服务器\n\n\n\n\n5、Babel\n经过一系列的配置，使得TS和webpack已经结合到了一起，除了webpack，开发中还经常需要结合babel来对代码进行转换以使其可以兼容到更多的浏览器，在上述步骤的基础上，通过以下步骤再将babel引入到项目中。\n\n安装依赖包：\n\nnpm i -D @babel/core @babel/preset-env babel-loader core-js\n共安装了4个包，分别是：\n@babel&#x2F;core\nbabel的核心工具\n\n\n@babel&#x2F;preset-env\nbabel的预定义环境\n\n\n@babel-loader\nbabel在webpack中的加载器\n\n\ncore-js\ncore-js用来使老版本的浏览器支持新版ES语法\n\n\n\n\n\n\n修改webpack.config.js配置文件\n...略...\nmodule: &#123;\n    rules: [\n        &#123;\n            test: /\\.ts$/,\n            use: [\n                &#123;\n                    loader: &quot;babel-loader&quot;,\n                    options:&#123;\n                        presets: [\n                            [\n                                &quot;@babel/preset-env&quot;,\n                                &#123;\n                                    &quot;targets&quot;:&#123;\n                                        &quot;chrome&quot;: &quot;58&quot;,\n                                        &quot;ie&quot;: &quot;11&quot;\n                                    &#125;,\n                                    &quot;corejs&quot;:&quot;3&quot;,\n                                    &quot;useBuiltIns&quot;: &quot;usage&quot;\n                                &#125;\n                            ]\n                        ]\n                    &#125;\n                &#125;,\n                &#123;\n                    loader: &quot;ts-loader&quot;,\n\n                &#125;\n            ],\n            exclude: /node_modules/\n        &#125;\n    ]\n&#125;\n...略...\n\n\n如此一来，使用ts编译后的文件将会再次被babel处理，使得代码可以在大部分浏览器中直接使用，可以在配置选项的targets中指定要兼容的浏览器版本。\n\n\n\n\n\n第二章：面向对象0、面向对象简介面向对象是程序中一个非常重要的思想，它被很多同学理解成了一个比较难，比较深奥的问题，其实不然。面向对象很简单，简而言之就是程序之中所有的操作都需要通过对象来完成。\n\n举例来说：\n操作浏览器要使用window对象\n操作网页要使用document对象\n操作控制台要使用console对象\n\n\n\n一切操作都要通过对象，也就是所谓的面向对象，那么对象到底是什么呢？这就要先说到程序是什么，计算机程序的本质就是对现实事物的抽象，抽象的反义词是具体，比如：照片是对一个具体的人的抽象，汽车模型是对具体汽车的抽象等等。程序也是对事物的抽象，在程序中我们可以表示一个人、一条狗、一把枪、一颗子弹等等所有的事物。一个事物到了程序中就变成了一个对象。\n在程序中所有的对象都被分成了两个部分数据和功能，以人为例，人的姓名、性别、年龄、身高、体重等属于数据，人可以说话、走路、吃饭、睡觉这些属于人的功能。数据在对象中被成为属性，而功能就被称为方法。所以简而言之，在程序中一切皆是对象。\n1、类（class）要想面向对象，操作对象，首先便要拥有对象，那么下一个问题就是如何创建对象。要创建对象，必须要先定义类，所谓的类可以理解为对象的模型，程序中可以根据类创建指定类型的对象，举例来说：可以通过Person类来创建人的对象，通过Dog类创建狗的对象，通过Car类来创建汽车的对象，不同的类可以用来创建不同的对象。\n\n定义类：\nclass 类名 &#123;\n    属性名: 类型;\n    \n    constructor(参数: 类型)&#123;\n        this.属性名 = 参数;\n    &#125;\n    \n    方法名()&#123;\n        ....\n    &#125;\n\n&#125;\n\n\n示例：\nclass Person&#123;\n    name: string;\n    age: number;\n\n    constructor(name: string, age: number)&#123;\n        this.name = name;\n        this.age = age;\n    &#125;\n\n    sayHello()&#123;\n        console.log(`大家好，我是$&#123;this.name&#125;`);\n    &#125;\n&#125;\n\n\n使用类：\nconst p = new Person(&#39;孙悟空&#39;, 18);\np.sayHello();\n\n\n\n\n直接定义的属性是实例属性，需要通过对象的实例去访问；使用static开头的属性是静态属性（类属性），可以直接通过类去访问static readonly age: number = 18;；readonly开头的属性表示一个只读的属性无法修改readonly name: string = &#39;孙悟空&#39;;\n\n2、面向对象的特点\n封装\n\n对象实质上就是属性和方法的容器，它的主要作用就是存储属性和方法，这就是所谓的封装\n\n默认情况下，对象的属性是可以任意的修改的，为了确保数据的安全性，在TS中可以对属性的权限进行设置\n\n只读属性（readonly）：\n\n如果在声明属性时添加一个readonly，则属性便成了只读属性无法修改\n\n\nTS中属性具有三种修饰符：\n\npublic（默认值），可以在类、子类和对象中修改\nprotected ，可以在类、子类中修改\nprivate ，可以在类中修改\n\n\n示例：\n\npublic\nclass Person&#123;\n    public name: string; // 写或什么都不写都是public\n    public age: number;\n\n    constructor(name: string, age: number)&#123;\n        this.name = name; // 可以在类中修改\n        this.age = age;\n    &#125;\n\n    sayHello()&#123;\n        console.log(`大家好，我是$&#123;this.name&#125;`);\n    &#125;\n&#125;\n\nclass Employee extends Person&#123;\n    constructor(name: string, age: number)&#123;\n        super(name, age);\n        this.name = name; //子类中可以修改\n    &#125;\n&#125;\n\nconst p = new Person(&#39;孙悟空&#39;, 18);\np.name = &#39;猪八戒&#39;;// 可以通过对象修改\n\n\nprotected\nclass Person&#123;\n    protected name: string;\n    protected age: number;\n\n    constructor(name: string, age: number)&#123;\n        this.name = name; // 可以修改\n        this.age = age;\n    &#125;\n\n    sayHello()&#123;\n        console.log(`大家好，我是$&#123;this.name&#125;`);\n    &#125;\n&#125;\n\nclass Employee extends Person&#123;\n\n    constructor(name: string, age: number)&#123;\n        super(name, age);\n        this.name = name; //子类中可以修改\n    &#125;\n&#125;\n\nconst p = new Person(&#39;孙悟空&#39;, 18);\np.name = &#39;猪八戒&#39;;// 不能修改\n\n\nprivate\nclass Person&#123;\n    private name: string;\n    private age: number;\n\n    constructor(name: string, age: number)&#123;\n        this.name = name; // 可以修改\n        this.age = age;\n    &#125;\n\n    sayHello()&#123;\n        console.log(`大家好，我是$&#123;this.name&#125;`);\n    &#125;\n&#125;\n\nclass Employee extends Person&#123;\n\n    constructor(name: string, age: number)&#123;\n        super(name, age);\n        this.name = name; //子类中不能修改\n    &#125;\n&#125;\n\nconst p = new Person(&#39;孙悟空&#39;, 18);\np.name = &#39;猪八戒&#39;;// 不能修改\n\n\n\n\n属性存取器\n\n对于一些不希望被任意修改的属性，可以将其设置为private\n\n直接将其设置为private将导致无法再通过对象修改其中的属性\n\n我们可以在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的存取器\n\n读取属性的方法叫做setter方法，设置属性的方法叫做getter方法\n\n示例：\nclass Person&#123;\n    private _name: string;\n\n    constructor(name: string)&#123;\n        this._name = name;\n    &#125;\n\n    get name()&#123;\n        return this._name;\n    &#125;\n\n    set name(name: string)&#123;\n        this._name = name;\n    &#125;\n\n&#125;\n\nconst p1 = new Person(&#39;孙悟空&#39;);\nconsole.log(p1.name); // 通过getter读取name属性\np1.name = &#39;猪八戒&#39;; // 通过setter修改name属性\n\n\n\n\n静态属性\n\n静态属性（方法），也称为类属性。使用静态属性无需创建实例，通过类即可直接使用\n\n静态属性（方法）使用static开头\n\n示例：\nclass Tools&#123;\n    static PI = 3.1415926;\n    \n    static sum(num1: number, num2: number)&#123;\n        return num1 + num2\n    &#125;\n&#125;\n\nconsole.log(Tools.PI);\nconsole.log(Tools.sum(123, 456));\n\n\n\n\nthis\n\n在类中，使用this表示当前对象\n\n\n\n\n继承\n\n继承时面向对象中的又一个特性\n\n通过继承可以将其他类中的属性和方法引入到当前类中\n\n示例：\nclass Animal&#123;\n    name: string;\n    age: number;\n\n    constructor(name: string, age: number)&#123;\n        this.name = name;\n        this.age = age;\n    &#125;\n&#125;\n\nclass Dog extends Animal&#123;\n\n    bark()&#123;\n        console.log(`$&#123;this.name&#125;在汪汪叫！`);\n    &#125;\n&#125;\n\nconst dog = new Dog(&#39;旺财&#39;, 4);\ndog.bark();\n\n\n\n\n通过继承可以在不修改类的情况下完成对类的扩展\n\n重写\n\n发生继承时，如果子类中的方法会替换掉父类中的同名方法，这就称为方法的重写\n\n示例：\nclass Animal&#123;\n    name: string;\n    age: number;\n\n    constructor(name: string, age: number)&#123;\n        this.name = name;\n        this.age = age;\n    &#125;\n\n    run()&#123;\n        console.log(`父类中的run方法！`);\n    &#125;\n&#125;\n\nclass Dog extends Animal&#123;\n\n    bark()&#123;\n        console.log(`$&#123;this.name&#125;在汪汪叫！`);\n    &#125;\n\n    run()&#123;\n        console.log(`子类中的run方法，会重写父类中的run方法！`);\n    &#125;\n&#125;\n\nconst dog = new Dog(&#39;旺财&#39;, 4);\ndog.bark();\n\n\n在子类中可以使用super来完成对父类的引用(构造函数)\n\n\n\n\n抽象类（abstract class）\n\n抽象类是专门用来被其他类所继承的类，它只能被其他类所继承不能用来创建实例\nabstract class Animal&#123;\n    abstract run(): void;\n    bark()&#123;\n        console.log(&#39;动物在叫~&#39;);\n    &#125;\n&#125;\n\nclass Dog extends Animals&#123;\n    run()&#123;\n        console.log(&#39;狗在跑~&#39;);\n    &#125;\n&#125;\n\n\n使用abstract开头的方法叫做抽象方法，抽象方法没有方法体只能定义在抽象类中，继承抽象类时抽象方法必须要实现\n\n\n\n\n\n\n3、接口（Interface）接口的作用类似于抽象类，不同点在于接口中的所有方法和属性都是没有实值的，换句话说接口中的所有方法都是抽象方法。接口主要负责定义一个类的结构，接口可以去限制一个对象的接口，对象只有包含接口中定义的所有属性和方法时才能匹配接口。同时，可以让一个类去实现接口，实现接口时类中要保护接口中的所有属性。\n\n示例（检查对象类型）：\ninterface Person&#123;\n    name: string;\n    sayHello():void;\n&#125;\n\nfunction fn(per: Person)&#123;\n    per.sayHello();\n&#125;\n\nfn(&#123;name:&#39;孙悟空&#39;, sayHello() &#123;console.log(`Hello, 我是 $&#123;this.name&#125;`)&#125;&#125;);\n\n\n示例（实现）\ninterface Person&#123;\n    name: string;\n    sayHello():void;\n&#125;\n\nclass Student implements Person&#123;\n    constructor(public name: string) &#123;\n    &#125;\n\n    sayHello() &#123;\n        console.log(&#39;大家好，我是&#39;+this.name);\n    &#125;\n&#125;\n\n\n\n4、泛型（Generic）定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定），此时泛型便能够发挥作用。\n\n举个例子：\nfunction test(arg: any): any&#123;\n    return arg;\n&#125;\n\n\n上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的，由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的，首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型\n\n使用泛型：\nfunction test&lt;T&gt;(arg: T): T&#123;\n    return arg;\n&#125;\n\n\n这里的&lt;T&gt;就是泛型，T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型。所以泛型其实很好理解，就表示某个类型。\n\n那么如何使用上边的函数呢？\n\n方式一（直接使用）：\ntest(10)\n\n\n使用时可以直接传递参数使用，类型会由TS自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式\n\n\n方式二（指定类型）：\ntest&lt;number&gt;(10)\n\n\n也可以在函数后手动指定泛型\n\n\n\n\n可以同时指定多个泛型，泛型间使用逗号隔开：\nfunction test&lt;T, K&gt;(a: T, b: K): K&#123;\n    return b;\n&#125;\n\ntest&lt;number, string&gt;(10, &quot;hello&quot;);\n\n\n使用泛型时，完全可以将泛型当成是一个普通的类去使用\n\n\n类中同样可以使用泛型：\nclass MyClass&lt;T&gt;&#123;\n    prop: T;\n\n    constructor(prop: T)&#123;\n        this.prop = prop;\n    &#125;\n&#125;\n\n\n除此之外，也可以对泛型的范围进行约束\ninterface MyInter&#123;\n    length: number;\n&#125;\n\nfunction test&lt;T extends MyInter&gt;(arg: T): number&#123;\n    return arg.length;\n&#125;\n\n\n使用T extends MyInter表示泛型T必须是MyInter的子类，不一定非要使用接口类和抽象类同样适用。\n\n\n\n\n\n","slug":"青训营--Typescript快速入门","date":"2022-02-05T10:40:59.000Z","categories_index":"前端","tags_index":"字节跳动青训营","author_index":"会思想的苇草i"},{"id":"cbeef85e3ef827f236c8157203105c9a","title":"Web多媒体入门","content":"\n1、Web多媒体历史\n\n2、基础知识编码格式图像基本概念\n图像分辨率：用于确定组成一副图像的像素数据，就是指在水平和垂直方向上图像所具有的像素个数。如1920*1080（水平方向1920个像素、垂直方向1080个像素）\n图像深度︰图像深度是指存储每个像素所需要的比特数。图像深度决定了图像的每个像素可能的颜色数，或可能的灰度级数。例如, 彩色图像每个像素用R,G,B三个分量表示,每个分量用8位,像素深度为24位可以表示的颜色数目为2的24次方，既16777216个﹔一副单色图像存储每个像素需要8bit，则图像的像素深度为8位，最大灰度数目为2的8次方，既256个。（图片的分辨率越大不一定所占据的存储空间越大，还要根据其图片深度占用位数。）\n视频的基本概念\n\n分辨率：每一帧图像的分辨率（所有帧分辨率相同）\n帧率：视频单位时间内包含的视频帧的数量\n码率：指视频单位时间内传输的数据量，一般用kbps标签，即千位每秒\n\n视频帧的分类\n\nI帧I帧对视频压缩编码无需依赖其他的帧，只要有I帧自己的数据就能完全解码。\nP帧（前项预测编码帧）其解码要依赖前一帧，前一帧没解码自身也无法解码。\nB帧其解码不仅要依赖前一帧，还要根据其后面的帧内容。\n\n\n\n为什么要编码假设存在一个图片，分辨率是1920*1080，则其未压缩的占用空间为：1920108024&#x2F;8&#x3D;6220800Byte，大约5.9M；若帧率为30FPS，时长 90分钟，则占用空间为大小 933G，这样的存储空间是不能接受的。因此编码的意义是为了压缩视频视频大小，为了更好的进行视频传输和节约存储空间。视频是有很多冗余的，包括空间冗余、时间冗余、编码冗余、视觉冗余等。\n\n编码格式\n\n封装格式存储音视频、图片或字幕信息的容器，便于存储传输。\n\n\n多媒体元素和扩展APIvideo和audio元素在h5中，通过可以通过video标签和audio标签分别播放视频和音频。两种标签用法一样。\n&lt;video src=&quot;./video.mp4&quot; muted autoplay width=600 height=300 control&gt;\n&lt;/video&gt;\n\n&lt;video muted autoplay width=600 height=300 control&gt;\n    &lt;source src=&quot;./video.mp4&quot;&gt;\n    &lt;/source&gt;\n    &lt;source src=&quot;./video1.mp4&quot;&gt;\n    &lt;/source&gt;   \n&lt;/video&gt;\n&lt;!-- 可以写多个source标签 --&gt;\n\n元素方法\n\nplay：开始播放音频&#x2F;视频 \npause：暂停当前播放的音频&#x2F;视频 \nload：重新加载音频&#x2F;视频元素\ncanPlayType：检测浏览器是否能播放指定的音频&#x2F;视频类型 \naddTextTrack：向音频&#x2F;视频添加新的文本轨道\n\n\nplay方法是异步的，立刻暂停，即立刻调用pause方法会报错\n\n 元素属性\n\nautoplay：设置或返回是否在加载完成后随即播放 \ncontrol：设置或返回是否显示控件\ncurrentTime：设置或返回视频&#x2F;视频中的当前播放位置(以秒计)\nduration：返回当前视频&#x2F;音频的长度\nsrc：设置或返回视频&#x2F;音频的来源 \nvolume：设置或返回视频&#x2F;音频的音量TimeRanges对象\nbuffered：返回表示视频&#x2F;音频已缓存部分的 \nplaybackRate：设置或返回视频&#x2F;音频的播放速度\nerror：返回表示错误状态的MediaError对象\nreadyState：返回当前的就绪状态\n\n 元素事件\n\nloadedmetadata：浏览器开始加载视频&#x2F;音频时触发 \ncanplay：浏览器可以开始播放视频&#x2F;音频时触发\nplay：视频&#x2F;音频暂停时触发 \nplaying：在视频&#x2F;音频在因缓冲而暂停或停止后已就绪时触发 \npause：视频&#x2F;音频暂停时触发\ntimeupdate：用于播放位置改变时触发 \nseeking：用于开始跳跃到视频&#x2F;音频中的新位置时触发\nseeked：用于已跳跃到视频&#x2F;音频中的新位置时触发 \nwaiting：视频由于缓冲下一帧而停止时触发 \nended：播放列表已结束时触发\n\nvideo和audio标签的缺陷\n\n不支持直接播放hls、flv等格式视频\n视频资源的请求和加载无法通过代码控制\n分段加载（节约流量） \n清晰度无缝切换（增强用户体验） \n精确预加载（增强用户体验）\n\n\n\n媒体源扩展MSE(Media Source Extensions)\n\n无插件在Web端播放流媒体 \n支持播放hls、flv、mp4等格式视频 \n可实现视频分段加载、清晰度无缝切换、自适应码率、精确预加载等\n\n\n\n\nmp4和fmp4fmp4文件结构相比普通的MP4文件多了多个moof和moot文件，因此对流式播放支持得更加友好\n流媒体协议HLS全称是HTTP Live Streaming，是一个由Apple公司提出的基于HTTP的媒体流传输协议，用于实时音视频流的传输。目前HLS协议被广泛的应用于视频点播和直播领域。在IOS段，只要把M3U8的地址直接赋给video标签的src，就可以直接播放。\n\n\n3、应用场景Web多媒体：视频编辑、点播、直播、图片、云游戏、实时通信。\n\n4、总结和展望总结：\n\nflash &gt; H5 video&gt; MSE\n编码格式、封装格式、多媒体元素、流媒体协议\n应用场景\n\n新技术标准：\n\nWebassembly\nWebCodecs\nWebGPU\nWebVR、WebXR\n\n","slug":"青训营--Web多媒体入门","date":"2022-02-05T10:40:59.000Z","categories_index":"前端","tags_index":"字节跳动青训营","author_index":"会思想的苇草i"},{"id":"a4ba43b16c40c17ef43c675dbe1ccabe","title":"数据结构基础","content":"\n1、数据结构的研究内容\n数据结构主要研究的问题：如何合理地组织、高效地处理数据。\n\n数据结构研究的内容为：研究非数值计算的程序设计问题中计算机的操作对象以及它们之间的关系和操作。\n\n\n\n2、基本概念和术语\n数据：是客观事物的符号表示，所有能输入到计算机且能被计算机处理的各种符号的集合。如整数、图像等。\n数据元素：是数据的&#x3D;&#x3D;基本单位&#x3D;&#x3D;，通常把数据元素作为一个整体进行考虑和处理。如一名学生的信息记录。\n\n\n\n数据项：是组成数据的、有独立含义的、不可分割的&#x3D;&#x3D;最小单位&#x3D;&#x3D;。如学生的学号、姓名、性别等都是数据项。\n\n\n\n数据对象：是性质相同的数据元素的集合，是数据的一个子集。如整数数据对象，学生数据对象。\n\n&#x3D;&#x3D;数据≥数据对象＞数据元素＞数据项&#x3D;&#x3D;\n （学生表≥性质相同的学生信息＞学生信息＞学生具体信息）\n&#x3D;&#x3D;数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。&#x3D;&#x3D;\n\n逻辑结构 数据元素之间抽象化的相互关系，与数据的存储无关，独立于计算机，它是从具体问题抽象出来的数学模型。  \n\n存储结构 数据元素及其关系在计算机存储器中的存储方式。\n\n顺序存储结构：顺序存储结构是借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系，通常借助程序设计语言的数组类型来描述。\n\n链式存储结构：顺序存储结构要求所有的元素依次存放在一片连续的存储空间中， 而链式存储结构，无需占用一整块存储空间。但为了表示结点之间的关系， 需要给每个结点附加指针字段，用千存放后继元素的存储地址。所以链式存储结构通常借助于程序设计语言的指针类型来描述。\n\n\n\n\n数据类型： 在一种抽象设计语言中，变量所具有的数据种类。如C语言中的数组，结构体。\n抽象数据类型： 抽象就是抽取出实际问题的本质。抽象数据类型(Abstract Data Type, ADT) 一般指由用户定义的、表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称，具体包括三部分：数据对象、数据对象上关系的集合以及对数据对象的基本操作的集合。\n\n\n3、算法和算法分析算法是为了解决某类问题而规定的一个有限长的操作序列。算法的特性：\n\n有穷性\n确定性\n可行性\n输入\n输出\n\n评价算法优劣的基本标准：\n\n正确性\n可读性\n健壮性\n高效性\n\n时间复杂度\n一般情况下， 算法中基本语句重复执行的次数是问题规模n的某个函数j(n), 算法的时间量度记作 &#x3D;&#x3D;T(n)&#x3D; O(f{n))&#x3D;&#x3D; 它表示随问题规模n的增大，算法执行时间的增长率 和 j(n的) 增长率相同， 称做算法的渐近时间复杂度， 简称时间复杂度。(TimeComplexity)。常见时间复杂度耗费时间从小到大是：&#x3D;&#x3D;O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2^) &lt;O(n^3^)&lt;O(2^n^) &lt;O(n!)&lt;O(n^n^)&#x3D;&#x3D;\n空间复杂度是度量算法所需存储空间的大小（算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数）记做S(n)&#x3D;O(f(n))。\n\n时间复杂度例题：\n","slug":"数据结构（C语言版）-- 数据结构基础","date":"2022-01-31T02:10:54.000Z","categories_index":"前端","tags_index":"字节跳动青训营","author_index":"会思想的苇草i"},{"id":"296a334cba71a48abd93af36204eaa13","title":"数据可视化基础","content":"\n1、什么是数据可视化任何一种数据转化成为可视化形式的展现(比如关系图表、地图、词云或能够展示图表的表格，类型及其丰富)\n数据可视化分类\n\n科学可视化:科学实验数据的直观展示\n信息可视化:对抽象数据的直观展示\n可视化分析:对分析结果的直观展示, 交互式反馈, 通常是一个跨领域的方向\n\n数据可视化目的\n\n记录信息\n分析推理 \n证实假设\n交流思想\n\n举例：安斯库姆四重奏\n\n\n2、可视化设计原则和方法能够正确地表达数据中的信息而不产生偏差与歧义。\n糟糕的可视化呈现\n\n错误的可视化呈现\n\n常见的错误可视化\n\n透视失真：如果数字是由视觉元素表示的，那么他们应该与视觉元素的感知成正比；使用清晰、详细和彻底的标签，以避免图形失真和含糊不清。\n\n\n\n图形设计&amp;数据尺寸：图形的每一部分都会产生对其的视觉预期，这些预期往往决定了眼睛能看到的东西。错误的数据洞察，产生于在图形的某个地方发生的不正确的视觉预期推断。一个典型的例子:轴刻度，我们期望它从始至终能够保持连贯且一致。\n\n\n\n数据上下文：使用可视化展示数据时，应该将数据的上下文展示全面。\n\n \n可视化设计原则\n\n准确地展示数据 \n节省笔墨 \n节省空间 \n消除不必要的“无价值”图形 \n在最短时间内传达最多的信息 \n最大化数据墨水占比\n\nData-ink Ratio可视化图形由墨水和空白区域构成；数据墨水:可视化图形当中不可擦除的核心部分被称之为“数据墨水”；擦除数据墨水将减少图形所传达的信息量；数据墨水占比:可视化图形中用于展示核心数据的“ 墨水”在整体可视化所使用的墨水中的比例。绝大多数墨水都是数据墨水:用于绘制散点和对应标签。10% - 20%的墨水是非数据墨水:用于绘制坐标轴和刻度线, 并非所有的非数据墨水都没有用(例如坐标轴信息)。\n\n3、视觉感知可视化致力于外部认知，也就是说，怎样利用大脑以外的资源来增强大脑本身的认知能力。人类视觉系统观察的是变化，而不是绝对值，并且容易被边界吸引。在可视化设计中，设计者需要充分考虑到人类感知系统 的这些现象,以使得设计的可视化结果不会存在阻碍或误导用户的可视化元素。\n格式塔格式塔学派的理论核心是整体决定部分的性质，部分依从于整体。结构比元素重要，视觉形象首先作为统一的整体被认知。感知的事物大于眼睛见到的事物。格式塔理论( Gestalt Laws)较为系统的对人类如何发现图形元素之间的相关性进行了全面总结，被广泛的应用在了视觉设计当中。\n\n\n\n\n\n\n\n\n4、视觉编码将数据信息映射成可视化元素的技术。\n可视化符号(Mark) : 用于在可视化当中表现数据元素或元素之间的关联。当表示元素时Mark包括:点、线、面, 当表示关系时Mark包括:闭包、连线\n视觉通道(Channel) : 基于数据属性，控制可视化的符号展现样式，例如，点根据其所代表的数据属性的不同可有不同的形状与颜色。视觉通道有两种类型:\n\n数量通道(Magnitude Channel )用于显示数据的数值属性(定量&#x2F;定序)包括:位置、长度、角度、面积、深度、色温、饱和度、曲率、体积。\n标识通道( Identity Channel)用于显示数据的分类属性( 是什么&#x2F;在哪里)包括:空间区域、色向、动向、形状。\n\n不同的视觉编码在表达信息的作用和能力上有不同的特性当利用数量通道编码表示数值属性时:位置通道是最为精确的，其次是长度、角度、面积、深度、色温、饱和度、曲率、最后是体积。当利用标识通道表示分类属性时:划分空间区域最为有效，其后依次是色向、动向、形状。例如：\n\n\n\n\n\n5、面向前端的可视化工具介绍\nD3D3.js是用于数据可视化的开源的JavaScript函数库，被认为是最好的JavaScript可视化框架之一。D3js: Data-Driven Documents\nVegaVega是一种可视化语法。通过其声明式语言，可以用JSON格式描述可视化的视觉外观和交互行为，并使用Canvas或SVG生成视图。\nG2一套面向常规统计图表，以数据驱动的高交互可视化图形语法，具有高度的易用性和扩展性。使用G2，你可以无需关注图表各种繁琐的实现细节，一条语句即可使用Canvas或SVG构建出各种各样的可交互的统计图表。G2 可视化引擎\nEChartsECharts，一个使用JavaScript实现的开源可视化库，可以流畅的运行在PC和移动设备上，兼容当前绝大部分览器( IE9&#x2F;10&#x2F;11, Chrome, Firefox, Safari等)，底层依赖矢量图形库ZRender,提供直观，交互丰富，可高度个性化定制的数据可视化图表Apache ECharts\n\n","slug":"青训营--数据可视化基础","date":"2022-01-30T06:57:04.000Z","categories_index":"前端","tags_index":"字节跳动青训营","author_index":"会思想的苇草i"},{"id":"3de72e581df02b5836f80f8bb40e188c","title":"WEB开发的安全之旅","content":"\n1、假如你是一个hacker–攻击Cross-Site Scripting(XSS)XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。\nXSS主要利用了：\n\n盲目信任用户提交的内容\nsring-&gt;DOM\ndocument.wirte\nelement.innerHTML &#x3D; anyString\nSSR(user_data) &#x2F;&#x2F;伪代码\n\n特点\n\n通常难以从 UI 上感知（暗地里执行脚本）\n窃取用户的信息（cookie&#x2F;token）\n绘制UI（例如弹窗），诱骗用户点击&#x2F;填写表单\n\n\n类型：\n\nStored XSS\n\n\n\nReflected XSS\n\n不涉及数据库\n从URL上攻击\n\n\nDOM-based XSS\n\n不需要服务器的参与\n恶意攻击的发起 + 执行，全在浏览器完成  \n\n\nMutation-based XSS\n\n利用了浏览器渲染DOM的特性\n不同浏览器，会有区别（按照浏览器进行攻击）\n\n\n\n\n\nCross-site request forgert(CSRF)\n在用户不知情的前提下\n利用用户权限（cookie）\n构造指定 HTTP 请求，窃取或者修改用户敏感信息\n\n\n\nSQL injectionSSRF injection\n\nDenial of Service(Dos)通过某种方式（构造特定请求），导致服务器资源被显著消耗，来不及响应更多请求，导致请求被挤压，进而雪崩效应。\n正则表达式–贪婪模式\n\nDistributed DoS(DDoS)短时间内，基于大量僵尸设备的请求流量，服务器不能及时完成全部请求，导致请求堆积，进而雪崩效应，无法响应新请求。\n特点：\n\n直接访问IP\n任意API\n消耗大量带宽(耗尽)\n\n\n\n基于传输层–中间人攻击\n明文传输\n信息篡改不可知\n对方身份未认证\n\n\n\n2、假如你是一个开发者–防御XSS原则\n\n永远不要相信用户提交的任何类容\n不要将用户提交内容直接转化成dom\n\n现成工具\n\n前端\n主流框架默认防御XSS\ngoogle-closure-library\n\n\n服务端（node）\nDOMPurify\n\n\n\n注意\n\nstring-&gt;DOM\n\n上次svg（以为里面可以插入script标签）\n\n自定义跳转链接\n\n自定义样式\n\n\n\nConten Security Policy(CSP)\n拿些源被认为是安全的\n\n来自安全源的脚本可以执行，否则直接抛出错误\n\n对eval + inline script直接拒绝\n\n\n\nCSRF的防御tokeniframe攻击\nanti-pattern\n SameSite Cookie对比SameSite vs CORS\n\nSameSite\ncookie发送\ndomain vs 页面域名\n\n\nCORS\n资源读写\n资源域名 vs 页面域名\n白名单\n\n\n\n\ninject\n找到项目中查询SQL的地方\n使用 prepared statement原则\n最小权限原则\nsudo || root\n\n\n建立允许白名单 + 过滤\nrm\n\n\n对URL类型参数进行协议、域名、ip等限制\n访问内网  Regex Dos   不要写出贪婪匹配的方式，特别处理接口的的地方   拒绝使用用户提供的正则表达式\n\n\n\n\nDDos\n流量治理\n负载均衡\nAPI网关\nCDN\n\n\n快速自动扩容\n非核心服务降级\n\n\n传输层–防御中间人HTTPS\n\n可靠性:加密\n完整性:MAC验证\n不可抵赖性:数字签名\n\n完整性成也证书，败也证书，当签名算法不够健壮时，签名算法被暴力破解！\nHTTP Strict-Transport-Security(HSTS)\nSubresource Integrity( SRI)\n\n扩展：\n\n总结：\n安全无小事\n使用的依赖（npm package,设置是nodejs）可能会成为最薄弱的一环\nleft-pad事件\neslint-scope事件\nevent-stream事件\n\n\n保持学习心态\n\n","slug":"青训营--WEB开发的安全之旅","date":"2022-01-28T03:01:14.000Z","categories_index":"前端","tags_index":"字节跳动青训营","author_index":"会思想的苇草i"},{"id":"ce5090caf1cc811b128b2cdaa9bcbdd2","title":"Webpack知识体系","content":"\n1、什么是Webpackwebpack 是代码编译工具，有入口、出口、loader 和插件。webpack 是一个用于现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个依赖图(dependency graph)，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 bundle。\n本质上是一种前端资源编译、打包工具\n\n多份资源文件打包成一个Bundle \n支持Babel、Eslint、TS等 \n支持模块化处理css、图片等资源 \n支持HMR+开发服务器\n支持持续监听、持续构建 \n支持代码分离\n支持Tree-shaking\n支持Sourcemap\n\n\n\n2、使用Webpack示例\n\n核心流程\n\n模块化+一致性\n\n多个文件资源合并成一个，减少http请求数\n支持模块化开发 支持高级JS特性 \n支持Typescript、CoffeeScript方言\n统一图片、CSS、字体等其它资源的处理模型\nEtc…\n\n使用Webpack\n\n\n流程类:作用于流程中某个 or若干个环节，直接影响打包效果的配置项\n\n按使用频率：\n- entry、output\n- module、plugins\n- mode\n- watch、devServer、devtool\n\nWebpack配置官方文档\n处理CSS\n接入Babel\n生成HTML\n\n\n工具类:主流程之外，提供更多工程化能力的配置项\n\nHMR模块热替换\nTree-Shaking删除没有用到的代码\n\n\n3、Loader组件为了处理非标准JS资源，设计出资源翻译模块—— Loader，用于将资源翻译为标准JS使用Loader\n\n链式调用\n\nless-loader :实现less &#x3D;&gt; css的转换\ncss-loader:将CSS包装成类似module.exports &#x3D; “${css]”的内容，包装后的内容符合JavaScript语法\nstyle-loader : 将css模块包进require语句，并在运行时调用injectStyle等函数将内容注入到页面的style标签\n\n\n其它特性\n特点\n\n链式执行\n支持异步执行\n分normal、pitch两种模式\n\n常见Loader\n\n\n4、Plugin组件插件架构精髓：对扩展开放，对修改封闭\n\n钩子的核心信息∶\n\n时机:编译过程的特定节点， Webpack 会以钩子形式通知插件此刻正在发生什么事情;\n上下文:通过tapable提供的回调机制,以参数方式传递上下文信息;\n交互:在上下文参数对象中附带了很多存在side effect 的交互接口，插件可以通过这些接口改变\n\n\n\n5、如何学习Webpack\n入门应用  - 理解打包流程  - 熟练掌握常用配置项、Loader、插件的使用方法，能够灵活搭建集成Vue、React、Babel、Eslint、Less、Sass、图片处理等工具的 Webpack 环境  - 掌握常见脚手架工具的用法，例如:Vuo-cli、create-react-app、@angular&#x2F;cli\n进阶 - 理解Loader、Plugin机制,能够自行开发Webpack组件      - 理解常见性能优化手段,并能用于解决实际问题  - 理解前端工程化概念与生态现状\n大师级 - 阅读源码,理解Webpack编译、打包原理,甚至能够参与共建\n\n\n参考资料：Webpack5知识体系\n扩展：面试要掌握到什么程度？首先，网上很多相关面试,主要围绕三种主题︰\n\nLoader有什么作用、怎么写loader、常用loader有哪些？  - css-loader、style-loader、wue-loader、 file-loader.eslint-laader、babel-laader·\n插件有什么用，怎么写插件，插件原理？\nBundle、chunk、rmodule 分别是什么含义？\n\n","slug":"青训营--Webpack知识体系","date":"2022-01-27T14:36:23.000Z","categories_index":"前端","tags_index":"字节跳动青训营","author_index":"会思想的苇草i"},{"id":"c2bb75f6dd30000ed3be30fb34a8fb6a","title":"WebGL初识","content":"WebGL是什么？\nGPU ≠ WebGL ≠ 2D\nWebGL是浏览器上的OpenGL\n需要一定计算机图形学基础和线性代数基础\n\nWebGL（全写Web Graphics Library）是一种3D绘图协议，这种绘图技术标准允许把JavaScript和OpenGL ES 2.0结合在一起，通过增加OpenGL ES 2.0的一个JavaScript绑定，WebGL可以为HTML5 Canvas提供硬件3D加速渲染，这样Web开发人员就可以借助系统显卡来在浏览器里更流畅地展示3D场景和模型了，还能创建复杂的导航和数据视觉化。显然，WebGL技术标准免去了开发网页专用渲染插件的麻烦，可被用于创建具有复杂3D结构的网站页面，甚至可以用来设计3D网页游戏等等。\n\nModern Graphics System\n\n光栅（Raster）：几乎所有的现代图形系统都是基于光栅来绘制图形的，光栅就是指构成图像的像素阵列。\n像素（Pixel）：一个像素对应图像上的一个点，它通常保存图像上的某个具体位置的颜色等信息。\n帧缓存（Frame Buffer）：在绘图过程中，像素信息被存放于帧缓存中，帧缓存是一块内存地址。\nCPU（Central Processing Unit）：中央处理单元，负责逻辑计算。\nGPU（Graphics Processing Unit）：图形处理单元，负责图形计算。\n\n\n\nCPU vs GPUCPU和GPU的区别是CPU是电脑的中央处理器，在电脑中起着控制计算机运行的作用；GPU是一个附属型的处理器，主要处理计算机中与图形计算有关的工作，并将数据更好地呈现在显示器中。GPU由大量的小运算单元构成，每个运算单元只负责处理很简单的计算，每个运算单元彼此独立，因此所有计算可以并行处理。图形渲染的像素处理数量一般都是非常大的，但是每个像素的计算量却不大，所以GPU处理图形渲染就非常有优势。\n\nWebGL Startup\n\n创建WebGL上下文\n\n创建WebGL ProgramShaders（着色器：）Vertex Shader（顶点着色器）和Fragment Shader（片源着色器）\n\n将数据存入缓冲区\n\n将缓冲区数据读取到GPU\n\nGPU 执行 WebGL程序，输出结果\n\n\n\nWebGL的封装库-Mesh.js\n\nPolygons如何绘制一个多边形？\n\n3D Meshing3D的模型较为复杂，是在设计软件里先设计好再导出，而不是像2D一样实时计算。\n\nTransforms\n\n\n3D Matrix3D标准模型的四个齐次矩阵（mat4）\n\n投影矩阵 Projection Matrix\n模型矩阵 Model Matrix\n视图矩阵 View Matrix\n法向量矩阵 Normal Matrix\n\n\nRead More\nThe book of shaders\nMesh.js\nglsl-doodle\nSpriteJS\nThreeJS\n\n\n\n\n","slug":"青训营--WebGL初识","date":"2022-01-26T01:59:26.000Z","categories_index":"前端","tags_index":"字节跳动青训营","author_index":"会思想的苇草i"},{"id":"0182665cc415e72321b4209011c914e6","title":"Node.js与前端开发实战","content":"一、Node.js的应用场景1.前端工程化\nBundle：webpack, vite, esbuild, parcel\nUglify：uglifyjs\nTranspile：bablejs, typescript\n其他语言加入竞争：esbuild（go）, parcel（rust）, prisma\n现状：难以替代\n\n2.Web服务端应用\n学习曲线平缓，开发效率较高\n运行效率接近常见的编译语言\n社区生态丰富及工具链成熟(npm, V8 inspector)\n与前端结合的场景会有优势(SSR)\n现状：竞争激烈，Node.js有自己独特的优势\n\n3.Electron跨端桌面应用\n商业应用：vscode, slack, discord, zoom\n大型公司内的效率工具\n现状：大部分场景在选型时，都值得考虑\n\n4.Node.js在字节\nBFF应用、SSR应用，举例：Modern.js\n服务端应用，例如：头条搜索，西瓜视频，懂车帝\nElectron应用：飞连，飞书\n每年新增1000+ Node.js应用\n\n\n二、Node.js运行时结构结构：\n\nV8：JavaScript Runtime，诊断调试工具(inspector)\nlibuv：eventloop(事件循环)， syscall (系统调用)\n举例：用node-fetch发起请求时…\n\n特点：\n\n异步I&#x2F;O当Node.js执行I&#x2F;O操作时，会在响应返回后恢复操作，而不是阻塞线程并占用额外内存等待。\n\n单线程\n\n\n\nJS 单线程\n实际：JS线程+uv线程池+V8任务线程池+V8 Inspector线程\n\n\n优点：不用考虑多线程状态同步问题，也就不需要锁；同时还能比较高效地利用系统资源\n缺点：阻塞会产生更多负面影响\n解决办法：多进程或多线程\n\n\n\n\n跨平台\n\n\n跨平台(大部分功能、api)\nNode.js跨平台+JS无需编译环境(+ Web 跨平台+诊断工具跨平台)\n&#x3D;开发成本低(大部分场景无需担心跨平台问题)，整体学习成本低\n\n\n\n\n三、编写 Http Server安装Node.js\n\nMac,Linux推荐使用nvm。多版本管理。\nWindows推荐 nvm4w 或是官方安装包。\n安装慢，安装失败的情况，设置安装源NVM_NODEJS_ORG_MRROR&#x3D;https://npmmirror.com/mirrors/node nvm install 16\n\nHttp Server静态文件\nReact SSR\nDebugV8 Inspector：开箱即用、特性丰富强大、与前端开发一致、跨平台\n\nnode –inspect\nopen http://localhost:9229/json\n\n场景：\n\n查看console.log内容\nbreakpoint\n高CPU、死循环：cpuprofile\n高内存占用：heapsnapshot\n性能分析\n\n部署\n部署要解决的问题：\n\n守护进程：当进程退出时，重新拉起\n多进程：cluster便捷地利用多进程\n记录进程状态，用于诊断\n\n容器环境：\n\n通常有健康检查的手段，只需考虑多核 cpu 利用率即可\n\n\n四、延伸话题\nNode.js贡献代码\n编译Node.js\n诊断&#x2F;追踪\nWASM,NAPI\n\n\n\nNode.js下载\nNode.js 教程-菜鸟教程\n","slug":"青训营--Node.js与前端开发实战","date":"2022-01-25T03:09:55.000Z","categories_index":"前端","tags_index":"字节跳动青训营","author_index":"会思想的苇草i"},{"id":"79d011c4f922321d4bb1c1cdb5390980","title":"Http实用指南","content":"\n1、初识当我们在输入框输入信息后发生的事情：\nOSI是一个开放性的通信系统互连参考模型，它是一个定义得非常好的协议规范。OSI模型有7层结构，每层都可以有几个子层。 OSI的7层从上到下分别是 7 应用层 6 表示层 5 会话层 4 传输层 3 网络层 2 数据链路层 1 物理层 ；其中高层（即7、6、5、4层）定义了应用程序的功能，下面3层（即3、2、1层）主要面向通过网络的端到端，点到点的数据流。\n\n什么是HTTP：\n\n\n2、协议分析发展历程：\nHTTP&#x2F;1.1Method:\n\nSafe(安全的）:不会修改服务器的数据的方法GET  HEAD  OPTIONS\nldempotent(幂等)︰同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的所有safe的方法都是ldempotent 的GET HEAD OPTIONS PUT DELETE\n\n状态码：RESTful API：常用请求头：常用响应头：缓存：浏览器发起get请求，判断是否有缓存，首先看强缓存是否新鲜，如果可用就直接读取浏览器缓存，如果不可用，就看上一次响应resource中的ETag标签，没有就去上一次请求中的Last-Modified，如果Etag存在，就发起请求，请求头中带上if-None-Match, Last-Modified存在就发起请求，请求头中带上if-Modified-Since,server会进化成验证，如果是新的返回304，浏览器使用浏览器缓存，如果不是新的返回200，并返回最新信息。cookie：\nHTTP&#x2F;2更快、更稳定、更简单\n\n帧（frame）：HTTP&#x2F;2通信的最小单位，每个帧都包含帧头，至少也会标识当前帧所属的数据流，采用二进制编码。\n消息：与逻辑请求或响应消息对应的完整的一系列帧。\n数据流：已建立的连接内的双向字节流，可以承载一条或多条消息。\n\n 特性：\n\nHTTP&#x2F;2连接都是永久的，而且仅需要每个来源一个连接\n流控制：阻止发送方向接收方发送大量数据的机制 \n服务器推送\n\nHTTPS经过TSL&#x2F;SSL加密\n\n对称加密︰加密和解密都是使用同一个密钥\n非对称加密，加密和解密需要使用两个不同的密钥︰公钥(public key)和私钥(private key)\n\n\n3、常见场景静态资源：登录：跨域问题导致OPTIONS请求。\n约定俗成：https默认就是用的443这个端口号，所以可省略。（http默认端口号为80）\n跨域解决方案：\n\nCORS：\n\n\n\n代理服务器：\n\n\n\niframe\n\n\n\n向什么地址做了什么动作?使用POST方法；目标域名https : &#x2F;&#x2F;sso.toutiao.com；目标path &#x2F;quick_login&#x2F;v2&#x2F;\n携带了哪些信息，返回了哪些信息携带信息：Post body,数据格式为form；希望获取的数据格式为json；已有的cookie返回信息：数据格式json；种cookie的信息\n\n下一次进入页面为什么能记住登录态呢？–  登录鉴权\nSSO单点登录就是在多个系统中，用户只需一次登录，各个系统即可感知该用户已经登录。\n\n4、实际应用浏览器：node：HTTP&#x2F;HTTPS\n\n默认模块，无需安装其他依赖\n功能有限&#x2F;不是十分友好\n\n实战：常用的请求库：axios\n\n支持浏览器、node.js环境\n丰富的拦截器\n\n我们在生产环境中，还要关心用户的体验，我们希望用户有更优秀的体验效果，一方面是大家知道的性能优化，还有一点是在网络上做一些优化，比如用HTTP2，它的传输效率而是更高的，使用CDN，传输获取的数据是更快的等等。\n网络优化：\n稳定性：\n\n5、了解更多WebSocket：\n\n浏览器与服务器进行全双工通讯的网络技术\n典型场景：实时性高，例如聊天室\nURL使用ws:&#x2F;&#x2F;或wss:&#x2F;&#x2F;等开头\n\nQUIC：\n\n0-RTT建联（(首次建联除外)。\n类似TCP的可靠传输。\n类似TLS的加密传输，支持完美前向安全。\n用户空间的拥塞控制,最新的BBR算法。\n支持h2的基于流的多路复用,但没有TCP的HOL问题。\n前向纠错FEC。\n类似MPTCP的Connection migration。\n\n\n","slug":"青训营--HTTP实用指南","date":"2022-01-24T02:38:04.000Z","categories_index":"前端","tags_index":"字节跳动青训营","author_index":"会思想的苇草i"},{"id":"96f2401ef260a2fda3074e7c72b8a623","title":"前端动画实现","content":"1、动画的基本原理 什么是动画？\n动画是通过快速连续排列批次差异极小的连续图像来制造运动错觉和变化错觉的过程 ——维基百科关键词：\n\n快速\n连续排列\n彼此差异极小\n制造错觉\n\n动画的历史与发展：\n动画早在五千年前就存在了：\n\n常见的前端动画技术:Sprite 动画、CSS 动画、JS 动画、SVG 动画、WebGL 动画\n\n按应用分类:UI 动画、基于Web 的游戏动画和动画数据可视化\n\n\n历史上第一个网站：\n计算机动画原理：\n帧:连续变换的多张画面，其中的每一幅画面都是一帧。帧率:用于度量一定时间段内的帧数，通常的测量单位是FPS (frame persecond) 。帧率与人眼:一般每秒10-12帧人会认为画面是连贯的,这个现象称为视觉暂留。对于一些电脑动画和游戏来说低于30FPS会感受到明显卡顿，目前主流的屏幕、显卡输出为60FPS，效果会明显更流畅。空白的补全方式:\n\n补间动画:传统动画，主画师绘制关键帧，交给清稿部门,清稿部门的补间动画师补充关键帧进行交付。(类比到这里，补间动画师由浏览器来担任，如keyframe，transition)\n\n逐帧动画(Frame By Frame) :从词语来说意味着全片每一帧逐帧都是纯手绘。(如css 的steps实现精灵动画)\n\n\n\n2、前端动画分类CSS动画animation\n\nanimation-name : 指定应用的一系列动画，每个名称代表一个由@keyframes定义的动画序列\nanimation-duration : 制定一个动画周期的时长（默认为0秒，表示无动画）\nanimation-timing-function : 定义CSS动画在每一动画周期中执行的节奏\nanimation-delay : 定义动画于何时开始\nanimation-iteration-count : 定义动画在结束前运行的次数，可以是1次也可以是无限循环\nanimation-direction : 定义动画是否反向播放\nanimation-fill-mode : 设置CSS动画在执行之前和之后如何将样式应用于目标\nanimation-play-state : 定义一个动画是否运行或暂停\n\ntransform\n\ntranslate : 平移\nscale : 缩放\nrotate : 旋转\nskew : 倾斜\n\ntransition API\n\ntransition-property : 指定哪个或者哪些CSS属性用于过渡\ntransition-duration : 指定过度的时长\ntransition-timing-function : 指定一个函数,定义属性值怎么变化\ntransition-delay : 指定延迟\n\n@Keyframe\n\nfrom to\n百分比\n\nCSS动画总结：优点 : 简单、高效 声明式的 不依赖于主线程，采用硬件加速(GPU) 简单的控制keyframe animation 的播放盒暂停缺点 : 不能动态修改或定义动画内容 不同的动画无法实现同步 多个动画无法堆叠适用场景 : 简单的h5活动&#x2F;宣传页推荐库 : animation.css、shake.css\nsvg动画SVG动画的实现方式 SVG时基于XML的矢量图形描述语言，实现方式一般有以下三种：\n\nSMIL(同步多媒体集成语言)，原始的兼容性不好，不过多讨论\nJS: 一般是以下两个属性配合使用实现笔画效果。 stroke-dashoffset： | 需要填充的路径 stroke-dasharray： |  dash模式开始位置的偏移量\nCSS： 主要使用animation、transform、transition来实现动画，类似于css动画。\n\nsvg动画总结：优点：通过矢量元素实现动画，不同的屏幕下均可获得较好的清晰度。可以实现一些特殊的效果：描字，形变，墨水扩散等。缺点：使用方式较为复杂，计算量比较大，过多使用可能会带来性能问题。\nJS动画可以通过JS控制CSS的属性值，以实现动画，或者操作canvas上的API进行动画绘制。\nJS动画总结：\n优点：使用灵活，调节参数方便；可以进行多个状态的组合执行或联动。缺点：调优不如CSS简单；对于性能和兼容性差的浏览器，JS需要写很多适配代码。\n总结\n为UI 元素采用较小的独立状态时，使用CSS。\n在需要对动画进行大量控制时，使用JavaScript。\n在特定的场景下可以使用SVG，可以使用CSS或JS去操作SVG变化。\n\n\n3、实现前端动画JS动画函数封装：JavaScript动画应该通过requestAnimationFrame.该内置方法允许设置回调函数以在浏览器准备重绘时运行。通常这很快，但确切的时间取决于浏览器。当页面在后台时,根本没有重绘，所以回调不会运行:动画将被暂停并且不会消耗资源。\n\n// *@param draw &#123;function&#125; 绘制函数\n//  @param easing &#123;function&#125; 缓动函数\n//  @param duration &#123;number&#125; 持续时间\n\n function animate (&#123;easing, draw, duration&#125;) &#123;\n   let start = performance.now();\n   return new Promise(resolve =&gt; &#123;\n     requestAnimationFrame(function animate(time) &#123;\n       let timeFraction = (time - start) / duation;\n       if (timeFraction &gt; 1) timeFraction = 1;\n       let progress = easing(timeFraction);\n       draw(progress);\n       if(timeFraction &lt; 1) &#123;\n         requestAnimationFrame(animate);\n       &#125; else &#123;\n         resolve();\n       &#125;\n     &#125;)\n   &#125;)\n &#125;\n\n\ndraw绘制函数：可以把draw想象成一只画笔,随着函数的执行，这个画笔的函数会反复被调用，并传入当前执行的进度progress，progress是一个介于0-1的number数字。\n\neasing缓动函数缓动函数决定了时间在线性增长过程中，实际的执行进度的变化，这个变化可以是线性的，也可以是非线性的，或者多维度的。\n\nduration持续时间动画的持续时间，单位是毫秒（返回Promise的原因：动画可以是连续的，支持通过then函数或await进行顺序调用）\n\n\n\n4、工作实践动画代码示例：https://codepen.io/https://codesandbox.io/设计网站：https://dribbble.com/动画资源：SVG :\n\nSnap.svg-现代SVG图形的JavaScript库。\nSvg.js -用于操作和动画SVG的轻量级库。\n\njs :\n\nGSAP - JavaScript动画库。\nTweenJs - 一个简单但功能强大的JavaScript补间&#x2F;动画库。Create]S库套件的一部分。\nVelocity-加速的JavaScript动画。\n\ncss :\n\nAnimate.css - CSS动画的跨浏览器库。像一件简单的事情一样容易使用。\n\ncanvas :\n\nEaselJs - EaselS是一个用于在 HTML5中构建高性能交互式2D内容的库\nFabric.js -支持动画的JavaScript 画布库。\nPaper.js -矢量图形脚本的瑞士军刀- Scriptographer使用HTML5Canvas移植到JavaScript和浏览器。\nPixijs -使用最快、最灵活的2D WebGL渲染器创建精美的数字内容。\n\n","slug":"青训营--前端动画实现","date":"2022-01-21T08:11:16.000Z","categories_index":"前端","tags_index":"字节跳动青训营","author_index":"会思想的苇草i"},{"id":"daa70c85e66020d3179c9d18aed40c23","title":"响应式系统与React","content":"1、React的历史与应用 React的历史\n\n2010年Facebook在其php生态中引入了xhp框架，首次引入了组合式组件的思想，启发了后来的React的设计。\n2011年Jordan Walke创造了FaxJs,也就是后来的React原型:\n\n\n\n2013年React正式开源，在2013 Jsconf上Jordan Walke介绍了这款全新的框架:\n2012年在Facebook收购Instagram后，该Faxus项目在内部得到使用。Jordan walke基于FaxJs的经验，创造了React。\n2014年–今天生态大爆发.各种围绕 React的新工具&#x2F;新框架开始涌现…\n\n React的应用\n\n前端应用开发，如Facebook，Instagram,Netflix网页版。\n移动原生应用开发，如Instagram,Discord,Oculus。\n结合Electron，进行桌面应用开发。\n\n\n2、React的设计思路UI编程痛点\n\n状态更新 UI不会自动更新 需要手动地调用DOM进行更新\n欠缺基本的代码层面的封装和隔离 代码层面没有组件化\nUI之间的数据依赖关系 需要手动维护 如果依赖链路长 则会遇到”Callback Hell”\n\n响应式\n响应式编程\n\n状态更新，UI自动更新。“状态更新，UI不会自动更新，需要手动地调用DOM进行更新。”\n前端代码组件化，可复用，可封装。“欠缺基本的代码层面的封装和隔离，代码层面没有组件化。”\n状态之间的相互依赖关系，只需声明即可。“UI之间的数据依赖关系，需要手动维护，如果依赖链路长，则会遇到“Callback Hell”。”\n\n组件化：总结：\n\n组件时组件的组合&#x2F;原子组件\n组件内拥有状态，外部不可见\n父组件可将状态传入组件内部\n\n（当前价格属于Root节点；状态上升：状态归属于两个节点向上寻找到最近的祖宗节点。）\n组件设计：\n\n组件声明了状态和UI的映射。\n组件有Props&#x2F;State两种状态。\n“组件”可由其他组件拼装而成。\n\n\n3、React（hooks）的写法import React,&#123;useState&#125;from &#39;react&#39;;\nfunction Example()&#123;\n  return(\n    &lt;div&gt;\n        &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;\n        &lt;button onclick=&#123;()=&gt;setCount(count+1)&#125;&gt;Click me&lt;/button&gt;\n    &lt;/div&gt;\n  );\n&#125;\n\nimport React,&#123;useState,useEffect&#125;from &#39;react&#39;;\nfunction Example()&#123;\n  const[count,setCount]=useState(0);\n  useEffect(()=&gt;&#123;\n    document.title=&#39;You clicked $&#123;count&#125; times&#39;;\n  &#125;);\n  return(\n    &lt;div&gt;\n        &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;\n        &lt;button onclick=&#123;()=&gt;setCount(count+1)&#125;&gt;Click me&lt;/button&gt;\n    &lt;/div&gt;\n  );\n&#125;\n\n\n4、React的实现Problem：\n\nJSX不符合JS标准语法解决办法：转译。\n\n返回的JSX发生改变时，如何更新DOM解决办法：Virtual DOM(虚拟DOM)，Virtual DOM是一种用于和真实DOM同步,而在JS内存中维护的一个对象，它具有和DOM类似的树状结构，并和DOM可以建立一一对应的关系。它赋予了React声明式的API:您告诉React希望让U是什么状态，React就确保DOM匹配该状态。这使您可以从属性操作、事件处理和手动DOM更新这些在构建应用程序时认要的操作中解放出来。How to Diff:完美的最小Diff 算法,需要o(n^3)的复杂度。牺牲理论最小Diff，换取时间，得到了O(n)复杂度的算法:Heuristic O(n) Algorithm\n\nState&#x2F;Props更新时，要重新触发render函数\n\n\n\n5、React的状态管理库核心思想：解决了状态共享问题，但是会降低组件的复用性。状态机：\n\n6、应用级框架科普\nNEXT.JS硅谷明星创业公司Vercel的 React开发框架，稳定，开发体验好，支持Unbundled Dev , SWC等，其同样有Serverless—键部署平台帮助开发者快速完成部署。口号是” Let’s Make WebFaster”\n\nMODERN.JS字节跳动Web lnfra团队研发的全栈开发框架，内置了很多开箱即用的能力与最佳实践，可以减少很多调研选择工具的时间。\n\nBlitz无API思想的全栈开发框架，开发过程中无需写API调用与CRUD逻辑，适合前后端紧密结合的小团队项目。\n\n\n","slug":"青训营--响应式系统与React","date":"2022-01-21T07:55:49.000Z","categories_index":"前端","tags_index":"字节跳动青训营","author_index":"会思想的苇草i"},{"id":"c724a6391cb1c094df5a91070462b271","title":"前端必须知道的开发调试知识","content":"1、Bug和Debug1.1、Bug的产生Bug一词的原意是臭虫或虫子。第一代计算机是由许多庞大的真空管组成，并利用大量的电力来使真空管发光，引得一只小虫子Bug钻进了一支真空管内，导致整个计算机无法工作。研究人员费了半天时间，总算发现原因所在，把这只小虫子从真空管中取出后，计算机又恢复正常。后来，Bug这个名词就沿用下来。\n1.2、前端Debug的特点\n多平台浏览器、nodejs、小程序、桌面应用…\n\n多环境本地开发环境、线上环境…\n\n多工具chrome、devTools、Charles、Spy-Debugger、vConsole…\n\n多技巧Console、BreakPoint、sourceMap、代理…\n\n\n2、Chrome DevTools2.1、Chrome DevTools–Element工具栏页面上右键–&gt;检查工具，或者直接F12键显示出来。\n 动态修改元素和样式\n\n点击.cls开启动态修改元素的class\n输入字符串可以动态的给元素添加类名\n勾选&#x2F;取消类名可以动态的查看类名生效效果\n点击具体的样式值（字号、颜色、宽度高度等）可以进行编辑，浏览器内容区域实时预览\nComputed下点击样式里的箭头可以跳转到styles面板中的CSS规则\n\n伪类样式的修改：元素处右键，点击Force state，再点击：hover，样式就出来了。点击.cls前面的:hov，选择：hover，样式就出来了。元素样式特别多时：Computed下点击样式里的箭头可以跳转到styles面板中的CSS规则。关于截图：选中元素，右键，capture node screenshot截图。\n2.2、Chrome DevTools–Console日志工具栏console日志工具栏是我们在写js代码时用到的最多的，我们可以在js代码中插入相应的语句，在devTools中查看相应的输入日志，在函数的不同阶段插入不同的console可以帮助我们观察到函数不同阶段变量的变化，帮助我们找出问题。\n\nconsole.log 日志打印 灰色是字符串 蓝色数字number\nconsole.warn  输出警告信息（黄色）\nconsole.error 输出错误信息（红色）\nconsole.debug 调试（蓝色）\nconsole.info info函数里放的是调试信息\nconsole.table 具象化展示json和数组数据\nconsole.dir 展示节点的属性\n占位符 %S 字符串占位符 %O 对象占位符 %C 样式占位符 在字符串之前添加样式，更加突出主题信息 \n\n2.3、Chrome DevTools–Sources面板Sources面板组成:在调试中，我们可以通过Sources面板看到网页的源代码，在右边的工具栏中可以查看监听、断点、作用域、调用栈等等信息。进入断点时，鼠标移到变量上可以查看数值，有点像后端IDE调试代码的感觉。 另外我们可以点击行号前面新增断点，也可以直接在程序中写上debugger。可以通过鼠标移动监听变量也可以通过watch方法监听变量。由于Sources面板可以直接看到源代码，那么就引出了安全性的问题，一般我们打开网站时看到的一般是处理过的。有的是压缩混淆过的，替换了变量名并压缩成一行，这种可以点击{}按钮进行格式化，而有的直接看不见。\n调试时为了保持客户端代码可读性和可调试性，可以使用Source Maps(源码映射)将源代码映射到已编译的代码。打包的时候生成Source map文件，上线前把文件上传到自己内网的错误监控平台，产生错误的时候就可以看到对应的映射。\n2.4、Chrome DevTools–Performance面板Performance面板组成：当我们对网站性能要求比较高的时候，可以在performance面板中查看每一帧。每一毫秒中执行了什么，汇总信息查看加载某一个模块花费了多少时间。\n2.5、Chrome DevTools–NetWork面板NetWork面板组成：Network面板里面可以看到所有的网络请求信息，进行抓包操作，禁止从cache中加载资源，限制带宽模拟弱网环境等等。选中一项网络请求信息，可以查看该请求的详细信息，比如请求行、请求头、响应行、响应头和响应体等等。直观地看到数据包中的原始内容，从而排除是否是自己网页渲染出了bug。\n2.6、Chrome DevTools–ApplicationApplication组成：在Application面板里可以检查和修改Storage(存储)、Databases(数据库)和Caches(缓存)。 在storage中可以点击clear site data 清除该网站的数据。\n3、移动端H5调试3.1、真机调试真机调试时，如果使用有线连接非常不方便，建议直接扫码。可以使用Fehelper插件（推荐）将网站生成二维码，在局域网内里可以用手机直接扫码查看网站。\n3.2、使用代理工具调试\n3.3、常用工具：\n4、常用调试技巧4.1、线上及时修改4.2、利用代理解决开发阶段的跨域问题\n4.3、启用本地source map\n4.4、小黄鸭调试大法“对鸭讲码”，帮助自己再次理清代码。\n\n总结这次的《前端必须知道的开发调试知识》一课属实受益匪浅，因为接触前端不久，用到这些方法不多，但是通过这次课程了解到许多的调试方法和技巧，以后会多多实践！Knowledge has no limit！（附Chrome DevTools手册文档）Chrome DevTools\n","slug":"青训营--前端开发调试知识","date":"2022-01-17T15:35:19.000Z","categories_index":"前端","tags_index":"字节跳动青训营","author_index":"会思想的苇草i"},{"id":"9e5f4d79310e12911a75fefd0392a14d","title":"C++_STL_常用算法","content":"\nC++ STL-常用算法概述:\n\n算法主要是由头文件&lt;algorithm&gt; &lt;functional&gt; &lt;numeric&gt;组成。\n\n&lt;algorithm&gt;是所有 STL 头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等\n\n&lt;numeric&gt;体积很小，只包括几个在序列上面进行简单数学运算的模板函数\n\n&lt;functional&gt;定义了一些模板类,用以声明函数对象。\n\n\n1 常用遍历算法学习目标：\n\n掌握常用的遍历算法\n\n算法简介：\n\nfor_each &#x2F;&#x2F;遍历容器\ntransform &#x2F;&#x2F;搬运容器到另一个容器中\n\n1.1 for_each功能描述：\n\n实现遍历容器\n\n函数原型：\n\nfor_each(iterator beg, iterator end, _func);  \n&#x2F;&#x2F; 遍历算法 遍历容器元素\n&#x2F;&#x2F; beg 开始迭代器\n&#x2F;&#x2F; end 结束迭代器\n&#x2F;&#x2F; _func 函数或者函数对象\n\n\n示例：\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\n//普通函数\nvoid print01(int val)\n&#123;\n    cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n&#125;\n//函数对象\nclass print02\n&#123;\n public:\n    void operator()(int val)\n    &#123;\n        cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\n//for_each算法基本用法\nvoid test01() &#123;\n\n    vector&lt;int&gt; v;\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        v.push_back(i);\n    &#125;\n\n    //遍历算法\n    for_each(v.begin(), v.end(), print01);\n    cout &lt;&lt; endl;\n\n    for_each(v.begin(), v.end(), print02());\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：for_each 在实际开发中是最常用遍历算法，需要熟练掌握\n1.2 transform功能描述：\n\n搬运容器到另一个容器中\n\n函数原型：\n\ntransform(iterator beg1, iterator end1, iterator beg2, _func);\n\n&#x2F;&#x2F;beg1 源容器开始迭代器\n&#x2F;&#x2F;end1 源容器结束迭代器\n&#x2F;&#x2F;beg2 目标容器开始迭代器\n&#x2F;&#x2F;_func 函数或者函数对象\n示例：\n#include&lt;vector&gt;\n#include&lt;algorithm&gt;\n\n//常用遍历算法  搬运 transform\n\nclass TransForm\n&#123;\npublic:\n    int operator()(int val)\n    &#123;\n        return val;\n    &#125;\n\n&#125;;\n\nclass MyPrint\n&#123;\npublic:\n    void operator()(int val)\n    &#123;\n        cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt;v;\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        v.push_back(i);\n    &#125;\n\n    vector&lt;int&gt;vTarget; //目标容器\n\n    vTarget.resize(v.size()); // 目标容器需要提前开辟空间\n\n    transform(v.begin(), v.end(), vTarget.begin(), TransForm());\n\n    for_each(vTarget.begin(), vTarget.end(), MyPrint());\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结： 搬运的目标容器必须要提前开辟空间，否则无法正常搬运\n2 常用查找算法学习目标：\n\n掌握常用的查找算法\n\n算法简介：\n\nfind &#x2F;&#x2F;查找元素\nfind_if &#x2F;&#x2F;按条件查找元素\nadjacent_find &#x2F;&#x2F;查找相邻重复元素\nbinary_search &#x2F;&#x2F;二分查找法\ncount &#x2F;&#x2F;统计元素个数\ncount_if &#x2F;&#x2F;按条件统计元素个数\n\n2.1 find功能描述：\n\n查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器 end()\n\n函数原型：\n\nfind(iterator beg, iterator end, value);  \n&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置\n&#x2F;&#x2F; beg 开始迭代器\n&#x2F;&#x2F; end 结束迭代器\n&#x2F;&#x2F; value 查找的元素\n\n\n示例：\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\nvoid test01() &#123;\n\n    vector&lt;int&gt; v;\n    for (int i = 0; i &lt; 10; i++) &#123;\n        v.push_back(i + 1);\n    &#125;\n    //查找容器中是否有 5 这个元素\n    vector&lt;int&gt;::iterator it = find(v.begin(), v.end(), 5);\n    if (it == v.end())\n    &#123;\n        cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl;\n    &#125;\n&#125;\n\nclass Person &#123;\npublic:\n    Person(string name, int age)\n    &#123;\n        this-&gt;m_Name = name;\n        this-&gt;m_Age = age;\n    &#125;\n    //重载==\n    bool operator==(const Person&amp; p)\n    &#123;\n        if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)\n        &#123;\n            return true;\n        &#125;\n        return false;\n    &#125;\n\npublic:\n    string m_Name;\n    int m_Age;\n&#125;;\n\nvoid test02() &#123;\n\n    vector&lt;Person&gt; v;\n\n    //创建数据\n    Person p1(&quot;aaa&quot;, 10);\n    Person p2(&quot;bbb&quot;, 20);\n    Person p3(&quot;ccc&quot;, 30);\n    Person p4(&quot;ddd&quot;, 40);\n\n    v.push_back(p1);\n    v.push_back(p2);\n    v.push_back(p3);\n    v.push_back(p4);\n\n    vector&lt;Person&gt;::iterator it = find(v.begin(), v.end(), p2);\n    if (it == v.end())\n    &#123;\n        cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;\n    &#125;\n&#125;\n\n总结： 利用 find 可以在容器中找指定的元素，返回值是迭代器\n2.2 find_if功能描述：\n\n按条件查找元素\n\n函数原型：\n\nfind_if(iterator beg, iterator end, _Pred);  \n&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置\n&#x2F;&#x2F; beg 开始迭代器\n&#x2F;&#x2F; end 结束迭代器\n&#x2F;&#x2F; _Pred 函数或者谓词（返回 bool 类型的仿函数）\n\n\n示例：\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n\n//内置数据类型\nclass GreaterFive\n&#123;\npublic:\n    bool operator()(int val)\n    &#123;\n        return val &gt; 5;\n    &#125;\n&#125;;\n\nvoid test01() &#123;\n\n    vector&lt;int&gt; v;\n    for (int i = 0; i &lt; 10; i++) &#123;\n        v.push_back(i + 1);\n    &#125;\n\n    vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());\n    if (it == v.end()) &#123;\n        cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;\n    &#125;\n    else &#123;\n        cout &lt;&lt; &quot;找到大于5的数字:&quot; &lt;&lt; *it &lt;&lt; endl;\n    &#125;\n&#125;\n\n//自定义数据类型\nclass Person &#123;\npublic:\n    Person(string name, int age)\n    &#123;\n        this-&gt;m_Name = name;\n        this-&gt;m_Age = age;\n    &#125;\npublic:\n    string m_Name;\n    int m_Age;\n&#125;;\n\nclass Greater20\n&#123;\npublic:\n    bool operator()(Person &amp;p)\n    &#123;\n        return p.m_Age &gt; 20;\n    &#125;\n\n&#125;;\n\nvoid test02() &#123;\n\n    vector&lt;Person&gt; v;\n\n    //创建数据\n    Person p1(&quot;aaa&quot;, 10);\n    Person p2(&quot;bbb&quot;, 20);\n    Person p3(&quot;ccc&quot;, 30);\n    Person p4(&quot;ddd&quot;, 40);\n\n    v.push_back(p1);\n    v.push_back(p2);\n    v.push_back(p3);\n    v.push_back(p4);\n\n    vector&lt;Person&gt;::iterator it = find_if(v.begin(), v.end(), Greater20());\n    if (it == v.end())\n    &#123;\n        cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;\n    &#125;\n&#125;\n\nint main() &#123;\n\n    //test01();\n\n    test02();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：find_if 按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略\n2.3 adjacent_find功能描述：\n\n查找相邻重复元素\n\n函数原型：\n\nadjacent_find(iterator beg, iterator end);  \n&#x2F;&#x2F; 查找相邻重复元素,返回相邻元素的第一个位置的迭代器\n&#x2F;&#x2F; beg 开始迭代器\n&#x2F;&#x2F; end 结束迭代器\n\n\n示例：\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt; v;\n    v.push_back(1);\n    v.push_back(2);\n    v.push_back(5);\n    v.push_back(2);\n    v.push_back(4);\n    v.push_back(4);\n    v.push_back(3);\n\n    //查找相邻重复元素\n    vector&lt;int&gt;::iterator it = adjacent_find(v.begin(), v.end());\n    if (it == v.end()) &#123;\n        cout &lt;&lt; &quot;找不到!&quot; &lt;&lt; endl;\n    &#125;\n    else &#123;\n        cout &lt;&lt; &quot;找到相邻重复元素为:&quot; &lt;&lt; *it &lt;&lt; endl;\n    &#125;\n&#125;\n\n总结：面试题中如果出现查找相邻重复元素，记得用 STL 中的 adjacent_find 算法\n2.4 binary_search功能描述：\n\n查找指定元素是否存在\n\n函数原型：\n\nbool binary_search(iterator beg, iterator end, value);  \n&#x2F;&#x2F; 查找指定的元素，查到 返回 true 否则 false\n&#x2F;&#x2F; 注意: 在无序序列中不可用\n&#x2F;&#x2F; beg 开始迭代器\n&#x2F;&#x2F; end 结束迭代器\n&#x2F;&#x2F; value 查找的元素\n\n\n示例：\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt;v;\n\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        v.push_back(i);\n    &#125;\n    //二分查找\n    bool ret = binary_search(v.begin(), v.end(),2);\n    if (ret)\n    &#123;\n        cout &lt;&lt; &quot;找到了&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;\n    &#125;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列\n2.5 count功能描述：\n\n统计元素个数\n\n函数原型：\n\ncount(iterator beg, iterator end, value);  \n&#x2F;&#x2F; 统计元素出现次数\n&#x2F;&#x2F; beg 开始迭代器\n&#x2F;&#x2F; end 结束迭代器\n&#x2F;&#x2F; value 统计的元素\n\n\n示例：\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\n//内置数据类型\nvoid test01()\n&#123;\n    vector&lt;int&gt; v;\n    v.push_back(1);\n    v.push_back(2);\n    v.push_back(4);\n    v.push_back(5);\n    v.push_back(3);\n    v.push_back(4);\n    v.push_back(4);\n\n    int num = count(v.begin(), v.end(), 4);\n\n    cout &lt;&lt; &quot;4的个数为： &quot; &lt;&lt; num &lt;&lt; endl;\n&#125;\n\n//自定义数据类型\nclass Person\n&#123;\npublic:\n    Person(string name, int age)\n    &#123;\n        this-&gt;m_Name = name;\n        this-&gt;m_Age = age;\n    &#125;\n    bool operator==(const Person &amp; p)\n    &#123;\n        if (this-&gt;m_Age == p.m_Age)\n        &#123;\n            return true;\n        &#125;\n        else\n        &#123;\n            return false;\n        &#125;\n    &#125;\n    string m_Name;\n    int m_Age;\n&#125;;\n\nvoid test02()\n&#123;\n    vector&lt;Person&gt; v;\n\n    Person p1(&quot;刘备&quot;, 35);\n    Person p2(&quot;关羽&quot;, 35);\n    Person p3(&quot;张飞&quot;, 35);\n    Person p4(&quot;赵云&quot;, 30);\n    Person p5(&quot;曹操&quot;, 25);\n\n    v.push_back(p1);\n    v.push_back(p2);\n    v.push_back(p3);\n    v.push_back(p4);\n    v.push_back(p5);\n\n    Person p(&quot;诸葛亮&quot;,35);\n\n    int num = count(v.begin(), v.end(), p);\n    cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;\n&#125;\nint main() &#123;\n\n    //test01();\n\n    test02();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结： 统计自定义数据类型时候，需要配合重载 operator==\n2.6 count_if功能描述：\n\n按条件统计元素个数\n\n函数原型：\n\ncount_if(iterator beg, iterator end, _Pred);  \n&#x2F;&#x2F; 按条件统计元素出现次数\n&#x2F;&#x2F; beg 开始迭代器\n&#x2F;&#x2F; end 结束迭代器\n&#x2F;&#x2F; _Pred 谓词\n\n\n示例：\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nclass Greater4\n&#123;\npublic:\n    bool operator()(int val)\n    &#123;\n        return val &gt;= 4;\n    &#125;\n&#125;;\n\n//内置数据类型\nvoid test01()\n&#123;\n    vector&lt;int&gt; v;\n    v.push_back(1);\n    v.push_back(2);\n    v.push_back(4);\n    v.push_back(5);\n    v.push_back(3);\n    v.push_back(4);\n    v.push_back(4);\n\n    int num = count_if(v.begin(), v.end(), Greater4());\n\n    cout &lt;&lt; &quot;大于4的个数为： &quot; &lt;&lt; num &lt;&lt; endl;\n&#125;\n\n//自定义数据类型\nclass Person\n&#123;\npublic:\n    Person(string name, int age)\n    &#123;\n        this-&gt;m_Name = name;\n        this-&gt;m_Age = age;\n    &#125;\n\n    string m_Name;\n    int m_Age;\n&#125;;\n\nclass AgeLess35\n&#123;\npublic:\n    bool operator()(const Person &amp;p)\n    &#123;\n        return p.m_Age &lt; 35;\n    &#125;\n&#125;;\nvoid test02()\n&#123;\n    vector&lt;Person&gt; v;\n\n    Person p1(&quot;刘备&quot;, 35);\n    Person p2(&quot;关羽&quot;, 35);\n    Person p3(&quot;张飞&quot;, 35);\n    Person p4(&quot;赵云&quot;, 30);\n    Person p5(&quot;曹操&quot;, 25);\n\n    v.push_back(p1);\n    v.push_back(p2);\n    v.push_back(p3);\n    v.push_back(p4);\n    v.push_back(p5);\n\n    int num = count_if(v.begin(), v.end(), AgeLess35());\n    cout &lt;&lt; &quot;小于35岁的个数：&quot; &lt;&lt; num &lt;&lt; endl;\n&#125;\n\n\nint main() &#123;\n\n    //test01();\n\n    test02();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：按值统计用 count，按条件统计用 count_if\n3 常用排序算法学习目标：\n\n掌握常用的排序算法\n\n算法简介：\n\nsort &#x2F;&#x2F;对容器内元素进行排序\nrandom_shuffle &#x2F;&#x2F;洗牌 指定范围内的元素随机调整次序\nmerge  &#x2F;&#x2F; 容器元素合并，并存储到另一容器中\nreverse &#x2F;&#x2F; 反转指定范围的元素\n\n3.1 sort功能描述：\n\n对容器内元素进行排序\n\n函数原型：\n\nsort(iterator beg, iterator end, _Pred);  \n&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置\n&#x2F;&#x2F; beg 开始迭代器\n&#x2F;&#x2F; end 结束迭代器\n&#x2F;&#x2F; _Pred 谓词\n\n\n示例：\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nvoid myPrint(int val)\n&#123;\n    cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n&#125;\n\nvoid test01() &#123;\n    vector&lt;int&gt; v;\n    v.push_back(10);\n    v.push_back(30);\n    v.push_back(50);\n    v.push_back(20);\n    v.push_back(40);\n\n    //sort默认从小到大排序\n    sort(v.begin(), v.end());\n    for_each(v.begin(), v.end(), myPrint);\n    cout &lt;&lt; endl;\n\n    //从大到小排序\n    sort(v.begin(), v.end(), greater&lt;int&gt;());\n    for_each(v.begin(), v.end(), myPrint);\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：sort 属于开发中最常用的算法之一，需熟练掌握\n3.2 random_shuffle功能描述：\n\n洗牌 指定范围内的元素随机调整次序\n\n函数原型：\n\nrandom_shuffle(iterator beg, iterator end);  \n&#x2F;&#x2F; 指定范围内的元素随机调整次序\n&#x2F;&#x2F; beg 开始迭代器\n&#x2F;&#x2F; end 结束迭代器\n\n\n示例：\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include &lt;ctime&gt;\n\nclass myPrint\n&#123;\npublic:\n    void operator()(int val)\n    &#123;\n        cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\nvoid test01()\n&#123;\n    srand((unsigned int)time(NULL));\n    vector&lt;int&gt; v;\n    for(int i = 0 ; i &lt; 10;i++)\n    &#123;\n        v.push_back(i);\n    &#125;\n    for_each(v.begin(), v.end(), myPrint());\n    cout &lt;&lt; endl;\n\n    //打乱顺序\n    random_shuffle(v.begin(), v.end());\n    for_each(v.begin(), v.end(), myPrint());\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：random_shuffle 洗牌算法比较实用，使用时记得加随机数种子\n3.3 merge功能描述：\n\n两个容器元素合并，并存储到另一容器中\n\n函数原型：\n\nmerge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  \n&#x2F;&#x2F; 容器元素合并，并存储到另一容器中\n&#x2F;&#x2F; 注意: 两个容器必须是有序的\n&#x2F;&#x2F; beg1 容器 1 开始迭代器&#x2F;&#x2F; end1 容器 1 结束迭代器&#x2F;&#x2F; beg2 容器 2 开始迭代器&#x2F;&#x2F; end2 容器 2 结束迭代器&#x2F;&#x2F; dest 目标容器开始迭代器\n\n\n示例：\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nclass myPrint\n&#123;\npublic:\n    void operator()(int val)\n    &#123;\n        cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt; v1;\n    vector&lt;int&gt; v2;\n    for (int i = 0; i &lt; 10 ; i++)\n    &#123;\n        v1.push_back(i);\n        v2.push_back(i + 1);\n    &#125;\n\n    vector&lt;int&gt; vtarget;\n    //目标容器需要提前开辟空间\n    vtarget.resize(v1.size() + v2.size());\n    //合并  需要两个有序序列\n    merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vtarget.begin());\n    for_each(vtarget.begin(), vtarget.end(), myPrint());\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：merge 合并的两个容器必须的有序序列\n3.4 reverse功能描述：\n\n将容器内元素进行反转\n\n函数原型：\n\nreverse(iterator beg, iterator end);  \n&#x2F;&#x2F; 反转指定范围的元素\n&#x2F;&#x2F; beg 开始迭代器\n&#x2F;&#x2F; end 结束迭代器\n\n\n示例：\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nclass myPrint\n&#123;\npublic:\n    void operator()(int val)\n    &#123;\n        cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt; v;\n    v.push_back(10);\n    v.push_back(30);\n    v.push_back(50);\n    v.push_back(20);\n    v.push_back(40);\n\n    cout &lt;&lt; &quot;反转前： &quot; &lt;&lt; endl;\n    for_each(v.begin(), v.end(), myPrint());\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;反转后： &quot; &lt;&lt; endl;\n\n    reverse(v.begin(), v.end());\n    for_each(v.begin(), v.end(), myPrint());\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：reverse 反转区间内元素，面试题可能涉及到\n4 常用拷贝和替换算法学习目标：\n\n掌握常用的拷贝和替换算法\n\n算法简介：\n\ncopy &#x2F;&#x2F; 容器内指定范围的元素拷贝到另一容器中\nreplace &#x2F;&#x2F; 将容器内指定范围的旧元素修改为新元素\nreplace_if  &#x2F;&#x2F; 容器内指定范围满足条件的元素替换为新元素\nswap &#x2F;&#x2F; 互换两个容器的元素\n\n4.1 copy功能描述：\n\n容器内指定范围的元素拷贝到另一容器中\n\n函数原型：\n\ncopy(iterator beg, iterator end, iterator dest);  \n&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置\n&#x2F;&#x2F; beg 开始迭代器\n&#x2F;&#x2F; end 结束迭代器\n&#x2F;&#x2F; dest 目标起始迭代器\n\n\n示例：\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nclass myPrint\n&#123;\npublic:\n    void operator()(int val)\n    &#123;\n        cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt; v1;\n    for (int i = 0; i &lt; 10; i++) &#123;\n        v1.push_back(i + 1);\n    &#125;\n    vector&lt;int&gt; v2;\n    v2.resize(v1.size());\n    copy(v1.begin(), v1.end(), v2.begin());\n\n    for_each(v2.begin(), v2.end(), myPrint());\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：利用 copy 算法在拷贝时，目标容器记得提前开辟空间\n4.2 replace功能描述：\n\n将容器内指定范围的旧元素修改为新元素\n\n函数原型：\n\nreplace(iterator beg, iterator end, oldvalue, newvalue);  \n&#x2F;&#x2F; 将区间内旧元素 替换成 新元素\n&#x2F;&#x2F; beg 开始迭代器\n&#x2F;&#x2F; end 结束迭代器\n&#x2F;&#x2F; oldvalue 旧元素\n&#x2F;&#x2F; newvalue 新元素\n\n\n示例：\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nclass myPrint\n&#123;\npublic:\n    void operator()(int val)\n    &#123;\n        cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt; v;\n    v.push_back(20);\n    v.push_back(30);\n    v.push_back(20);\n    v.push_back(40);\n    v.push_back(50);\n    v.push_back(10);\n    v.push_back(20);\n\n    cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl;\n    for_each(v.begin(), v.end(), myPrint());\n    cout &lt;&lt; endl;\n\n    //将容器中的20 替换成 2000\n    cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl;\n    replace(v.begin(), v.end(), 20,2000);\n    for_each(v.begin(), v.end(), myPrint());\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：replace 会替换区间内满足条件的元素\n4.3 replace_if功能描述:\n\n将区间内满足条件的元素，替换成指定元素\n\n函数原型：\n\nreplace_if(iterator beg, iterator end, _pred, newvalue);  \n&#x2F;&#x2F; 按条件替换元素，满足条件的替换成指定元素\n&#x2F;&#x2F; beg 开始迭代器\n&#x2F;&#x2F; end 结束迭代器\n&#x2F;&#x2F; _pred 谓词\n&#x2F;&#x2F; newvalue 替换的新元素\n\n\n示例：\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nclass myPrint\n&#123;\npublic:\n    void operator()(int val)\n    &#123;\n        cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\nclass ReplaceGreater30\n&#123;\npublic:\n    bool operator()(int val)\n    &#123;\n        return val &gt;= 30;\n    &#125;\n\n&#125;;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt; v;\n    v.push_back(20);\n    v.push_back(30);\n    v.push_back(20);\n    v.push_back(40);\n    v.push_back(50);\n    v.push_back(10);\n    v.push_back(20);\n\n    cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl;\n    for_each(v.begin(), v.end(), myPrint());\n    cout &lt;&lt; endl;\n\n    //将容器中大于等于的30 替换成 3000\n    cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl;\n    replace_if(v.begin(), v.end(), ReplaceGreater30(), 3000);\n    for_each(v.begin(), v.end(), myPrint());\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：replace_if 按条件查找，可以利用仿函数灵活筛选满足的条件\n4.4 swap功能描述：\n\n互换两个容器的元素\n\n函数原型：\n\nswap(container c1, container c2);  \n&#x2F;&#x2F; 互换两个容器的元素\n&#x2F;&#x2F; c1 容器 1\n&#x2F;&#x2F; c2 容器 2\n\n\n示例：\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nclass myPrint\n&#123;\npublic:\n    void operator()(int val)\n    &#123;\n        cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt; v1;\n    vector&lt;int&gt; v2;\n    for (int i = 0; i &lt; 10; i++) &#123;\n        v1.push_back(i);\n        v2.push_back(i+100);\n    &#125;\n\n    cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl;\n    for_each(v1.begin(), v1.end(), myPrint());\n    cout &lt;&lt; endl;\n    for_each(v2.begin(), v2.end(), myPrint());\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl;\n    swap(v1, v2);\n    for_each(v1.begin(), v1.end(), myPrint());\n    cout &lt;&lt; endl;\n    for_each(v2.begin(), v2.end(), myPrint());\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：swap 交换容器时，注意交换的容器要同种类型\n5 常用算术生成算法学习目标：\n\n掌握常用的算术生成算法\n\n注意：\n\n算术生成算法属于小型算法，使用时包含的头文件为 #include &lt;numeric&gt;\n\n算法简介：\n\naccumulate &#x2F;&#x2F; 计算容器元素累计总和\n\nfill &#x2F;&#x2F; 向容器中添加元素\n\n\n5.1 accumulate功能描述：\n\n计算区间内 容器元素累计总和\n\n函数原型：\n\naccumulate(iterator beg, iterator end, value);  \n&#x2F;&#x2F; 计算容器元素累计总和\n&#x2F;&#x2F; beg 开始迭代器\n&#x2F;&#x2F; end 结束迭代器\n&#x2F;&#x2F; value 起始值\n\n\n示例：\n#include &lt;numeric&gt;\n#include &lt;vector&gt;\nvoid test01()\n&#123;\n    vector&lt;int&gt; v;\n    for (int i = 0; i &lt;= 100; i++) &#123;\n        v.push_back(i);\n    &#125;\n\n    int total = accumulate(v.begin(), v.end(), 0);\n\n    cout &lt;&lt; &quot;total = &quot; &lt;&lt; total &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：accumulate 使用时头文件注意是 numeric，这个算法很实用\n5.2 fill功能描述：\n\n向容器中填充指定的元素\n\n函数原型：\n\nfill(iterator beg, iterator end, value);  \n&#x2F;&#x2F; 向容器中填充元素\n&#x2F;&#x2F; beg 开始迭代器\n&#x2F;&#x2F; end 结束迭代器\n&#x2F;&#x2F; value 填充的值\n\n\n示例：\n#include &lt;numeric&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nclass myPrint\n&#123;\npublic:\n    void operator()(int val)\n    &#123;\n        cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\nvoid test01()\n&#123;\n\n    vector&lt;int&gt; v;\n    v.resize(10);\n    //填充\n    fill(v.begin(), v.end(), 100);\n\n    for_each(v.begin(), v.end(), myPrint());\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：利用 fill 可以将容器区间内元素填充为 指定的值\n6 常用集合算法学习目标：\n\n掌握常用的集合算法\n\n算法简介：\n\nset_intersection &#x2F;&#x2F; 求两个容器的交集\n\nset_union &#x2F;&#x2F; 求两个容器的并集\n\nset_difference  &#x2F;&#x2F; 求两个容器的差集\n\n\n6.1 set_intersection功能描述：\n\n求两个容器的交集\n\n函数原型：\n\nset_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  \n&#x2F;&#x2F; 求两个集合的交集\n&#x2F;&#x2F; 注意:两个集合必须是有序序列\n&#x2F;&#x2F; beg1 容器 1 开始迭代器&#x2F;&#x2F; end1 容器 1 结束迭代器&#x2F;&#x2F; beg2 容器 2 开始迭代器&#x2F;&#x2F; end2 容器 2 结束迭代器&#x2F;&#x2F; dest 目标容器开始迭代器\n\n\n示例：\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nclass myPrint\n&#123;\npublic:\n    void operator()(int val)\n    &#123;\n        cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt; v1;\n    vector&lt;int&gt; v2;\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        v1.push_back(i);\n        v2.push_back(i+5);\n    &#125;\n\n    vector&lt;int&gt; vTarget;\n    //取两个里面较小的值给目标容器开辟空间\n    vTarget.resize(min(v1.size(), v2.size()));\n\n    //返回目标容器的最后一个元素的迭代器地址\n    vector&lt;int&gt;::iterator itEnd =\n        set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());\n\n    for_each(vTarget.begin(), itEnd, myPrint());\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\n\n求交集的两个集合必须的有序序列\n目标容器开辟空间需要从两个容器中取小值\nset_intersection 返回值既是交集中最后一个元素的位置\n\n6.2 set_union功能描述：\n\n求两个集合的并集\n\n函数原型：\n\nset_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  \n&#x2F;&#x2F; 求两个集合的并集\n&#x2F;&#x2F; 注意:两个集合必须是有序序列\n&#x2F;&#x2F; beg1 容器 1 开始迭代器&#x2F;&#x2F; end1 容器 1 结束迭代器&#x2F;&#x2F; beg2 容器 2 开始迭代器&#x2F;&#x2F; end2 容器 2 结束迭代器&#x2F;&#x2F; dest 目标容器开始迭代器\n\n\n示例：\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nclass myPrint\n&#123;\npublic:\n    void operator()(int val)\n    &#123;\n        cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt; v1;\n    vector&lt;int&gt; v2;\n    for (int i = 0; i &lt; 10; i++) &#123;\n        v1.push_back(i);\n        v2.push_back(i+5);\n    &#125;\n\n    vector&lt;int&gt; vTarget;\n    //取两个容器的和给目标容器开辟空间\n    vTarget.resize(v1.size() + v2.size());\n\n    //返回目标容器的最后一个元素的迭代器地址\n    vector&lt;int&gt;::iterator itEnd =\n        set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());\n\n    for_each(vTarget.begin(), itEnd, myPrint());\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\n\n求并集的两个集合必须的有序序列\n目标容器开辟空间需要两个容器相加\nset_union 返回值既是并集中最后一个元素的位置\n\n6.3 set_difference功能描述：\n\n求两个集合的差集\n\n函数原型：\n\nset_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  \n&#x2F;&#x2F; 求两个集合的差集\n&#x2F;&#x2F; 注意:两个集合必须是有序序列\n&#x2F;&#x2F; beg1 容器 1 开始迭代器&#x2F;&#x2F; end1 容器 1 结束迭代器&#x2F;&#x2F; beg2 容器 2 开始迭代器&#x2F;&#x2F; end2 容器 2 结束迭代器&#x2F;&#x2F; dest 目标容器开始迭代器\n\n\n示例：\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nclass myPrint\n&#123;\npublic:\n    void operator()(int val)\n    &#123;\n        cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt; v1;\n    vector&lt;int&gt; v2;\n    for (int i = 0; i &lt; 10; i++) &#123;\n        v1.push_back(i);\n        v2.push_back(i+5);\n    &#125;\n\n    vector&lt;int&gt; vTarget;\n    //取两个里面较大的值给目标容器开辟空间\n    vTarget.resize( max(v1.size() , v2.size()));\n\n    //返回目标容器的最后一个元素的迭代器地址\n    cout &lt;&lt; &quot;v1与v2的差集为： &quot; &lt;&lt; endl;\n    vector&lt;int&gt;::iterator itEnd =\n        set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());\n    for_each(vTarget.begin(), itEnd, myPrint());\n    cout &lt;&lt; endl;\n\n\n    cout &lt;&lt; &quot;v2与v1的差集为： &quot; &lt;&lt; endl;\n    itEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin());\n    for_each(vTarget.begin(), itEnd, myPrint());\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\n\n求差集的两个集合必须的有序序列\n目标容器开辟空间需要从两个容器取较大值\nset_difference 返回值既是差集中最后一个元素的位置\n\n","slug":"C++_STL_常用算法","date":"2022-01-15T08:40:57.000Z","categories_index":"C++","tags_index":"STL","author_index":"会思想的苇草i"},{"id":"ccfaee9dae4598dc22f175fda2e90c05","title":"C++_STL_常用容器","content":"STL 常用容器1 string 容器1.1 string 基本概念本质：\n\nstring 是 C++风格的字符串，而 string 本质上是一个类\n\nstring 和 char * 区别：\n\nchar * 是一个指针\nstring 是一个类，类内部封装了 char*，管理这个字符串，是一个 char*型的容器。\n\n特点：\nstring 类内部封装了很多成员方法\n例如：查找 find，拷贝 copy，删除 delete 替换 replace，插入 insert\nstring 管理 char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责\n1.2 string 构造函数构造函数原型：\n\nstring(); &#x2F;&#x2F;创建一个空的字符串 例如: string str;string(const char* s); &#x2F;&#x2F;使用字符串 s 初始化\nstring(const string&amp; str); &#x2F;&#x2F;使用一个 string 对象初始化另一个 string 对象\nstring(int n, char c); &#x2F;&#x2F;使用 n 个字符 c 初始化\n\n示例：\n#include &lt;string&gt;\n//string构造\nvoid test01()\n&#123;\n    string s1; //创建空字符串，调用无参构造函数\n    cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; s1 &lt;&lt; endl;\n\n    const char* str = &quot;hello world&quot;;\n    string s2(str); //把c_string转换成了string\n\n    cout &lt;&lt; &quot;str2 = &quot; &lt;&lt; s2 &lt;&lt; endl;\n\n    string s3(s2); //调用拷贝构造函数\n    cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; s3 &lt;&lt; endl;\n\n    string s4(10, &#39;a&#39;);\n    cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; s3 &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：string 的多种构造方式没有可比性，灵活使用即可\n1.3 string 赋值操作功能描述：\n\n给 string 字符串进行赋值\n\n赋值的函数原型：\n\nstring&amp; operator=(const char* s); &#x2F;&#x2F;char*类型字符串 赋值给当前的字符串\nstring&amp; operator=(const string &amp;s); &#x2F;&#x2F;把字符串 s 赋给当前的字符串\nstring&amp; operator=(char c); &#x2F;&#x2F;字符赋值给当前的字符串\nstring&amp; assign(const char *s); &#x2F;&#x2F;把字符串 s 赋给当前的字符串\nstring&amp; assign(const char *s, int n); &#x2F;&#x2F;把字符串 s 的前 n 个字符赋给当前的字符串\nstring&amp; assign(const string &amp;s); &#x2F;&#x2F;把字符串 s 赋给当前字符串\nstring&amp; assign(int n, char c); &#x2F;&#x2F;用 n 个字符 c 赋给当前字符串\n\n示例：\n//赋值\nvoid test01()\n&#123;\n    string str1;\n    str1 = &quot;hello world&quot;;\n    cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;\n\n    string str2;\n    str2 = str1;\n    cout &lt;&lt; &quot;str2 = &quot; &lt;&lt; str2 &lt;&lt; endl;\n\n    string str3;\n    str3 = &#39;a&#39;;\n    cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl;\n\n    string str4;\n    str4.assign(&quot;hello c++&quot;);\n    cout &lt;&lt; &quot;str4 = &quot; &lt;&lt; str4 &lt;&lt; endl;\n\n    string str5;\n    str5.assign(&quot;hello c++&quot;,5);\n    cout &lt;&lt; &quot;str5 = &quot; &lt;&lt; str5 &lt;&lt; endl;\n\n\n    string str6;\n    str6.assign(str5);\n    cout &lt;&lt; &quot;str6 = &quot; &lt;&lt; str6 &lt;&lt; endl;\n\n    string str7;\n    str7.assign(5, &#39;x&#39;);\n    cout &lt;&lt; &quot;str7 = &quot; &lt;&lt; str7 &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\nstring 的赋值方式很多，operator= 这种方式是比较实用的\n1.4 string 字符串拼接功能描述：\n\n实现在字符串末尾拼接字符串\n\n函数原型：\n\nstring&amp; operator += (const char* str); &#x2F;&#x2F;重载 +&#x3D; 操作符\nstring&amp; operator += (const char c); &#x2F;&#x2F;重载 +&#x3D; 操作符\nstring&amp; operator += (const string&amp; str); &#x2F;&#x2F;重载 +&#x3D; 操作符\nstring&amp; append(const char *s);  &#x2F;&#x2F;把字符串 s 连接到当前字符串结尾\nstring&amp; append(const char *s, int n); &#x2F;&#x2F;把字符串 s 的前 n 个字符连接到当前字符串结尾\nstring&amp; append(const string &amp;s); &#x2F;&#x2F;同 operator +&#x3D; (const string&amp; str)\nstring&amp; append(const string &amp;s, int pos, int n);&#x2F;&#x2F;字符串 s 中从 pos 开始的 n 个字符连接到字符串结尾\n\n示例：\n//字符串拼接\nvoid test01()\n&#123;\n    string str1 = &quot;我&quot;;\n\n    str1 += &quot;爱玩游戏&quot;;\n\n    cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;\n\n    str1 += &#39;:&#39;;\n\n    cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;\n\n    string str2 = &quot;LOL DNF&quot;;\n\n    str1 += str2;\n\n    cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;\n\n    string str3 = &quot;I&quot;;\n    str3.append(&quot; love &quot;);\n    str3.append(&quot;game abcde&quot;, 4);\n    //str3.append(str2);\n    str3.append(str2, 4, 3); // 从下标4位置开始 ，截取3个字符，拼接到字符串末尾\n    cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl;\n&#125;\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：字符串拼接的重载版本很多，初学阶段记住几种即可\n1.5 string 查找和替换功能描述：\n\n查找：查找指定字符串是否存在\n替换：在指定的位置替换字符串\n\n函数原型：\n\nint find(const string&amp; str, int pos = 0) const; &#x2F;&#x2F;查找 str 第一次出现位置,从 pos 开始查找\nint find(const char* s, int pos = 0) const;  &#x2F;&#x2F;查找 s 第一次出现位置,从 pos 开始查找\nint find(const char* s, int pos, int n) const;  &#x2F;&#x2F;从 pos 位置查找 s 的前 n 个字符第一次位置\nint find(const char c, int pos = 0) const;  &#x2F;&#x2F;查找字符 c 第一次出现位置\nint rfind(const string&amp; str, int pos = npos) const; &#x2F;&#x2F;查找 str 最后一次位置,从 pos 开始查找\nint rfind(const char* s, int pos = npos) const; &#x2F;&#x2F;查找 s 最后一次出现位置,从 pos 开始查找\nint rfind(const char* s, int pos, int n) const; &#x2F;&#x2F;从 pos 查找 s 的前 n 个字符最后一次位置\nint rfind(const char c, int pos = 0) const;   &#x2F;&#x2F;查找字符 c 最后一次出现位置\nstring&amp; replace(int pos, int n, const string&amp; str);  &#x2F;&#x2F;替换从 pos 开始 n 个字符为字符串 str\nstring&amp; replace(int pos, int n,const char* s);  &#x2F;&#x2F;替换从 pos 开始的 n 个字符为字符串 s\n\n示例：\n//查找和替换\nvoid test01()\n&#123;\n    //查找\n    string str1 = &quot;abcdefgde&quot;;\n\n    int pos = str1.find(&quot;de&quot;);\n\n    if (pos == -1)\n    &#123;\n        cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl;\n    &#125;\n\n\n    pos = str1.rfind(&quot;de&quot;);\n\n    cout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl;\n\n&#125;\n\nvoid test02()\n&#123;\n    //替换\n    string str1 = &quot;abcdefgde&quot;;\n    str1.replace(1, 3, &quot;1111&quot;);\n\n    cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    //test01();\n    //test02();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\n\nfind 查找是从左往后，rfind 从右往左\nfind 找到字符串后返回查找的第一个字符位置，找不到返回-1\nreplace 在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串\n\n1.6 string 字符串比较功能描述：\n\n字符串之间的比较\n\n比较方式：\n\n字符串比较是按字符的 ASCII 码进行对比\n\n&#x3D; 返回 0\n&gt; 返回 1\n&lt; 返回 -1\n函数原型：\n\nint compare(const string &amp;s) const;  &#x2F;&#x2F;与字符串 s 比较\nint compare(const char *s) const; &#x2F;&#x2F;与字符串 s 比较\n\n示例：\n//字符串比较\nvoid test01()\n&#123;\n\n    string s1 = &quot;hello&quot;;\n    string s2 = &quot;aello&quot;;\n\n    int ret = s1.compare(s2);\n\n    if (ret == 0) &#123;\n        cout &lt;&lt; &quot;s1 等于 s2&quot; &lt;&lt; endl;\n    &#125;\n    else if (ret &gt; 0)\n    &#123;\n        cout &lt;&lt; &quot;s1 大于 s2&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;s1 小于 s2&quot; &lt;&lt; endl;\n    &#125;\n\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大\n1.7 string 字符存取string 中单个字符存取方式有两种\n\nchar&amp; operator[](int n);  &#x2F;&#x2F;通过[]方式取字符\nchar&amp; at(int n);    &#x2F;&#x2F;通过 at 方法获取字符\n\n示例：\nvoid test01()\n&#123;\n    string str = &quot;hello world&quot;;\n\n    for (int i = 0; i &lt; str.size(); i++)\n    &#123;\n        cout &lt;&lt; str[i] &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n\n    for (int i = 0; i &lt; str.size(); i++)\n    &#123;\n        cout &lt;&lt; str.at(i) &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n\n\n    //字符修改\n    str[0] = &#39;x&#39;;\n    str.at(1) = &#39;x&#39;;\n    cout &lt;&lt; str &lt;&lt; endl;\n\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：string 字符串中单个字符存取有两种方式，利用 [ ] 或 at\n1.8 string 插入和删除功能描述：\n\n对 string 字符串进行插入和删除字符操作\n\n函数原型：\n\nstring&amp; insert(int pos, const char* s);   &#x2F;&#x2F;插入字符串\nstring&amp; insert(int pos, const string&amp; str);  &#x2F;&#x2F;插入字符串\nstring&amp; insert(int pos, int n, char c); &#x2F;&#x2F;在指定位置插入 n 个字符 c\nstring&amp; erase(int pos, int n = npos); &#x2F;&#x2F;删除从 Pos 开始的 n 个字符\n\n示例：\n//字符串插入和删除\nvoid test01()\n&#123;\n    string str = &quot;hello&quot;;\n    str.insert(1, &quot;111&quot;);\n    cout &lt;&lt; str &lt;&lt; endl;\n\n    str.erase(1, 3);  //从1号位置开始3个字符\n    cout &lt;&lt; str &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：插入和删除的起始下标都是从 0 开始\n1.9 string 子串功能描述：\n\n从字符串中获取想要的子串\n\n函数原型：\n\nstring substr(int pos = 0, int n = npos) const; &#x2F;&#x2F;返回由 pos 开始的 n 个字符组成的字符串\n\n示例：\n//子串\nvoid test01()\n&#123;\n\n    string str = &quot;abcdefg&quot;;\n    string subStr = str.substr(1, 3);\n    cout &lt;&lt; &quot;subStr = &quot; &lt;&lt; subStr &lt;&lt; endl;\n\n    string email = &quot;hello@sina.com&quot;;\n    int pos = email.find(&quot;@&quot;);\n    string username = email.substr(0, pos);\n    cout &lt;&lt; &quot;username: &quot; &lt;&lt; username &lt;&lt; endl;\n\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：灵活的运用求子串功能，可以在实际开发中获取有效的信息\n2 vector 容器2.1 vector 基本概念功能：\n\nvector 数据结构和数组非常相似，也称为单端数组\n\nvector 与普通数组区别：\n\n不同之处在于数组是静态空间，而 vector 可以动态扩展\n\n动态扩展：\n\n并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间\n\nvector 容器的迭代器是支持随机访问的迭代器\n\n\n2.2 vector 构造函数功能描述：\n\n创建 vector 容器\n\n函数原型：\n\nvector&lt;T&gt; v;  &#x2F;&#x2F;采用模板实现类实现，默认构造函数\nvector(v.begin(), v.end());    &#x2F;&#x2F;将 v[begin(), end())区间中的元素拷贝给本身。\nvector(n, elem); &#x2F;&#x2F;构造函数将 n 个 elem 拷贝给本身。\nvector(const vector &amp;vec); &#x2F;&#x2F;拷贝构造函数。\n\n示例：\n#include &lt;vector&gt;\n\nvoid printVector(vector&lt;int&gt;&amp; v) &#123;\n\n    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt; v1; //无参构造\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        v1.push_back(i);\n    &#125;\n    printVector(v1);\n\n    vector&lt;int&gt; v2(v1.begin(), v1.end());\n    printVector(v2);\n\n    vector&lt;int&gt; v3(10, 100);\n    printVector(v3);\n\n    vector&lt;int&gt; v4(v3);\n    printVector(v4);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：vector 的多种构造方式没有可比性，灵活使用即可\n2.3 vector 赋值操作功能描述：\n\n给 vector 容器进行赋值\n\n函数原型：\n\nvector&amp; operator=(const vector &amp;vec);&#x2F;&#x2F;重载等号操作符\n\nassign(beg, end); &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。\n\nassign(n, elem); &#x2F;&#x2F;将 n 个 elem 拷贝赋值给本身。\n\n\n示例：\n#include &lt;vector&gt;\n\nvoid printVector(vector&lt;int&gt;&amp; v) &#123;\n\n    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\n//赋值操作\nvoid test01()\n&#123;\n    vector&lt;int&gt; v1; //无参构造\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        v1.push_back(i);\n    &#125;\n    printVector(v1);\n\n    vector&lt;int&gt;v2;\n    v2 = v1;\n    printVector(v2);\n\n    vector&lt;int&gt;v3;\n    v3.assign(v1.begin(), v1.end());\n    printVector(v3);\n\n    vector&lt;int&gt;v4;\n    v4.assign(10, 100);\n    printVector(v4);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结： vector 赋值方式比较简单，使用 operator&#x3D;，或者 assign 都可以\n2.4 vector 容量和大小功能描述：\n\n对 vector 容器的容量和大小操作\n\n函数原型：\n\nempty();  &#x2F;&#x2F;判断容器是否为空\n\ncapacity(); &#x2F;&#x2F;容器的容量\n\nsize(); &#x2F;&#x2F;返回容器中元素的个数\n\nresize(int num); &#x2F;&#x2F;重新指定容器的长度为 num，若容器变长，则以默认值填充新位置。\n&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。\n\nresize(int num, elem); &#x2F;&#x2F;重新指定容器的长度为 num，若容器变长，则以 elem 值填充新位置。\n&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除\n\n\n示例：\n#include &lt;vector&gt;\n\nvoid printVector(vector&lt;int&gt;&amp; v) &#123;\n\n    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt; v1;\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        v1.push_back(i);\n    &#125;\n    printVector(v1);\n    if (v1.empty())\n    &#123;\n        cout &lt;&lt; &quot;v1为空&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;v1不为空&quot; &lt;&lt; endl;\n        cout &lt;&lt; &quot;v1的容量 = &quot; &lt;&lt; v1.capacity() &lt;&lt; endl;\n        cout &lt;&lt; &quot;v1的大小 = &quot; &lt;&lt; v1.size() &lt;&lt; endl;\n    &#125;\n\n    //resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充\n    v1.resize(15,10);\n    printVector(v1);\n\n    //resize 重新指定大小 ，若指定的更小，超出部分元素被删除\n    v1.resize(5);\n    printVector(v1);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\n\n判断是否为空 — empty\n返回元素个数 — size\n返回容器容量 — capacity\n重新指定大小 — resize\n\n2.5 vector 插入和删除功能描述：\n\n对 vector 容器进行插入、删除操作\n\n函数原型：\n\npush_back(ele); &#x2F;&#x2F;尾部插入元素 ele\npop_back(); &#x2F;&#x2F;删除最后一个元素\ninsert(const_iterator pos, ele); &#x2F;&#x2F;迭代器指向位置 pos 插入元素 ele\ninsert(const_iterator pos, int count,ele);&#x2F;&#x2F;迭代器指向位置 pos 插入 count 个元素 ele\nerase(const_iterator pos); &#x2F;&#x2F;删除迭代器指向的元素\nerase(const_iterator start, const_iterator end);&#x2F;&#x2F;删除迭代器从 start 到 end 之间的元素\nclear(); &#x2F;&#x2F;删除容器中所有元素\n\n示例：\n\n#include &lt;vector&gt;\n\nvoid printVector(vector&lt;int&gt;&amp; v) &#123;\n\n    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\n//插入和删除\nvoid test01()\n&#123;\n    vector&lt;int&gt; v1;\n    //尾插\n    v1.push_back(10);\n    v1.push_back(20);\n    v1.push_back(30);\n    v1.push_back(40);\n    v1.push_back(50);\n    printVector(v1);\n    //尾删\n    v1.pop_back();\n    printVector(v1);\n    //插入\n    v1.insert(v1.begin(), 100);\n    printVector(v1);\n\n    v1.insert(v1.begin(), 2, 1000);\n    printVector(v1);\n\n    //删除\n    v1.erase(v1.begin());\n    printVector(v1);\n\n    //清空\n    v1.erase(v1.begin(), v1.end());\n    v1.clear();\n    printVector(v1);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\n\n尾插 — push_back\n尾删 — pop_back\n插入 — insert (位置迭代器)\n删除 — erase （位置迭代器）\n清空 — clear\n\n2.6 vector 数据存取功能描述：\n\n对 vector 中的数据的存取操作\n\n函数原型：\n\nat(int idx);  &#x2F;&#x2F;返回索引 idx 所指的数据\noperator[];  &#x2F;&#x2F;返回索引 idx 所指的数据\nfront();  &#x2F;&#x2F;返回容器中第一个数据元素\nback(); &#x2F;&#x2F;返回容器中最后一个数据元素\n\n示例：\n#include &lt;vector&gt;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt;v1;\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        v1.push_back(i);\n    &#125;\n\n    for (int i = 0; i &lt; v1.size(); i++)\n    &#123;\n        cout &lt;&lt; v1[i] &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n\n    for (int i = 0; i &lt; v1.size(); i++)\n    &#123;\n        cout &lt;&lt; v1.at(i) &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;v1的第一个元素为： &quot; &lt;&lt; v1.front() &lt;&lt; endl;\n    cout &lt;&lt; &quot;v1的最后一个元素为： &quot; &lt;&lt; v1.back() &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\n\n除了用迭代器获取 vector 容器中元素，[ ]和 at 也可以\nfront 返回容器第一个元素\nback 返回容器最后一个元素\n\n2.7 vector 互换容器功能描述：\n\n实现两个容器内元素进行互换\n\n函数原型：\n\nswap(vec); &#x2F;&#x2F; 将 vec 与本身的元素互换\n\n示例：\n#include &lt;vector&gt;\n\nvoid printVector(vector&lt;int&gt;&amp; v) &#123;\n\n    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt;v1;\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        v1.push_back(i);\n    &#125;\n    printVector(v1);\n\n    vector&lt;int&gt;v2;\n    for (int i = 10; i &gt; 0; i--)\n    &#123;\n        v2.push_back(i);\n    &#125;\n    printVector(v2);\n\n    //互换容器\n    cout &lt;&lt; &quot;互换后&quot; &lt;&lt; endl;\n    v1.swap(v2);\n    printVector(v1);\n    printVector(v2);\n&#125;\n\nvoid test02()\n&#123;\n    vector&lt;int&gt; v;\n    for (int i = 0; i &lt; 100000; i++) &#123;\n        v.push_back(i);\n    &#125;\n\n    cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;\n    cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;\n\n    v.resize(3);\n\n    cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;\n    cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;\n\n    //收缩内存\n    vector&lt;int&gt;(v).swap(v); //匿名对象\n\n    cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;\n    cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    test02();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：swap 可以使两个容器互换，可以达到实用的收缩内存效果\n2.8 vector 预留空间功能描述：\n\n减少 vector 在动态扩展容量时的扩展次数\n\n函数原型：\n\nreserve(int len);&#x2F;&#x2F;容器预留 len 个元素长度，预留位置不初始化，元素不可访问。\n\n示例：\n#include &lt;vector&gt;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt; v;\n\n    //预留空间\n    v.reserve(100000);\n\n    int num = 0;\n    int* p = NULL;\n    for (int i = 0; i &lt; 100000; i++) &#123;\n        v.push_back(i);\n        if (p != &amp;v[0]) &#123;\n            p = &amp;v[0];\n            num++;\n        &#125;\n    &#125;\n\n    cout &lt;&lt; &quot;num:&quot; &lt;&lt; num &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：如果数据量较大，可以一开始利用 reserve 预留空间\n3 deque 容器3.1 deque 容器基本概念功能：\n\n双端数组，可以对头端进行插入删除操作\n\ndeque 与 vector 区别：\n\nvector 对于头部的插入删除效率低，数据量越大，效率越低\ndeque 相对而言，对头部的插入删除速度回比 vector 快\nvector 访问元素时的速度会比 deque 快,这和两者内部实现有关\n\ndeque 内部工作原理:\ndeque 内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据\n中控器维护的是每个缓冲区的地址，使得使用 deque 时像一片连续的内存空间\n\ndeque 容器的迭代器也是支持随机访问的\n\n3.2 deque 构造函数功能描述：\n\ndeque 容器构造\n\n函数原型：\n\ndeque&lt;T&gt; deqT; &#x2F;&#x2F;默认构造形式\ndeque(beg, end); &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。\ndeque(n, elem); &#x2F;&#x2F;构造函数将 n 个 elem 拷贝给本身。\ndeque(const deque &amp;deq); &#x2F;&#x2F;拷贝构造函数\n\n示例：\n#include &lt;deque&gt;\n\nvoid printDeque(const deque&lt;int&gt;&amp; d)\n&#123;\n    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n//deque构造\nvoid test01() &#123;\n\n    deque&lt;int&gt; d1; //无参构造函数\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        d1.push_back(i);\n    &#125;\n    printDeque(d1);\n    deque&lt;int&gt; d2(d1.begin(),d1.end());\n    printDeque(d2);\n\n    deque&lt;int&gt;d3(10,100);\n    printDeque(d3);\n\n    deque&lt;int&gt;d4 = d3;\n    printDeque(d4);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：deque 容器和 vector 容器的构造方式几乎一致，灵活使用即可\n3.3 deque 赋值操作功能描述：\n\n给 deque 容器进行赋值\n\n函数原型：\n\ndeque&amp; operator=(const deque &amp;deq);  &#x2F;&#x2F;重载等号操作符\n\nassign(beg, end); &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。\n\nassign(n, elem); &#x2F;&#x2F;将 n 个 elem 拷贝赋值给本身。\n\n\n示例：\n#include &lt;deque&gt;\n\nvoid printDeque(const deque&lt;int&gt;&amp; d)\n&#123;\n    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n//赋值操作\nvoid test01()\n&#123;\n    deque&lt;int&gt; d1;\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        d1.push_back(i);\n    &#125;\n    printDeque(d1);\n\n    deque&lt;int&gt;d2;\n    d2 = d1;\n    printDeque(d2);\n\n    deque&lt;int&gt;d3;\n    d3.assign(d1.begin(), d1.end());\n    printDeque(d3);\n\n    deque&lt;int&gt;d4;\n    d4.assign(10, 100);\n    printDeque(d4);\n\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：deque 赋值操作也与 vector 相同，需熟练掌握\n3.4 deque 大小操作功能描述：\n\n对 deque 容器的大小进行操作\n\n函数原型：\n\ndeque.empty(); &#x2F;&#x2F;判断容器是否为空\n\ndeque.size(); &#x2F;&#x2F;返回容器中元素的个数\n\ndeque.resize(num); &#x2F;&#x2F;重新指定容器的长度为 num,若容器变长，则以默认值填充新位置。\n&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。\n\ndeque.resize(num, elem); &#x2F;&#x2F;重新指定容器的长度为 num,若容器变长，则以 elem 值填充新位置。\n&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。\n\n\n示例：\n#include &lt;deque&gt;\n\nvoid printDeque(const deque&lt;int&gt;&amp; d)\n&#123;\n    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\n//大小操作\nvoid test01()\n&#123;\n    deque&lt;int&gt; d1;\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        d1.push_back(i);\n    &#125;\n    printDeque(d1);\n\n    //判断容器是否为空\n    if (d1.empty()) &#123;\n        cout &lt;&lt; &quot;d1为空!&quot; &lt;&lt; endl;\n    &#125;\n    else &#123;\n        cout &lt;&lt; &quot;d1不为空!&quot; &lt;&lt; endl;\n        //统计大小\n        cout &lt;&lt; &quot;d1的大小为：&quot; &lt;&lt; d1.size() &lt;&lt; endl;\n    &#125;\n\n    //重新指定大小\n    d1.resize(15, 1);\n    printDeque(d1);\n\n    d1.resize(5);\n    printDeque(d1);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\n\ndeque 没有容量的概念\n判断是否为空 — empty\n返回元素个数 — size\n重新指定个数 — resize\n\n3.5 deque 插入和删除功能描述：\n\n向 deque 容器中插入和删除数据\n\n函数原型：\n两端插入操作：\n\npush_back(elem); &#x2F;&#x2F;在容器尾部添加一个数据\npush_front(elem); &#x2F;&#x2F;在容器头部插入一个数据\npop_back(); &#x2F;&#x2F;删除容器最后一个数据\npop_front(); &#x2F;&#x2F;删除容器第一个数据\n\n指定位置操作：\n\ninsert(pos,elem); &#x2F;&#x2F;在 pos 位置插入一个 elem 元素的拷贝，返回新数据的位置。\n\ninsert(pos,n,elem); &#x2F;&#x2F;在 pos 位置插入 n 个 elem 数据，无返回值。\n\ninsert(pos,beg,end); &#x2F;&#x2F;在 pos 位置插入[beg,end)区间的数据，无返回值。\n\nclear(); &#x2F;&#x2F;清空容器的所有数据\n\nerase(beg,end); &#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。\n\nerase(pos); &#x2F;&#x2F;删除 pos 位置的数据，返回下一个数据的位置。\n\n\n示例：\n#include &lt;deque&gt;\n\nvoid printDeque(const deque&lt;int&gt;&amp; d)\n&#123;\n    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n//两端操作\nvoid test01()\n&#123;\n    deque&lt;int&gt; d;\n    //尾插\n    d.push_back(10);\n    d.push_back(20);\n    //头插\n    d.push_front(100);\n    d.push_front(200);\n\n    printDeque(d);\n\n    //尾删\n    d.pop_back();\n    //头删\n    d.pop_front();\n    printDeque(d);\n&#125;\n\n//插入\nvoid test02()\n&#123;\n    deque&lt;int&gt; d;\n    d.push_back(10);\n    d.push_back(20);\n    d.push_front(100);\n    d.push_front(200);\n    printDeque(d);\n\n    d.insert(d.begin(), 1000);\n    printDeque(d);\n\n    d.insert(d.begin(), 2,10000);\n    printDeque(d);\n\n    deque&lt;int&gt;d2;\n    d2.push_back(1);\n    d2.push_back(2);\n    d2.push_back(3);\n\n    d.insert(d.begin(), d2.begin(), d2.end());\n    printDeque(d);\n\n&#125;\n\n//删除\nvoid test03()\n&#123;\n    deque&lt;int&gt; d;\n    d.push_back(10);\n    d.push_back(20);\n    d.push_front(100);\n    d.push_front(200);\n    printDeque(d);\n\n    d.erase(d.begin());\n    printDeque(d);\n\n    d.erase(d.begin(), d.end());\n    d.clear();\n    printDeque(d);\n&#125;\n\nint main() &#123;\n\n    //test01();\n\n    //test02();\n\n    test03();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\n\n插入和删除提供的位置是迭代器！\n尾插 — push_back\n尾删 — pop_back\n头插 — push_front\n头删 — pop_front\n\n3.6 deque 数据存取功能描述：\n\n对 deque 中的数据的存取操作\n\n函数原型：\n\nat(int idx);  &#x2F;&#x2F;返回索引 idx 所指的数据\noperator[];  &#x2F;&#x2F;返回索引 idx 所指的数据\nfront();  &#x2F;&#x2F;返回容器中第一个数据元素\nback(); &#x2F;&#x2F;返回容器中最后一个数据元素\n\n示例：\n#include &lt;deque&gt;\n\nvoid printDeque(const deque&lt;int&gt;&amp; d)\n&#123;\n    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\n//数据存取\nvoid test01()\n&#123;\n\n    deque&lt;int&gt; d;\n    d.push_back(10);\n    d.push_back(20);\n    d.push_front(100);\n    d.push_front(200);\n\n    for (int i = 0; i &lt; d.size(); i++) &#123;\n        cout &lt;&lt; d[i] &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n\n\n    for (int i = 0; i &lt; d.size(); i++) &#123;\n        cout &lt;&lt; d.at(i) &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;front:&quot; &lt;&lt; d.front() &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;back:&quot; &lt;&lt; d.back() &lt;&lt; endl;\n\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\n\n除了用迭代器获取 deque 容器中元素，[ ]和 at 也可以\nfront 返回容器第一个元素\nback 返回容器最后一个元素\n\n3.7 deque 排序功能描述：\n\n利用算法实现对 deque 容器进行排序\n\n算法：\n\nsort(iterator beg, iterator end) &#x2F;&#x2F;对 beg 和 end 区间内元素进行排序\n\n示例：\n#include &lt;deque&gt;\n#include &lt;algorithm&gt;\n\nvoid printDeque(const deque&lt;int&gt;&amp; d)\n&#123;\n    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid test01()\n&#123;\n\n    deque&lt;int&gt; d;\n    d.push_back(10);\n    d.push_back(20);\n    d.push_front(100);\n    d.push_front(200);\n\n    printDeque(d);\n    sort(d.begin(), d.end());\n    printDeque(d);\n\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：sort 算法非常实用，使用时包含头文件 algorithm 即可\n4 案例-评委打分4.1 案例描述有 5 名选手：选手 ABCDE，10 个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。\n4.2 实现步骤\n创建五名选手，放到 vector 中\n遍历 vector 容器，取出来每一个选手，执行 for 循环，可以把 10 个评分打分存到 deque 容器中\nsort 算法对 deque 容器中分数排序，去除最高和最低分\ndeque 容器遍历一遍，累加总分\n获取平均分\n\n示例代码：\n//选手类\nclass Person\n&#123;\npublic:\n    Person(string name, int score)\n    &#123;\n        this-&gt;m_Name = name;\n        this-&gt;m_Score = score;\n    &#125;\n\n    string m_Name; //姓名\n    int m_Score;  //平均分\n&#125;;\n\nvoid createPerson(vector&lt;Person&gt;&amp;v)\n&#123;\n    string nameSeed = &quot;ABCDE&quot;;\n    for (int i = 0; i &lt; 5; i++)\n    &#123;\n        string name = &quot;选手&quot;;\n        name += nameSeed[i];\n\n        int score = 0;\n\n        Person p(name, score);\n\n        //将创建的person对象 放入到容器中\n        v.push_back(p);\n    &#125;\n&#125;\n\n//打分\nvoid setScore(vector&lt;Person&gt;&amp;v)\n&#123;\n    for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)\n    &#123;\n        //将评委的分数 放入到deque容器中\n        deque&lt;int&gt;d;\n        for (int i = 0; i &lt; 10; i++)\n        &#123;\n            int score = rand() % 41 + 60;  // 60 ~ 100\n            d.push_back(score);\n        &#125;\n\n        //cout &lt;&lt; &quot;选手： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 打分： &quot; &lt;&lt; endl;\n        //for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)\n        //&#123;\n        //\tcout &lt;&lt; *dit &lt;&lt; &quot; &quot;;\n        //&#125;\n        //cout &lt;&lt; endl;\n\n        //排序\n        sort(d.begin(), d.end());\n\n        //去除最高和最低分\n        d.pop_back();\n        d.pop_front();\n\n        //取平均分\n        int sum = 0;\n        for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)\n        &#123;\n            sum += *dit; //累加每个评委的分数\n        &#125;\n\n        int avg = sum / d.size();\n\n        //将平均分 赋值给选手身上\n        it-&gt;m_Score = avg;\n    &#125;\n\n&#125;\n\nvoid showScore(vector&lt;Person&gt;&amp;v)\n&#123;\n    for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)\n    &#123;\n        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 平均分： &quot; &lt;&lt; it-&gt;m_Score &lt;&lt; endl;\n    &#125;\n&#125;\n\nint main() &#123;\n\n    //随机数种子\n    srand((unsigned int)time(NULL));\n\n    //1、创建5名选手\n    vector&lt;Person&gt;v;  //存放选手容器\n    createPerson(v);\n\n    //测试\n    //for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)\n    //&#123;\n    //\tcout &lt;&lt; &quot;姓名： &quot; &lt;&lt; (*it).m_Name &lt;&lt; &quot; 分数： &quot; &lt;&lt; (*it).m_Score &lt;&lt; endl;\n    //&#125;\n\n    //2、给5名选手打分\n    setScore(v);\n\n    //3、显示最后得分\n    showScore(v);\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结： 选取不同的容器操作数据，可以提升代码的效率\n5 stack 容器5.1 stack 基本概念概念：stack 是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口\n栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为\n栈中进入数据称为 — 入栈 push\n栈中弹出数据称为 — 出栈 pop\n5.2 stack 常用接口功能描述：栈容器常用的对外接口\n构造函数：\n\nstack&lt;T&gt; stk; &#x2F;&#x2F;stack 采用模板类实现， stack 对象的默认构造形式\nstack(const stack &amp;stk); &#x2F;&#x2F;拷贝构造函数\n\n赋值操作：\n\nstack&amp; operator=(const stack &amp;stk); &#x2F;&#x2F;重载等号操作符\n\n数据存取：\n\npush(elem); &#x2F;&#x2F;向栈顶添加元素\npop(); &#x2F;&#x2F;从栈顶移除第一个元素\ntop();  &#x2F;&#x2F;返回栈顶元素\n\n大小操作：\n\nempty(); &#x2F;&#x2F;判断堆栈是否为空\nsize();  &#x2F;&#x2F;返回栈的大小\n\n示例：\n#include &lt;stack&gt;\n\n//栈容器常用接口\nvoid test01()\n&#123;\n    //创建栈容器 栈容器必须符合先进后出\n    stack&lt;int&gt; s;\n\n    //向栈中添加元素，叫做 压栈 入栈\n    s.push(10);\n    s.push(20);\n    s.push(30);\n\n    while (!s.empty()) &#123;\n        //输出栈顶元素\n        cout &lt;&lt; &quot;栈顶元素为： &quot; &lt;&lt; s.top() &lt;&lt; endl;\n        //弹出栈顶元素\n        s.pop();\n    &#125;\n    cout &lt;&lt; &quot;栈的大小为：&quot; &lt;&lt; s.size() &lt;&lt; endl;\n\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\n\n入栈 — push\n出栈 — pop\n返回栈顶 — top\n判断栈是否为空 — empty\n返回栈大小 — size\n\n6 queue 容器6.1 queue 基本概念概念：Queue 是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口\n队列容器允许从一端新增元素，从另一端移除元素\n队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为\n队列中进数据称为 — 入队 push\n队列中出数据称为 — 出队 pop\n6.2 queue 常用接口功能描述：栈容器常用的对外接口\n构造函数：\n\nqueue&lt;T&gt; que; &#x2F;&#x2F;queue 采用模板类实现，queue 对象的默认构造形式\nqueue(const queue &amp;que); &#x2F;&#x2F;拷贝构造函数\n\n赋值操作：\n\nqueue&amp; operator=(const queue &amp;que); &#x2F;&#x2F;重载等号操作符\n\n数据存取：\n\npush(elem); &#x2F;&#x2F;往队尾添加元素\npop(); &#x2F;&#x2F;从队头移除第一个元素\nback(); &#x2F;&#x2F;返回最后一个元素\nfront();  &#x2F;&#x2F;返回第一个元素\n\n大小操作：\n\nempty(); &#x2F;&#x2F;判断堆栈是否为空\nsize();  &#x2F;&#x2F;返回栈的大小\n\n示例：\n#include &lt;queue&gt;\n#include &lt;string&gt;\nclass Person\n&#123;\npublic:\n    Person(string name, int age)\n    &#123;\n        this-&gt;m_Name = name;\n        this-&gt;m_Age = age;\n    &#125;\n\n    string m_Name;\n    int m_Age;\n&#125;;\n\nvoid test01() &#123;\n\n    //创建队列\n    queue&lt;Person&gt; q;\n\n    //准备数据\n    Person p1(&quot;唐僧&quot;, 30);\n    Person p2(&quot;孙悟空&quot;, 1000);\n    Person p3(&quot;猪八戒&quot;, 900);\n    Person p4(&quot;沙僧&quot;, 800);\n\n    //向队列中添加元素  入队操作\n    q.push(p1);\n    q.push(p2);\n    q.push(p3);\n    q.push(p4);\n\n    //队列不提供迭代器，更不支持随机访问\n    while (!q.empty()) &#123;\n        //输出队头元素\n        cout &lt;&lt; &quot;队头元素-- 姓名： &quot; &lt;&lt; q.front().m_Name\n              &lt;&lt; &quot; 年龄： &quot;&lt;&lt; q.front().m_Age &lt;&lt; endl;\n\n        cout &lt;&lt; &quot;队尾元素-- 姓名： &quot; &lt;&lt; q.back().m_Name\n              &lt;&lt; &quot; 年龄： &quot; &lt;&lt; q.back().m_Age &lt;&lt; endl;\n\n        cout &lt;&lt; endl;\n        //弹出队头元素\n        q.pop();\n    &#125;\n\n    cout &lt;&lt; &quot;队列大小为：&quot; &lt;&lt; q.size() &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\n\n入队 — push\n出队 — pop\n返回队头元素 — front\n返回队尾元素 — back\n判断队是否为空 — empty\n返回队列大小 — size\n\n7 list 容器7.1 list 基本概念功能：将数据进行链式存储\n链表（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的\n链表的组成：链表由一系列结点组成\n结点的组成：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域\nSTL 中的链表是一个双向循环链表\n由于链表的存储方式并不是连续的内存空间，因此链表 list 中的迭代器只支持前移和后移，属于双向迭代器\nlist 的优点：\n\n采用动态存储分配，不会造成内存浪费和溢出\n链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素\n\nlist 的缺点：\n\n链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大\n\nList 有一个重要的性质，插入操作和删除操作都不会造成原有 list 迭代器的失效，这在 vector 是不成立的。\n总结：STL 中List 和 vector 是两个最常被使用的容器，各有优缺点\n7.2 list 构造函数功能描述：\n\n创建 list 容器\n\n函数原型：\n\nlist&lt;T&gt; lst; &#x2F;&#x2F;list 采用采用模板类实现,对象的默认构造形式：\nlist(beg,end); &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。\nlist(n,elem); &#x2F;&#x2F;构造函数将 n 个 elem 拷贝给本身。\nlist(const list &amp;lst); &#x2F;&#x2F;拷贝构造函数。\n\n示例：\n#include &lt;list&gt;\n\nvoid printList(const list&lt;int&gt;&amp; L) &#123;\n\n    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid test01()\n&#123;\n    list&lt;int&gt;L1;\n    L1.push_back(10);\n    L1.push_back(20);\n    L1.push_back(30);\n    L1.push_back(40);\n\n    printList(L1);\n\n    list&lt;int&gt;L2(L1.begin(),L1.end());\n    printList(L2);\n\n    list&lt;int&gt;L3(L2);\n    printList(L3);\n\n    list&lt;int&gt;L4(10, 1000);\n    printList(L4);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：list 构造方式同其他几个 STL 常用容器，熟练掌握即可\n7.3 list 赋值和交换功能描述：\n\n给 list 容器进行赋值，以及交换 list 容器\n\n函数原型：\n\nassign(beg, end); &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。\nassign(n, elem); &#x2F;&#x2F;将 n 个 elem 拷贝赋值给本身。\nlist&amp; operator=(const list &amp;lst); &#x2F;&#x2F;重载等号操作符\nswap(lst); &#x2F;&#x2F;将 lst 与本身的元素互换。\n\n示例：\n#include &lt;list&gt;\n\nvoid printList(const list&lt;int&gt;&amp; L) &#123;\n\n    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\n//赋值和交换\nvoid test01()\n&#123;\n    list&lt;int&gt;L1;\n    L1.push_back(10);\n    L1.push_back(20);\n    L1.push_back(30);\n    L1.push_back(40);\n    printList(L1);\n\n    //赋值\n    list&lt;int&gt;L2;\n    L2 = L1;\n    printList(L2);\n\n    list&lt;int&gt;L3;\n    L3.assign(L2.begin(), L2.end());\n    printList(L3);\n\n    list&lt;int&gt;L4;\n    L4.assign(10, 100);\n    printList(L4);\n\n&#125;\n\n//交换\nvoid test02()\n&#123;\n\n    list&lt;int&gt;L1;\n    L1.push_back(10);\n    L1.push_back(20);\n    L1.push_back(30);\n    L1.push_back(40);\n\n    list&lt;int&gt;L2;\n    L2.assign(10, 100);\n\n    cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl;\n    printList(L1);\n    printList(L2);\n\n    cout &lt;&lt; endl;\n\n    L1.swap(L2);\n\n    cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl;\n    printList(L1);\n    printList(L2);\n\n&#125;\n\nint main() &#123;\n\n    //test01();\n\n    test02();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：list 赋值和交换操作能够灵活运用即可\n7.4 list 大小操作功能描述：\n\n对 list 容器的大小进行操作\n\n函数原型：\n\nsize();  &#x2F;&#x2F;返回容器中元素的个数\n\nempty();  &#x2F;&#x2F;判断容器是否为空\n\nresize(num); &#x2F;&#x2F;重新指定容器的长度为 num，若容器变长，则以默认值填充新位置。\n&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。\n\nresize(num, elem);  &#x2F;&#x2F;重新指定容器的长度为 num，若容器变长，则以 elem 值填充新位置。\n&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。\n\n\n示例：\n#include &lt;list&gt;\n\nvoid printList(const list&lt;int&gt;&amp; L) &#123;\n\n    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\n//大小操作\nvoid test01()\n&#123;\n    list&lt;int&gt;L1;\n    L1.push_back(10);\n    L1.push_back(20);\n    L1.push_back(30);\n    L1.push_back(40);\n\n    if (L1.empty())\n    &#123;\n        cout &lt;&lt; &quot;L1为空&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;L1不为空&quot; &lt;&lt; endl;\n        cout &lt;&lt; &quot;L1的大小为： &quot; &lt;&lt; L1.size() &lt;&lt; endl;\n    &#125;\n\n    //重新指定大小\n    L1.resize(10);\n    printList(L1);\n\n    L1.resize(2);\n    printList(L1);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\n\n判断是否为空 — empty\n返回元素个数 — size\n重新指定个数 — resize\n\n7.5 list 插入和删除功能描述：\n\n对 list 容器进行数据的插入和删除\n\n函数原型：\n\npush_back(elem);&#x2F;&#x2F;在容器尾部加入一个元素\npop_back();&#x2F;&#x2F;删除容器中最后一个元素\npush_front(elem);&#x2F;&#x2F;在容器开头插入一个元素\npop_front();&#x2F;&#x2F;从容器开头移除第一个元素\ninsert(pos,elem);&#x2F;&#x2F;在 pos 位置插 elem 元素的拷贝，返回新数据的位置。\ninsert(pos,n,elem);&#x2F;&#x2F;在 pos 位置插入 n 个 elem 数据，无返回值。\ninsert(pos,beg,end);&#x2F;&#x2F;在 pos 位置插入[beg,end)区间的数据，无返回值。\nclear();&#x2F;&#x2F;移除容器的所有数据\nerase(beg,end);&#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。\nerase(pos);&#x2F;&#x2F;删除 pos 位置的数据，返回下一个数据的位置。\nremove(elem);&#x2F;&#x2F;删除容器中所有与 elem 值匹配的元素。\n\n示例：\n#include &lt;list&gt;\n\nvoid printList(const list&lt;int&gt;&amp; L) &#123;\n\n    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\n//插入和删除\nvoid test01()\n&#123;\n    list&lt;int&gt; L;\n    //尾插\n    L.push_back(10);\n    L.push_back(20);\n    L.push_back(30);\n    //头插\n    L.push_front(100);\n    L.push_front(200);\n    L.push_front(300);\n\n    printList(L);\n\n    //尾删\n    L.pop_back();\n    printList(L);\n\n    //头删\n    L.pop_front();\n    printList(L);\n\n    //插入\n    list&lt;int&gt;::iterator it = L.begin();\n    L.insert(++it, 1000);\n    printList(L);\n\n    //删除\n    it = L.begin();\n    L.erase(++it);\n    printList(L);\n\n    //移除\n    L.push_back(10000);\n    L.push_back(10000);\n    L.push_back(10000);\n    printList(L);\n    L.remove(10000);\n    printList(L);\n\n    //清空\n    L.clear();\n    printList(L);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\n\n尾插 — push_back\n尾删 — pop_back\n头插 — push_front\n头删 — pop_front\n插入 — insert\n删除 — erase\n移除 — remove\n清空 — clear\n\n7.6 list 数据存取功能描述：\n\n对 list 容器中数据进行存取\n\n函数原型：\n\nfront(); &#x2F;&#x2F;返回第一个元素。\nback(); &#x2F;&#x2F;返回最后一个元素。\n\n示例：\n#include &lt;list&gt;\n\n//数据存取\nvoid test01()\n&#123;\n    list&lt;int&gt;L1;\n    L1.push_back(10);\n    L1.push_back(20);\n    L1.push_back(30);\n    L1.push_back(40);\n\n\n    //cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据\n    //cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据\n    cout &lt;&lt; &quot;第一个元素为： &quot; &lt;&lt; L1.front() &lt;&lt; endl;\n    cout &lt;&lt; &quot;最后一个元素为： &quot; &lt;&lt; L1.back() &lt;&lt; endl;\n\n    //list容器的迭代器是双向迭代器，不支持随机访问\n    list&lt;int&gt;::iterator it = L1.begin();\n    //it = it + 1;//错误，不可以跳跃访问，即使是+1\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\n\nlist 容器中不可以通过[]或者 at 方式访问数据\n返回第一个元素 — front\n返回最后一个元素 — back\n\n7.7 list 反转和排序功能描述：\n\n将容器中的元素反转，以及将容器中的数据进行排序\n\n函数原型：\n\nreverse(); &#x2F;&#x2F;反转链表\nsort(); &#x2F;&#x2F;链表排序\n\n示例：\nvoid printList(const list&lt;int&gt;&amp; L) &#123;\n\n    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nbool myCompare(int val1 , int val2)\n&#123;\n    return val1 &gt; val2;\n&#125;\n\n//反转和排序\nvoid test01()\n&#123;\n    list&lt;int&gt; L;\n    L.push_back(90);\n    L.push_back(30);\n    L.push_back(20);\n    L.push_back(70);\n    printList(L);\n\n    //反转容器的元素\n    L.reverse();\n    printList(L);\n\n    //排序\n    L.sort(); //默认的排序规则 从小到大\n    printList(L);\n\n    L.sort(myCompare); //指定规则，从大到小\n    printList(L);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\n\n反转 — reverse\n排序 — sort （成员函数）\n\n7.8 排序案例案例描述：将 Person 自定义数据类型进行排序，Person 中属性有姓名、年龄、身高\n排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序\n示例：\n#include &lt;list&gt;\n#include &lt;string&gt;\nclass Person &#123;\npublic:\n    Person(string name, int age , int height) &#123;\n        m_Name = name;\n        m_Age = age;\n        m_Height = height;\n    &#125;\n\npublic:\n    string m_Name;  //姓名\n    int m_Age;      //年龄\n    int m_Height;   //身高\n&#125;;\n\n\nbool ComparePerson(Person&amp; p1, Person&amp; p2) &#123;\n\n    if (p1.m_Age == p2.m_Age) &#123;\n        return p1.m_Height  &gt; p2.m_Height;\n    &#125;\n    else\n    &#123;\n        return  p1.m_Age &lt; p2.m_Age;\n    &#125;\n\n&#125;\n\nvoid test01() &#123;\n\n    list&lt;Person&gt; L;\n\n    Person p1(&quot;刘备&quot;, 35 , 175);\n    Person p2(&quot;曹操&quot;, 45 , 180);\n    Person p3(&quot;孙权&quot;, 40 , 170);\n    Person p4(&quot;赵云&quot;, 25 , 190);\n    Person p5(&quot;张飞&quot;, 35 , 160);\n    Person p6(&quot;关羽&quot;, 35 , 200);\n\n    L.push_back(p1);\n    L.push_back(p2);\n    L.push_back(p3);\n    L.push_back(p4);\n    L.push_back(p5);\n    L.push_back(p6);\n\n    for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123;\n        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age\n              &lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl;\n    &#125;\n\n    cout &lt;&lt; &quot;---------------------------------&quot; &lt;&lt; endl;\n    L.sort(ComparePerson); //排序\n\n    for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123;\n        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age\n              &lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl;\n    &#125;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\n\n对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序\n\n高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂\n\n\n8 set|multiset 容器8.1 set 基本概念简介：\n\n所有元素都会在插入时自动被排序\n\n本质：\n\nset&#x2F;multiset 属于关联式容器，底层结构是用二叉树实现。\n\nset 和 multiset 区别：\n\nset 不允许容器中有重复的元素\nmultiset 允许容器中有重复的元素\n\n8.2 set 构造和赋值功能描述：创建 set 容器以及赋值\n构造：\n\nset&lt;T&gt; st; &#x2F;&#x2F;默认构造函数：\nset(const set &amp;st); &#x2F;&#x2F;拷贝构造函数\n\n赋值：\n\nset&amp; operator=(const set &amp;st); &#x2F;&#x2F;重载等号操作符\n\n示例：\n#include &lt;set&gt;\n\nvoid printSet(set&lt;int&gt; &amp; s)\n&#123;\n    for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\n//构造和赋值\nvoid test01()\n&#123;\n    set&lt;int&gt; s1;\n\n    s1.insert(10);\n    s1.insert(30);\n    s1.insert(20);\n    s1.insert(40);\n    printSet(s1);\n\n    //拷贝构造\n    set&lt;int&gt;s2(s1);\n    printSet(s2);\n\n    //赋值\n    set&lt;int&gt;s3;\n    s3 = s2;\n    printSet(s3);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\n\nset 容器插入数据时用 insert\nset 容器插入数据的数据会自动排序\n\n8.3 set 大小和交换功能描述：\n\n统计 set 容器大小以及交换 set 容器\n\n函数原型：\n\nsize(); &#x2F;&#x2F;返回容器中元素的数目\nempty(); &#x2F;&#x2F;判断容器是否为空\nswap(st); &#x2F;&#x2F;交换两个集合容器\n\n示例：\n#include &lt;set&gt;\n\nvoid printSet(set&lt;int&gt; &amp; s)\n&#123;\n    for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\n//大小\nvoid test01()\n&#123;\n\n    set&lt;int&gt; s1;\n\n    s1.insert(10);\n    s1.insert(30);\n    s1.insert(20);\n    s1.insert(40);\n\n    if (s1.empty())\n    &#123;\n        cout &lt;&lt; &quot;s1为空&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;s1不为空&quot; &lt;&lt; endl;\n        cout &lt;&lt; &quot;s1的大小为： &quot; &lt;&lt; s1.size() &lt;&lt; endl;\n    &#125;\n\n&#125;\n\n//交换\nvoid test02()\n&#123;\n    set&lt;int&gt; s1;\n\n    s1.insert(10);\n    s1.insert(30);\n    s1.insert(20);\n    s1.insert(40);\n\n    set&lt;int&gt; s2;\n\n    s2.insert(100);\n    s2.insert(300);\n    s2.insert(200);\n    s2.insert(400);\n\n    cout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl;\n    printSet(s1);\n    printSet(s2);\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl;\n    s1.swap(s2);\n    printSet(s1);\n    printSet(s2);\n&#125;\n\nint main() &#123;\n\n    //test01();\n\n    test02();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\n\n统计大小 — size\n判断是否为空 — empty\n交换容器 — swap\n\n8.4 set 插入和删除功能描述：\n\nset 容器进行插入数据和删除数据\n\n函数原型：\n\ninsert(elem); &#x2F;&#x2F;在容器中插入元素。\nclear(); &#x2F;&#x2F;清除所有元素\nerase(pos); &#x2F;&#x2F;删除 pos 迭代器所指的元素，返回下一个元素的迭代器。\nerase(beg, end); &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。\nerase(elem); &#x2F;&#x2F;删除容器中值为 elem 的元素。\n\n示例：\n#include &lt;set&gt;\n\nvoid printSet(set&lt;int&gt; &amp; s)\n&#123;\n    for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\n//插入和删除\nvoid test01()\n&#123;\n    set&lt;int&gt; s1;\n    //插入\n    s1.insert(10);\n    s1.insert(30);\n    s1.insert(20);\n    s1.insert(40);\n    printSet(s1);\n\n    //删除\n    s1.erase(s1.begin());\n    printSet(s1);\n\n    s1.erase(30);\n    printSet(s1);\n\n    //清空\n    //s1.erase(s1.begin(), s1.end());\n    s1.clear();\n    printSet(s1);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\n\n插入 — insert\n删除 — erase\n清空 — clear\n\n8.5 set 查找和统计功能描述：\n\n对 set 容器进行查找数据以及统计数据\n\n函数原型：\n\nfind(key); &#x2F;&#x2F;查找 key 是否存在,若存在，返回该键的元素的迭代器；若不存在，返回 set.end();\ncount(key); &#x2F;&#x2F;统计 key 的元素个数\n\n示例：\n#include &lt;set&gt;\n\n//查找和统计\nvoid test01()\n&#123;\n    set&lt;int&gt; s1;\n    //插入\n    s1.insert(10);\n    s1.insert(30);\n    s1.insert(20);\n    s1.insert(40);\n\n    //查找\n    set&lt;int&gt;::iterator pos = s1.find(30);\n\n    if (pos != s1.end())\n    &#123;\n        cout &lt;&lt; &quot;找到了元素 ： &quot; &lt;&lt; *pos &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl;\n    &#125;\n\n    //统计\n    int num = s1.count(30);\n    cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\n\n查找 — find （返回的是迭代器）\n统计 — count （对于 set，结果为 0 或者 1）\n\n8.6 set 和 multiset 区别学习目标：\n\n掌握 set 和 multiset 的区别\n\n区别：\n\nset 不可以插入重复数据，而 multiset 可以\nset 插入数据的同时会返回插入结果，表示插入是否成功\nmultiset 不会检测数据，因此可以插入重复数据\n\n示例：\n#include &lt;set&gt;\n\n//set和multiset区别\nvoid test01()\n&#123;\n    set&lt;int&gt; s;\n    pair&lt;set&lt;int&gt;::iterator, bool&gt;  ret = s.insert(10);\n    if (ret.second) &#123;\n        cout &lt;&lt; &quot;第一次插入成功!&quot; &lt;&lt; endl;\n    &#125;\n    else &#123;\n        cout &lt;&lt; &quot;第一次插入失败!&quot; &lt;&lt; endl;\n    &#125;\n\n    ret = s.insert(10);\n    if (ret.second) &#123;\n        cout &lt;&lt; &quot;第二次插入成功!&quot; &lt;&lt; endl;\n    &#125;\n    else &#123;\n        cout &lt;&lt; &quot;第二次插入失败!&quot; &lt;&lt; endl;\n    &#125;\n\n    //multiset\n    multiset&lt;int&gt; ms;\n    ms.insert(10);\n    ms.insert(10);\n\n    for (multiset&lt;int&gt;::iterator it = ms.begin(); it != ms.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\n\n如果不允许插入重复数据可以利用 set\n如果需要插入重复数据利用 multiset\n\n8.7 pair 对组创建功能描述：\n\n成对出现的数据，利用对组可以返回两个数据\n\n两种创建方式：\n\npair&lt;type, type&gt; p ( value1, value2 );\npair&lt;type, type&gt; p = make_pair( value1, value2 );\n\n示例：\n#include &lt;string&gt;\n\n//对组创建\nvoid test01()\n&#123;\n    pair&lt;string, int&gt; p(string(&quot;Tom&quot;), 20);\n    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt;  p.first &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.second &lt;&lt; endl;\n\n    pair&lt;string, int&gt; p2 = make_pair(&quot;Jerry&quot;, 10);\n    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p2.first &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p2.second &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\n两种方式都可以创建对组，记住一种即可\n8.8 set 容器排序学习目标：\n\nset 容器默认排序规则为从小到大，掌握如何改变排序规则\n\n主要技术点：\n\n利用仿函数，可以改变排序规则\n\n示例一 set 存放内置数据类型\n#include &lt;set&gt;\n\nclass MyCompare\n&#123;\npublic:\n    bool operator()(int v1, int v2) &#123;\n        return v1 &gt; v2;\n    &#125;\n&#125;;\nvoid test01()\n&#123;\n    set&lt;int&gt; s1;\n    s1.insert(10);\n    s1.insert(40);\n    s1.insert(20);\n    s1.insert(30);\n    s1.insert(50);\n\n    //默认从小到大\n    for (set&lt;int&gt;::iterator it = s1.begin(); it != s1.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n\n    //指定排序规则\n    set&lt;int,MyCompare&gt; s2;\n    s2.insert(10);\n    s2.insert(40);\n    s2.insert(20);\n    s2.insert(30);\n    s2.insert(50);\n\n    for (set&lt;int, MyCompare&gt;::iterator it = s2.begin(); it != s2.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：利用仿函数可以指定 set 容器的排序规则\n示例二 set 存放自定义数据类型\n#include &lt;set&gt;\n#include &lt;string&gt;\n\nclass Person\n&#123;\npublic:\n    Person(string name, int age)\n    &#123;\n        this-&gt;m_Name = name;\n        this-&gt;m_Age = age;\n    &#125;\n\n    string m_Name;\n    int m_Age;\n\n&#125;;\nclass comparePerson\n&#123;\npublic:\n    bool operator()(const Person&amp; p1, const Person &amp;p2)\n    &#123;\n        //按照年龄进行排序  降序\n        return p1.m_Age &gt; p2.m_Age;\n    &#125;\n&#125;;\n\nvoid test01()\n&#123;\n    set&lt;Person, comparePerson&gt; s;\n\n    Person p1(&quot;刘备&quot;, 23);\n    Person p2(&quot;关羽&quot;, 27);\n    Person p3(&quot;张飞&quot;, 25);\n    Person p4(&quot;赵云&quot;, 21);\n\n    s.insert(p1);\n    s.insert(p2);\n    s.insert(p3);\n    s.insert(p4);\n\n    for (set&lt;Person, comparePerson&gt;::iterator it = s.begin(); it != s.end(); it++)\n    &#123;\n        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;\n    &#125;\n&#125;\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\n对于自定义数据类型，set 必须指定排序规则才可以插入数据\n9 map|multimap 容器9.1 map 基本概念简介：\n\nmap 中所有元素都是 pair\npair 中第一个元素为 key（键值），起到索引作用，第二个元素为 value（实值）\n所有元素都会根据元素的键值自动排序\n\n本质：\n\nmap&#x2F;multimap 属于关联式容器，底层结构是用二叉树实现。\n\n优点：\n\n可以根据 key 值快速找到 value 值\n\nmap 和 multimap区别：\n\nmap 不允许容器中有重复 key 值元素\nmultimap 允许容器中有重复 key 值元素\n\n9.2 map 构造和赋值功能描述：\n\n对 map 容器进行构造和赋值操作\n\n函数原型：\n构造：\n\nmap&lt;T1, T2&gt; mp; &#x2F;&#x2F;map 默认构造函数:\nmap(const map &amp;mp); &#x2F;&#x2F;拷贝构造函数\n\n赋值：\n\nmap&amp; operator=(const map &amp;mp); &#x2F;&#x2F;重载等号操作符\n\n示例：\n#include &lt;map&gt;\n\nvoid printMap(map&lt;int,int&gt;&amp;m)\n&#123;\n    for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)\n    &#123;\n        cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid test01()\n&#123;\n    map&lt;int,int&gt;m; //默认构造\n    m.insert(pair&lt;int, int&gt;(1, 10));\n    m.insert(pair&lt;int, int&gt;(2, 20));\n    m.insert(pair&lt;int, int&gt;(3, 30));\n    printMap(m);\n\n    map&lt;int, int&gt;m2(m); //拷贝构造\n    printMap(m2);\n\n    map&lt;int, int&gt;m3;\n    m3 = m2; //赋值\n    printMap(m3);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：map 中所有元素都是成对出现，插入数据时候要使用对组\n9.3 map 大小和交换功能描述：\n\n统计 map 容器大小以及交换 map 容器\n\n函数原型：\n\nsize(); &#x2F;&#x2F;返回容器中元素的数目\nempty(); &#x2F;&#x2F;判断容器是否为空\nswap(st); &#x2F;&#x2F;交换两个集合容器\n\n示例：\n#include &lt;map&gt;\n\nvoid printMap(map&lt;int,int&gt;&amp;m)\n&#123;\n    for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)\n    &#123;\n        cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid test01()\n&#123;\n    map&lt;int, int&gt;m;\n    m.insert(pair&lt;int, int&gt;(1, 10));\n    m.insert(pair&lt;int, int&gt;(2, 20));\n    m.insert(pair&lt;int, int&gt;(3, 30));\n\n    if (m.empty())\n    &#123;\n        cout &lt;&lt; &quot;m为空&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;m不为空&quot; &lt;&lt; endl;\n        cout &lt;&lt; &quot;m的大小为： &quot; &lt;&lt; m.size() &lt;&lt; endl;\n    &#125;\n&#125;\n\n\n//交换\nvoid test02()\n&#123;\n    map&lt;int, int&gt;m;\n    m.insert(pair&lt;int, int&gt;(1, 10));\n    m.insert(pair&lt;int, int&gt;(2, 20));\n    m.insert(pair&lt;int, int&gt;(3, 30));\n\n    map&lt;int, int&gt;m2;\n    m2.insert(pair&lt;int, int&gt;(4, 100));\n    m2.insert(pair&lt;int, int&gt;(5, 200));\n    m2.insert(pair&lt;int, int&gt;(6, 300));\n\n    cout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl;\n    printMap(m);\n    printMap(m2);\n\n    cout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl;\n    m.swap(m2);\n    printMap(m);\n    printMap(m2);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    test02();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\n\n统计大小 — size\n判断是否为空 — empty\n交换容器 — swap\n\n9.4 map 插入和删除功能描述：\n\nmap 容器进行插入数据和删除数据\n\n函数原型：\n\ninsert(elem); &#x2F;&#x2F;在容器中插入元素。\nclear(); &#x2F;&#x2F;清除所有元素\nerase(pos); &#x2F;&#x2F;删除 pos 迭代器所指的元素，返回下一个元素的迭代器。\nerase(beg, end); &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。\nerase(key); &#x2F;&#x2F;删除容器中值为 key 的元素。\n\n示例：\n#include &lt;map&gt;\n\nvoid printMap(map&lt;int,int&gt;&amp;m)\n&#123;\n    for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)\n    &#123;\n        cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid test01()\n&#123;\n    //插入\n    map&lt;int, int&gt; m;\n    //第一种插入方式\n    m.insert(pair&lt;int, int&gt;(1, 10));\n    //第二种插入方式\n    m.insert(make_pair(2, 20));\n    //第三种插入方式\n    m.insert(map&lt;int, int&gt;::value_type(3, 30));\n    //第四种插入方式\n    m[4] = 40;\n    printMap(m);\n\n    //删除\n    m.erase(m.begin());\n    printMap(m);\n\n    m.erase(3);\n    printMap(m);\n\n    //清空\n    m.erase(m.begin(),m.end());\n    m.clear();\n    printMap(m);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\n\nmap 插入方式很多，记住其一即可\n\n\n插入 — insert\n删除 — erase\n清空 — clear\n\n9.5 map 查找和统计功能描述：\n\n对 map 容器进行查找数据以及统计数据\n\n函数原型：\n\nfind(key); &#x2F;&#x2F;查找 key 是否存在,若存在，返回该键的元素的迭代器；若不存在，返回 set.end();\ncount(key); &#x2F;&#x2F;统计 key 的元素个数\n\n示例：\n#include &lt;map&gt;\n\n//查找和统计\nvoid test01()\n&#123;\n    map&lt;int, int&gt;m;\n    m.insert(pair&lt;int, int&gt;(1, 10));\n    m.insert(pair&lt;int, int&gt;(2, 20));\n    m.insert(pair&lt;int, int&gt;(3, 30));\n\n    //查找\n    map&lt;int, int&gt;::iterator pos = m.find(3);\n\n    if (pos != m.end())\n    &#123;\n        cout &lt;&lt; &quot;找到了元素 key = &quot; &lt;&lt; (*pos).first &lt;&lt; &quot; value = &quot; &lt;&lt; (*pos).second &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl;\n    &#125;\n\n    //统计\n    int num = m.count(3);\n    cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\n\n查找 — find （返回的是迭代器）\n统计 — count （对于 map，结果为 0 或者 1）\n\n9.6 map 容器排序学习目标：\n\nmap 容器默认排序规则为 按照 key 值进行 从小到大排序，掌握如何改变排序规则\n\n主要技术点:\n\n利用仿函数，可以改变排序规则\n\n示例：\n#include &lt;map&gt;\n\nclass MyCompare &#123;\npublic:\n    bool operator()(int v1, int v2) &#123;\n        return v1 &gt; v2;\n    &#125;\n&#125;;\n\nvoid test01()\n&#123;\n    //默认从小到大排序\n    //利用仿函数实现从大到小排序\n    map&lt;int, int, MyCompare&gt; m;\n\n    m.insert(make_pair(1, 10));\n    m.insert(make_pair(2, 20));\n    m.insert(make_pair(3, 30));\n    m.insert(make_pair(4, 40));\n    m.insert(make_pair(5, 50));\n\n    for (map&lt;int, int, MyCompare&gt;::iterator it = m.begin(); it != m.end(); it++) &#123;\n        cout &lt;&lt; &quot;key:&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value:&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;\n    &#125;\n&#125;\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\n\n利用仿函数可以指定 map 容器的排序规则\n对于自定义数据类型，map 必须要指定排序规则,同 set 容器\n\n10 案例-员工分组10.1 案例描述\n公司今天招聘了 10 个员工（ABCDEFGHIJ），10 名员工进入公司之后，需要指派员工在那个部门工作\n员工信息有: 姓名 工资组成；部门分为：策划、美术、研发\n随机给 10 名员工分配部门和工资\n通过 multimap 进行信息的插入 key(部门编号) value(员工)\n分部门显示员工信息\n\n10.2 实现步骤\n创建 10 名员工，放到 vector 中\n遍历 vector 容器，取出每个员工，进行随机分组\n分组后，将员工部门编号作为 key，具体员工作为 value，放入到 multimap 容器中\n分部门显示员工信息\n\n案例代码：\n#include&lt;iostream&gt;\nusing namespace std;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;map&gt;\n#include &lt;ctime&gt;\n\n/*\n- 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作\n- 员工信息有: 姓名  工资组成；部门分为：策划、美术、研发\n- 随机给10名员工分配部门和工资\n- 通过multimap进行信息的插入  key(部门编号) value(员工)\n- 分部门显示员工信息\n*/\n\n#define CEHUA  0\n#define MEISHU 1\n#define YANFA  2\n\nclass Worker\n&#123;\npublic:\n    string m_Name;\n    int m_Salary;\n&#125;;\n\nvoid createWorker(vector&lt;Worker&gt;&amp;v)\n&#123;\n    string nameSeed = &quot;ABCDEFGHIJ&quot;;\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        Worker worker;\n        worker.m_Name = &quot;员工&quot;;\n        worker.m_Name += nameSeed[i];\n\n        worker.m_Salary = rand() % 10000 + 10000; // 10000 ~ 19999\n        //将员工放入到容器中\n        v.push_back(worker);\n    &#125;\n&#125;\n\n//员工分组\nvoid setGroup(vector&lt;Worker&gt;&amp;v,multimap&lt;int,Worker&gt;&amp;m)\n&#123;\n    for (vector&lt;Worker&gt;::iterator it = v.begin(); it != v.end(); it++)\n    &#123;\n        //产生随机部门编号\n        int deptId = rand() % 3; // 0 1 2\n\n        //将员工插入到分组中\n        //key部门编号，value具体员工\n        m.insert(make_pair(deptId, *it));\n    &#125;\n&#125;\n\nvoid showWorkerByGourp(multimap&lt;int,Worker&gt;&amp;m)\n&#123;\n    // 0  A  B  C   1  D  E   2  F G ...\n    cout &lt;&lt; &quot;策划部门：&quot; &lt;&lt; endl;\n\n    multimap&lt;int,Worker&gt;::iterator pos = m.find(CEHUA);\n    int count = m.count(CEHUA); // 统计具体人数\n    int index = 0;\n    for (; pos != m.end() &amp;&amp; index &lt; count; pos++ , index++)\n    &#123;\n        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;\n    &#125;\n\n    cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;美术部门： &quot; &lt;&lt; endl;\n    pos = m.find(MEISHU);\n    count = m.count(MEISHU); // 统计具体人数\n    index = 0;\n    for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)\n    &#123;\n        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;\n    &#125;\n\n    cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;研发部门： &quot; &lt;&lt; endl;\n    pos = m.find(YANFA);\n    count = m.count(YANFA); // 统计具体人数\n    index = 0;\n    for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)\n    &#123;\n        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;\n    &#125;\n\n&#125;\n\nint main() &#123;\n\n    srand((unsigned int)time(NULL));\n\n    //1、创建员工\n    vector&lt;Worker&gt;vWorker;\n    createWorker(vWorker);\n\n    //2、员工分组\n    multimap&lt;int, Worker&gt;mWorker;\n    setGroup(vWorker, mWorker);\n\n\n    //3、分组显示员工\n    showWorkerByGourp(mWorker);\n\n    ////测试\n    //for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++)\n    //&#123;\n    //\tcout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;\n    //&#125;\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n总结：\n\n当数据以键值对形式存在，可以考虑用 map 或 multimap\n\n","slug":"C++_STL_常用容器","date":"2022-01-14T04:16:24.000Z","categories_index":"C++","tags_index":"STL","author_index":"会思想的苇草i"},{"id":"9f006e9426f7337b910be637ae59775f","title":"C++_STL_初识","content":"\nC++ STL-初识1 STL 的诞生\n长久以来，软件界一直希望建立一种可重复利用的东西\n\nC++的面向对象和泛型编程思想，目的就是复用性的提升\n\n大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作\n\n为了建立数据结构和算法的一套标准,诞生了STL\n\n\n2 STL 基本概念\nSTL(Standard Template Library,标准模板库)\nSTL 从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator)\n容器和算法之间通过迭代器进行无缝连接。\nSTL 几乎所有的代码都采用了模板类或者模板函数\n\n3 STL 六大组件STL 大体分为六大组件，分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器\n\n容器：各种数据结构，如 vector、list、deque、set、map 等,用来存放数据。\n算法：各种常用的算法，如 sort、find、copy、for_each 等\n迭代器：扮演了容器与算法之间的胶合剂。\n仿函数：行为类似函数，可作为算法的某种策略。\n适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。\n空间配置器：负责空间的配置与管理。\n\n4 STL 中容器、算法、迭代器容器：置物之所也\nSTL容器就是将运用最广泛的一些数据结构实现出来\n常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等\n这些容器分为序列式容器和关联式容器两种:\n​ 序列式容器:强调值的排序，序列式容器中的每个元素均有固定的位置。​ 关联式容器:二叉树结构，各元素之间没有严格的物理上的顺序关系\n算法：问题之解法也\n有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)\n算法分为:质变算法和非质变算法。\n质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等\n非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等\n迭代器：容器和算法之间粘合剂\n提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。\n每个容器都有自己专属的迭代器\n迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针\n迭代器种类：\n\n\n\n种类\n功能\n支持运算\n\n\n\n输入迭代器\n对数据的只读访问\n只读，支持++、&#x3D;&#x3D;、！&#x3D;\n\n\n输出迭代器\n对数据的只写访问\n只写，支持++\n\n\n前向迭代器\n读写操作，并能向前推进迭代器\n读写，支持++、&#x3D;&#x3D;、！&#x3D;\n\n\n双向迭代器\n读写操作，并能向前和向后操作\n读写，支持++、–，\n\n\n随机访问迭代器\n读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器\n读写，支持++、–、[n]、-n、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;\n\n\n常用的容器中迭代器种类为双向迭代器，和随机访问迭代器\n5 容器算法迭代器初识了解 STL 中容器、算法、迭代器概念之后，我们利用代码感受 STL 的魅力\nSTL 中最常用的容器为 Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器\n5.1 vector 存放内置数据类型容器： vector\n算法： for_each\n迭代器： vector&lt;int&gt;::iterator\n示例：\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nvoid MyPrint(int val)\n&#123;\n    cout &lt;&lt; val &lt;&lt; endl;\n&#125;\n\nvoid test01() &#123;\n\n    //创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型\n    vector&lt;int&gt; v;\n    //向容器中放数据\n    v.push_back(10);\n    v.push_back(20);\n    v.push_back(30);\n    v.push_back(40);\n\n    //每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素\n    //v.begin()返回迭代器，这个迭代器指向容器中第一个数据\n    //v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置\n    //vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型\n\n    vector&lt;int&gt;::iterator pBegin = v.begin();\n    vector&lt;int&gt;::iterator pEnd = v.end();\n\n    //第一种遍历方式：\n    while (pBegin != pEnd) &#123;\n        cout &lt;&lt; *pBegin &lt;&lt; endl;\n        pBegin++;\n    &#125;\n\n\n    //第二种遍历方式：\n    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; endl;\n    &#125;\n    cout &lt;&lt; endl;\n\n    //第三种遍历方式：\n    //使用STL提供标准遍历算法  头文件 algorithm\n    for_each(v.begin(), v.end(), MyPrint);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n5.2 Vector 存放自定义数据类型学习目标：vector 中存放自定义数据类型，并打印输出\n示例：\n#include &lt;vector&gt;\n#include &lt;string&gt;\n\n//自定义数据类型\nclass Person &#123;\npublic:\n    Person(string name, int age) &#123;\n        mName = name;\n        mAge = age;\n    &#125;\npublic:\n    string mName;\n    int mAge;\n&#125;;\n//存放对象\nvoid test01() &#123;\n\n    vector&lt;Person&gt; v;\n\n    //创建数据\n    Person p1(&quot;aaa&quot;, 10);\n    Person p2(&quot;bbb&quot;, 20);\n    Person p3(&quot;ccc&quot;, 30);\n    Person p4(&quot;ddd&quot;, 40);\n    Person p5(&quot;eee&quot;, 50);\n\n    v.push_back(p1);\n    v.push_back(p2);\n    v.push_back(p3);\n    v.push_back(p4);\n    v.push_back(p5);\n\n    for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;\n        cout &lt;&lt; &quot;Name:&quot; &lt;&lt; (*it).mName &lt;&lt; &quot; Age:&quot; &lt;&lt; (*it).mAge &lt;&lt; endl;\n\n    &#125;\n&#125;\n\n\n//放对象指针\nvoid test02() &#123;\n\n    vector&lt;Person*&gt; v;\n\n    //创建数据\n    Person p1(&quot;aaa&quot;, 10);\n    Person p2(&quot;bbb&quot;, 20);\n    Person p3(&quot;ccc&quot;, 30);\n    Person p4(&quot;ddd&quot;, 40);\n    Person p5(&quot;eee&quot;, 50);\n\n    v.push_back(&amp;p1);\n    v.push_back(&amp;p2);\n    v.push_back(&amp;p3);\n    v.push_back(&amp;p4);\n    v.push_back(&amp;p5);\n\n    for (vector&lt;Person*&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;\n        Person * p = (*it);\n        cout &lt;&lt; &quot;Name:&quot; &lt;&lt; p-&gt;mName &lt;&lt; &quot; Age:&quot; &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl;\n    &#125;\n&#125;\n\n\nint main() &#123;\n\n    test01();\n\n    test02();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n5.3 Vector 容器嵌套容器学习目标：容器中嵌套容器，我们将所有数据进行遍历输出\n示例：\n#include &lt;vector&gt;\n\n//容器嵌套容器\nvoid test01() &#123;\n\n    vector&lt; vector&lt;int&gt; &gt;  v;\n\n    vector&lt;int&gt; v1;\n    vector&lt;int&gt; v2;\n    vector&lt;int&gt; v3;\n    vector&lt;int&gt; v4;\n\n    for (int i = 0; i &lt; 4; i++) &#123;\n        v1.push_back(i + 1);\n        v2.push_back(i + 2);\n        v3.push_back(i + 3);\n        v4.push_back(i + 4);\n    &#125;\n\n    //将容器元素插入到vector v中\n    v.push_back(v1);\n    v.push_back(v2);\n    v.push_back(v3);\n    v.push_back(v4);\n\n\n    for (vector&lt;vector&lt;int&gt;&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;\n\n        for (vector&lt;int&gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++) &#123;\n            cout &lt;&lt; *vit &lt;&lt; &quot; &quot;;\n        &#125;\n        cout &lt;&lt; endl;\n    &#125;\n\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n\n","slug":"C++_STL_初识","date":"2022-01-13T02:22:56.000Z","categories_index":"C++","tags_index":"STL","author_index":"会思想的苇草i"},{"id":"5b88581a52377230e43264c4419525c8","title":"C语言程序设计（第二版）知识点总结(下)","content":"\n八、结构\n结构属于派生类型，是用其他数据类型的对象构建的。关键字 struct 用来引出一个结构类型定义，结构标识符用来对这个结构类型命名。\n\nstruct 结构标识符\n&#123;\n    数据类型 成员1的名字;\n    数据类型 成员2的名字;\n    ...\n    数据类型 成员3的名字;\n&#125;;\n\n\n在此，只是声明了一种数据类型，定义了数据组织形式，并未声明结构类型的变量，不会分配内存。定义结构变量方式如下：\n\n\n先声明结构类型，再定义结构变量。\n\nstruct student stu;\n\n\n声明结构的同时定义结构变量。\n\nstruct student&#123;\n    char ID[16];\n    char name[16];\n    char sex;\n    float score;\n&#125;stu;\n\n\n结构变量的初始化：\n\nstruct student stu = &#123;&quot;202222&quot;,&quot;杰哥&quot;,‘M’，69&#125;;\n\n#include&lt;stdio.h&gt;//结构是一个名字下一组相关变量的集合\n\nstruct date\n&#123;\n    int year;\n    int mouth;\n    int day;\n&#125;;\ntypedef struct student//为已有变量起别名\n&#123;\n    char ID[16];\n    char name[16];\n    char sex;\n    struct date birthday;//将一个结构而作为另一个结构的成员\n    float score;\n&#125;STUDENT;\n\nint main(void)\n&#123;\n    STUDENT stu = &#123;&quot;2020260104&quot;,&quot;zhangwei&quot;,&#39;M&#39;,&#123;2001,9,29&#125;,98&#125;;\n\n    printf(&quot;学号:%s\\n&quot;,stu.ID);\n    printf(&quot;姓名:%s\\n&quot;,stu.name);\n    printf(&quot;性别:%c\\n&quot;,stu.sex);\n    printf(&quot;生日:%d年%d月%d日\\n&quot;,stu.birthday.year,stu.birthday.mouth,stu.birthday.day);//成员选择运算符\n    printf(&quot;成绩:%4.1f\\n&quot;,stu.score);\n\n    return 0;\n&#125;\n\n结构数组与指针\n结构指针的声明方式与其他类型的指针变量相同。\n\n#include&lt;stdio.h&gt;\n\ntypedef struct student\n&#123;\n    char ID[16];\n    char name[16];\n    char sex;\n    float score;\n&#125;STUDENT;\n\nint main(void)\n&#123;\n    STUDENT stu = &#123;&quot;202222&quot;,&quot;杰哥&quot;,&#39;M&#39;,69&#125;;\n    STUDENT *p;//定义结构指针\n\n    p = &amp;stu;//结构指针初始化\n    printf(&quot;\\n%s %s %c %.lf&quot;,stu.ID,stu.name,stu.sex,stu.score);\n    printf(&quot;\\n%s %s %c %.lf&quot;,(*p).ID,(*p).name,(*p).sex,(*p).score);\n    printf(&quot;\\n%s %s %c %.lf&quot;,p-&gt;ID,p-&gt;name,p-&gt;sex,p-&gt;score);\n    return 0;\n&#125;\n\n联合与枚举\nC 语言中允许多个不同变量共享同一内存区的功能称为联合（union）。\n\n#include&lt;stdio.h&gt;//起作用的成员是最后一次被赋值的成员\n\nunion share\n&#123;\n    int a;\n    float b;\n    double c;\n&#125;u;//按变量最长的类型为联合变量分配存储空间，所以为u分配8个字节\n\nint main(void)\n&#123;\n    u.a = 10;\n    u.b = 100.5f;\n    u.c = 10000.1;\n    printf(&quot;a=%d,b=%f,c=%lf\\n&quot;,u.a,u.b,u.c);\n    printf(&quot;u size=%d,a size=%d,b size=%d,c size=%d\\n&quot;,\n    sizeof(u),sizeof(u.a),sizeof(u.b),sizeof(u.c));\n    return 0;\n&#125;\n\n\n枚举类型（enumerated type）是一种代表整数常量的数据类型。通过关键字 enum，可以创建一个新“类型”并指定它的值。枚举类型的语法与结构体的语法相类似。设计枚举类型的目的在于提高程序的可读性。\n\n#include&lt;stdio.h&gt;\n#include&lt;time.h&gt;//时间函数头文件\n\nenum weekday &#123;Sun,Mon,Tue,Wed,Thu,Fri,Sat&#125;;\n\nint main(void)\n&#123;\n    time_t rawtime;//定义代表时间的变量；\n    struct tm*timeinfo;//定义一个指向tm结构变量的指针；\n    enum weekday wday;//定义一个枚举变量\n\n    rawtime = time(NULL);//获取当前的日历时间；（返回从1970年1月1日0点到现在的秒数）\n    timeinfo = localtime(&amp;rawtime);//把日历时间值转化为日期类型\n    wday = (enum weekday)timeinfo-&gt;tm_wday;//获取星期域的值\n\n    switch (wday)\n    &#123;\n    case Mon:printf(&quot;学习编程!\\n&quot;);break;\n    case Wed:printf(&quot;继续学习编程!\\n&quot;);break;\n    case Thu:printf(&quot;还是学习编程!\\n&quot;);break;\n    case Sat:printf(&quot;看编程视频!\\n&quot;);break;\n    default:printf(&quot;刷编程题\\n&quot;);\n    &#125;\n    return 0;\n&#125;\n\n单链表\n单链表 https://blog.csdn.net/ASHIYI66/article/details/113467748\n\n九、文件文件指针\n每一个被使用的文件都要在内存中开辟一个区域，用来存放有关信息，包括文件名称、文件状态和文件当前位置。这些信息被保存在一个结构变量中，该结构类型被系统定义为 FILE，放在头文件“stdio.h”文件中。有了 FILE 类型后，可以用它来定义若干个 FILE 类型的变量，以便存放若干个文件的信息，一般使用文件型指针变量。\n\nFILE *fp;\n\n\n定义一个文件指针 fp，指向该文件对应的结构变量，即可通过文件指针访问该文件。\n\nfp = fopen(&quot;f1.txt&quot;,&quot;w&quot;);\n\n文件的打开和关闭\nANSI C 规定了标准&#x2F;输出函数库，用 fopen 函数来实现打开文件。fopen 函数的原型定义在头文件 stdio.h 中。一般形式为：\n\nFILE *fp; fp=fopen(filename,mode);\n\n\nfopen 函数有两个参数：\n\nfilename：一个指向字符的指针\nmode：系统规定的字符串，表示文件的操作属性mode 字符串对应的操作模式：\n\n\n\n\n三个基本模式：\n\n“r”(read)模式总是打开一个已经存在的文件，如果文件不存在则出错。\n“w”(write)模式建立一个新文件，如果文件已经存在，那么先删除存在的文件，再建立新文件。\n“a”(append)打开一个存在的文件，在文件的尾部追加数据。\n\n\n三个追加符：\n\n“b”(binary)表示二进制文件。\n\n“t”(或默认)表示文本文件。\n\n“+”表示将模式扩展为可读、可写方式。\n\n\n\n\n文件打开的目的是为了读&#x2F;写，当文件使用完毕后，应当关闭文件。C 语言定义了关闭文件的标准函数 fclose。函数原型定义在头文件 stdio.h 中，其一般形式为:\n\nfclose(文件指针);\n\n\n正常关闭文件，返回值为 0；无法正常关闭文件，返回值为 EOF（-1）。\n\n文件读&#x2F;写操作字符读&#x2F;写函数 fgetc()和 fputc()\n\n字符输出函数 fputc()用法:fputc(ch,fp);ch:输出的字符；fp:文件指针变量功能:把一个字符写到磁盘文件上，同时移动读写位置指针到下一个写入位置。如果调用函数成功，则返回 ch 的值；如果失败，则返回值 EOF(系统定义的宏，值为-1);\n\n字符输入函数 fgetc()用法:ch&#x3D;fgetc(fp);fp:文件指针变量功能:从磁盘文件读取一个字符。如果调用成功，则返回读到的字符(赋值给 ch);如果读到文件结束，则返回 EOF(-1)。\n\n/*字符读/写操作*/\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n\nint main(void)\n&#123;\n    FILE *fp;\n    char ch;\n\n    if((fp=fopen(&quot;f2.txt&quot;,&quot;w&quot;))==NULL)\n    &#123;\n        printf(&quot;can not open this file\\n&quot;);\n        exit(0);\n    &#125;\n\n    for(;(ch=getchar())!=&#39;@&#39;;)\n        fputc(ch,fp);\n\n    fclose(fp);\n\n    if((fp=fopen(&quot;f1.txt&quot;,&quot;r&quot;))==NULL)\n    &#123;\n        printf(&quot;can not open this file\\n&quot;);\n        exit(0);\n    &#125;\n\n    for(;(ch=fgetc(fp))!=EOF;)\n        putchar(ch);\n\n    fclose(fp);\n    return 0;\n &#125;\n\n字符串读&#x2F;写函数 fegts()和 fputs()\n\n字符串输入函数 fgets()用法:fgets(str,n,fp);str:字符指针或数组名;n:整型量，说明输入字符串的最大长度(包括‘\\0’);fp:文件指针功能:从文本文件中读取字符，从 fp 对应文件的当前位置，最多输入 n-1 个字符，在最后加‘\\0’，之后放在 str 为首地址的内存中。注意:在输入过程中，如果遇到换行符或 EOF，输入即结束。函数正常调用，返回 str 的首地址，当出错或遇到文件结束标志时，返回 NULL。\n\n字符串输出函数 fputs()用法:fputs(str,fp);str:函数参数 str 是字符指针或数组名;fp:文件指针功能:向指定的文本文件写入一个字符串，将首地址是 str 的字符串输出到 fp 对应文件的当前位置，自动丢弃 str 后的‘\\0’。函数调用成功后返回值是 0，否则是 EOF。\n\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;string.h&gt;\nint main(void)\n&#123;\n    FILE *fp;\n    char string[81];\n\n\n    if((fp=fopen(&quot;f2.txt&quot;,&quot;w&quot;))==NULL)\n    &#123;\n        printf(&quot;can not open this file\\n&quot;);\n        exit(0);\n    &#125;\n\n    printf(&quot;Input a string:&quot;);\n    gets(string);\n    fputs(string,fp);\n    fclose(fp);\n\n    if((fp=fopen(&quot;f2.txt&quot;,&quot;r&quot;))==NULL)\n    &#123;\n        printf(&quot;can not open this file\\n&quot;);\n        exit(0);\n    &#125;\n\n    fgets(string,strlen(string)+1,fp);\n    printf(&quot;Output the string:&quot;);\n    puts(string);\n    fclose(fp);\n    return 0;\n &#125;\n\n文件的格式化读&#x2F;写函数 fscanf()和 fprintf()\n\n格式化输入函数 fscanf()用法:fscanf(fp,format,&amp;arg1,&amp;arg2,…,&amp;argn);fp:文件指针;format:格式说明字符串;&amp;arg1…&amp;argn:输入变量的地址列表。功能:从 fp 指向的文件的当前位置，顺序读取 ASCII 码值，按照 fomat 规定的格式转化为各个变量对应的值，送入指定变量。\nfscanf(fp,&quot;%d%f&quot;,&amp;n,&amp;x);\n\n\n格式化输出函数 fprintf()用法:fprintf(fp,format,arg1,arg2,…,argn);fp:文件指针;format:格式说明字符串;arg1…argn:输出参数个数表功能:按指定的格式(format)将输出列表 arg1…argn 的值转换成对应的 ASCII 码表示形式，写入 fp 文件的当前位置。\nfprintf(fp,&quot;%d%f&quot;,n,x);\n\n\n文件的数据块读&#x2F;写函数 fread()和 fwrite()\n\n数据块输入函数 fread()用法:表示从文件中读入数据到内存缓冲区。形式为:fread(buf,size,count,fp);buf:类型为 void 指针，表示内存中存放着数据到首地址，通常是数组名或数组指针。size:无符号整型，表示一次读取的字节数。count:无符号整型，表示读取的大小为 size 的块的次数。fp:文件指针。功能:从 fp 指向的文件的当前位置读区 size 个字节，共 count 次，读取的总字节数为 size* count，存放到首地址为 buf 的内存中。读取成功则返回读取的项数 count。\n\n数据块输出函数 fwrite()用法:表示从内存输出数据块到文件中。其一般形式为:fwrite(buf,size,count,fp);buf:类型为 void 指针，表示内存中存放着数据到首地址，通常是数组名或数组指针。size:无符号整型，表示一次写入的字节数。count:无符号整型，表示写入的大小为 size 的块的次数。fp:文件指针。功能:从 fp 指向的地址开始，分 count 次，每次 size 个字节，向 fp 指向的文件的当前位置写数据，共写入 count*size 个字节。写入成功则返回读取的项数 count。\nfwrite(stuArr,sizeof(stuArr),1,fp)\n\n\n文件定位函数除了顺序读&#x2F;写，C 语言还允许对文件进行随机读&#x2F;写，可以通过定位函数来改变读写指针的位置。\n\n位置指针定位函数 fseek()fseek 函数用来改变文件指针的当前位置。其一般形式为:fseek(fp，offset，from);offset:位移量，类型为 long 型，表示以 from 为起点移动的量相对值（字节数）。如果是正数，表示向文件尾移动，如果负数，表示向文件头移动。from:移动的起始位置。文件头、当前位置和文件尾部分别对应 0、1、2，或常量 SEEK_SET、SEEK_CUR、SEEK_END。\n\nfseek(fp,20L,0);//将文件位置指针移动到离文件首20字节处\nfseek(fp,-20L,SEEK_END);//将文件位置指针从文件尾向文件首移动20字节处\n\n\n位置指针复位函数 rewind()用来置文件读&#x2F;写位置于开头处。一般形式为:rewind(fp);功能:将文件的当前位置移动到文件的开始处。\n返回文件当前位置函数 ftell()用来取文件当前位置。其一般形式为:long n；n&#x3D;ftell(fp);功能:取得文件当前的读&#x2F;写位置。（即从文件开始处到当前读&#x2F;写位置的字节数(用长整型量表示)）。函数调用正确返回文件当前读&#x2F;写位置。调用错误就返回-1L。\n\n文件检测\n文件结束检测函数 feof()用法:feof(fp);fp:文件指针变量功能:判断文件是否处于文件结束位置。如果文件结束，则返回 1，否则返回 0。它适用于文本文件而不适用于二进制文件。\n检测文件操作错误函数 ferror()用法：ferror(fp);fp:文件指针变量功能:检测文件在各种输入输出函数进行读写时是否错误，若返回值为 0，表示未出错，否则表示有错。\n清除错误标志函数用法：clearerr(fp);fp:文件指针变量功能:清除出错标志和文件结束标志，把它们置为 0。\n\n","slug":"C语言程序设计（第二版）知识点总结（下）","date":"2022-01-12T12:50:49.000Z","categories_index":"C","tags_index":"C语言","author_index":"会思想的苇草i"},{"id":"0ca2db43264aba823021e557298340df","title":"C语言程序设计（第二版）知识点总结(中)","content":"\n五、数组一维数组\n数组是统一命名的一组变量，它们具有相同的名字的相同的数据类型，可以用数组名和每个元素在数组中的位置来访问数组元素。\n一维数组初始化情况如下：\n\n\n数组初始化,数组初始化后，数组元素的初值为：a[0]值为 1，a[1]值为 2…\n\nint a[10] = &#123;1,2,3,4,5,6,7,8,9,10&#125;;\n\n\n部分数组元素初始化，如果初值表中数据个数比数组长度少，那么数组中剩余元素赋值为 0。\n\nint a[10] = &#123;1,2,3&#125;;\n\n\n直接将数组全部初始化为 0。\n\nint a[10] = &#123;0&#125;;\n\n\n数组应用实例：\n\n#include&lt;stdio.h&gt;//斐波拉契数列\n#define N 50\n\nint main(void)\n&#123;\n    int f[N];\n    int n,i;\n\n    scanf(&quot;%d&quot;,&amp;n);\n    f[0]=1;\n    f[1]=1;\n\n    for(i=2;i&lt;n;i++)\n    &#123;\n        f[i] = f [i-1] +f[i-2];\n    &#125;\n\n    for(i=0;i&lt;n;i++)\n    &#123;\n        printf(&quot;%d &quot;,f[i]);\n    &#125;\n    printf(&quot;\\n&quot;);\n    return 0;\n &#125;\n\n#include&lt;stdio.h&gt;//比较交换排序\n#define N 10\n\nint main(void)\n&#123;\n    int i,j,t,n;\n    int a[N];\n\n    printf(&quot;请输入元素个数：\\n&quot;);\n    scanf(&quot;%d&quot;,&amp;n);\n    printf(&quot;请输入%d个元素\\n&quot;,n);\n\n    for(i=0;i&lt;n;i++)\n        scanf(&quot;%d&quot;,&amp;a[i]);\n\n    for(i=0;i&lt;n-1;i++)\n    &#123;\n        for(j=i+1;j&lt;n;j++)\n            if(a[i]&gt;a[j])\n            &#123;\n                t=a[i];\n                a[i]=a[j];\n                a[j]=t;\n             &#125;\n    &#125;\n    printf(&quot;排序后：\\n&quot;);\n\n    for(i=0;i&lt;n;i++)\n    &#123;\n        printf(&quot;%d &quot;,a[i]);\n    &#125;\n    return 0;\n &#125;\n\n数组作为函数参数\n数组名代表数组首元素的地址，因此数组名做参数就可以将数组的起始地址传递给形参。\n\n#include&lt;stdio.h&gt;//数组数据相加\n\nint SumArr(int array[],int n);\n\nint main(void)\n&#123;\n    int b[5]=&#123;1,3,5,7,9&#125;;\n\n    printf(&quot;%d\\n&quot;,SumArr(b,5));\n    return 0;\n &#125;\nint SumArr(int array[],int n)\n&#123;\n    int i,s=0;\n\n    for(i=0;i&lt;n;i++)\n        s += array[i];\n\n    return s;\n&#125;\n\n\n形参数组和实参数组实质上是同一块内存区域，为同一数组，所以形参数组发生改变，实参数组也随之改变。\n\n#include&lt;stdio.h&gt;//乘10变换\n\nvoid ModifyArr(int array[],int n);\n\nint main(void)\n&#123;\n    int i;\n    int a[5]=&#123;1,4,5,7,9&#125;;\n    int n = 5;\n    printf(&quot;数组a的内容：\\n&quot;);\n\n    for(i=0;i&lt;n;i++)\n        printf(&quot;%d &quot;,a[i]);\n\n    printf(&quot;\\n\\n&quot;);\n\n    ModifyArr(a,5);\n\n    printf(&quot;数组a被修改后的内容:\\n&quot;);\n\n    for(i=0;i&lt;n;i++)\n        printf(&quot;%d &quot;,a[i]);\n\n    printf(&quot;\\n\\n&quot;);\n    return 0;\n&#125;\nvoid ModifyArr(int array[],int n)\n&#123;\n    int i,s=0;\n\n    for(i=0;i&lt;n;i++)\n        array[i] *= 10;\n&#125;\n\n二维数组\n二维数组本质上是以数组作为数组元素的数组，即“数组的数组”，类型说明符 数组名[常量表达式][常量表达式]。二维数组又称为矩阵，行列数相等的矩阵称为方阵。\n\n#include&lt;stdio.h&gt;//杨辉三角\n#define N 6\n\nint main(void)\n&#123;\n    int a[N][N];\n    int i,j,n;\n\n    scanf(&quot;%d&quot;,&amp;n);\n\n    a[0][0] = a[1][0] = a[1][1] = 1;\n\n    for(i=0;i&lt;n;i++)\n        a[i][0] = a[i][i] = 1;\n\n    for(i=2;i&lt;n;i++)\n        for(j=1;j&lt;i;j++)\n            a[i][j] = a[i-1][j] + a[i-1][j-1];\n\n    for(i=0;i&lt;n;i++)\n    &#123;\n        for(j=0;j&lt;=i;j++)\n            printf(&quot;%6d&quot;,a[i][j]);\n        printf(&quot;\\n&quot;);\n    &#125;\n    return 0;\n&#125;\n\n六、字符数组与字符串转义序列\n字符常量通常是单引号括起来的单个字符，然而一些特殊的字符无法采用上述方式书写，于是使用转义字符。\n\n字符数据的输入问题\nscanf（）函数和 getchar（）函数都可以用来读入单个字符，但如果下一个字符是空格，scanf（）或 getchar（）会把读到的空格字符存入对应的变量，类似问题解决方法如下：\n\n\ngetchar 法通过调用 getchar（）函数将回车符读入：\n\nscanf(&quot;%d&quot;,&amp;n);\ngetchar();//将缓冲区的回车符读入\nscanf(&quot;%c&quot;,&amp;ch);\n\n\n赋值抑制符使用赋值抑制符“*”来跳过所读入的回车符：\n\nscanf(&quot;%d&quot;,&amp;n);\nscanf(&quot;%*c%c&quot;,&amp;ch);//用%*c将缓冲区的回车符读入但不存储\n\n\nscanf 格式串中的空格符scanf 格式串中的空格符意味着跳过零个或多个空白字符。\n\nscanf(&quot;%d&quot;,&amp;n);\nscanf(&quot; %c&quot;,&amp;ch);\n\n处理字符的函数\n字符数组与字符串\nC 语言本来没有“字符串这种数据类型。通常用一个字符数组来存放一个字符串。字符串与普通字符数组的区别是：字符串的末尾有一个空字符’\\0’，空字符不计入字符串有效字符。字符串中没有显式给出有效字符的个数，只规定在字符串结束符’\\0’之前的字符都是字符串的有效字符，一般用’\\0’来控制循环。循环条件是 s[i]!&#x3D;’\\0’。\n输入输出：\n\n\n用%s 整体输入&#x2F;输出，格式描述串中使用转化字符串”%s”。用 scanf（）函数以%s 格式读入的数据不能含有空白符，所有的空白符都被当做数据结束的标志。\n\nchar name[100];\nscanf(&quot;%s&quot;,name);\nprintf(&quot;%s&quot;,name);\n\n\n用 gets（）和 puts（）函数：功能是读取字符串，并存放在指定字符数组中，遇到换行符或文件结束标志时结束读入。\n\ngets(字符数组名);\nputs(字符数组名);\n\n常用字符串函数\n求字符串长度函数（以下函数的头文件为 string.h）调用格式：strlen（str）功能：测试字符串长度，函数返回值是 str 中字符的个数。\n\nchar str[10]=&quot;China&quot;;\nprintf(&quot;%d&quot;,strlen(&quot;China&quot;));//程序输出为5\n\n\n字符串复制函数调用格式：strcpy（str1，str2）功能：复制第二个参数的内容到第一个参数中。调用格式：strncpy（str1，str2，n）功能：复制第二个参数中最多 n 个字符的内容到第一个参数中。\n\nchar s1[10],s2[]=&quot;Beijing&quot;;\nstrcpy(s1,s2);\n\n\n字符串比较函数调用格式：strcmp（str1，str2）功能：比较字符串 1 和字符串 2 的大小，若前者大则返回一个正整数，若后者大则返回一个负整数，若两者相等，则返回 0。调用格式：strncmp（str1，str2，n）功能：比较字符串 1 最多 n 个字符和字符串 2 的大小，若前者大则返回一个正整数，若后者大则返回一个负整数，若两者相等，则返回 0。\n\nstrcmp(&quot;abc&quot;,&quot;abc&quot;);\n\n\n字符串连接函数 strcat（）和 strncat（）调用格式：strcat（str1，str2）功能：将第二个参数的内容添加到第一个参数的有效字符后面。调用格式：strncat（str1，str2，n）功能：将第二个参数的 n 个字符内容添加到第一个参数的有效字符后面。\n\nchar str1[21] = &quot;Beijing and&quot;;\nchar str2[] = &quot;Shanghai&quot;;\nstrcat(str1,str2);\nprintf(&quot;%s&quot;,str1);//输出为:Beijing and Shanghai\n\n\n字符串逆置函数调用格式：strrev（str）功能：将字符串前后颠倒。\n\nchar str[10] = &quot;hello&quot;;\nstrrev(str);\nputs(str);//程序的输出为:olleh\n\n#include&lt;stdio.h&gt;//输出最大字符串\n#include&lt;string.h&gt;\n#define LEN 81\nint main(void)\n&#123;\n    int n,i;\n    char str[LEN];\n    char maxStr[LEN]=&quot;&quot;;\n\n    printf(&quot;请输入字符串个数：&quot;);\n    scanf(&quot;%d&quot;,&amp;n);\n    getchar();\n    printf(&quot;请输入%d个字符串:&quot;,n);\n\n    for(i=0;i&lt;n;i++)\n    &#123;\n        gets(str);\n        if(strcmp(str,maxStr)&gt;0)\n            strcpy(maxStr,str);\n    &#125;\n\n    printf(&quot;最大字符串：&quot;);\n    puts(maxStr);\n    return 0;\n&#125;\n\n\n函数 sprintf（）（以下函数头文件为 stdio.h）调用格式：sprintf（str，格式字符串，输出项列表）功能：与 printf（）唯一的不同是多了一个参数 str，并且输出结果是保存在字符数组 str 中，而不是输出到屏幕。\n\nsprintf(str,&quot;Price is %d&quot;,d);\n\n\n函数 sscanf（）调用格式：sscanf（字符数组，格式字符串，输出项列表）功能：与 scanf（）唯一不同的是多了一个参数字符数组，并且是从字符数组中读入，而不是从键盘读入。\n\nsscanf(str,&quot;%*6d%4d%2d%2d&quot;,&amp;year，&amp;month，&amp;day);\n\n#include&lt;stdio.h&gt;//水仙花数\n\nint main(void)\n&#123;\n    char str[10];\n    int n,a,b,c;\n    gets(str);\n    sscanf(str,&quot;%d&quot;,&amp;n);             //作为一个三位整数读入；\n    sscanf(str,&quot;%1d%1d%1d&quot;,&amp;a,&amp;b,&amp;c);//作为三个一位整数读入；\n\n    if(n == a*a*a + b*b*b + c*c*c)&#123;\n        printf(&quot;Yes\\n&quot;);\n    &#125;\n    else&#123;\n        printf(&quot;No\\n&quot;);\n    &#125;\n    return 0;\n&#125;\n\n字符串数组\n一维字符数组可以存储一个字符串，二维字符数组可以存储多个字符串，这种用来存放字符串的数组称为字符串数组。字符串数组的每一行元素中都含有字符串结束符’\\0’，因此它的每一行元素都可以和字符串一样输入、输出及初始化。\n\nchar color[][10] = &#123;&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;&#125;;\n\n#include&lt;stdio.h&gt;//二维字符数组实现多个字符串排序\n#include&lt;stdlib.h&gt;\n#include&lt;string.h&gt;\n#define N 100\n#define LEN 81\n\nvoid Sort(char str[][LEN],int n);\n\nint main(void)\n&#123;\n    int i,n;\n    char str[N][LEN];\n\n    printf(&quot;输入n和n个字符串\\n&quot;);\n    scanf(&quot;%d&quot;,&amp;n);\n    getchar();\n\n    for(i=0;i&lt;n;i++)\n    &#123;\n        gets(str[i]);\n    &#125;\n\n    Sort(str,n);\n\n    for(i=0;i&lt;n;i++)\n    &#123;\n        printf(&quot;%s\\n&quot;,str[i]);\n    &#125;\n    return 0;\n&#125;\n\nvoid Sort(char str[][LEN],int n)\n&#123;\n    int i,j;\n    char temp[LEN];\n\n    for(i=0;i&lt;n-1;i++)\n        for(j=i+1;j&lt;n;j++)\n        &#123;\n            if(strcmp(str[i],str[j])&gt;0)\n            &#123;\n                strcpy(temp,str[i]);\n                strcpy(str[i],str[j]);\n                strcpy(str[j],temp);\n            &#125;\n        &#125;\n&#125;\n\n七、指针\n指针是用于表示内存地址的数据项。\n\n指针的声明与普通变量的声明方式基本相同，唯一的不同是必须在指针变量名字前加一个“*”。\n\n\nint *ptr;//ptr是一个指向int类型的指针\n\n\n指针变量使用时必须赋初值，可以再定义指针时进行初始化，也可以通过一个赋值语句来完成。\n\nint count = 5, *cntptr;\ncntptr = &amp;count;\n/*\nint count = 5;\nint *cntptr = &amp;count;\n*/\n\n\n指针的基本运算\n&amp;：取地址运算符；\n*：访问指针所指内存对象。（间接寻址运算符）\n\n\n\n一维数组与指针\n指针与数组有着非常密切的关系，凡是由数组下标完成的操作都可以用指针完成。\n指针加&#x2F;减一个整数的结果是另一个指针。如果指针 p 指向数组元素 a[0]，则 p+1 将指向数组元素 a[1]。指针每增 1，指针所指向的内存地址的增量是其所指向类型的大小（字节数），即指向下一个同类型元素。\n\n#include&lt;stdio.h&gt;\n\nint main(void)\n&#123;\n    double a[4] = &#123;1.5,2,3,4&#125;;\n    double *p;\n\n    p = &amp;a[0];\n    printf(&quot;p中存储的地址值:%p\\n&quot;,p);\n    printf(&quot;p所指变量的值:%.1f\\n&quot;,*p);\n\n    p = p + 1;\n    printf(&quot;p+1后\\n&quot;);\n    printf(&quot;p中存储的地址值:%p\\n&quot;,p);\n    printf(&quot;p所指变量的值:%.1f\\n&quot;,*p);\n\n    return 0;\n&#125;\n\n\n同类型的指针相减结果为两个指针之间的距离，这个距离是用元素个数来度量，而不是用字节来度量。\n\n#include&lt;stdio.h&gt;\n\nint main(void)\n&#123;\n    double a[2],*p,*q;\n\n    p = &amp;a[0];\n    q = &amp;a[1];\n    printf(&quot;%d\\n&quot;,(int*)q-(int*)p);\n    printf(&quot;%d\\n&quot;,q-p);\n    return 0;\n&#125;\n\n\n数组相当于地址常量。\n\n#include&lt;stdio.h&gt;\n#define N 100\n\nint main(void)\n&#123;\n    int i,n,a[N];\n    int *ptr = a;\n\n    scanf(&quot;%d&quot;,&amp;n);\n    for(i=0;i&lt;n;i++)\n        scanf(&quot;%d&quot;,a+i);\n    //用数组名/下标法引用数组元素\n    for(i=n-1;i&gt;=0;i--)\n        printf(&quot;%d &quot;,a[i]);\n\n    printf(&quot;\\n&quot;);\n    //用数组名/偏移量法引用数组元素\n    for(i=n-1;i&gt;=0;i--)\n        printf(&quot;%d &quot;,*(a+i));\n\n    printf(&quot;\\n&quot;);\n    //用指针/偏移量法引用数组元素\n    for(i=n-1;i&gt;=0;i--)\n        printf(&quot;%d &quot;,*(ptr+i));\n\n    printf(&quot;\\n&quot;);\n    //用指针下标法引用数组元素\n    for(i=n-1;i&gt;=0;i--)\n        printf(&quot;%d &quot;,ptr[i]);\n\n    printf(&quot;\\n&quot;);\n    //用移动指针法遍历数组元素\n    for(ptr=a+n-1;ptr&gt;=a;ptr--)\n        printf(&quot;%d &quot;,*ptr);\n\n    printf(&quot;\\n&quot;);\n    return 0;\n&#125;\n\n\n数组名在参数传递时，总是被视为指针。数组名作为实参时，因数组名是指针常量，形参应该是同类型的指针变量。\n\n指针与字符串\n由指向首字符的指针和字符串结束标志’\\0’就可以唯一地确定一个字符串。\n\n\n字符串常量为字符指针变量赋值\n\nchar *p;\np = &quot;abcd&quot;;//内存首地址存入p\n\n\n字符串常量的指针运算\n\nprintf(&quot;%s&quot;,&quot;abcdef&quot;+2);//输出cdef\n\n\n字符串常量的下标运算\n\nchar ch = &quot;abcd&quot;[2];//下标为2的字符&#39;c&#39;存入ch\n\nvoid DToR(int n,char str[],int r)//将十进制转换为r进制\n&#123;\n    int k = 0,d;\n\n    while(n!=0)\n    &#123;\n        d  = n%r;\n        str[k] = &quot;123456789abcdef&quot;[d];\n        k++;\n        n=n/r;\n    &#125;\n    str[k] = &#39;\\0&#39;;\n    strrev(str);\n&#125;\n\n指针实现动态内存分配\n在 C 语言中，动态分配内存是通过动态存储分配函数 malloc()来实现的。malloc（）函数功能是在内存的动态存储区中分配一连续空间。若申请成功，则返回指向所分配内存空间的起始地址的指针；若申请内存空间不成功，则返回 NULL（值为 0）\ncalloc（）函数为数组分配内存，大致同 malloc（）相同，区别是 calloc（）函数会通过把所有字节置 0 来初始化该内存空间。\n为数组分配完空间后可能会发现帅过大或者过小。realloc（）函数可以调整已申请内存的大小。\n在动态内存分配时，应该在不需要该内存时将内存释放。如果频繁地申请内存而没有及时释放不再需要的内存，可能会将内存耗尽。free（）函数用来释放不需要的内存。\n\n#include&lt;stdio.h&gt; //动态申请一个一维数组\n#include&lt;stdlib.h&gt;//malloc的头文件\n\nint main(void)\n&#123;\n    int n,i,*p;\n\n    scanf(&quot;%d&quot;,&amp;n);\n    p = (int *)/*强制转换*/malloc(n*sizeof(int));\n\n    if(p == NULL)\n    &#123;\n        printf(&quot;申请失败\\n&quot;);\n        exit(0);\n    &#125;\n\n    for(i=0;i&lt;n;i++)&#123;\n        scanf(&quot;%d&quot;,p+i);\n    &#125;\n    for(i=n-1;i&gt;=0;i--)&#123;\n        printf(&quot;%d &quot;,p[i]);\n    &#125;\n    printf(&quot;\\n&quot;);\n    free(p);\n    return 0;\n&#125;\n\n","slug":"C语言程序设计（第二版）知识点总结（中）","date":"2022-01-11T01:18:27.000Z","categories_index":"C","tags_index":"C语言","author_index":"会思想的苇草i"},{"id":"0a53341be894f519839526451962b94e","title":"C语言程序设计（第二版）知识点总结(上)","content":"\n一、简单 C 程序设计变量高级语言都能通过变量名来访问内存中的数据。用变量名来标识内存中的某个存储位置—-由一个或多个连续的字节组成，在程序中使用变量名，实际上引用的是内存中对应的某个存储位置。变量取名最好能做到“见名识义”。在 c 语言中，变量命名必须遵守以下规则：\n\n变量名可以由字母、数字和_（下划线）组成；\n变量名不能包含除_（下划线）以外的任何特殊字符，如：%、#、逗号，空格等；\n变量名必须以字母或_（下划线）开头；\n保留字（int、float 等）不能用作变量名，要区分大小写（A，a）。\n\n整数类型32 位机的整数类型：\n格式化输出\n输出格式中的普通字符\n\nprintf(&quot;Hello World!\\n&quot;);\n\n\n输出格式中的转换字符串常用的转换字符串：\n输出格式中的宽度修饰符宽度修饰符用一个十进制整数来表示输出数据的位数，插在%与转换说明符之间，其作用是控制打印数据的宽度，也称为“域宽”。%md代表数据以十进制整数形式输出，宽度占 m 列，数据不足 m 列的左补空格，超过 m 列的情况下按实际位数输出。**%-md数据不足 m 列的右补空格**。\n\nint salary = 15000;\nprintf(&quot;%10d&quot;,salary&quot;);\n//     15000\nint salary = 15000;\nprintf(&quot;%-10d&quot;,salary&quot;);\n//15000\n\n格式化输入\n输入格式中的转换字符串常用的转换字符串：\n\n读入 64 位整数如果编译器支持__int64，用格式符%I64d，如果编译器支持；long long，用格式符%lld。\n\n宽度用十进制整数指定输入的宽度。\n\n\nscanf(&quot;%5d&quot;,&amp;a);\n\n\n赋值抑制符号\n\n/*赋值抑制符号*用以表示该输入项读入后不赋予相应的值，即跳过该输入值*/\n#include&lt;stdio.h&gt;//求出生年月日\n\nint main(void)\n&#123;\n    int year,mouth,day;\n    printf(&quot;请输入身份证号码:\\n&quot;);\n    scanf(&quot;%*6d%4d%2d%2d%*d&quot;,&amp;year,&amp;mouth,&amp;day);\n    printf(&quot;%4d-%02d-%02d\\n&quot;,year,mouth,day);\n    return 0;\n&#125;\n\n浮点类型\n浮点数据的输出\n转换字符串%f格式转换符 f 用于浮点数据的输出格式限定。\n\nprintf(&quot;%f\\n&quot;,demo);//默认输出6位小数\n\n\n转换字符串%m.nfm 表示输出宽度，而 n 表示精度，指定小数点后显示的数字个数。\n\n浮点数据的输入float a;\ndouble b;\n\nscanf(&quot;%f&quot;,&amp;a);\nscanf(&quot;%lf&quot;,&amp;b);\n\nprintf(&quot;%f\\n&quot;,a);\nprintf(&quot;%f\\n&quot;,b);\n\n常量\n字面常量\n宏常量#deine 编译指令的准确含义是，命令编译器将源代码中所有的标识符常量替换为替换文本，其效果与使用编辑器手工进行查找并替换相同。\n\n#define PI 3.1415926//#define 标识符常量 替换文本\n\n\nconst 常量const 给出了对应的内存地址，而不是像#define 给出的是替换文本，所以 const 定义的常量在程序运行过程中只有一份副本，而#define 定义的常量在内存中有若干份副本，而#define 定义的常量在内存中有若干份副本。\n\nconst double PI = 3.1415926;\n\n类型转换在执行算数运算时，通常要求操作数具有相同的数据类型。类型转换方式有以下 3 种：\n\n常用算数转换当算数运算、关系运算或逻辑运算的两个操作数类型不同时，精度低的自动向精度高的转换，这称类型提升。数据类型由低级向高级排序为：char -&gt;int-&gt;float-&gt;double\n\ndouble a = 1.0/2;//2由int转换为double再进行除法运算\n\n\n赋值时类型转换在执行赋值运算时，会把赋值运算符右侧表达式的值转换为赋值运算符左侧变量的类型。\n\ndouble a = 1;//把1.0赋值给a\nint i = 1.5;//把1赋值给i\n\n\n类型转换运算符（类型名）表达式，不改变操作数本身。\n\ndouble a = 2.5;\nint n;\nn = (int)a;//将2赋值给n\n\n二、分支结构if…else 语句if…else 语句通过对一个条件进行判断，当条件为真时，执行一个操作，否则执行另一个不同的操作。\n#include&lt;stdio.h&gt;//比较大小\n\nint main(void)\n&#123;\n    int a,b;\n    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);\n    if(a&gt;b)\n    &#123;\n        printf(&quot;%d\\n&quot;,a)\n    &#125;\n    else\n    &#123;\n        printf(&quot;%d\\n&quot;,b)\n    &#125;\n    return 0;\n\n条件表达式/*若条件（a&gt;b)成立，则条件表达式取值a;否则，取值b*/\n#include&lt;stdio.h&gt;\n\nint main(void)\n&#123;\n    int a,b,c,max;\n\n    scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);\n    max = (a&gt;b) ? a : b;\n    max = (max&gt;c) ? max : c;\n    printf(&quot;%d\\n&quot;,max);\n    return 0;\n&#125;\n\n常见运算符优先级\nswitch 语句#include&lt;stdio.h&gt;//四则运算\n#include&lt;math.h&gt;\n\nint main(void)\n&#123;\n    char op;\n    double x,y;\n\n    scanf(&quot;%lf%c%lf&quot;,&amp;x,&amp;op,&amp;y);\n\n    switch(op)\n    &#123;\n        case &#39;+&#39;:printf(&quot;=%.2f\\n&quot;,x+y);break;\n        case &#39;-&#39;:printf(&quot;=%.2f\\n&quot;,x-y);break;\n        case &#39;*&#39;:printf(&quot;=%.2f\\n&quot;,x*y);break;\n        case &#39;/&#39;:\n            if(fabs(y)&gt;1e-6)&#123;\n                printf(&quot;=%.2f\\n&quot;,x/y);\n            &#125;\n            else&#123;\n                printf(&quot;wrong input\\n&quot;);\n            &#125;\n            break;\n        default :printf(&quot;wrong input\\n&quot;);\n    &#125;\n    return 0;\n&#125;\n\n三、循环结构C 语言有三种循环语句，即 for 循环语句、while 循环语句和 do 语句、while 循环在循环体执行之前测试循环表达式，do 循环在循环体执行之后测试循环表达式，for 循环则非常适合那些指定次数的循环。\nwhile(表达式)m\n    循环体语句;\n\ndo\n    循环体语句\nwhile(表达式)\n\nfor(表达式1；表达式2；表达式3)\n    语句\n\nbreak 语句break 的作用一般是提前结束循环过程。\n#include&lt;stdio.h&gt;//求素数\n#include&lt;math.h&gt;\n\nint main(void)\n&#123;\n    int i,k,m,find;\n\n    printf(&quot;输入一个正整数：\\n&quot;);\n    scanf(&quot;%d&quot;,&amp;m);\n    k = (int)sqrt(m);\n    find = 0;\n\n    for(i=2;i&lt;=k;i++)\n    &#123;\n        if(m%i==0)\n        &#123;\n            find = 1;\n            break;\n        &#125;\n    &#125;\n\n    if(find==1||m==1)\n    &#123;\n        printf(&quot;No\\n&quot;);\n    &#125;\n    else\n    &#123;\n        printf(&quot;Yes\\n&quot;);\n    &#125;\n    return 0;\n &#125;\n\ncontinue 语句continue 语句能跳过循环体中尚未执行的语句，开始新一轮的循环。\n#include&lt;stdio.h&gt;//逢7过\n\nint main(void)\n&#123;\n    int i;\n\n    for(i=1;i&lt;=100;i++)\n    &#123;\n        if(i%7==0)\n            continue;\n\n        printf(&quot;%d &quot;,i);\n    &#125;\n\n    return 0;\n&#125;\n\ngoto 语句goto 语句可以跳转到函数中任何有标号的语句处。\n#include&lt;stdio.h&gt;\n\nint main(void)\n&#123;\n    int sum=0,i=1;\n\nloop:sum +=i;\n    i++;\n    if(i&lt;=100)&#123;\n        goto loop;\n    &#125;\n    printf(&quot;%d\\n&quot;,sum);\n    return 0;\n&#125;\n\n多实例测试\n确定次数的多实例测试\n\n#include&lt;stdio.h&gt;\n\nint main(void)\n&#123;\n    int i=1,n;\n    printf(&quot;请输入测试次数：&quot;);\n    scanf(&quot;%d&quot;,&amp;n);\n\n    while(n--)\n    &#123;\n        printf(&quot;%d\\n&quot;,i++);\n     &#125;\n    return 0;\n&#125;\n\n\n以特殊输入作为结束标志的多实例测试\n\n#include&lt;stdio.h&gt;\n\nint main(void)\n&#123;\n    int n;\n\n    while(scanf(&quot;%d&quot;,&amp;n),n!=0)//输入0结束循环\n    &#123;\n        printf(&quot;%d\\n&quot;,n);\n     &#125;\n    return 0;\n&#125;\n\n\n以 EOF 结束的多实例测试\n\n#include&lt;stdio.h&gt;\n\nint main(void)\n&#123;\n    int n;\n\n    while(scanf(&quot;%d&quot;,&amp;n) !=EOF)\n    &#123;\n        printf(&quot;%d\\n&quot;,n);\n     &#125;\n    return 0;\n&#125;\n\n四、函数函数的定义返回值类型 函数名 (形式参数列表)\n&#123;\n    变量声明;\n    函数实现过程;\n&#125;\n\n返回值类型是返回给主函数的运算结果的数据类型。当返回值为 void 类型时说明函数没有返回值。函数名可以是任意的合法标识符，为了提高程序的可读性并减少注释，一般要求做到“见名至义”。形式参数列表是一组用逗号隔开的形式参数，它规定了函数被调用时应该接受到的参数。\n#include&lt;stdio.h&gt;//输出100以内的全部素数\n#include&lt;math.h&gt;\n\nint prime(int m);\n\nint main(void)\n&#123;\n    int m;\n    for(m=2;m&lt;=100;m++)\n    &#123;\n        if(prime(m)!=0)\n            printf(&quot;%6d&quot;,m);\n    &#125;\n\n    printf(&quot;\\n&quot;);\n    return 0;\n &#125;\n\nint prime(int m)\n&#123;\n    int i,k;\n\n    if(m == 1)\n        return 0;\n\n    k = (int)sqrt(m);\n\n    for(i=2;i&lt;=k;i++)\n    &#123;\n        if(m%i==0)\n            return 0;\n     &#125;\n    return 1;\n &#125;\n\n变量的存储类型\nauto 存储变量auto 存储类型的变量只在所在块有效，在所在块被执行时获得内存单元，并在块终止时释放内存单元。\nstatic 存储类型静态存储周期的变量所占用的存储单元是从程序运行的开始时刻分配和初始化的，并且只分配和初始化一次。\nextern 存储类型extern 存储类型可以使几个源文件共享一个变量，提醒编译器需要访问定义在别处的变量。\nregister 存储类型寄存器是驻留在 CPU 中的存储单元，具有比内存更高的存取速度。\n\n函数的递归调用#include&lt;stdio.h&gt;\n\nint gcd(int a,int b);\nint main(void)\n&#123;\n    int a,b,c;\n    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);\n    c = gcd(a,b);\n    printf(&quot;最大公约数为:%d\\n&quot;,c);\n    return 0;\n&#125;\nint gcd(int a,int b)\n&#123;\n    if(a%b==0)&#123;\n        return b;\n    &#125;\n    else&#123;\n        return gcd(b,a%b);\n    &#125;\n&#125;\n\n","slug":"C语言程序设计（第二版）知识点总结（上）","date":"2022-01-10T02:01:04.000Z","categories_index":"C","tags_index":"C语言","author_index":"会思想的苇草i"},{"id":"168349b15cc8fc12508a6c4a439d5818","title":"C++--类的深入剖析(下)","content":"0.const对象和const成员函数\n程序员可以使用关键字const来指定对象是不可修改的，这样任何试图修改该对象的操作都将导致编译错误。下面的代码块：\n\nconst Time noon(12,0，0);\n\n\n即声明了一个Time类的const对象noon，并且将它初始化为中午12点。对于const对象C++编译器不允许进行成员函数的调用，除非成员函数本身也声明为const。对于构造函数和析构函数是不可以进行const声明的，必须允许构造函数修改对象\n\n//Time.h\n#ifndef TIME_H\n#define TIME_H\n\nclass Time\n&#123;\n    public:\n        Time(int=0,int=0,int=0);\n        \n        void setTime(int,int,int);\n        void setHour(int);\n        void setMinute(int);\n        void setSecond(int);\n        \n        int getHour()const;\n        int getMinute()const;\n        int getSecond()const;\n        \n        void printUniversal()const;\n        void printStandard();\n    private:\n        int hour;\n        int minute;\n        int second;\n&#125;;\n\n#endif\n\n//Time.cpp\n#include&lt;iostream&gt;\nusing std::cout;\n\n#include&lt;iomanip&gt;\nusing std::setfill;\nusing std::setw;\n\n#include&quot;Time.h&quot;\n\nTime::Time(int hr,int min,int sec)\n&#123;\n    setTime(hr,min,sec);\n&#125;\n\nvoid Time::setTime(int h,int m,int s)\n&#123;\n    setHour(h);\n    setMinute(m);\n    setSecond(s);\n&#125;\n\nvoid Time::setHour(int h)\n&#123;\n    hour = (h&gt;=0&amp;&amp;h&lt;24)?h:0;\t\n&#125;\n\nvoid Time::setMinute(int m)\n&#123;\n    minute = (m&gt;=0&amp;&amp;m&lt;60)?m:0;\t\n&#125;\n\nvoid Time::setSecond(int s)\n&#123;\n    second = (s&gt;=0&amp;&amp;s&lt;60)?s:0;\t\n&#125;\n\nint Time::getHour()const\n&#123;\n    return hour;\n&#125;\n\nint Time::getMinute()const\n&#123;\n    return minute;\n&#125;\n\nint Time::getSecond()const\n&#123;\n    return second;\n&#125;\n\nvoid Time::printUniversal()const\n&#123;\n    cout&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;setw(2)&lt;&lt;hour&lt;&lt;&quot;:&quot;\n    &lt;&lt;setw(2)&lt;&lt;minute&lt;&lt;&quot;:&quot;&lt;&lt;setw(2)&lt;&lt;second;\n&#125;\n\nvoid Time::printStandard()const\n&#123;\n    cout&lt;&lt;((hour==0||hour==12)?12:hour%12)&lt;&lt;&quot;:&quot;\n    &lt;&lt;setfill(&#39;0&#39;)&lt;&lt;setw(2)&lt;&lt;minute&lt;&lt;&quot;:&quot;&lt;&lt;setw(2)\n    &lt;&lt;second&lt;&lt;(hour&lt;12?&quot;AM&quot;:&quot;PM&quot;);\n&#125;\n\n//TimeTest.cpp\n#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\n#include&quot;Time.h&quot;\n\nint main(void)\n&#123;\n    Time wakeUp(6.45,0);\n    const Time noon(12,1,1);\n    \n    wakeUp.setHour(18);\n    //noon.setHour(12);const对象调用非const成员函数 -error \n    \n    wakeUp.getHour();\n    noon.getHour();\n    \n    wakeUp.printUniversal();//非const对象调用const成员函数\n    cout&lt;&lt;endl;\n    wakeUp.printStandard();//非const对象调用非const成员函数\n    cout&lt;&lt;endl;\n    \n    noon.printUniversal();//const对象调用const成员函数\n    cout&lt;&lt;endl;\n    //noon.printStandard();const对象调用非const成员函数 -error \n    \n    return 0;\n&#125;\n\n1.用成员初始化器来初始化\n所有的数据成员均可以用成员初始化器形式进行初始化，但是const数据成员和引用的数据成员必须使用成员初始化器进行初始化。成员初始化器用法如下：\n\n//Demo.h\n#ifndef DEMO_H\n#define DEMO_H\n\nclass Demo\n&#123;\n    public:\n        Demo(int c=0,int i=1);\n        \n        void addDemo()\n        &#123;\n            count += demo;\n        &#125;\n        void print()const;\n    private:\n        int count;\n        const int demo;\n&#125;;\n\n#endif\n\n//Demo.cpp\n#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\n#include&quot;Demo.h&quot;\n\nDemo::Demo(int c,int i)\n    :count(c),\n     demo(i)\n&#123;\n    \n&#125;\n\nvoid Demo::print()const\n&#123;\n    cout&lt;&lt;&quot;count = &quot;&lt;&lt;count&lt;&lt;&quot;, demo = &quot;&lt;&lt;demo&lt;&lt;endl;\n&#125;\n\n//DemoTest.cpp\n#include&lt;iostream&gt;\nusing std::cout;\n\n#include&quot;Demo.h&quot;\n\nint main(void)\n&#123;\n    Demo value(10,5);\n    \n    cout&lt;&lt;&quot;before &quot;;\n    value.print();\n    \n    for(int j=1;j&lt;=3;j++)\n    &#123;\n        value.addDemo();\n        cout&lt;&lt;&quot;after &quot;&lt;&lt;j&lt;&lt;&quot;:&quot;;\n        value.print(); \n    &#125;\n    return 0;\n&#125;\n\n\n构造函数的定义使用了一个成员初始化器列表来初始化demo类的数据成员–非const整数count和const整数demo。成员初始化器出现在构造函数的参数列表和作为构造函数体开始的左花括号之间。多个成员初始化器之间用逗号隔开。不可以用赋值初始化const数据成员。\n\n2.组成：对象作为类的成员\n一个类可以将其他类的对象作为其成员，这种功能称为组成。\n\n#include&quot;Date.h&quot;//Employee.h头文件中包含Date.h\n\n#include&quot;Employee.h&quot;//程序中同时包含Employee.h和Date.h头文件\n#include&quot;Date.h&quot;\n\n3.friend函数和friend类\n类的friend函数在类的作用域以外定义，却具有访问类的非public成员的权限。单独的函数或整个类都可以被声明为另一个类的友元。在类定义中函数原型前加保留字friend，就将函数声明为该类的友元。使用非friend函数修改private成员是错误的尝试\n\n#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\nclass Count\n&#123;\n    friend void setX(Count &amp;,int);//友元声明 \npublic:\n    Count()\n    :x(0)\n    &#123;\n    &#125;\n    \n    void print()const\n    &#123;\n        cout&lt;&lt;x&lt;&lt;endl;\n    &#125;\nprivate:\n    int x;\n &#125;;\n \nvoid setX(Count &amp;c,int val)\n&#123;\n    c.x=val;\n&#125;\n\nint main(void)\n&#123;\n    Count counter;\n    cout&lt;&lt;&quot;counter.x after instantiation: &quot;;\n    counter.print();\n    \n    setX(counter,8);\n    cout&lt;&lt;&quot;counter.x after call to setX firend function: &quot;;\n    counter.print();\n    return 0;\n&#125;\n\n4.this指针\n对象的成员函数可以操作对象的数据，是因为每个对象有一个this指针来访问自己的地址。对象的this指针不是对象本身的一部分–也就是说，this指针占用的内存大小不会反映再对对象进行sizeof运算得到的结果中。对象可以隐式或者显示的使用this指针来引用它们的数据成员和成员函数。this指针的类型取决于对象的类型以及使用this的成员函数是否被声明为const。（A * const 为一个指向非const对象的const指针，const A *const为指向一个const A对象的const指针）\n\n#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\nclass Test\n&#123;\n    public:\n        Test(int = 0);//构造函数 \n        void print()const;\n    private:\n        int x;\n&#125;;\nTest::Test(int value)//成员初始化器 \n    :x(value)\n&#123;\n    \n&#125;\nvoid Test::print() const\n&#123;\n    cout&lt;&lt;&quot;          x = &quot;&lt;&lt;x&lt;&lt;endl;//隐式调用 \n    cout&lt;&lt;&quot;    this-&gt;x = &quot;&lt;&lt;this-&gt;x&lt;&lt;endl;//显式调用 \n    cout&lt;&lt;&quot;  (*this).x = &quot;&lt;&lt;(*this).x&lt;&lt;endl;//显式调用 \n&#125;\nint main(void)\n&#123;\n    Test test(666);\n    test.print();\n    return 0;\n&#125;\n\n\n使用this指针使串联的函数调用成为可能。\n\n//Time.h\n#ifndef TIME_H\n#define TIME_H\n\nclass Time\n&#123;\npublic:\n    Time(int =0,int =0,int =0);\n    \n    Time &amp;setTime(int,int,int);\n    Time &amp;setHour(int);\n    Time &amp;setMinute(int);\n    Time &amp;setSecond(int);\n    \n    int getHour()const;\n    int getMinute()const;\n    int getSecond()const;\n    \n    void printUniversal()const;\n    void printStandard()const;\nprivate:\n    int hour;\n    int minute;\n    int second; \n &#125;;\n\n#endif\n\n//Time.cpp\n#include&lt;iostream&gt;\nusing std::cout;\n\n#include&lt;iomanip&gt;\nusing std::setfill;\nusing std::setw;\n\n#include&quot;Time.h&quot;\n\nTime::Time(int hr,int min,int sec)\n&#123;\n    setTime(hr,min,sec);\n&#125;\n\nTime &amp;Time::setTime(int h,int m,int s)\n&#123;\n    setHour(h);\n    setMinute(m);\n    setSecond(s);\n    return *this;//返回Time类型\n&#125;\nTime &amp;Time::setHour(int h)\n&#123;\n    hour = (h&gt;=0&amp;&amp;h&lt;24)?h:0;\n    return *this;\t\n&#125;\n\nTime &amp;Time::setMinute(int m)\n&#123;\n    minute = (m&gt;=0&amp;&amp;m&lt;60)?m:0;\n    return *this;\t\n&#125;\n\nTime &amp;Time::setSecond(int s)\n&#123;\n    second = (s&gt;=0&amp;&amp;s&lt;60)?s:0;\n    return *this;\t\n&#125;\n\nint Time::getHour()const\n&#123;\n    return hour;\n&#125;\n\nint Time::getMinute()const\n&#123;\n    return minute;\n&#125;\n\nint Time::getSecond()const\n&#123;\n    return second;\n&#125;\n\nvoid Time::printUniversal()const\n&#123;\n    cout&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;setw(2)&lt;&lt;hour&lt;&lt;&quot;:&quot;\n    &lt;&lt;setw(2)&lt;&lt;minute&lt;&lt;&quot;:&quot;&lt;&lt;setw(2)&lt;&lt;second;\n&#125;\n\nvoid Time::printStandard()const\n&#123;\n    cout&lt;&lt;((hour==0||hour==12)?12:hour%12)&lt;&lt;&quot;:&quot;\n    &lt;&lt;setfill(&#39;0&#39;)&lt;&lt;setw(2)&lt;&lt;minute&lt;&lt;&quot;:&quot;&lt;&lt;setw(2)\n    &lt;&lt;second&lt;&lt;(hour&lt;12?&quot;AM&quot;:&quot;PM&quot;);\n&#125;\n\n//TimeTest.cpp\n#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\n#include&quot;Time.h&quot;\n\nint main(void)\n&#123;\n    Time t;\n    \n    t.setHour(18).setMinute(30).setSecond(30);//串联的函数调用\n    \n    cout&lt;&lt;&quot;Universal time:&quot;;\n    t.printUniversal();\n    \n    cout&lt;&lt;&quot;\\nStandard time:&quot;;\n    t.printStandard();\n    \n    cout&lt;&lt;&quot;\\n\\n New Standard time:&quot;;\n    t.setTime(20,20,20).printStandard();\n    cout&lt;&lt;endl;\n    return 0;\n&#125;\n\n5.使用new和delete运算符进行内存的动态管理\n对任何内置的或用户自定义的类型控制的内存进行分配与释放称为动态内存管理，由new和delete运算符完成。new运算符为一个Time类型的对象分配大小合适的内存空间，调用默认的构造函数来初始化这个对象并返回一个指向new运算符右边类型的指针。\n\nTime *timePtr;\ntimePtr = new Time;\n\n\nnew可以用于动态分布任何基本类型。\n\ndouble *ptr = new double(3.14159);\nTime &amp;timePtr = new Time(12,45,0);\nint &amp;gradesArray = new int[10];\n\n\ndelete运算符首先调用指针所指对象的析构函数，然后回收对象占用的内存空间。\n\ndelete timePtr;\n\n6.static成员\n对于类的每个对象来说，一般都满足一条规则，即它们各自拥有类所有数据成员的一份拷贝。但static数据成员仅有变量的一份拷贝供类的所有对象共享。如果对类的所有对象仅用一份数据拷贝就足够时，使用static数据成员可以节省存储空间。\n在static成员函数中使用this指针是一个编译错误；\n将static成员函数声明为const是一个编译错误。const限定词指示函数不能修改它操作的对象的内容，但是static成员函数独立于类的任何对象存在并且进行操作\n在删除动态分配的内存空间后，将指向这片内存的指针设置为0\n\n//Employee.h\n#ifndef EMPLOYEE_H\n#define EMPLOYEE_H\n\nclass Employee\n&#123;\npublic:\n    Employee(const char*const,const char*const);\n    ~Employee();\n    const char *getFirstNmae()const;\n    const char *getLastName()const;\n    \n    static int getCount();\nprivate:\n    char *firstName;\n    char *lastName;\n    \n    static int count;\n&#125;;\n\n#endif\n\n//Employee.cpp\n#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\n#include&lt;cstring&gt;\nusing std::strlen;\nusing std::strcpy;\n\n#include&quot;Employee.h&quot;\n\nint Employee::count=0;\n\nint Employee::getCount()\n&#123;\n    return count;\n&#125;\n\nEmployee::Employee(const char*const first,const char*const last)\n&#123;\n    firstName = new char[strlen(first)+1];\n    strcpy(firstName,first);\n    \n    lastName = new char[strlen(last)+1];\n    strcpy(lastName,last);\n    \n    count++;\n    \n    cout&lt;&lt;&quot;Employee constructor for&quot;&lt;&lt;firstName\n    &lt;&lt;&#39; &#39;&lt;&lt;lastName&lt;&lt;&quot; called &quot;&lt;&lt;endl; \n&#125;\nEmployee::~Employee()\n&#123;\n    cout&lt;&lt;&quot;~Employee() called for &quot;&lt;&lt;\n    firstName&lt;&lt;&#39; &#39;&lt;&lt;lastName&lt;&lt;endl;\n    \n    delete [] firstName;\n    delete [] lastName;\n    \n    count--;\n&#125;\nconst char *Employee::getFirstNmae()const\n&#123;\n    return firstName;\n&#125;\nconst char *Employee::getLastName()const\n&#123;\n    return lastName;\n&#125;\n\n//EmployeeTest.cpp\n#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\n#include&quot;Employee.h&quot;\n\nint main(void)\n&#123;\n    cout&lt;&lt;&quot;Number of employees before instantiation of any objects is &quot;\n    &lt;&lt;Employee::getCount()&lt;&lt;endl;\n    \n    Employee *e1Ptr = new Employee(&quot;Susan&quot;,&quot;Baker&quot;);\n    Employee *e2Ptr = new Employee(&quot;Robert&quot;,&quot;Jones&quot;);\n    \n    cout&lt;&lt;&quot;Number of employees after objects are instantiated is &quot;&lt;&lt;e1Ptr-&gt;getCount();\n    \n    cout&lt;&lt;&quot;\\n\\nEmployee 1: &quot;\n    &lt;&lt;e1Ptr-&gt;getFirstNmae()&lt;&lt;&quot; &quot;&lt;&lt;e1Ptr-&gt;getLastName()\n    &lt;&lt;&quot;\\n\\nEmployee 2: &quot;\n    &lt;&lt;e2Ptr-&gt;getFirstNmae()&lt;&lt;&quot; &quot;&lt;&lt;e2Ptr-&gt;getLastName()\n    &lt;&lt;&quot;\\n\\n&quot;;\n    \n    delete e1Ptr;\n    e1Ptr = 0;\n    delete e2Ptr;\n    e2Ptr = 0;\n    \n    cout&lt;&lt;&quot;Number of employees after objects are deleted is &quot;&lt;&lt;Employee::getCount()&lt;&lt;endl;\n    return 0;\n&#125;\n\n6.容器类和迭代器\n最受欢迎的类种类之一是容器类，也称为集合类，也就是为保存一组对象而设计的类。容器类一般提供诸如插入、删除、查找、排序以及测试某元素以确定其是否是集合的成员等之类的服务。数组、堆栈、队列、树和链表但是容器类的例子。\n迭代器对象或者简称迭代器常常与容器类结合在一起。迭代器是对象，它“穿行”于集合，返回集合中下一个元素。\n\n7.代理类\n代理类的作用：即使是类的private数据，代理类也允许你向类的客户隐藏。通过向类的客户提供只知道类法人public接口的代理类，就可以使客户能够使用类的服务，而又无法访问类的实现细节。\n\n//Yuanlei.h\nclass Yuanlei\n&#123;\npublic:\n    Yuanlei(int v)\n    :value(v)\n    &#123;\n        \n    &#125;\n\n    void setValue(int v)\n    &#123;\n        value = v;\n    &#125;\n    \n    int getValue()const\n    &#123;\n        return value;\n    &#125;\nprivate:\n    int value;\n&#125;;\n\n//Daililei.h\nclass Yuanlei;\n\nclass Daililei\n&#123;\npublic:\n    Daililei(int);\n    void setValue(int);\n    int getValue()const;\n    ~Daililei();\nprivate:\n    Yuanlei *ptr;\n&#125;;\n\n//Daililei.cpp\n#include&quot;Yuanlei.h&quot;\n#include&quot;Daililei.h&quot;\n\nDaililei::Daililei(int v)\n    :ptr(new Yuanlei(v))\n&#123;\n    \n&#125;\nvoid Daililei::setValue(int v)\n&#123;\n    ptr-&gt;setValue(v);\n&#125;\nint Daililei::getValue()const\n&#123;\n    return ptr-&gt;getValue();\n&#125;\nDaililei::~Daililei()\n&#123;\n    delete ptr;\n&#125;\n\n//DailileiTest.cpp\n#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\n#include&quot;Daililei.h&quot;\n\nint main(void)\n&#123;\n    Daililei i(5);\n    cout&lt;&lt;&quot;Daililei contains: &quot;&lt;&lt;i.getValue()&lt;&lt;&quot; before setValue &quot;&lt;&lt;endl;\n    i.setValue(10);\n    cout&lt;&lt;&quot;Daililei contains: &quot;&lt;&lt;i.getValue()&lt;&lt;&quot; after setValue &quot;&lt;&lt;endl;\n    return 0;\n&#125;\n\n","slug":"C++--类的深入剖析（下）","date":"2021-04-22T02:58:09.000Z","categories_index":"C++","tags_index":"类和对象","author_index":"会思想的苇草i"},{"id":"6830f8a00d81e25dd175ae13a91978e0","title":"C++--类的深入剖析(上)","content":"0.Time类的实例研究//Time.h\n#ifndef TIME_H\n#define TIME_H\n\nclass Time\n&#123;\n    public:\n        Time();\n        void setTime(int,int,int);\n        void printUniversal();\n        void printStandard();\n    private:\n        int hour;\n        int minute;\n        int second;\n&#125;;\n#endif\n\n//Time.cpp\n#include&lt;iostream&gt;\nusing std::cout;\n\n#include&lt;iomanip&gt;\nusing std::setfill;\nusing std::setw;\n\n#include&quot;Time.h&quot;\n\nTime::Time()\n&#123;\n    hour=minute=second=0;\n&#125;\n\nvoid Time::setTime(int h,int m,int s)\n&#123;\n    hour = (h&gt;=0&amp;&amp;h&lt;24)?h:0;\n    minute = (m&gt;=0&amp;&amp;m&lt;60)?m:0;\n    second = (s&gt;=0&amp;&amp;s&lt;60)?s:0;\n&#125;\n\nvoid Time::printUniversal()\n&#123;\n    cout&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;setw(2)&lt;&lt;hour&lt;&lt;&quot;:&quot;\n    &lt;&lt;setw(2)&lt;&lt;minute&lt;&lt;&quot;:&quot;&lt;&lt;setw(2)&lt;&lt;second;\n&#125;\n\nvoid Time::printStandard()\n&#123;\n    cout&lt;&lt;((hour==0||hour==12)?12:hour%12)&lt;&lt;&quot;:&quot;\n    &lt;&lt;setfill(&#39;0&#39;)&lt;&lt;setw(2)&lt;&lt;minute&lt;&lt;&quot;:&quot;&lt;&lt;setw(2)\n    &lt;&lt;second&lt;&lt;(hour&lt;12?&quot;AM&quot;:&quot;PM&quot;);\n&#125;\n\n//TimeTest.cpp\n#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\n#include&quot;Time.h&quot;\n\nint main(void)\n&#123;\n    Time t;\n    cout&lt;&lt;&quot;The initial universal time is&quot;;\n    t.printUniversal();\n    cout&lt;&lt;&quot;\\nThe initial standard time is&quot;;\n    t.printStandard();\n    \n    t.setTime(13,27,6);\n    \n    cout&lt;&lt;&quot;\\n\\nUniversal time after setTime is&quot;;\n    t.printUniversal();\n    cout&lt;&lt;&quot;\\nStandard time after setTime is&quot;;\n    t.printStandard();\n    \n    t.setTime(99,99,99);\n\n    cout&lt;&lt;&quot;\\n\\nAfter attempting invalid settings&quot;;\n    cout&lt;&lt;&quot;\\nUniversal time:&quot;;\n    t.printUniversal();\n    cout&lt;&lt;&quot;\\nStandard time:&quot;;\n    t.printStandard();\n    cout&lt;&lt;endl;\n    \n    return 0;\t\n&#125;\n\n1)预处理器封套利用预处理器指令#ifndef、#define和#endif等构成预处理器封套，从而避免头文件在一个程序中被多次包含。预处理器指令中符号常量命名的通常约定是简单地将头文件名用大写形式，其中的原点用下划线代替。（如TIME_H)\n2）数据成员初始化Time构造函数将数据成员初始化为0，这就确保了对象可以以一个可靠的状态开始。类的成员函数不能在类体中声明时初始化，推荐由类的构造函数初始化这些数据成员。（数据成员也可以由用Time类的设置函数来赋值）\n3）“粘性设置和非粘性设置使用流操作元setfill，用于指定当输出域宽大于输出整数值中数字个数时所需显示的填充字符。一旦用setfill指定了填充字符，该字符将应用在后续值的显示中。也就是说，setfill是一个粘性设置；与setw相反，setw是一个非粘性设置，它只对紧接着显示的值起作用。每个粘性设置当不再需要时，应当将它恢复为以前的设置。如果不这样做，可能导致后面程序中输出格式的不正确。\n4）成员函数与全局函数printUniversal函数和printStandard函数都不接收任何参数，因为这些成员函数隐式地知道他们将打印调用它们的特定Time对象的数据成员。（对象中封装了数据成员和成员函数，使成员函数有权访问数据成员）\n5）对象大小从逻辑上来讲，程序员认为对象是包含了数据和函数。然而事实并非如此，对象只包含数据，所以同假设也包含了成员函数的对象相比要小的多。（可用sizeof检验，结果只报告该类数据成员的大小）\n1.类的作用域和类成员的访问#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\nclass Count\n&#123;\n    public:\n        void setX(int value)\n        &#123;\n            x=value;\n        &#125;\n        void print()\n        &#123;\n            cout&lt;&lt;x&lt;&lt;endl;\n        &#125;\n    private:\n        int x;\n&#125;;\n\nint main(void)\n&#123;\n    Count counter;//实例化一个对象\n    Count *counterPtr=&amp;counter;//指向类的成员的指针\n    Count &amp;counterRef=counter;//定义一个变量,这个变量指向的是一个对象,称为对象的引用\n    \n    cout&lt;&lt;&quot;Set x to 1 and print using the object&#39;s name:&quot;;\n    counter.setX(1);\n    counter.print();\n    \n    cout&lt;&lt;&quot;Set x to 2 and print using the object&#39;s name:&quot;;\n    counterRef.setX(2);\n    counterRef.print();\n    \n    cout&lt;&lt;&quot;Set x to 3 and print using the object&#39;s name:&quot;;\n    counterPtr-&gt;setX(3);\n    counterPtr-&gt;print();\n    return 0;\n&#125;\n\n\n类的数据成员和成员函数属于该类的作用域。圆点成员选择运算符（.)前面加对象名称或者对象的引用，则可以访问对象的成员；箭头成员选择运算符（-&gt;)前面加对象的指针，则可以访问对象的成员。（可称为通过对象句柄来访问对象的成员函数）\n\n2.访问函数和工具函数\n访问函数可以读取或者显示数据。访问函数另一个常见的用法是测试条件是真还是假–常常称这样的函数为判定函数。如一开始的Time类，isAM和isPM就是一组有用的判定函数。\n工具函数不属于类的public接口部分，它是支持类的public成员函数操作的private成员函数。\n\n3.Time类的实例研究：默认实参的构造函数//Time.h\n#ifndef TIME_H\n#define TIME_H\n\nclass Time\n&#123;\n    public:\n        Time(int=0,int=0,int=0);\n        \n        void setTime(int,int,int);\n        void setHour(int);\n        void setMinute(int);\n        void setSecond(int);\n        \n        int getHour();\n        int getMinute();\n        int getSecond();\n        \n        void printUniversal();\n        void printStandard();\n    private:\n        int hour;\n        int minute;\n        int second;\n&#125;;\n#endif\n\n//Time.cpp\n#include&lt;iostream&gt;\nusing std::cout;\n\n#include&lt;iomanip&gt;\nusing std::setfill;\nusing std::setw;\n\n#include&quot;Time.h&quot;\n\nTime::Time(int hr,int min,int sec)\n&#123;\n    setTime(hr,min,sec);\n&#125;\n\nvoid Time::setTime(int h,int m,int s)\n&#123;\n    setHour(h);\n    setMinute(m);\n    setSecond(s);\n&#125;\n\nvoid Time::setHour(int h)\n&#123;\n    hour = (h&gt;=0&amp;&amp;h&lt;24)?h:0;\t\n&#125;\n\nvoid Time::setMinute(int m)\n&#123;\n    minute = (m&gt;=0&amp;&amp;m&lt;60)?m:0;\t\n&#125;\n\nvoid Time::setSecond(int s)\n&#123;\n    second = (s&gt;=0&amp;&amp;s&lt;60)?s:0;\t\n&#125;\n\nint Time::getHour()\n&#123;\n    return hour;\n&#125;\n\nint Time::getMinute()\n&#123;\n    return minute;\n&#125;\n\nint Time::getSecond()&#123;\n    return second;\n&#125;\n\nvoid Time::printUniversal()\n&#123;\n    cout&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;setw(2)&lt;&lt;hour&lt;&lt;&quot;:&quot;\n    &lt;&lt;setw(2)&lt;&lt;minute&lt;&lt;&quot;:&quot;&lt;&lt;setw(2)&lt;&lt;second;\n&#125;\n\nvoid Time::printStandard()\n&#123;\n    cout&lt;&lt;((hour==0||hour==12)?12:hour%12)&lt;&lt;&quot;:&quot;\n    &lt;&lt;setfill(&#39;0&#39;)&lt;&lt;setw(2)&lt;&lt;minute&lt;&lt;&quot;:&quot;&lt;&lt;setw(2)\n    &lt;&lt;second&lt;&lt;(hour&lt;12?&quot;AM&quot;:&quot;PM&quot;);\n&#125;\n\n//TimeTest.cpp\n#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\n#include&quot;Time.h&quot;\n\nint main(void)\n&#123;\n    Time t1;\n    Time t2(2);\n    Time t3(21,34);\n    Time t4(12,25,42);\n    Time t5(27,74,99);\n    \n    cout&lt;&lt;&quot;Constructed with:\\n\\nt1:all argument defaulted\\n&quot;;\n    t1.printUniversal();\n    cout&lt;&lt;endl;\n    t1.printStandard();\n    \n    cout&lt;&lt;&quot;\\n\\nt2:hour specified;minute and second defaulted\\n&quot;;\n    t2.printUniversal();\n    cout&lt;&lt;endl;\n    t2.printStandard();\n    \n    cout&lt;&lt;&quot;\\n\\nt3:hour and minute specified;second defaulted\\n&quot;;\n    t3.printUniversal();\n    cout&lt;&lt;endl;\n    t3.printStandard();\n    \n    cout&lt;&lt;&quot;\\n\\nt4:hour ,minute and second specified\\n&quot;;\n    t4.printUniversal();\n    cout&lt;&lt;endl;\n    t4.printStandard();\n    \n    cout&lt;&lt;&quot;\\n\\nt5:all invalues specified\\n&quot;;\n    t5.printUniversal();\n    cout&lt;&lt;endl;\n    t5.printStandard();\n    \n    return 0;\t\n&#125;\n\n\n实参隐式地传递给构造函数。Time的设置函数和获取函数始终在类的内部调用。本来，printUniversal和printStandard函数可以不通过调用这些设置和获取函数而直接访问类的private数据。以这样的方式来对类进行设计，可以降低因改变类的实现方法而造成的编程出错的可能性。\n\n4.  析构函数//CreatAndDestroy.h\n#include&lt;string&gt;\nusing std::string;\n\n#ifndef CREATE_H\n#define CREATE_H\n\nclass CreatAndDestroy\n&#123;\n    public:\n        CreatAndDestroy(int,string);\n        ~CreatAndDestroy();\n    private:\n        int objectID;\n        string message;\n&#125;;\n\n//CreatAndDestroy.cpp\n#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\n#include&quot;CreatAndDestroy.h&quot;\n\nCreatAndDestroy::CreatAndDestroy(int ID,string messageString)\n&#123;\n    objectID=ID;\n    message=messageString;\n    \n    cout&lt;&lt;&quot;Object &quot;&lt;&lt;objectID&lt;&lt;&quot; constructor runs  &quot;&lt;&lt;message&lt;&lt;endl;\n&#125;\nCreatAndDestroy::~CreatAndDestroy()\n&#123;\n    cout&lt;&lt;(objectID==1||objectID==6?&quot;\\n&quot;:&quot;&quot;);\n    \n    cout&lt;&lt;&quot;Object &quot;&lt;&lt;objectID&lt;&lt;&quot;  destructor runs  &quot;&lt;&lt;message&lt;&lt;endl;\n&#125;\n\n//CreatAndDestroytest.cpp\n#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\n#include&quot;CreatAndDestroy.h&quot;\n\nvoid creat(void);\n\nCreatAndDestroy first(1,&quot;(global before main)&quot;);\n\nint main(void)\n&#123;\n    cout&lt;&lt;&quot;\\nMAIN FUNCTION:EXECUTION BEGINS&quot;&lt;&lt;endl;\n    CreatAndDestroy second(2,&quot;(local automatic in main)&quot;);\n    static CreatAndDestroy third(3,&quot;(local static in main)&quot;);\n    \n    creat(); \n    \n    cout&lt;&lt;&quot;\\nMAIN FUNCTION:EXECUTION RESUMES&quot;&lt;&lt;endl;\n    CreatAndDestroy fouth(4,&quot;(local automatic in main)&quot;);\n    cout&lt;&lt;&quot;\\nMAIN FUNCTION:EXECUTION ENDS&quot;&lt;&lt;endl;\n    return 0; \n&#125;\nvoid creat(void)\n&#123;\n    cout&lt;&lt;&quot;\\nCREAT FUNCTION:EXECUYION BEGINS&quot;&lt;&lt;endl;\n    CreatAndDestroy fifth(5,&quot;(local static in creat)&quot;);\n    static CreatAndDestroy sixth(6,&quot;(local automatic in creat)&quot;);\n    CreatAndDestroy seventh(7,&quot;(local automatic in creat)&quot;);\n    cout&lt;&lt;&quot;\\nCREAT FUNCTION:EXECUTION ENDS&quot;&lt;&lt;endl; \n&#125;\n\n\n析构函数是另一种特殊的成员函数，类的析构函数的名字是在类名之前添加发音字符（~）后形成的字符序列。析构函数不接收任何参数，也不返回任何值；当对象撤销后，类的析构函数会隐式地调用。构造函数和析构函数都被隐式调用，一般而言析构函数的调用顺序与相应构造函数的调用顺序相反。析构函数本身不释放对象占用的内存空间，它只是在系统回收对象的内存空间之前执行扫尾工作，这样内存可以成行用于保存新的对象。\n全局作用域内定义的对象的构造函数，在文件内任何其他函数（包括main函数）开始执行前调用。当main函数执行结束时，相应的析构函数被调用。\n当程序执行到自动局部对象的定义处时，该对象的构造函数被调用；当程序执行离开对象的作用域时，相应的析构函数被调用。\nstatic局部对象的构造函数只调用一次,即在程序第一次执行到该对象的定义处时；而相应的析构函数的调用则发生在main函数结束时。\n如果程序的终止是调用exit函数，那么自动对象的析构函数不被调用；如果程序的终止是调用abort函数，那么任何对象的析构函数不被调用；全局或者静态对象的撤销顺序与他们建立的顺序正好相反。\n\n5.默认的逐个成员赋值//Date.h\n#ifndef DATE_H\n#define DATE_H\n\nclass Date\n&#123;\n    public:\n        Date(int=1,int=1,int=2000);\n        void print();\n    private:\n        int month;\n        int day;\n        int year;\n&#125;;\n\n#endif\n\n//Date.cpp\n#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\n#include&quot;Date.h&quot;\n\nDate::Date(int m,int d,int y)\n&#123;\n    month = m;\n    day = d;\n    year = y;\n&#125;\n\nvoid Date::print()\n&#123;\n    cout&lt;&lt;month&lt;&lt;&quot;/&quot;&lt;&lt;day&lt;&lt;&quot;/&quot;&lt;&lt;year;\n&#125;\n\n//DateTest.cpp\n#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\n#include&quot;Date.h&quot;\n\nint main(void)\n&#123;\n    Date date1(7,4,2004);\n    Date date2;\n    \n    cout&lt;&lt;&quot;date1=&quot;;\n    date1.print();\n    cout&lt;&lt;&quot;\\ndate2=&quot;;\n    date2.print();\n    \n    date2=date1;\n    \n    cout&lt;&lt;&quot;\\n\\nAfter default memberwise assignment,date2=&quot;;\n    date2.print();\n    cout&lt;&lt;endl;\n    return 0;\n&#125;\n\n\n赋值运算符可以将一个对象赋给另一个类型相同的对象。当所用类的数据成员包含指向动态分配内存的指针时，逐个成员赋值可能会引发严重的问题。\n\n","slug":"C++--类的深入剖析（上）","date":"2021-04-14T14:38:05.000Z","categories_index":"C++","tags_index":"类和对象","author_index":"会思想的苇草i"},{"id":"7669cae9d33b780b1bd0b4de74a11898","title":"C++--类和对象","content":"\n0、类、对象、成员函数、数据函数\n首先，我们做一个简单的类比。\n通常，一辆小汽车是从工程图样开始的，它们类似于设计房屋用的蓝图，可以通过蓝图去制造具有复杂功能的小汽车，我们可以将其类比于“类”。\n我们不能驾驶小轿车的工程图样，也不能驾驶“类”，所以应该先根据工程图样制造一辆小轿车；同样，我们应该创建类的对象。\n小汽车的每一项操作由对应的功能实现，这相当于类里面的成员函数。\n小轿车具有许多属性，比如颜色，油量；在类里面，属性由类的数据成员来具体说明。\n下面，通过七个例子对类进行初步剖析：\n\n\n1、定义具有类的成员函数#include&lt;iostream&gt;\n\nusing std::cout;\nusing std::endl;\n\nclass GradeBook//创建类\n&#123;\n    //公共成员访问说明符\n    public:\n        void displayMessage()//成员函数\n        &#123;\n            cout&lt;&lt;&quot;Welcome to the Grade Book!&quot;&lt;&lt;endl;\n         &#125; \n&#125;;\n\nint main(void)\n&#123;\n    GradeBook myGradeBook;//根据类来实例化对象\n    myGradeBook.displayMessage();//对象调用成员函数\n    return 0;\n&#125;\n\n\n定义具有一个成员函数的GradeBook类，然后创建一个GradeBook对象并调用它的成员函数。\n\n\n2、定义一个具有形参的成员函数#include&lt;iostream&gt;\nusing std::cout;\nusing std::cin;\nusing std::endl;\n\n#include&lt;string&gt;\nusing std::string;\nusing std::getline;\n\nclass GradeBook\n&#123;\n    public:\n        void displayMessage(string courseName)//设置形参\n        &#123;\n            cout &lt;&lt;&quot;Welcome to the grade book for\\n&quot;&lt;&lt;courseName&lt;&lt;&quot;!&quot;&lt;&lt;endl;\n        &#125;\n &#125; ;\n \n int main(void)\n &#123;\n     string nameofCourse;\n     GradeBook myGradeBook;\n     \n     cout&lt;&lt;&quot;Please enter the course name:&quot;&lt;&lt;endl;\n     getline(cin,nameofCourse);//获取参数\n     cout&lt;&lt;endl;\n     \n     myGradeBook.displayMessage(nameofCourse);//参数传递\n     return 0;\n &#125;\n\n\n定义具有一个成员函数的GradeBook类，该成员函数接受一个形参。\n\n\n3.数据成员、设置函数和一个获取函数的类#include&lt;iostream&gt;\nusing std::cout;\nusing std::cin;\nusing std::endl;\n\n#include&lt;string&gt;\nusing std::string;\nusing std::getline;\n\nclass GradeBook\n&#123;\n    public:\n        void setCourseName(string name)//设置-“更换器”\n        &#123;\n            courseName = name;\n        &#125;\n        string getCourseName()//获取-“访问器”\n        &#123;\n            return courseName;\n        &#125;\n        void displayMessage()\n        &#123;\n            cout&lt;&lt;&quot;Welcome to the grade book for\\n&quot;&lt;&lt;getCourseName()&lt;&lt;&quot;!&quot;&lt;&lt;endl; \n        &#125;\n    private://私有数据\n        string courseName;\n &#125; ;\n \n int main(void)\n &#123;\n     string nameofCourse;\n     GradeBook myGradeBook;\n     \n     cout&lt;&lt;&quot;Initial course name is:&quot;&lt;&lt;myGradeBook.getCourseName()&lt;&lt;endl;\n     \n     cout&lt;&lt;&quot;\\nPlease enter the course name:&quot;&lt;&lt;endl;\n     getline(cin,nameofCourse);\n     myGradeBook.setCourseName(nameofCourse);\n     \n     cout&lt;&lt;endl;\n     myGradeBook.displayMessage();\n     return 0;\n &#125;\n\n\n定义测试具有一个数据成员以及设置获取函数的类。\n\n\n4.用构造函数初始化对象#include&lt;iostream&gt;\nusing std::cout;\nusing std::cin;\nusing std::endl;\n\n#include&lt;string&gt;\nusing std::string;\n\nclass GradeBook\n&#123;\n    public:\n        GradeBook(string name)\n//构造函数：用于创建对象时初始化，无返回类型，不可以返回任何值\n        &#123;\n            setCourseName(name);\n        &#125;\n        void setCourseName(string name)\n        &#123;\n            courseName = name;\n        &#125;\n        string getCourseName()\n        &#123;\n            return courseName;\n        &#125;\n        void displayMessage()\n        &#123;\n            cout&lt;&lt;&quot;Welcome to the grade book for\\n&quot;&lt;&lt;getCourseName()&lt;&lt;&quot;!&quot;&lt;&lt;endl; \n        &#125;\n    private:\n        string courseName;\n &#125; ;\n \n int main(void)\n &#123;\n    GradeBook gradeBook1(&quot;C语言程序设计基础&quot;);//创建对象时初始化\n    GradeBook gradeBook2(&quot;C++大学基础教程&quot;);\n    \n    cout&lt;&lt;&quot;gradeBook1 created for course:&quot;&lt;&lt;gradeBook1.getCourseName()\n    &lt;&lt;&quot;\\ngradeBook2 created for course:&quot;&lt;&lt;gradeBook2.getCourseName()&lt;&lt;endl;\n     \n     return 0;\n &#125;\n\n\n实例化GradeBook类的多个对象并在创建每个GradeBook对象时使用GradeBook构造函数指定课程名称。\n\n\n5.一个类对应一个独立文件的可重用性//GradeBook.h\n#include&lt;iostream&gt;\nusing std::cout;\nusing std::cin;\nusing std::endl;\n\n#include&lt;string&gt;\nusing std::string;\n\nclass GradeBook\n&#123;\n    public:\n        GradeBook(string name)\n        &#123;\n            setCourseName(name);\n        &#125;\n        \n        void setCourseName(string name)\n        &#123;\n            courseName = name;\n        &#125;\n        \n        string getCourseName()\n        &#123;\n            return courseName;\n        &#125;\n        \n        void displayMessage()\n        &#123;\n            cout&lt;&lt;&quot;Welcome to the grade book for\\n&quot;&lt;&lt;getCourseName()&lt;&lt;&quot;!&quot;&lt;&lt;endl; \n        &#125;\n    private:\n        string courseName;\n &#125; ;\n\n//GeadeBook.cpp\n#include&lt;iostream&gt;\nusing std::cout; \nusing std::endl;\n\n#include&quot;GradeBook.h&quot;\n \nint main(void)\n &#123;\n    GradeBook gradeBook1(&quot;C语言程序设计基础&quot;);\n    GradeBook gradeBook2(&quot;C++大学基础教程&quot;);\n    \n    cout&lt;&lt;&quot;gradeBook1 created for course:&quot;&lt;&lt;gradeBook1.getCourseName()\n    &lt;&lt;&quot;\\ngradeBook2 created for course:&quot;&lt;&lt;gradeBook2.getCourseName()&lt;&lt;endl;\n     \n     return 0;\n &#125;\n\n\nGradeBook的类定义；\n包含源自文件GradeBook.h的GradeBook类以让main函数使用。\n\n\n6.接口的实现与分离//GradeBook.h\n#include&lt;string&gt;\nusing std::string;\n\nclass GradeBook\n&#123;\n    public:\n        GradeBook(string);\n        void setCourseName(string);\n        string getCourseName();\n        void displayMessage();\n    private:\n        string courseName;\n &#125;; \n\n//GradeBook.cpp\n#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\n#include&quot;GradeBook.h&quot;\n//成员函数名之前都添加了二元作用域分辨运算符&quot;::&quot;;在类的外部定义类的成员函数时，在函数名前省略类名和二元作用域分辨运算符会导致编译错误\nGradeBook::GradeBook(string name)\n&#123;\n    setCourseName(name);\n&#125;\n\nvoid GradeBook::setCourseName(string name)\n&#123;\n    courseName = name;\n&#125;\n\nstring GradeBook::getCourseName()\n&#123;\n    return courseName;\n&#125;\n\nvoid GradeBook::displayMessage()\n&#123;\n    cout&lt;&lt;&quot;Welcome to the grade book for\\n&quot;&lt;&lt;getCourseName()&lt;&lt;&quot;!&quot;&lt;&lt;endl; \n&#125;\n\n//GradeBookTest.cpp\n#include&lt;iostream&gt;\nusing std::cout; \nusing std::endl;\n\n#include&quot;GradeBook.h&quot;\n \nint main(void)\n &#123;\n    GradeBook gradeBook1(&quot;C语言程序设计基础&quot;);\n    GradeBook gradeBook2(&quot;C++大学基础教程&quot;);\n    \n    cout&lt;&lt;&quot;gradeBook1 created for course:&quot;&lt;&lt;gradeBook1.getCourseName()\n    &lt;&lt;&quot;\\ngradeBook2 created for course:&quot;&lt;&lt;gradeBook2.getCourseName()&lt;&lt;endl;\n     \n     return 0;\n &#125;\n\n\n指定类接口的函数原型的GradeBook的类定义；\nGradeBook成员函数的定义描述了GradeBook类的实现；\n接口和实现分离之后的GradeBook类的演示。\n\n\n7.用设置函数确认数据的有效性//GradeBook.h\n#include&lt;string&gt;\nusing std::string;\n\nclass GradeBook\n&#123;\n    public:\n        GradeBook(string);\n        void setCourseName(string);\n        string getCourseName();\n        void displayMessage();\n    private:\n        string courseName;\n &#125;; \n\n//GradeBook.cpp\n#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\n#include&quot;GradeBook.h&quot;\n\nGradeBook::GradeBook(string name)\n&#123;\n    setCourseName(name);\n&#125;\n\nvoid GradeBook::setCourseName(string name)\n&#123;\n    if(name.length() &lt;= 25)\n        courseName = name;\n        \n    if(name.length() &gt; 25)\n    &#123;\n        courseName = name.substr(0,25);//start at 0,length of 25\n        \n        cout&lt;&lt;&quot;Name\\&quot;&quot;&lt;&lt;name&lt;&lt;&quot;\\&quot;exceeds maximum length(25).\\n&quot; &lt;&lt;\n        &quot;Limiting courseName to first 25 characters.\\n&quot;&lt;&lt;endl;\n    &#125;\t\t\n&#125;\n\nstring GradeBook::getCourseName()\n&#123;\n    return courseName;\n&#125;\n\nvoid GradeBook::displayMessage()\n&#123;\n    cout&lt;&lt;&quot;Welcome to the grade book for\\n&quot;&lt;&lt;getCourseName()&lt;&lt;&quot;!&quot;&lt;&lt;endl; \n&#125;\n\n//GradeBookTest.cpp\n#include&lt;iostream&gt;\nusing std::cout; \nusing std::endl;\n\n#include&quot;GradeBook.h&quot;\n \nint main(void)\n &#123;\n    GradeBook gradeBook1(&quot;C语言程序设计基础1 2 3 4 5 6 7 9 10&quot;);\n    GradeBook gradeBook2(&quot;C++大学基础教程&quot;);\n    \n    cout&lt;&lt;&quot;gradeBook1&#39;s initial course name is:&quot;&lt;&lt;gradeBook1.getCourseName()\n    &lt;&lt;&quot;\\ngradeBook.2&#39;s initial course name is:&quot;&lt;&lt;gradeBook2.getCourseName()&lt;&lt;endl; \n    \n    gradeBook1.setCourseName(&quot;C语言程序设计基础&quot;); \n    \n    cout&lt;&lt;&quot;\\ngradeBook1&#39;s course name is:&quot;&lt;&lt;gradeBook1.getCourseName()\n    &lt;&lt;&quot;\\ngradeBook2&#39;s course name is:&quot;&lt;&lt;gradeBook2.getCourseName()&lt;&lt;endl;\n     \n     return 0;\n &#125;\n\n\nGradeBook的类定义；\nGradeBook类定义的成员函数定义，其中使用了确认数据成员courseName长度有效性的一个设置函数；\n创建和操作一个GradeBook对象，该对象中的课程名称限制到25个字符长。\n\n\n","slug":"C++--类和对象","date":"2021-04-14T04:52:28.000Z","categories_index":"C++","tags_index":"类和对象","author_index":"会思想的苇草i"},{"id":"c47e1917b76d2ae57b175191d76a83f7","title":"C语言--单链表","content":"单链表\n1、单链表的结构\n&#x3D;&#x3D;单链表是由一连串的结构（称为结点）组成的，其中每个结点都包含指向下一个结点的指针，单链表最后一个结点的指针为空。&#x3D;&#x3D; 如下：\n\nstruct node\n&#123;\n    int date;\n    struct node *next;\n&#125;\n\n\n\n头指针总是指向链表的第一个结点，如果整个链表为空（即不包含任何结点），则将头指针置为 NULL。\n\n为了操作方便，往往在首元结点前再增加一个结点，称之为头结点，头结点不存储元素。\n\n头指针指向头结点，头结点的指针域指向首元结点，我们称这种单链表为带头结点的单链表。链表为空时，头结点的指针域为空。\n\n\n\n\n2、单链表的建立（1）定义单链表的数据结构；（2）读取数据；（3）生成新结点；（4）将数据存入结点的成员变量中；（5）将新结点连接到表头或表尾。重复（2）~（5）直到输入结束。\nvoid CreatList(LinkList head)//尾插法\n&#123;\n    LinkList p, rear = head;\n    int num;\n\n    printf(&quot;输入若干整数，输入-1表示输入结束\\n&quot;);\n    while (scanf(&quot;%d&quot;,&amp;num),num != -1)\n    &#123;\n        p = (LinkList)malloc(sizeof(LNode));\n        p-&gt;date = num;\n        rear-&gt;next = p;\n        rear = p;\n    &#125;\n    rear-&gt;next = NULL;\n&#125;\n\n\n3、单链表的遍历（1）声明一个指针 p，并指向首元结点；（2）当 p 不为空，重复如下两个操作：输出 p 所指结点中的元素；指针 p 后移指向下一个元素。\nvoid PrintList(LinkList head)\n&#123;\n    LinkList p = head-&gt;next;\n\n    while(p)\n    &#123;\n        printf(&quot;%d &quot;,p-&gt;date);\n        p = p-&gt;next;\n    &#125;\n&#125;\n\n\n4、单链表的插入（1）在链表中，确定新元素应被加入到哪个结点的后面，该节点就被称为前驱结点，用指针变量 pre 指向；（2）创建一个新结点，使用一个指针 p 指向它；（3）将新结点的 next 指针指向前驱结点 next 指针指向那个结点；（4）将前驱结点的 next 指针指向新结点。\nvoid ListInsert(LinkList head,int i,int e)\n&#123;\n    LinkList p,pre = head;\n    int j = 0;\n\n    while (pre &amp;&amp; j&lt;i-1)\n    &#123;\n        pre = pre-&gt;next;\n        j++;\n    &#125;\n\n    if(!pre || i&lt;1)\n    &#123;\n        printf(&quot;i值错误\\n&quot;);\n        return;\n    &#125;\n\n    p = (LinkList)malloc(sizeof(LNode));\n    p-&gt;date = e;\n    p-&gt;next = pre-&gt;next;\n    pre-&gt;next = p;\n\n&#125;\n\n\n5、单链表的删除（1)定位要删除的结点（用 p 指向）的前驱结点（用 pre 指向）；（2）改变前驱结点的 next 指针，从而使它“绕过”被删除的结点；（3）调用 free 函数释放删除结点占用的内存空间。\nvoid ListDelete(LinkList head,int i,int *e)\n&#123;\n    LinkList p,pre = head;\n    int j = 0;\n    while (pre &amp;&amp; j&lt;i-1)\n    &#123;\n        pre = pre-&gt;next;\n        ++j;\n    &#125;\n    if(!pre || i&lt;1)\n    &#123;\n        printf(&quot;i值错误\\n&quot;);\n        return;\n    &#125;\n\n    p = pre-&gt;next;\n    pre-&gt;next = p-&gt;next;\n    *e = p-&gt;date;\n    free(p);\n&#125;\n\n\n6、单链表的综合运用//单链表的使用\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n\nstruct node\n&#123;\n    int date;\n    struct node *next;\n&#125;;\ntypedef struct node LNode,*LinkList;\n\nvoid CreatList(LinkList head);\nvoid PrintList(LinkList head);\nvoid ListDelete(LinkList head,int i,int *e);\nvoid ListInsert(LinkList head,int i,int e);\n\nint main(void)\n&#123;\n    LinkList head;\n    int i,e,select,n;\n\n    head = (LinkList)malloc(sizeof(LNode));\n    head-&gt;next  = NULL;\n\n    while (1)\n    &#123;\n        printf(&quot;1:创建链表\\n&quot;);\n        printf(&quot;2:在链表中插入元素\\n&quot;);\n        printf(&quot;3:删除元素\\n&quot;);\n        printf(&quot;4:输出链表中的元素\\n&quot;);\n        printf(&quot;0:退出系统\\n&quot;);\n        scanf(&quot;%d&quot;,&amp;select);\n\n        switch(select)&#123;\n            case 1:\n                CreatList(head);break;\n            case 2:\n                printf(&quot;请输入待插入位置和元素:&quot;);\n                scanf(&quot;%d%d&quot;,&amp;i,&amp;e);\n                ListInsert(head,i,e);break;\n            case 3:\n                printf(&quot;请输入待删除元素位置:&quot;);\n                scanf(&quot;%d&quot;,&amp;i);\n                ListDelete(head,i,&amp;e);break;\n            case 4:\n                PrintList(head);\n                printf(&quot;\\n&quot;);break;\n            case 0:\n                exit(0);\n        &#125;\n    &#125;\n    return 0;\n&#125;\nvoid CreatList(LinkList head)\n&#123;\n    LinkList p, rear = head;\n    int num;\n\n    printf(&quot;输入若干整数，输入-1表示输入结束\\n&quot;);\n    while (scanf(&quot;%d&quot;,&amp;num),num != -1)\n    &#123;\n        p = (LinkList)malloc(sizeof(LNode));\n        p-&gt;date = num;\n        rear-&gt;next = p;\n        rear = p;\n    &#125;\n    rear-&gt;next = NULL;\n&#125;\nvoid PrintList(LinkList head)\n&#123;\n    LinkList p = head-&gt;next;\n\n    while(p)\n    &#123;\n        printf(&quot;%d &quot;,p-&gt;date);\n        p = p-&gt;next;\n    &#125;\n&#125;\nvoid ListDelete(LinkList head,int i,int *e)\n&#123;\n    LinkList p,pre = head;\n    int j = 0;\n    while (pre &amp;&amp; j&lt;i-1)\n    &#123;\n        pre = pre-&gt;next;\n        ++j;\n    &#125;\n    if(!pre || i&lt;1)\n    &#123;\n        printf(&quot;i值错误\\n&quot;);\n        return;\n    &#125;\n\n    p = pre-&gt;next;\n    pre-&gt;next = p-&gt;next;\n    *e = p-&gt;date;\n    free(p);\n&#125;\nvoid ListInsert(LinkList head,int i,int e)\n&#123;\n    LinkList p,pre = head;\n    int j = 0;\n\n    while (pre &amp;&amp; j&lt;i-1)\n    &#123;\n        pre = pre-&gt;next;\n        j++;\n    &#125;\n\n    if(!pre || i&lt;1)\n    &#123;\n        printf(&quot;i值错误\\n&quot;);\n        return;\n    &#125;\n\n    p = (LinkList)malloc(sizeof(LNode));\n    p-&gt;date = e;\n    p-&gt;next = pre-&gt;next;\n    pre-&gt;next = p;\n\n&#125;\n\n\n","slug":"C语言--单链表","date":"2021-02-01T02:56:02.000Z","categories_index":"C语言","tags_index":"单链表","author_index":"会思想的苇草i"},{"id":"0a1ade0bf6e307cade98e485e243d791","title":"C语言--进制转换","content":"十进制与八进制的转换\n1.格式控制（直接输出）\n格式控制包括格式说明和格式字符。\n\n格式说明由“％”和格式字符组成，如％d、％f 等。它的作用是将输出的数据转换为指定的格式输出。格式说明总是由“％”字符开始的。不同类型的数据用不同的格式字符。\n\n&#x3D;&#x3D;％d 为整型输出；％o 以八进制数形式输出整数。&#x3D;&#x3D;\n\n\n#include&lt;stdio.h&gt;\n\nint main(void)\n&#123;\n    int n;\n    scanf(&quot;%d&quot;,&amp;n);\n    printf(&quot;%o&quot;,n);\n    return 0;\n&#125;\n\n\n2.除 k 取余法（循环）\n通过利用循环来实现除 k 取余法，是比较常见的一种进制转换的方式。\n\n#include&lt;stdio.h&gt;\n#include&lt;math.h&gt;\n\nint main(void)\n&#123;\n    int n,temp,sum=0,i=0;\n    scanf(&quot;%d&quot;,&amp;n);\n    while(n)\n    &#123;\n        temp = n%8;\n        n = n/8;\n        sum += temp*pow(10,i);\n        i++;\n    &#125;\n    printf(&quot;%d&quot;,sum);\n    return 0;\n&#125;\n\n\n3.字符串版\n利用字符串的特性来实现进制转换。\n\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#define N 100\n\nvoid change (char str[N],int n);\nint main(void)\n&#123;\n    char str[N];\n    int n;\n    scanf(&quot;%d&quot;,&amp;n);\n    change(str,n);\n    puts(str);\n    return 0;\n&#125;\nvoid change (char str[N],int n)\n&#123;\n    int i=0;\n    while(n)\n    &#123;\n        str[i]=n%8+&#39;0&#39;;\n        i++;\n        n/=8;\n    &#125;\n    str[i]=&#39;\\0&#39;;\n    strrev(str);\n&#125;\n\n\n4.指针法\n结合循环、字符串、指针来实现进制转换。\n\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#define N 100\n\nvoid change (char str[N],int n);\nint main(void)\n&#123;\n    char str[N];\n    int n;\n    scanf(&quot;%d&quot;,&amp;n);\n    change(str,n);\n    puts(str);\n    return 0;\n&#125;\nvoid change (char str[N],int n)\n&#123;\n    int i=0,d;\n    while(n)\n    &#123;\n        d = n%8;\n        str[i]=&quot;0123456789abcdef&quot;[d];\n        i++;\n        n/=8;\n    &#125;\n    str[i]=&#39;\\0&#39;;\n    strrev(str);\n&#125;\n\n\n","slug":"C语言--进制转换","date":"2021-01-02T04:53:42.000Z","categories_index":"C语言","tags_index":"进制转换","author_index":"会思想的苇草i"}]