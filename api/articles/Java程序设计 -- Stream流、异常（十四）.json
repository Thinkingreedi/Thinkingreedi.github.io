{"title":"Java程序设计--Stream流、异常","uid":"0b9a635cc4d74b69a28063082e6467ef","slug":"Java程序设计 -- Stream流、异常（十四）","date":"2022-03-28T08:27:03.000Z","updated":"2025-07-14T15:12:20.459Z","comments":true,"path":"api/articles/Java程序设计 -- Stream流、异常（十四）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","content":"<hr>\n<h1 id=\"1、Stream流\"><a href=\"#1、Stream流\" class=\"headerlink\" title=\"1、Stream流\"></a>1、Stream流</h1><h2 id=\"1-1-Stream流的概述\"><a href=\"#1-1-Stream流的概述\" class=\"headerlink\" title=\"1.1 Stream流的概述\"></a>1.1 Stream流的概述</h2><p>&#x3D;&#x3D;用于简化集合和数组操作的API。&#x3D;&#x3D;</p>\n<p>Stream流式思想的核心:</p>\n<ol>\n<li>先得到集合或者数组的Stream流(就是一根传送带)</li>\n<li>把元素放上去</li>\n<li>然后就用这个Stream流简化的API来方便的操作元素。</li>\n</ol>\n<pre><code class=\"java\">import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        List&lt;String&gt; names = new ArrayList&lt;&gt;();\n        Collections.addAll(names, &quot;张三丰&quot;,&quot;张无忌&quot;,&quot;周芷若&quot;,&quot;赵敏&quot;,&quot;张强&quot;);\n        System.out.println(names);\n        // 使用Stream实现的\n        names.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).filter(s -&gt; s.length() == 3).forEach(s -&gt; System.out.println(s));\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"1-2-Stream流的获取\"><a href=\"#1-2-Stream流的获取\" class=\"headerlink\" title=\"1.2 Stream流的获取\"></a>1.2 Stream流的获取</h2><p><strong>获取Stream流</strong></p>\n<p>创建─条流水线，并把数据放到流水线上准备进行操作</p>\n<p><strong>中间方法</strong></p>\n<p>流水线上的操作。一次操作完毕之后，还可以继续进行其他操作</p>\n<p><strong>终结方法</strong></p>\n<p>一个Stream流只能有一个终结方法，是流水线上的最后一个操作</p>\n<p>Stream操作集合或者数组的第一步是先得到Stream流，然后才能使用流的功能。</p>\n<p><strong>集合获取Stream流的方式</strong></p>\n<p>可以使用Collection接口中的默认方法stream()生成流</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">default Stream&lt; E &gt; stream()</td>\n<td align=\"center\">获取当前集合对象的Stream流</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>数组获取Stream流的方式</strong></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public static &lt; T&gt; Stream&lt; T&gt; stream(T[ ] array)</td>\n<td align=\"center\">获取当前数组的Stream流</td>\n</tr>\n<tr>\n<td align=\"center\">public static&lt; T&gt; stream&lt; T&gt; of(T… values)</td>\n<td align=\"center\">获取当前数组&#x2F;可变数据的Stream流</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">import java.util.*;\nimport java.util.stream.Stream;\n\npublic class StreamDemo02 &#123;\n    public static void main(String[] args) &#123;\n        /** --------------------Collection集合获取流-------------------------------   */\n        Collection&lt;String&gt; list = new ArrayList&lt;&gt;();\n        Stream&lt;String&gt; s =  list.stream();\n\n        /** --------------------Map集合获取流-------------------------------   */\n        Map&lt;String, Integer&gt; maps = new HashMap&lt;&gt;();\n        // 键流\n        Stream&lt;String&gt; keyStream = maps.keySet().stream();\n        // 值流\n        Stream&lt;Integer&gt; valueStream = maps.values().stream();\n        // 键值对流（拿整体）\n        Stream&lt;Map.Entry&lt;String,Integer&gt;&gt; keyAndValueStream =  maps.entrySet().stream();\n\n        /** ---------------------数组获取流------------------------------   */\n        String[] names = &#123;&quot;赵敏&quot;,&quot;小昭&quot;,&quot;灭绝&quot;,&quot;周芷若&quot;&#125;;\n        Stream&lt;String&gt; nameStream = Arrays.stream(names);\n        Stream&lt;String&gt; nameStream2 = Stream.of(names);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"1-3-Stream流的常用API\"><a href=\"#1-3-Stream流的常用API\" class=\"headerlink\" title=\"1.3 Stream流的常用API\"></a>1.3 Stream流的常用API</h2><p>Stream流的常用API(中间操作方法)</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">stream&lt; T&gt; filter(Predicate&lt;? super T&gt; predicate)</td>\n<td align=\"center\">用于对流中的数据进行过滤。</td>\n</tr>\n<tr>\n<td align=\"center\">stream&lt; T&gt; limit(long maxsize)</td>\n<td align=\"center\">获取前几个元素</td>\n</tr>\n<tr>\n<td align=\"center\">stream&lt; T&gt; skip(long n)</td>\n<td align=\"center\">跳过前几个元素</td>\n</tr>\n<tr>\n<td align=\"center\">stream&lt; T&gt; distinct()</td>\n<td align=\"center\">去除流中重复的元素。依赖(hashCode和eqluals方法)</td>\n</tr>\n<tr>\n<td align=\"center\">static &lt; T&gt; stream&lt; T&gt; concat(stream a,stream b)</td>\n<td align=\"center\">合并a和b两个流为一个流</td>\n</tr>\n<tr>\n<td align=\"center\">注意:</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<ul>\n<li>中间方法也称为非终结方法，调用完成后返回新的Stream流可以继续使用，支持链式编程。</li>\n<li>在Stream流中无法直接修改集合、数组中的数据。</li>\n</ul>\n<p><strong>Stream流的常见终结操作方法</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">void forEach(Consumer action)</td>\n<td align=\"center\">对此流的每个元素执行遍历操作</td>\n</tr>\n<tr>\n<td align=\"center\">long count()</td>\n<td align=\"center\">返回此流中的元素数</td>\n</tr>\n<tr>\n<td align=\"center\">注意:终结操作方法，调用完成后流就无法继续使用了，原因是不会返回Stream了。</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\n\npublic class StreamDemo03 &#123;\n    public static void main(String[] args) &#123;\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n        list.add(&quot;张无忌&quot;);\n        list.add(&quot;周芷若&quot;);\n        list.add(&quot;赵敏&quot;);\n        list.add(&quot;张强&quot;);\n        list.add(&quot;张三丰&quot;);\n        list.add(&quot;张三丰&quot;);\n\n        // Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)\n        list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).forEach(s -&gt; System.out.println(s));\n\n        long size = list.stream().filter(s -&gt; s.length() == 3).count();\n        System.out.println(size);\n\n       // list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).limit(2).forEach(s -&gt; System.out.println(s));\n        list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).limit(2).forEach(System.out::println);\n\n        list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).skip(2).forEach(System.out::println);\n\n        // map加工方法: 第一个参数原材料  -&gt; 第二个参数是加工后的结果。\n        // 给集合元素的前面都加上一个：黑马的：\n        list.stream().map(s -&gt; &quot;黑马的：&quot; + s).forEach(a -&gt; System.out.println(a));\n\n        // 需求：把所有的名称 都加工成一个学生对象。\n         list.stream().map(s -&gt; new Student(s)).forEach(s -&gt; System.out.println(s));\n//        list.stream().map(Student::new).forEach(System.out::println); // 构造器引用  方法引用\n\n        // 合并流。\n        Stream&lt;String&gt; s1 = list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;));\n        Stream&lt;String&gt; s2 = Stream.of(&quot;java1&quot;, &quot;java2&quot;);\n        // public static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)\n        Stream&lt;String&gt; s3 = Stream.concat(s1 , s2);\n        s3.distinct().forEach(s -&gt; System.out.println(s));\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"1-4-Stream流的收集操作\"><a href=\"#1-4-Stream流的收集操作\" class=\"headerlink\" title=\"1.4 Stream流的收集操作\"></a>1.4 Stream流的收集操作</h2><ul>\n<li><p>收集Stream流的含义:就是把Stream流操作后的结果数据转回到集合或者数组中去。</p>\n</li>\n<li><p>Stream流:方便操作集合&#x2F;数组的手段。</p>\n</li>\n<li><p>集合&#x2F;数组:才是开发中的目的。</p>\n</li>\n</ul>\n<p><strong>Stream流的收集方法</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">R collect(collector collector)</td>\n<td align=\"center\">开始收集Stream流，指定收集器</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>Collectors工具类提供了具体的收集方式</strong></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">名称</td>\n<td align=\"center\">说明</td>\n</tr>\n<tr>\n<td align=\"center\">:-:</td>\n<td align=\"center\">:-:</td>\n</tr>\n<tr>\n<td align=\"center\">public static <T> Collector toList()</td>\n<td align=\"center\">把元素收集到List集合中</td>\n</tr>\n<tr>\n<td align=\"center\">public static <T> collector toSet()</td>\n<td align=\"center\">把元素收集到Set集合中</td>\n</tr>\n<tr>\n<td align=\"center\">public static collector toMap(Function keyMapper , Function valueMapper)</td>\n<td align=\"center\">把元素收集到Map集合中</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">import java.util.*;\nimport java.util.function.IntFunction;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class StreamDemo05 &#123;\n    public static void main(String[] args) &#123;\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n        list.add(&quot;张无忌&quot;);\n        list.add(&quot;周芷若&quot;);\n        list.add(&quot;赵敏&quot;);\n        list.add(&quot;张强&quot;);\n        list.add(&quot;张三丰&quot;);\n        list.add(&quot;张三丰&quot;);\n\n        Stream&lt;String&gt; s1 = list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;));\n        List&lt;String&gt; zhangList = s1.collect(Collectors.toList()); // 可变集合\n        zhangList.add(&quot;java1&quot;);\n        System.out.println(zhangList);\n\n        // 注意注意注意：“流只能使用一次”\n        Stream&lt;String&gt; s2 = list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;));\n        Set&lt;String&gt; zhangSet = s2.collect(Collectors.toSet());\n        System.out.println(zhangSet);\n\n        Stream&lt;String&gt; s3 = list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;));\n//         Object[] arrs = s3.toArray();\n        String[] arrs = s3.toArray(String[]::new); // 可以不管，拓展一下思维！！\n        System.out.println(&quot;Arrays数组内容：&quot; + Arrays.toString(arrs));\n\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h1 id=\"2、异常处理\"><a href=\"#2、异常处理\" class=\"headerlink\" title=\"2、异常处理\"></a>2、异常处理</h1><h2 id=\"2-1-异常概述\"><a href=\"#2-1-异常概述\" class=\"headerlink\" title=\"2.1 异常概述\"></a>2.1 异常概述</h2><p>异常是程序在”编译”或者”执行”的过程中可能出现的问题，注意:语法错误不算在异常体系中。比如:数组索引越界、空指针异常、日期格式化异常，等…</p>\n<p>异常一旦出现了，如果没有提前处理，程序就会退出JVM虚拟机而终止。研究异常并且避免异常，然后提前处理异常，体现的是程序的安全，健壮性。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/1748a15d7b024825996a9d4716f68b4c.png\"><br><strong>Error:</strong></p>\n<ul>\n<li>&#x3D;&#x3D;系统级别问题、JVM退出等，代码无法控制。&#x3D;&#x3D;</li>\n</ul>\n<p><strong>Exception:</strong> java.lang包下，称为异常类，它表示程序本身可以处理的问题</p>\n<ul>\n<li><p>&#x3D;&#x3D;RuntimeException及其子类:运行时异常，编译阶段不会报错。(空指针异常，数组索引越界异常)&#x3D;&#x3D;</p>\n</li>\n<li><p>&#x3D;&#x3D;除RuntimeException之外所有的异常:编译时异常，编译期必须处理的，否则程序不能通过编译。(日期格式化异常)。&#x3D;&#x3D;</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/afb57acd5ab34038bba3df6fa06059b6.png\"></p>\n<p>编译时异常就是在编译的时候出现的异常，运行时异常就是在运行时出现的异常。</p>\n<h2 id=\"2-2-常见运行时异常\"><a href=\"#2-2-常见运行时异常\" class=\"headerlink\" title=\"2.2 常见运行时异常\"></a>2.2 常见运行时异常</h2><p>直接继承自RuntimeException或者其子类，编译阶段不会报错，运行时可能出现的错误。</p>\n<p><strong>运行时异常示例</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">中文</th>\n<th align=\"center\">英文</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">数组索引越界异常</td>\n<td align=\"center\">ArraylndexOutOfBoundsException</td>\n</tr>\n<tr>\n<td align=\"center\">空指针异常</td>\n<td align=\"center\">NullPointerException，直接输出没有问题，但是调用空指针H的变量的</td>\n</tr>\n<tr>\n<td align=\"center\">数学操作异常</td>\n<td align=\"center\">ArithmeticException</td>\n</tr>\n<tr>\n<td align=\"center\">类型转换异常</td>\n<td align=\"center\">ClassCastException</td>\n</tr>\n<tr>\n<td align=\"center\">数字转换异常</td>\n<td align=\"center\">NumberFormatException</td>\n</tr>\n</tbody></table>\n<p><strong>运行时异常:一般是程序员业务没有考虑好或者是编程逻辑不严谨引起的程序错误，自己的水平有问题!</strong></p>\n<pre><code class=\"java\">public class ExceptionDemo &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(&quot;程序开始。。。。。。&quot;);\n        /** 1.数组索引越界异常: ArrayIndexOutOfBoundsException。*/\n        int[] arr = &#123;1, 2, 3&#125;;\n        System.out.println(arr[2]);\n        // System.out.println(arr[3]); // 运行出错，程序终止\n\n        /** 2.空指针异常 : NullPointerException。直接输出没有问题。但是调用空指针的变量的功能就会报错！！ */\n        String name = null;\n        System.out.println(name); // null\n        // System.out.println(name.length()); // 运行出错，程序终止\n\n        /** 3.类型转换异常：ClassCastException。 */\n        Object o = 23;\n        // String s = (String) o;  // 运行出错，程序终止\n\n        /** 5.数学操作异常：ArithmeticException。 */\n        //int c = 10 / 0;\n\n        /** 6.数字转换异常： NumberFormatException。 */\n        //String number = &quot;23&quot;;\n        String number = &quot;23aabbc&quot;;\n        Integer it = Integer.valueOf(number); // 运行出错，程序终止\n        System.out.println(it + 1);\n\n        System.out.println(&quot;程序结束。。。。。&quot;);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"2-3-常见编译时异常\"><a href=\"#2-3-常见编译时异常\" class=\"headerlink\" title=\"2.3 常见编译时异常\"></a>2.3 常见编译时异常</h2><p>不是RuntimeException或者其子类的异常，编译阶段就报错，必须处理，否则代码不通过。</p>\n<p>编译时异常的作用是担心程序员的技术不行，在编译阶段就爆出一个错误,目的在于提醒不要出错!编译时异常是可遇不可求。遇到了就遇到了呗。</p>\n<pre><code class=\"java\">import java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class ExceptionDemo &#123;\n    public static void main(String[] args) throws ParseException &#123;\n        String date = &quot;2015-01-12 10:23:21&quot;;\n        // 创建一个简单日期格式化类：\n        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM-dd HH:mm:ss&quot;);\n        // 解析字符串时间成为日期对象\n        Date d = sdf.parse(date);\n        //\n        System.out.println(d);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"2-4-异常默认处理机制\"><a href=\"#2-4-异常默认处理机制\" class=\"headerlink\" title=\"2.4 异常默认处理机制\"></a>2.4 异常默认处理机制</h2><ol>\n<li>默认会在出现异常的代码那里自动的创建一个异常对象:ArithmeticException。</li>\n<li>异常会从方法中出现的点这里抛出给调用者，调用者最终抛出给JVM虚拟机。</li>\n<li>虚拟机接收到异常对象后，先在控制台直接输出异常栈信息数据。</li>\n<li>直接从当前执行的异常点干掉当前程序。</li>\n<li>后续代码没有机会执行了，因为程序已经死亡。</li>\n</ol>\n<h2 id=\"2-5-编译时异常的处理机制\"><a href=\"#2-5-编译时异常的处理机制\" class=\"headerlink\" title=\"2.5 编译时异常的处理机制\"></a>2.5 编译时异常的处理机制</h2><p>编译时异常是编译阶段就出错的，所以必须处理，否则代码根本无法通过。</p>\n<p>编译时异常的处理形式有三种:</p>\n<ol>\n<li>出现异常直接抛出去给调用者，调用者也继续抛出去。</li>\n<li>出现异常自己捕获处理，不麻烦别人。</li>\n<li>前两者结合，出现异常直接抛出去给调用者，调用者捕获处理。</li>\n</ol>\n<p><strong>异常处理方式1——throws</strong></p>\n<p>&#x3D;&#x3D;throws:用在方法上，可以将方法内部出现的异常抛出去给本方法的调用者处理。&#x3D;&#x3D;</p>\n<p>这种方式并不好，发生异常的方法自己不处理异常，如果异常最终抛出去给虚拟机将引起程序死亡。</p>\n<pre><code class=\"java\">//抛出异常格式\n方法 throws 异常1,异常2,异常3..&#123;\n&#125;\n//规范做法\n方法 throws Exception&#123;\n&#125;\n//（代表可以抛出一切异常）\n</code></pre>\n<pre><code class=\"java\">import java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class ExceptionDemo01 &#123;\n    public static void main(String[] args) throws Exception &#123;\n        System.out.println(&quot;程序开始。。。。。&quot;);\n        parseTime(&quot;2011-11-11 11:11:11&quot;);\n        System.out.println(&quot;程序结束。。。。。&quot;);\n    &#125;\n\n    public static void parseTime(String date) throws Exception &#123;\n        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);\n        Date d = sdf.parse(date);\n        System.out.println(d);\n    &#125;\n&#125;\n</code></pre>\n<p><strong>异常处理方式2—— try…catch…</strong></p>\n<p>&#x3D;&#x3D;监视捕获异常，用在方法内部，可以将方法内部出现的异常直接捕获处理。&#x3D;&#x3D;</p>\n<p>这种方式还可以，发生异常的方法自己独立完成异常的处理，程序可以继续往下执行。</p>\n<pre><code class=\"java\">//格式:\ntry&#123;\n    //监视可能出现异常的代码!\n&#125;catch(异常类型1变量)&#123;\n    //处理异常\n&#125;catch(异常类型2变量)&#123;\n    //处理异常\n&#125;...\n\n\n//建议格式:\ntry&#123;\n    //可能出现异常的代码！\n&#125;catch(Exception e)&#123;\n    e.printStackTrace();\n&#125;\n//Exception可以捕获一切异常类型\n</code></pre>\n<pre><code class=\"java\">import java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.InputStream;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class ExceptionDemo02 &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(&quot;程序开始。。。。&quot;);\n        parseTime(&quot;2011-11-11 11:11:11&quot;);\n        System.out.println(&quot;程序结束。。。。&quot;);\n    &#125;\n\n    public static void parseTime(String date) &#123;\n        try &#123;\n            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM-dd HH:mm:ss&quot;);\n            Date d = sdf.parse(date);\n            System.out.println(d);\n\n            InputStream is = new FileInputStream(&quot;E:/meinv.jpg&quot;);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace(); // 打印异常栈信息\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>异常处理方式3——前两者结合</strong></p>\n<ul>\n<li>&#x3D;&#x3D;方法直接将异通过throws抛出去给调用者&#x3D;&#x3D;</li>\n<li>&#x3D;&#x3D;调用者收到异常后直接捕获处理&#x3D;&#x3D;</li>\n</ul>\n<pre><code class=\"java\">import java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class ExceptionDemo03 &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(&quot;程序开始。。。。&quot;);\n        try &#123;\n            parseTime(&quot;2011-11-11 11:11:11&quot;);\n            System.out.println(&quot;功能操作成功~~~&quot;);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n            System.out.println(&quot;功能操作失败~~~&quot;);\n        &#125;\n        System.out.println(&quot;程序结束。。。。&quot;);\n    &#125;\n\n    public static void parseTime(String date) throws Exception &#123;\n        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy、MM-dd HH:mm:ss&quot;);\n        Date d = sdf.parse(date);\n        System.out.println(d);\n\n        InputStream is = new FileInputStream(&quot;D:/meinv.jpg&quot;);\n    &#125;\n\n&#125;\n</code></pre>\n<p><strong>在开发中按照规范来说第三种方式是最好的:底层的异常抛出去给最外层，最外层集中捕获处理。</strong></p>\n<p>实际应用中，只要代码能够编译通过，并且功能能完成，那么每一种异常处理方式似乎也都是可以的。</p>\n<h2 id=\"2-6-运行时异常的处理机制\"><a href=\"#2-6-运行时异常的处理机制\" class=\"headerlink\" title=\"2.6 运行时异常的处理机制\"></a>2.6 运行时异常的处理机制</h2><p>运行时异常编译阶段不会出错，是运行时才可能出错的，所以编译阶段不处理也可以。</p>\n<p>按照规范建议还是处理:建议在最外层调用处集中捕获处理即可。</p>\n<h2 id=\"2-7-自定义异常\"><a href=\"#2-7-自定义异常\" class=\"headerlink\" title=\"2.7 自定义异常\"></a>2.7 自定义异常</h2><p>自定义异常的必要?</p>\n<ul>\n<li>Java无法为这个世界上全部的问题提供异常类。</li>\n<li>如果企业想通过异常的方式来管理自己的某个业务问题，就需要自定义异常类了。</li>\n</ul>\n<p>自定义异常的好处:</p>\n<ul>\n<li>可以使用异常的机制管理业务问题，如提醒程序员注意。</li>\n<li>同时一旦出现bug，可以用异常的形式清晰的指出出错的地方。</li>\n</ul>\n<p><strong>自定义异常的分类</strong></p>\n<p><strong>1、自定义编译时异常</strong></p>\n<ol>\n<li>定义一个异常类继承Exception</li>\n<li>重写构造器</li>\n<li>在出现异常的地方用throw new自定义对象抛出</li>\n</ol>\n<p>作用:编译时异常是编译阶段就报错，提醒更加强烈，一定需要处理!!</p>\n<p><strong>2、自定义运行时异常</strong></p>\n<ol>\n<li>定义一个异常类继承RuntimeException</li>\n<li>重写构造器</li>\n<li>在出现异常的地方用throw new自定义对象抛出</li>\n</ol>\n<p>作用:提醒不强烈，编译阶段不报错!!运行时才可能出现!!</p>\n<pre><code class=\"java\">/**\n    自定义的编译时异常\n      1、继承Exception\n      2、重写构造器\n */\npublic class ItheimaAgeIlleagalException extends Exception&#123;\n    public ItheimaAgeIlleagalException() &#123;\n    &#125;\n\n    public ItheimaAgeIlleagalException(String message) &#123;\n        super(message);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">/**\n    自定义的编译时异常\n      1、继承RuntimeException\n      2、重写构造器\n */\npublic class ItheimaAgeIlleagalRuntimeException extends RuntimeException&#123;\n    public ItheimaAgeIlleagalRuntimeException() &#123;\n    &#125;\n\n    public ItheimaAgeIlleagalRuntimeException(String message) &#123;\n        super(message);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class ExceptionDemo &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            checkAge2(-23);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n    public static void checkAge2(int age)  &#123;\n        if(age &lt; 0 || age &gt; 200)&#123;\n            // 抛出去一个异常对象给调用者\n            // throw ：在方法内部直接创建一个异常对象，并从此点抛出\n            // throws : 用在方法申明上的，抛出方法内部的异常\n            throw new ItheimaAgeIlleagalRuntimeException(age + &quot; is illeagal!&quot;);\n        &#125;else &#123;\n            System.out.println(&quot;年龄合法：推荐商品给其购买~~&quot;);\n        &#125;\n    &#125;\n\n    public static void checkAge(int age) throws ItheimaAgeIlleagalException &#123;\n        if(age &lt; 0 || age &gt; 200)&#123;\n            // 抛出去一个异常对象给调用者\n            // throw ：在方法内部直接创建一个异常对象，并从此点抛出\n            // throws : 用在方法申明上的，抛出方法内部的异常\n            throw new ItheimaAgeIlleagalException(age + &quot; is illeagal!&quot;);\n        &#125;else &#123;\n            System.out.println(&quot;年龄合法：推荐商品给其购买~~&quot;);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<hr>\n","feature":true,"text":"Stream流和异常处理是Java编程中的关键概念。Stream提供了优雅的集合数据处理方式，简化了代码。异常处理确保程序稳定运行，通过try-catch-finally和throw机制捕获和处理错误。掌握Stream流和异常处理对于高效编程至关重要。...","permalink":"/post/Java程序设计 -- Stream流、异常（十四）","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"13 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1%E3%80%81Stream%E6%B5%81\"><span class=\"toc-text\">1、Stream流</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-Stream%E6%B5%81%E7%9A%84%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1.1 Stream流的概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-Stream%E6%B5%81%E7%9A%84%E8%8E%B7%E5%8F%96\"><span class=\"toc-text\">1.2 Stream流的获取</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-Stream%E6%B5%81%E7%9A%84%E5%B8%B8%E7%94%A8API\"><span class=\"toc-text\">1.3 Stream流的常用API</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4-Stream%E6%B5%81%E7%9A%84%E6%94%B6%E9%9B%86%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">1.4 Stream流的收集操作</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86\"><span class=\"toc-text\">2、异常处理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E5%BC%82%E5%B8%B8%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">2.1 异常概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E5%B8%B8%E8%A7%81%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">2.2 常见运行时异常</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-%E5%B8%B8%E8%A7%81%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">2.3 常见编译时异常</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-4-%E5%BC%82%E5%B8%B8%E9%BB%98%E8%AE%A4%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">2.4 异常默认处理机制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-5-%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">2.5 编译时异常的处理机制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-6-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">2.6 运行时异常的处理机制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-7-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">2.7 自定义异常</span></a></li></ol></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Java程序设计--日志框架、File、递归","uid":"414614a1c2fb25b2cf7d59eca8c59b48","slug":"Java程序设计 -- 日志框架、File、递归（十五）","date":"2022-03-29T10:02:05.000Z","updated":"2025-07-14T15:12:20.461Z","comments":true,"path":"api/articles/Java程序设计 -- 日志框架、File、递归（十五）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","text":"日志框架可以帮助开发者记录程序的运行状态和错误信息，提供了方便的日志管理和调试工具。File类则是用于文件和目录操作的核心类，提供了创建、删除、读取和写入等功能。递归是一种算法技巧，通过自我调用来解决问题，特别适合处理复杂的数据结构和算法。...","permalink":"/post/Java程序设计 -- 日志框架、File、递归（十五）","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true},"next_post":{"title":"Java程序设计--集合(下)","uid":"d48d7238235ebfe7d1b58dbbcb25bc7c","slug":"Java程序设计 -- 集合(下)（十三）","date":"2022-03-24T10:16:55.000Z","updated":"2025-07-14T15:12:20.462Z","comments":true,"path":"api/articles/Java程序设计 -- 集合(下)（十三）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","text":"Java集合框架是Java编程中至关重要的组成部分，其中Set和Map是两个核心接口。Set接口代表着不含重复元素的集合，而Map接口则表示键值对的映射关系。通过Set和Map，开发者能够高效地处理各种数据，并且这两个接口提供了丰富的方法和功能，如查找、遍历、添加和删除等。...","permalink":"/post/Java程序设计 -- 集合(下)（十三）","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true}}