{"title":"C++--类的深入剖析(下)","uid":"168349b15cc8fc12508a6c4a439d5818","slug":"C++--类的深入剖析（下）","date":"2021-04-22T02:58:09.000Z","updated":"2025-07-14T15:12:20.457Z","comments":true,"path":"api/articles/C++--类的深入剖析（下）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/506e6842fd8542408c76ef139e90ebd3.png","content":"<h2 id=\"0-const对象和const成员函数\"><a href=\"#0-const对象和const成员函数\" class=\"headerlink\" title=\"0.const对象和const成员函数\"></a>0.const对象和const成员函数</h2><ul>\n<li>程序员可以使用关键字const来指定对象是不可修改的，这样任何试图修改该对象的操作都将导致编译错误。下面的代码块：</li>\n</ul>\n<pre><code class=\"cpp\">const Time noon(12,0，0);\n</code></pre>\n<ul>\n<li>即声明了一个Time类的const对象noon，并且将它初始化为中午12点。对于const对象C++编译器不允许进行成员函数的调用，除非成员函数本身也声明为const。<strong>对于构造函数和析构函数是不可以进行const声明的，必须允许构造函数修改对象</strong></li>\n</ul>\n<pre><code class=\"cpp\">//Time.h\n#ifndef TIME_H\n#define TIME_H\n\nclass Time\n&#123;\n    public:\n        Time(int=0,int=0,int=0);\n        \n        void setTime(int,int,int);\n        void setHour(int);\n        void setMinute(int);\n        void setSecond(int);\n        \n        int getHour()const;\n        int getMinute()const;\n        int getSecond()const;\n        \n        void printUniversal()const;\n        void printStandard();\n    private:\n        int hour;\n        int minute;\n        int second;\n&#125;;\n\n#endif\n</code></pre>\n<pre><code class=\"cpp\">//Time.cpp\n#include&lt;iostream&gt;\nusing std::cout;\n\n#include&lt;iomanip&gt;\nusing std::setfill;\nusing std::setw;\n\n#include&quot;Time.h&quot;\n\nTime::Time(int hr,int min,int sec)\n&#123;\n    setTime(hr,min,sec);\n&#125;\n\nvoid Time::setTime(int h,int m,int s)\n&#123;\n    setHour(h);\n    setMinute(m);\n    setSecond(s);\n&#125;\n\nvoid Time::setHour(int h)\n&#123;\n    hour = (h&gt;=0&amp;&amp;h&lt;24)?h:0;\t\n&#125;\n\nvoid Time::setMinute(int m)\n&#123;\n    minute = (m&gt;=0&amp;&amp;m&lt;60)?m:0;\t\n&#125;\n\nvoid Time::setSecond(int s)\n&#123;\n    second = (s&gt;=0&amp;&amp;s&lt;60)?s:0;\t\n&#125;\n\nint Time::getHour()const\n&#123;\n    return hour;\n&#125;\n\nint Time::getMinute()const\n&#123;\n    return minute;\n&#125;\n\nint Time::getSecond()const\n&#123;\n    return second;\n&#125;\n\nvoid Time::printUniversal()const\n&#123;\n    cout&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;setw(2)&lt;&lt;hour&lt;&lt;&quot;:&quot;\n    &lt;&lt;setw(2)&lt;&lt;minute&lt;&lt;&quot;:&quot;&lt;&lt;setw(2)&lt;&lt;second;\n&#125;\n\nvoid Time::printStandard()const\n&#123;\n    cout&lt;&lt;((hour==0||hour==12)?12:hour%12)&lt;&lt;&quot;:&quot;\n    &lt;&lt;setfill(&#39;0&#39;)&lt;&lt;setw(2)&lt;&lt;minute&lt;&lt;&quot;:&quot;&lt;&lt;setw(2)\n    &lt;&lt;second&lt;&lt;(hour&lt;12?&quot;AM&quot;:&quot;PM&quot;);\n&#125;\n</code></pre>\n<pre><code class=\"cpp\">//TimeTest.cpp\n#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\n#include&quot;Time.h&quot;\n\nint main(void)\n&#123;\n    Time wakeUp(6.45,0);\n    const Time noon(12,1,1);\n    \n    wakeUp.setHour(18);\n    //noon.setHour(12);const对象调用非const成员函数 -error \n    \n    wakeUp.getHour();\n    noon.getHour();\n    \n    wakeUp.printUniversal();//非const对象调用const成员函数\n    cout&lt;&lt;endl;\n    wakeUp.printStandard();//非const对象调用非const成员函数\n    cout&lt;&lt;endl;\n    \n    noon.printUniversal();//const对象调用const成员函数\n    cout&lt;&lt;endl;\n    //noon.printStandard();const对象调用非const成员函数 -error \n    \n    return 0;\n&#125;\n</code></pre>\n<h2 id=\"1-用成员初始化器来初始化\"><a href=\"#1-用成员初始化器来初始化\" class=\"headerlink\" title=\"1.用成员初始化器来初始化\"></a>1.用成员初始化器来初始化</h2><ul>\n<li><strong>所有的数据成员均可以用成员初始化器形式进行初始化，但是const数据成员和引用的数据成员必须使用成员初始化器进行初始化</strong>。成员初始化器用法如下：</li>\n</ul>\n<pre><code class=\"cpp\">//Demo.h\n#ifndef DEMO_H\n#define DEMO_H\n\nclass Demo\n&#123;\n    public:\n        Demo(int c=0,int i=1);\n        \n        void addDemo()\n        &#123;\n            count += demo;\n        &#125;\n        void print()const;\n    private:\n        int count;\n        const int demo;\n&#125;;\n\n#endif\n</code></pre>\n<pre><code class=\"cpp\">//Demo.cpp\n#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\n#include&quot;Demo.h&quot;\n\nDemo::Demo(int c,int i)\n    :count(c),\n     demo(i)\n&#123;\n    \n&#125;\n\nvoid Demo::print()const\n&#123;\n    cout&lt;&lt;&quot;count = &quot;&lt;&lt;count&lt;&lt;&quot;, demo = &quot;&lt;&lt;demo&lt;&lt;endl;\n&#125;\n</code></pre>\n<pre><code class=\"cpp\">//DemoTest.cpp\n#include&lt;iostream&gt;\nusing std::cout;\n\n#include&quot;Demo.h&quot;\n\nint main(void)\n&#123;\n    Demo value(10,5);\n    \n    cout&lt;&lt;&quot;before &quot;;\n    value.print();\n    \n    for(int j=1;j&lt;=3;j++)\n    &#123;\n        value.addDemo();\n        cout&lt;&lt;&quot;after &quot;&lt;&lt;j&lt;&lt;&quot;:&quot;;\n        value.print(); \n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<ul>\n<li>构造函数的定义使用了一个成员初始化器列表来初始化demo类的数据成员–非const整数count和const整数demo。成员初始化器出现在构造函数的参数列表和作为构造函数体开始的左花括号之间。多个成员初始化器之间用逗号隔开。<strong>不可以用赋值初始化const数据成员。</strong></li>\n</ul>\n<h2 id=\"2-组成：对象作为类的成员\"><a href=\"#2-组成：对象作为类的成员\" class=\"headerlink\" title=\"2.组成：对象作为类的成员\"></a>2.组成：对象作为类的成员</h2><ul>\n<li>一个类可以将其他类的对象作为其成员，这种功能称为组成。</li>\n</ul>\n<pre><code class=\"cpp\">#include&quot;Date.h&quot;//Employee.h头文件中包含Date.h\n</code></pre>\n<pre><code class=\"cpp\">#include&quot;Employee.h&quot;//程序中同时包含Employee.h和Date.h头文件\n#include&quot;Date.h&quot;\n</code></pre>\n<h2 id=\"3-friend函数和friend类\"><a href=\"#3-friend函数和friend类\" class=\"headerlink\" title=\"3.friend函数和friend类\"></a>3.friend函数和friend类</h2><ul>\n<li>类的friend函数在类的作用域以外定义，却具有访问类的非public成员的权限。单独的函数或整个类都可以被声明为另一个类的友元。在类定义中函数原型前加保留字friend，就将函数声明为该类的友元。<strong>使用非friend函数修改private成员是错误的尝试</strong></li>\n</ul>\n<pre><code class=\"cpp\">#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\nclass Count\n&#123;\n    friend void setX(Count &amp;,int);//友元声明 \npublic:\n    Count()\n    :x(0)\n    &#123;\n    &#125;\n    \n    void print()const\n    &#123;\n        cout&lt;&lt;x&lt;&lt;endl;\n    &#125;\nprivate:\n    int x;\n &#125;;\n \nvoid setX(Count &amp;c,int val)\n&#123;\n    c.x=val;\n&#125;\n\nint main(void)\n&#123;\n    Count counter;\n    cout&lt;&lt;&quot;counter.x after instantiation: &quot;;\n    counter.print();\n    \n    setX(counter,8);\n    cout&lt;&lt;&quot;counter.x after call to setX firend function: &quot;;\n    counter.print();\n    return 0;\n&#125;\n</code></pre>\n<h2 id=\"4-this指针\"><a href=\"#4-this指针\" class=\"headerlink\" title=\"4.this指针\"></a>4.this指针</h2><ul>\n<li>对象的成员函数可以操作对象的数据，是因为每个对象有一个this指针来访问自己的地址。对象的this指针不是对象本身的一部分–也就是说，this指针占用的内存大小不会反映再对对象进行sizeof运算得到的结果中。对象可以隐式或者显示的使用this指针来引用它们的数据成员和成员函数。this指针的类型取决于对象的类型以及使用this的成员函数是否被声明为const。（A * const 为一个指向非const对象的const指针，const A *const为指向一个const A对象的const指针）</li>\n</ul>\n<pre><code class=\"cpp\">#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\nclass Test\n&#123;\n    public:\n        Test(int = 0);//构造函数 \n        void print()const;\n    private:\n        int x;\n&#125;;\nTest::Test(int value)//成员初始化器 \n    :x(value)\n&#123;\n    \n&#125;\nvoid Test::print() const\n&#123;\n    cout&lt;&lt;&quot;          x = &quot;&lt;&lt;x&lt;&lt;endl;//隐式调用 \n    cout&lt;&lt;&quot;    this-&gt;x = &quot;&lt;&lt;this-&gt;x&lt;&lt;endl;//显式调用 \n    cout&lt;&lt;&quot;  (*this).x = &quot;&lt;&lt;(*this).x&lt;&lt;endl;//显式调用 \n&#125;\nint main(void)\n&#123;\n    Test test(666);\n    test.print();\n    return 0;\n&#125;\n</code></pre>\n<ul>\n<li>使用this指针使串联的函数调用成为可能。</li>\n</ul>\n<pre><code class=\"cpp\">//Time.h\n#ifndef TIME_H\n#define TIME_H\n\nclass Time\n&#123;\npublic:\n    Time(int =0,int =0,int =0);\n    \n    Time &amp;setTime(int,int,int);\n    Time &amp;setHour(int);\n    Time &amp;setMinute(int);\n    Time &amp;setSecond(int);\n    \n    int getHour()const;\n    int getMinute()const;\n    int getSecond()const;\n    \n    void printUniversal()const;\n    void printStandard()const;\nprivate:\n    int hour;\n    int minute;\n    int second; \n &#125;;\n\n#endif\n</code></pre>\n<pre><code class=\"cpp\">//Time.cpp\n#include&lt;iostream&gt;\nusing std::cout;\n\n#include&lt;iomanip&gt;\nusing std::setfill;\nusing std::setw;\n\n#include&quot;Time.h&quot;\n\nTime::Time(int hr,int min,int sec)\n&#123;\n    setTime(hr,min,sec);\n&#125;\n\nTime &amp;Time::setTime(int h,int m,int s)\n&#123;\n    setHour(h);\n    setMinute(m);\n    setSecond(s);\n    return *this;//返回Time类型\n&#125;\nTime &amp;Time::setHour(int h)\n&#123;\n    hour = (h&gt;=0&amp;&amp;h&lt;24)?h:0;\n    return *this;\t\n&#125;\n\nTime &amp;Time::setMinute(int m)\n&#123;\n    minute = (m&gt;=0&amp;&amp;m&lt;60)?m:0;\n    return *this;\t\n&#125;\n\nTime &amp;Time::setSecond(int s)\n&#123;\n    second = (s&gt;=0&amp;&amp;s&lt;60)?s:0;\n    return *this;\t\n&#125;\n\nint Time::getHour()const\n&#123;\n    return hour;\n&#125;\n\nint Time::getMinute()const\n&#123;\n    return minute;\n&#125;\n\nint Time::getSecond()const\n&#123;\n    return second;\n&#125;\n\nvoid Time::printUniversal()const\n&#123;\n    cout&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;setw(2)&lt;&lt;hour&lt;&lt;&quot;:&quot;\n    &lt;&lt;setw(2)&lt;&lt;minute&lt;&lt;&quot;:&quot;&lt;&lt;setw(2)&lt;&lt;second;\n&#125;\n\nvoid Time::printStandard()const\n&#123;\n    cout&lt;&lt;((hour==0||hour==12)?12:hour%12)&lt;&lt;&quot;:&quot;\n    &lt;&lt;setfill(&#39;0&#39;)&lt;&lt;setw(2)&lt;&lt;minute&lt;&lt;&quot;:&quot;&lt;&lt;setw(2)\n    &lt;&lt;second&lt;&lt;(hour&lt;12?&quot;AM&quot;:&quot;PM&quot;);\n&#125;\n</code></pre>\n<pre><code class=\"cpp\">//TimeTest.cpp\n#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\n#include&quot;Time.h&quot;\n\nint main(void)\n&#123;\n    Time t;\n    \n    t.setHour(18).setMinute(30).setSecond(30);//串联的函数调用\n    \n    cout&lt;&lt;&quot;Universal time:&quot;;\n    t.printUniversal();\n    \n    cout&lt;&lt;&quot;\\nStandard time:&quot;;\n    t.printStandard();\n    \n    cout&lt;&lt;&quot;\\n\\n New Standard time:&quot;;\n    t.setTime(20,20,20).printStandard();\n    cout&lt;&lt;endl;\n    return 0;\n&#125;\n</code></pre>\n<h2 id=\"5-使用new和delete运算符进行内存的动态管理\"><a href=\"#5-使用new和delete运算符进行内存的动态管理\" class=\"headerlink\" title=\"5.使用new和delete运算符进行内存的动态管理\"></a>5.使用new和delete运算符进行内存的动态管理</h2><ul>\n<li>对任何内置的或用户自定义的类型控制的内存进行分配与释放称为动态内存管理，由new和delete运算符完成。new运算符为一个Time类型的对象分配大小合适的内存空间，调用默认的构造函数来初始化这个对象并返回一个指向new运算符右边类型的指针。</li>\n</ul>\n<pre><code class=\"cpp\">Time *timePtr;\ntimePtr = new Time;\n</code></pre>\n<ul>\n<li><strong>new可以用于动态分布任何基本类型。</strong></li>\n</ul>\n<pre><code class=\"cpp\">double *ptr = new double(3.14159);\nTime &amp;timePtr = new Time(12,45,0);\nint &amp;gradesArray = new int[10];\n</code></pre>\n<ul>\n<li>delete运算符首先调用指针所指对象的析构函数，然后回收对象占用的内存空间。</li>\n</ul>\n<pre><code class=\"cpp\">delete timePtr;\n</code></pre>\n<h2 id=\"6-static成员\"><a href=\"#6-static成员\" class=\"headerlink\" title=\"6.static成员\"></a>6.static成员</h2><ul>\n<li>对于类的每个对象来说，一般都满足一条规则，即它们各自拥有类所有数据成员的一份拷贝。但static数据成员仅有变量的一份拷贝供类的所有对象共享。如果对类的所有对象仅用一份数据拷贝就足够时，使用static数据成员可以节省存储空间。</li>\n<li><strong>在static成员函数中使用this指针是一个编译错误；</strong></li>\n<li><strong>将static成员函数声明为const是一个编译错误。const限定词指示函数不能修改它操作的对象的内容，但是static成员函数独立于类的任何对象存在并且进行操作</strong></li>\n<li><strong>在删除动态分配的内存空间后，将指向这片内存的指针设置为0</strong></li>\n</ul>\n<pre><code class=\"cpp\">//Employee.h\n#ifndef EMPLOYEE_H\n#define EMPLOYEE_H\n\nclass Employee\n&#123;\npublic:\n    Employee(const char*const,const char*const);\n    ~Employee();\n    const char *getFirstNmae()const;\n    const char *getLastName()const;\n    \n    static int getCount();\nprivate:\n    char *firstName;\n    char *lastName;\n    \n    static int count;\n&#125;;\n\n#endif\n</code></pre>\n<pre><code class=\"cpp\">//Employee.cpp\n#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\n#include&lt;cstring&gt;\nusing std::strlen;\nusing std::strcpy;\n\n#include&quot;Employee.h&quot;\n\nint Employee::count=0;\n\nint Employee::getCount()\n&#123;\n    return count;\n&#125;\n\nEmployee::Employee(const char*const first,const char*const last)\n&#123;\n    firstName = new char[strlen(first)+1];\n    strcpy(firstName,first);\n    \n    lastName = new char[strlen(last)+1];\n    strcpy(lastName,last);\n    \n    count++;\n    \n    cout&lt;&lt;&quot;Employee constructor for&quot;&lt;&lt;firstName\n    &lt;&lt;&#39; &#39;&lt;&lt;lastName&lt;&lt;&quot; called &quot;&lt;&lt;endl; \n&#125;\nEmployee::~Employee()\n&#123;\n    cout&lt;&lt;&quot;~Employee() called for &quot;&lt;&lt;\n    firstName&lt;&lt;&#39; &#39;&lt;&lt;lastName&lt;&lt;endl;\n    \n    delete [] firstName;\n    delete [] lastName;\n    \n    count--;\n&#125;\nconst char *Employee::getFirstNmae()const\n&#123;\n    return firstName;\n&#125;\nconst char *Employee::getLastName()const\n&#123;\n    return lastName;\n&#125;\n</code></pre>\n<pre><code class=\"cpp\">//EmployeeTest.cpp\n#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\n#include&quot;Employee.h&quot;\n\nint main(void)\n&#123;\n    cout&lt;&lt;&quot;Number of employees before instantiation of any objects is &quot;\n    &lt;&lt;Employee::getCount()&lt;&lt;endl;\n    \n    Employee *e1Ptr = new Employee(&quot;Susan&quot;,&quot;Baker&quot;);\n    Employee *e2Ptr = new Employee(&quot;Robert&quot;,&quot;Jones&quot;);\n    \n    cout&lt;&lt;&quot;Number of employees after objects are instantiated is &quot;&lt;&lt;e1Ptr-&gt;getCount();\n    \n    cout&lt;&lt;&quot;\\n\\nEmployee 1: &quot;\n    &lt;&lt;e1Ptr-&gt;getFirstNmae()&lt;&lt;&quot; &quot;&lt;&lt;e1Ptr-&gt;getLastName()\n    &lt;&lt;&quot;\\n\\nEmployee 2: &quot;\n    &lt;&lt;e2Ptr-&gt;getFirstNmae()&lt;&lt;&quot; &quot;&lt;&lt;e2Ptr-&gt;getLastName()\n    &lt;&lt;&quot;\\n\\n&quot;;\n    \n    delete e1Ptr;\n    e1Ptr = 0;\n    delete e2Ptr;\n    e2Ptr = 0;\n    \n    cout&lt;&lt;&quot;Number of employees after objects are deleted is &quot;&lt;&lt;Employee::getCount()&lt;&lt;endl;\n    return 0;\n&#125;\n</code></pre>\n<h2 id=\"6-容器类和迭代器\"><a href=\"#6-容器类和迭代器\" class=\"headerlink\" title=\"6.容器类和迭代器\"></a>6.容器类和迭代器</h2><ul>\n<li>最受欢迎的类种类之一是容器类，也称为集合类，也就是为保存一组对象而设计的类。容器类一般提供诸如插入、删除、查找、排序以及测试某元素以确定其是否是集合的成员等之类的服务。数组、堆栈、队列、树和链表但是容器类的例子。</li>\n<li>迭代器对象或者简称迭代器常常与容器类结合在一起。迭代器是对象，它“穿行”于集合，返回集合中下一个元素。</li>\n</ul>\n<h2 id=\"7-代理类\"><a href=\"#7-代理类\" class=\"headerlink\" title=\"7.代理类\"></a>7.代理类</h2><ul>\n<li>代理类的作用：即使是类的private数据，代理类也允许你向类的客户隐藏。通过向类的客户提供只知道类法人public接口的代理类，就可以使客户能够使用类的服务，而又无法访问类的实现细节。</li>\n</ul>\n<pre><code class=\"cpp\">//Yuanlei.h\nclass Yuanlei\n&#123;\npublic:\n    Yuanlei(int v)\n    :value(v)\n    &#123;\n        \n    &#125;\n\n    void setValue(int v)\n    &#123;\n        value = v;\n    &#125;\n    \n    int getValue()const\n    &#123;\n        return value;\n    &#125;\nprivate:\n    int value;\n&#125;;\n</code></pre>\n<pre><code class=\"cpp\">//Daililei.h\nclass Yuanlei;\n\nclass Daililei\n&#123;\npublic:\n    Daililei(int);\n    void setValue(int);\n    int getValue()const;\n    ~Daililei();\nprivate:\n    Yuanlei *ptr;\n&#125;;\n</code></pre>\n<pre><code class=\"cpp\">//Daililei.cpp\n#include&quot;Yuanlei.h&quot;\n#include&quot;Daililei.h&quot;\n\nDaililei::Daililei(int v)\n    :ptr(new Yuanlei(v))\n&#123;\n    \n&#125;\nvoid Daililei::setValue(int v)\n&#123;\n    ptr-&gt;setValue(v);\n&#125;\nint Daililei::getValue()const\n&#123;\n    return ptr-&gt;getValue();\n&#125;\nDaililei::~Daililei()\n&#123;\n    delete ptr;\n&#125;\n</code></pre>\n<pre><code class=\"cpp\">//DailileiTest.cpp\n#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\n#include&quot;Daililei.h&quot;\n\nint main(void)\n&#123;\n    Daililei i(5);\n    cout&lt;&lt;&quot;Daililei contains: &quot;&lt;&lt;i.getValue()&lt;&lt;&quot; before setValue &quot;&lt;&lt;endl;\n    i.setValue(10);\n    cout&lt;&lt;&quot;Daililei contains: &quot;&lt;&lt;i.getValue()&lt;&lt;&quot; after setValue &quot;&lt;&lt;endl;\n    return 0;\n&#125;\n</code></pre>\n","feature":false,"text":"C++中的类有一些进阶概念，包括friend函数、this指针和static成员。友元函数可以突破类的封装边界，this指针可以在成员函数中区分成员变量和局部变量，static成员可以在类的所有对象之间共享数据和行为。...","permalink":"/post/C++--类的深入剖析（下）","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"11 mins."},"categories":[{"name":"C++","slug":"C","count":6,"path":"api/categories/C.json"}],"tags":[{"name":"类和对象","slug":"类和对象","count":3,"path":"api/tags/类和对象.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0-const%E5%AF%B9%E8%B1%A1%E5%92%8Cconst%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">0.const对象和const成员函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E7%94%A8%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8%E6%9D%A5%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">1.用成员初始化器来初始化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E7%BB%84%E6%88%90%EF%BC%9A%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98\"><span class=\"toc-text\">2.组成：对象作为类的成员</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-friend%E5%87%BD%E6%95%B0%E5%92%8Cfriend%E7%B1%BB\"><span class=\"toc-text\">3.friend函数和friend类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-this%E6%8C%87%E9%92%88\"><span class=\"toc-text\">4.this指针</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E4%BD%BF%E7%94%A8new%E5%92%8Cdelete%E8%BF%90%E7%AE%97%E7%AC%A6%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E7%9A%84%E5%8A%A8%E6%80%81%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">5.使用new和delete运算符进行内存的动态管理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-static%E6%88%90%E5%91%98\"><span class=\"toc-text\">6.static成员</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8\"><span class=\"toc-text\">6.容器类和迭代器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-%E4%BB%A3%E7%90%86%E7%B1%BB\"><span class=\"toc-text\">7.代理类</span></a></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"C语言程序设计（第二版）知识点总结(上)","uid":"0a53341be894f519839526451962b94e","slug":"C语言程序设计（第二版）知识点总结（上）","date":"2022-01-10T02:01:04.000Z","updated":"2025-07-14T15:12:20.458Z","comments":true,"path":"api/articles/C语言程序设计（第二版）知识点总结（上）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/80b418cc19e241938eb78767b2f2382a.png","text":"《C语言程序设计（第二版）》是一本经典的教材，涵盖了C语言程序设计的基本知识和技巧。本文将对该书进行知识点总结，包括数据类型、控制语句、函数、数组、指针等重要内容。我们将概述每个知识点的核心概念和用法，并提供一些实例来加深理解。希望这篇文章能够帮助读者系统地掌握《C语言程序设计（第二版）》中的知识，提高编程能力，为日后的项目开发打下坚实的基础。...","permalink":"/post/C语言程序设计（第二版）知识点总结（上）","photos":[],"count_time":{"symbolsCount":"6.5k","symbolsTime":"6 mins."},"categories":[{"name":"C","slug":"C","count":3,"path":"api/categories/C.json"}],"tags":[{"name":"C语言","slug":"C语言","count":3,"path":"api/tags/C语言.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":false},"next_post":{"title":"C++--类的深入剖析(上)","uid":"6830f8a00d81e25dd175ae13a91978e0","slug":"C++--类的深入剖析（上）","date":"2021-04-14T14:38:05.000Z","updated":"2025-07-14T15:12:20.456Z","comments":true,"path":"api/articles/C++--类的深入剖析（上）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/506e6842fd8542408c76ef139e90ebd3.png","text":"在C++中，析构函数是一种特殊的成员函数，主要作用是释放对象所占用的资源，如释放动态分配的内存、关闭文件或释放其他系统资源。它可以执行任何必要的清理操作，以确保对象的资源被正确处理。...","permalink":"/post/C++--类的深入剖析（上）","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"C++","slug":"C","count":6,"path":"api/categories/C.json"}],"tags":[{"name":"类和对象","slug":"类和对象","count":3,"path":"api/tags/类和对象.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":false}}