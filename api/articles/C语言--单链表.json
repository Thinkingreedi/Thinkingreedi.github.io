{"title":"C语言--单链表","uid":"c47e1917b76d2ae57b175191d76a83f7","slug":"C语言--单链表","date":"2021-02-01T02:56:02.000Z","updated":"2025-07-14T15:12:20.457Z","comments":true,"path":"api/articles/C语言--单链表.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/aca9cfd116ae48d7a8782bc3b7550da2.png","content":"<h1 id=\"单链表\"><a href=\"#单链表\" class=\"headerlink\" title=\"单链表\"></a>单链表</h1><hr>\n<h2 id=\"1、单链表的结构\"><a href=\"#1、单链表的结构\" class=\"headerlink\" title=\"1、单链表的结构\"></a>1、单链表的结构</h2><ul>\n<li>&#x3D;&#x3D;单链表是由一连串的结构（称为结点）组成的，其中每个结点都包含指向下一个结点的指针，单链表最后一个结点的指针为空。&#x3D;&#x3D; 如下：</li>\n</ul>\n<pre><code class=\"c\">struct node\n&#123;\n    int date;\n    struct node *next;\n&#125;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/2021013113063363.png#pic_center\"></p>\n<ul>\n<li><p>头指针总是指向链表的第一个结点，如果整个链表为空（即不包含任何结点），则将头指针置为 NULL。</p>\n</li>\n<li><p>为了操作方便，往往在首元结点前再增加一个结点，称之为头结点，头结点不存储元素。</p>\n</li>\n<li><p>头指针指向头结点，头结点的指针域指向首元结点，我们称这种单链表为带头结点的单链表。链表为空时，头结点的指针域为空。</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/20210131130916171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FTSElZSTY2,size_16,color_FFFFFF,t_70#pic_center\"></p>\n<hr>\n<h2 id=\"2、单链表的建立\"><a href=\"#2、单链表的建立\" class=\"headerlink\" title=\"2、单链表的建立\"></a>2、单链表的建立</h2><p>（1）定义单链表的数据结构；<br>（2）读取数据；<br>（3）生成新结点；<br>（4）将数据存入结点的成员变量中；<br>（5）将新结点连接到表头或表尾。<br>重复（2）~（5）直到输入结束。</p>\n<pre><code class=\"c\">void CreatList(LinkList head)//尾插法\n&#123;\n    LinkList p, rear = head;\n    int num;\n\n    printf(&quot;输入若干整数，输入-1表示输入结束\\n&quot;);\n    while (scanf(&quot;%d&quot;,&amp;num),num != -1)\n    &#123;\n        p = (LinkList)malloc(sizeof(LNode));\n        p-&gt;date = num;\n        rear-&gt;next = p;\n        rear = p;\n    &#125;\n    rear-&gt;next = NULL;\n&#125;\n</code></pre>\n<hr>\n<h2 id=\"3、单链表的遍历\"><a href=\"#3、单链表的遍历\" class=\"headerlink\" title=\"3、单链表的遍历\"></a>3、单链表的遍历</h2><p>（1）声明一个指针 p，并指向首元结点；<br>（2）当 p 不为空，重复如下两个操作：输出 p 所指结点中的元素；指针 p 后移指向下一个元素。</p>\n<pre><code class=\"c\">void PrintList(LinkList head)\n&#123;\n    LinkList p = head-&gt;next;\n\n    while(p)\n    &#123;\n        printf(&quot;%d &quot;,p-&gt;date);\n        p = p-&gt;next;\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h2 id=\"4、单链表的插入\"><a href=\"#4、单链表的插入\" class=\"headerlink\" title=\"4、单链表的插入\"></a>4、单链表的插入</h2><p>（1）在链表中，确定新元素应被加入到哪个结点的后面，该节点就被称为前驱结点，用指针变量 pre 指向；<br>（2）创建一个新结点，使用一个指针 p 指向它；<br>（3）将新结点的 next 指针指向前驱结点 next 指针指向那个结点；<br>（4）将前驱结点的 next 指针指向新结点。</p>\n<pre><code class=\"c\">void ListInsert(LinkList head,int i,int e)\n&#123;\n    LinkList p,pre = head;\n    int j = 0;\n\n    while (pre &amp;&amp; j&lt;i-1)\n    &#123;\n        pre = pre-&gt;next;\n        j++;\n    &#125;\n\n    if(!pre || i&lt;1)\n    &#123;\n        printf(&quot;i值错误\\n&quot;);\n        return;\n    &#125;\n\n    p = (LinkList)malloc(sizeof(LNode));\n    p-&gt;date = e;\n    p-&gt;next = pre-&gt;next;\n    pre-&gt;next = p;\n\n&#125;\n</code></pre>\n<hr>\n<h2 id=\"5、单链表的删除\"><a href=\"#5、单链表的删除\" class=\"headerlink\" title=\"5、单链表的删除\"></a>5、单链表的删除</h2><p>（1)定位要删除的结点（用 p 指向）的前驱结点（用 pre 指向）；<br>（2）改变前驱结点的 next 指针，从而使它“绕过”被删除的结点；<br>（3）调用 free 函数释放删除结点占用的内存空间。</p>\n<pre><code class=\"c\">void ListDelete(LinkList head,int i,int *e)\n&#123;\n    LinkList p,pre = head;\n    int j = 0;\n    while (pre &amp;&amp; j&lt;i-1)\n    &#123;\n        pre = pre-&gt;next;\n        ++j;\n    &#125;\n    if(!pre || i&lt;1)\n    &#123;\n        printf(&quot;i值错误\\n&quot;);\n        return;\n    &#125;\n\n    p = pre-&gt;next;\n    pre-&gt;next = p-&gt;next;\n    *e = p-&gt;date;\n    free(p);\n&#125;\n</code></pre>\n<hr>\n<h2 id=\"6、单链表的综合运用\"><a href=\"#6、单链表的综合运用\" class=\"headerlink\" title=\"6、单链表的综合运用\"></a>6、单链表的综合运用</h2><pre><code class=\"c\">//单链表的使用\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n\nstruct node\n&#123;\n    int date;\n    struct node *next;\n&#125;;\ntypedef struct node LNode,*LinkList;\n\nvoid CreatList(LinkList head);\nvoid PrintList(LinkList head);\nvoid ListDelete(LinkList head,int i,int *e);\nvoid ListInsert(LinkList head,int i,int e);\n\nint main(void)\n&#123;\n    LinkList head;\n    int i,e,select,n;\n\n    head = (LinkList)malloc(sizeof(LNode));\n    head-&gt;next  = NULL;\n\n    while (1)\n    &#123;\n        printf(&quot;1:创建链表\\n&quot;);\n        printf(&quot;2:在链表中插入元素\\n&quot;);\n        printf(&quot;3:删除元素\\n&quot;);\n        printf(&quot;4:输出链表中的元素\\n&quot;);\n        printf(&quot;0:退出系统\\n&quot;);\n        scanf(&quot;%d&quot;,&amp;select);\n\n        switch(select)&#123;\n            case 1:\n                CreatList(head);break;\n            case 2:\n                printf(&quot;请输入待插入位置和元素:&quot;);\n                scanf(&quot;%d%d&quot;,&amp;i,&amp;e);\n                ListInsert(head,i,e);break;\n            case 3:\n                printf(&quot;请输入待删除元素位置:&quot;);\n                scanf(&quot;%d&quot;,&amp;i);\n                ListDelete(head,i,&amp;e);break;\n            case 4:\n                PrintList(head);\n                printf(&quot;\\n&quot;);break;\n            case 0:\n                exit(0);\n        &#125;\n    &#125;\n    return 0;\n&#125;\nvoid CreatList(LinkList head)\n&#123;\n    LinkList p, rear = head;\n    int num;\n\n    printf(&quot;输入若干整数，输入-1表示输入结束\\n&quot;);\n    while (scanf(&quot;%d&quot;,&amp;num),num != -1)\n    &#123;\n        p = (LinkList)malloc(sizeof(LNode));\n        p-&gt;date = num;\n        rear-&gt;next = p;\n        rear = p;\n    &#125;\n    rear-&gt;next = NULL;\n&#125;\nvoid PrintList(LinkList head)\n&#123;\n    LinkList p = head-&gt;next;\n\n    while(p)\n    &#123;\n        printf(&quot;%d &quot;,p-&gt;date);\n        p = p-&gt;next;\n    &#125;\n&#125;\nvoid ListDelete(LinkList head,int i,int *e)\n&#123;\n    LinkList p,pre = head;\n    int j = 0;\n    while (pre &amp;&amp; j&lt;i-1)\n    &#123;\n        pre = pre-&gt;next;\n        ++j;\n    &#125;\n    if(!pre || i&lt;1)\n    &#123;\n        printf(&quot;i值错误\\n&quot;);\n        return;\n    &#125;\n\n    p = pre-&gt;next;\n    pre-&gt;next = p-&gt;next;\n    *e = p-&gt;date;\n    free(p);\n&#125;\nvoid ListInsert(LinkList head,int i,int e)\n&#123;\n    LinkList p,pre = head;\n    int j = 0;\n\n    while (pre &amp;&amp; j&lt;i-1)\n    &#123;\n        pre = pre-&gt;next;\n        j++;\n    &#125;\n\n    if(!pre || i&lt;1)\n    &#123;\n        printf(&quot;i值错误\\n&quot;);\n        return;\n    &#125;\n\n    p = (LinkList)malloc(sizeof(LNode));\n    p-&gt;date = e;\n    p-&gt;next = pre-&gt;next;\n    pre-&gt;next = p;\n\n&#125;\n</code></pre>\n<hr>\n","feature":true,"text":"C语言中的单链表是一种常见的数据结构，用于存储和组织数据。在C语言中，可以使用指针和动态内存分配来实现单链表。单链表在C语言中有着广泛的应用，能够帮助程序员解决各种实际的数据组织和操作问题。...","permalink":"/post/C语言--单链表","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"C语言","slug":"C语言","count":2,"path":"api/categories/C语言.json"}],"tags":[{"name":"单链表","slug":"单链表","count":1,"path":"api/tags/单链表.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">单链表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">1、单链表的结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BB%BA%E7%AB%8B\"><span class=\"toc-text\">2、单链表的建立</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">3、单链表的遍历</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5\"><span class=\"toc-text\">4、单链表的插入</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">5、单链表的删除</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%BC%E5%90%88%E8%BF%90%E7%94%A8\"><span class=\"toc-text\">6、单链表的综合运用</span></a></li></ol></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"C++--类和对象","uid":"7669cae9d33b780b1bd0b4de74a11898","slug":"C++--类和对象","date":"2021-04-14T04:52:28.000Z","updated":"2025-07-14T15:12:20.456Z","comments":true,"path":"api/articles/C++--类和对象.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/506e6842fd8542408c76ef139e90ebd3.png","text":"类和对象是C++中面向对象编程的基本概念。通过使用类和对象，可以实现封装、继承和多态等面向对象编程的特性。类和对象的使用能够提高代码的可维护性、重用性和扩展性，使程序更加模块化和灵活。...","permalink":"/post/C++--类和对象","photos":[],"count_time":{"symbolsCount":"8.4k","symbolsTime":"8 mins."},"categories":[{"name":"C++","slug":"C","count":6,"path":"api/categories/C.json"}],"tags":[{"name":"类和对象","slug":"类和对象","count":3,"path":"api/tags/类和对象.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":false},"next_post":{"title":"C语言--进制转换","uid":"0a1ade0bf6e307cade98e485e243d791","slug":"C语言--进制转换","date":"2021-01-02T04:53:42.000Z","updated":"2025-07-14T15:12:20.458Z","comments":true,"path":"api/articles/C语言--进制转换.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/aca9cfd116ae48d7a8782bc3b7550da2.png","text":"当涉及C语言中的十进制和八进制转换时，可以使用一些技巧和函数来实现。在C语言中，我们可以通过使用printf函数和%o格式说明符将十进制数转换为八进制数进行输出。此外也可以使用除K取余法、指针法等。...","permalink":"/post/C语言--进制转换","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"C语言","slug":"C语言","count":2,"path":"api/categories/C语言.json"}],"tags":[{"name":"进制转换","slug":"进制转换","count":1,"path":"api/tags/进制转换.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":false}}