{"title":"Java程序设计--集合(下)","uid":"d48d7238235ebfe7d1b58dbbcb25bc7c","slug":"Java程序设计 -- 集合(下)（十三）","date":"2022-03-24T10:16:55.000Z","updated":"2025-07-14T15:12:20.462Z","comments":true,"path":"api/articles/Java程序设计 -- 集合(下)（十三）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","content":"<hr>\n<h1 id=\"1、Set系列集合\"><a href=\"#1、Set系列集合\" class=\"headerlink\" title=\"1、Set系列集合\"></a>1、Set系列集合</h1><h2 id=\"1-1-Set系列集合概述\"><a href=\"#1-1-Set系列集合概述\" class=\"headerlink\" title=\"1.1 Set系列集合概述\"></a>1.1 Set系列集合概述</h2><p><img src=\"https://img-blog.csdnimg.cn/f001a368983c4b2698ff7b0e154ee30e.png#pic_center\"><br>Set系列集合特点</p>\n<ul>\n<li><strong>无序:</strong> 存取顺序不一致</li>\n<li><strong>不重复:</strong> 可以去除重复</li>\n<li><strong>无索引:</strong> 没有带索引的方法，所以不能使用普通for循环遍历，也不能通过索弓|来获取元素。</li>\n</ul>\n<p>Set集合实现类特点</p>\n<ul>\n<li><strong>HashSet :&#x3D;&#x3D;无序&#x3D;&#x3D;、不重复、无索引。</strong></li>\n<li><strong>LinkedHashSet: &#x3D;&#x3D;有序&#x3D;&#x3D;、不重复、无索引。</strong></li>\n<li><strong>TreeSet: &#x3D;&#x3D;可排序&#x3D;&#x3D;、不重复、无索引。</strong></li>\n</ul>\n<pre><code class=\"java\">import java.util.HashSet;\nimport java.util.Set;\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        // 看看Set系列集合的特点： HashSet LinkedHashSet TreeSet\n        //\n        Set&lt;String&gt; sets = new HashSet&lt;&gt;(); // 一行经典代码  无序不重复，无索引\n        // Set&lt;String&gt; sets = new LinkedHashSet&lt;&gt;(); // 有序  不重复 无索引\n        sets.add(&quot;MySQL&quot;);\n        sets.add(&quot;MySQL&quot;);\n        sets.add(&quot;Java&quot;);\n        sets.add(&quot;Java&quot;);\n        sets.add(&quot;HTML&quot;);\n        sets.add(&quot;HTML&quot;);\n        sets.add(&quot;SpringBoot&quot;);\n        sets.add(&quot;SpringBoot&quot;);\n        System.out.println(sets);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"1-2-HashSet元素无序的底层原理\"><a href=\"#1-2-HashSet元素无序的底层原理\" class=\"headerlink\" title=\"1.2 HashSet元素无序的底层原理\"></a>1.2 HashSet元素无序的底层原理</h2><p>HashSet集合底层采取<strong>哈希表</strong>存储的数据。</p>\n<p>哈希表是一种对于增删改查数据性能都较好的结构。</p>\n<p>哈希值- -是JDK根据对象的地址，按照某种规则算出来的int类型的数值。</p>\n<p><strong>Object类的API</strong></p>\n<ul>\n<li>public int hashCode():返回对象的哈希值</li>\n</ul>\n<pre><code class=\"java\">public class Test &#123;\n    public static void main(String[] args) &#123;\n        // 目标：学会获取对象的哈希值，并确认一下\n        String name = &quot;haut&quot;;\n        System.out.println(name.hashCode());\n        System.out.println(name.hashCode());\n\n        String name1 = &quot;haut1&quot;;\n        System.out.println(name1.hashCode());\n        System.out.println(name1.hashCode());\n    &#125;\n&#125;\n</code></pre>\n<p><strong>对象的哈希值特点</strong></p>\n<ul>\n<li>同一个对象多次调用hashCode()方法返回的哈希值是相同的</li>\n<li>默认情况下，不同对象的哈希值是不同的。</li>\n</ul>\n<p><strong>HashSet1.7版本原理解析（数组+链表）</strong></p>\n<ol>\n<li>创建一个默认长度1 6的数组，数组名table</li>\n<li>根据元素的哈希值跟数组的长度求余计算出应存入的位置(哈希算法)</li>\n<li>判断当前位置是否为null,如果是null直接存入</li>\n<li>如果位置不为null,表示有元素，则调用equals方法比较</li>\n<li>如果一样，则不存，如果不一样，则存入数组,<ul>\n<li>JDK 7新元素占老元素位置，指向老元素</li>\n<li>JDK 8中新元素挂在老元素下面</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/9f89918bd8d049a28ccf2e9878a5f9d2.png#pic_center\"><br><strong>JDK1. .8版本HashSet原理解析（数组+链表+红黑树）</strong></p>\n<p>底层结构:哈希表(数组、链表、红黑树的结合体)<br>当挂在元素下面的数据过多时,查询性能降低，从JDK8开始后，当链表长度超过8的时候，自动转换为红黑树。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/0708913118dc4ea68eb0a3d2ae260336.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/41e8be63826148b6aeb3bf5b14e44886.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/9f46ad6f051846ba8d3102df9772b6cd.png#pic_center\"></p>\n<h2 id=\"1-3-HashSet元素去重复的底层原理\"><a href=\"#1-3-HashSet元素去重复的底层原理\" class=\"headerlink\" title=\"1.3 HashSet元素去重复的底层原理\"></a>1.3 HashSet元素去重复的底层原理</h2><p><img src=\"https://img-blog.csdnimg.cn/c14eff023bc24feb9f0e1a217d234494.png#pic_center\"></p>\n<ol>\n<li>创建一个默认长度16的数组, 数组名table</li>\n<li>根据元素的哈希值跟数组的长度求余计算出应存入的位置(哈希算法)</li>\n<li>判断当前位置是否为nll,如果是nulI直接存入</li>\n<li>如果位置不为null,表示有元素,则调用equals方法比较</li>\n<li>如果一样,则不存,如果不一样, 则存入数组</li>\n</ol>\n<p>结论:如果希望Set集合认为2个内容一样的对象是重复的,必须重写对象的hashCode()和equals(方法</p>\n<h2 id=\"1-4-实现类：LinkedHashSet\"><a href=\"#1-4-实现类：LinkedHashSet\" class=\"headerlink\" title=\"1.4 实现类：LinkedHashSet\"></a>1.4 实现类：LinkedHashSet</h2><p>LinkedHashSet集合概述和特点</p>\n<ul>\n<li>有序、不重复、无索引。</li>\n<li>这里的有序指的是保证存储和取出的元素顺序一致。</li>\n<li>原理:底层数据结构是依然哈希表,只是每个元素又额外的多了一个双链表的机制记录存储的顺序。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/3f6670665a53445cb08936cdc1452638.png#pic_center\"></p>\n<h2 id=\"1-5-实现类：TreeSet\"><a href=\"#1-5-实现类：TreeSet\" class=\"headerlink\" title=\"1.5 实现类：TreeSet\"></a>1.5 实现类：TreeSet</h2><p><strong>TreeSet集合概述和特点</strong></p>\n<ul>\n<li>&#x3D;&#x3D;不重复、 无索引、可排序。&#x3D;&#x3D;</li>\n<li>&#x3D;&#x3D;可排序: 按照元素的大小默认升序(有小到大)排序。&#x3D;&#x3D;</li>\n<li>TreeSet集合底层是基 于红黑树的数据结构实现排序的，增删改查性能都较好。</li>\n</ul>\n<p>注意: TreeSet集合是一定要排序的，可以将元素按照指定的规则进行排序。</p>\n<p><strong>TreeSet集合默认的规则</strong></p>\n<ul>\n<li>&#x3D;&#x3D;对于数值类型: Integer , Double,官方默认按照大小进行升序排序。&#x3D;&#x3D;</li>\n<li>&#x3D;&#x3D;对于字符串类型: 默认按照首字符的编号升序排序。&#x3D;&#x3D;</li>\n<li>&#x3D;&#x3D;对于自定义类型如Student对象, TreeSet无法直接排序。&#x3D;&#x3D;</li>\n</ul>\n<p>结论:想要使用TreeSet存储自定义类型，需要制定排序规则</p>\n<p><strong>自定义排序规则</strong></p>\n<p>TreeSet集合存储对象的的时候有2种方式可以设计自定义比较规则</p>\n<p><strong>方式一</strong></p>\n<ul>\n<li>让自定义的类实现Comparable接口重写里面的compareTo方法来定制比较规则。</li>\n</ul>\n<p><strong>方式二</strong></p>\n<ul>\n<li>TreeSet集合有参数构造器， 可以设置Comparator接口对应的比较器对象,来定制比较规则。</li>\n</ul>\n<p><strong>两种方式中，关于返回值的规则:</strong></p>\n<ul>\n<li>如果认为第一 个元素大于第二个元素返回正整数即可。</li>\n<li>如果认为第一 个元素小于第二个元素返回负整数即可。</li>\n<li>如果认为第一 个元素等于第二个元素返回0即可，此时Treeset集合只会保留一个元素,认为两者重复。</li>\n</ul>\n<p>&#x3D;&#x3D;注意:如果TreeSet集合存储的对象有实现比较规则，集合也自带比较器，默认使用集合自带的比较器排序。&#x3D;&#x3D;</p>\n<hr>\n<h1 id=\"2、Collection体系的特点、总结\"><a href=\"#2、Collection体系的特点、总结\" class=\"headerlink\" title=\"2、Collection体系的特点、总结\"></a>2、Collection体系的特点、总结</h1><ol>\n<li>如果希望元素<strong>可以重复，又有索引，索引查询要快</strong> - - 用<strong>ArrayList集合</strong>,基于数组的。(用的最多)</li>\n<li>如果希望元素<strong>可以重复，又有索引，增删首尾操作快</strong> - - 用<strong>LinkedList集合</strong>, 基于链表的。</li>\n<li>如果希望<strong>增删改查都快，但是元素不重复无序无索引</strong> - - 用<strong>HashSe集合</strong>,基于哈希表的。</li>\n<li>如果希望<strong>增删改查都快，但是元素不重复有序、无索引</strong> - - 用<strong>LinkedHashSe集合</strong>, 基于哈希表和双链表。</li>\n<li>如果要<strong>对对象进行排序</strong> - - 用<strong>TeeSet集合</strong>,基于红黑树。后续也可以用Lis集合实现排序。</li>\n</ol>\n<hr>\n<h1 id=\"3、可变参数\"><a href=\"#3、可变参数\" class=\"headerlink\" title=\"3、可变参数\"></a>3、可变参数</h1><p><strong>可变参数</strong></p>\n<ul>\n<li>可变参数用在形参中可以接收多个数据。</li>\n<li>&#x3D;&#x3D;可变参数的格式:数据类型..参数名称&#x3D;&#x3D;</li>\n</ul>\n<p><strong>可变参数的作用</strong></p>\n<ul>\n<li>传输参数非常灵活，方便。可以不传输参数,可以传输1个或者多个，也可以传输一个数组</li>\n<li>可变参数在方法内部本质上就是一个数组。</li>\n</ul>\n<pre><code class=\"java\">import java.util.Arrays;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n\n        sum(); // 1、不传参数\n        sum(10); // 2、可以传输一个参数\n        sum(10, 20, 30); // 3、可以传输多个参数\n        sum(new int[]&#123;10, 20, 30, 40, 50&#125;); // 4、可以传输一个数组\n    &#125;\n\n    /**\n     注意：一个形参列表中只能有一个可变参数,可变参数必须放在形参列表的最后面\n     * @param nums\n     */\n    public static void sum(  int...nums)&#123;\n        // 注意：可变参数在方法内部其实就是一个数组。 nums\n        System.out.println(&quot;元素个数：&quot; + nums.length);\n        System.out.println(&quot;元素内容：&quot; + Arrays.toString(nums));\n    &#125;\n&#125;\n</code></pre>\n<p><strong>可变参数的注意事项</strong></p>\n<ul>\n<li>一个形参列表中可变参数只能有一个</li>\n<li>可变参数必须放在形参列表的最后面</li>\n</ul>\n<hr>\n<h1 id=\"4、集合工具类\"><a href=\"#4、集合工具类\" class=\"headerlink\" title=\"4、集合工具类\"></a>4、集合工具类</h1><p>Collections集合工具类</p>\n<p>java.utils.Collections:是集合工具类<br>作用: Collections并不属于集合， 是用来操作集合的工具类。</p>\n<p><strong>Collections常用的API</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public static <T> boolean addAll(Collection&lt;? super T&gt; C, T… elements)</td>\n<td align=\"center\">给集合对象批量添加元素</td>\n</tr>\n<tr>\n<td align=\"center\">public static void shuffle(List&lt;?&gt; list)</td>\n<td align=\"center\">打乱List集合元素的顺序</td>\n</tr>\n</tbody></table>\n<p><strong>Collections排序相关API</strong></p>\n<p>使用范围:只能对于List集合的排序。</p>\n<p>排序方式1:</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public static <T> void sort(List<T> list)</td>\n<td align=\"center\">将集合中元素按照默认规则排序</td>\n</tr>\n</tbody></table>\n<p>注意:本方式不可以直接对自定义类型的List集合排序,除非自定义类型实现了比较规则Comparable接口。</p>\n<p>排序方式2:</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public static <T> void sort(List<T> list, Comparator&lt;? super T&gt; c)</td>\n<td align=\"center\">将集合中元素按照指定规则排序</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">public class Test &#123;\n    public static void main(String[] args) &#123;\n        List&lt;String&gt; names = new ArrayList&lt;&gt;();\n        //names.add(&quot;楚留香&quot;);\n        //names.add(&quot;胡铁花&quot;);\n        //names.add(&quot;张无忌&quot;);\n        //names.add(&quot;陆小凤&quot;);\n        Collections.addAll(names, &quot;楚留香&quot;,&quot;胡铁花&quot;, &quot;张无忌&quot;,&quot;陆小凤&quot;);\n        System.out.println(names);\n\n        // 2、public static void shuffle(List&lt;?&gt; list) :打乱集合顺序。\n        Collections.shuffle(names);\n        System.out.println(names);\n\n        // 3、 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 （排值特性的元素）\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n        Collections.addAll(list, 12, 23, 2, 4);\n        System.out.println(list);\n        Collections.sort(list);\n        System.out.println(list);\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h1 id=\"5、Map集合体系\"><a href=\"#5、Map集合体系\" class=\"headerlink\" title=\"5、Map集合体系\"></a>5、Map集合体系</h1><h2 id=\"5-1-Map集合的概述及特点\"><a href=\"#5-1-Map集合的概述及特点\" class=\"headerlink\" title=\"5.1 Map集合的概述及特点\"></a>5.1 Map集合的概述及特点</h2><p><strong>Map集合概述和使用</strong></p>\n<ul>\n<li>Map集合是一种双列集合， 每个元素包含两个数据。</li>\n<li>Map集合的每个元素的格式: key&#x3D;value(键值对元素)。</li>\n<li>Map集合也被称为”键值对集合”。</li>\n</ul>\n<p><strong>Map集合整体格式</strong></p>\n<ul>\n<li>Collection集合的格式: [元素1,元素2,元素3..]</li>\n<li>Map集合的完整格式: {key1 &#x3D;value1 , key2&#x3D;value2 , key3&#x3D;value3 …}</li>\n</ul>\n<pre><code class=\"java\">import java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        // 1、创建一个Map集合对象\n        // Map&lt;String, Integer&gt; maps = new HashMap&lt;&gt;(); // 一行经典代码\n        Map&lt;String, Integer&gt; maps = new LinkedHashMap&lt;&gt;();\n        maps.put(&quot;鸿星尔克&quot;, 3);\n        maps.put(&quot;Java&quot;, 1);\n        maps.put(&quot;枸杞&quot;, 100);\n        maps.put(&quot;Java&quot;, 100); // 覆盖前面的数据\n        maps.put(null, null);\n        System.out.println(maps);\n\n    &#125;\n&#125;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/91648f01d7394ab5ad6fee8d87e7e967.png#pic_center\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/d7fe92a9edd94753a7499dabbb54adcb.png#pic_center\"></p>\n<p><strong>Map集合体系特点</strong></p>\n<ul>\n<li>Map集合的特点都是由键决定的。</li>\n<li>Map集合的键是无序,不重复的,无索引的,值不做要求(可以重复)。</li>\n<li>Map集合后面重复的键对应的值会覆盖前面重复键的值。</li>\n<li>Map集合的键值对都可以为null。</li>\n</ul>\n<p><strong>Map集合实现类特点</strong></p>\n<ul>\n<li>HashMap:元素按照键是无序, 不重复,无索引，值不做要求。(与Map体系一致)</li>\n<li>LinkedHashMap:元素按照键是有序, 不重复,无索引,值不做要求。</li>\n<li>TreeMap: 元素按照建是排序,不重复,无索引的,值不做要求。</li>\n</ul>\n<h2 id=\"5-2-Map集合常用API\"><a href=\"#5-2-Map集合常用API\" class=\"headerlink\" title=\"5.2 Map集合常用API\"></a>5.2 Map集合常用API</h2><p>Map集合</p>\n<p>Map是双列集合的祖宗接口，它的功能是全部双列集合都可以继承使用的。</p>\n<p><strong>Map API如下:</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">V put(K key,V value)</td>\n<td align=\"center\">添加元素</td>\n</tr>\n<tr>\n<td align=\"center\">V remove(0bject key)</td>\n<td align=\"center\">根据键删除键值对元素</td>\n</tr>\n<tr>\n<td align=\"center\">void clear( )</td>\n<td align=\"center\">移除所有的键值对元素</td>\n</tr>\n<tr>\n<td align=\"center\">boolean containsKey(object key)</td>\n<td align=\"center\">判断集合是否包含指定的键</td>\n</tr>\n<tr>\n<td align=\"center\">boolean containsValue(0bject value )</td>\n<td align=\"center\">判断集合是否包含指定的值</td>\n</tr>\n<tr>\n<td align=\"center\">boolean isEmpty()</td>\n<td align=\"center\">判断集合是否为空</td>\n</tr>\n<tr>\n<td align=\"center\">int size()</td>\n<td align=\"center\">集合的长度，也就是集合中键值对的个数</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">import java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        // 1.添加元素: 无序，不重复，无索引。\n        Map&lt;String , Integer&gt; maps = new HashMap&lt;&gt;();\n        maps.put(&quot;iphoneX&quot;,10);\n        maps.put(&quot;娃娃&quot;,20);\n        maps.put(&quot;iphoneX&quot;,100);//  Map集合后面重复的键对应的元素会覆盖前面重复的整个元素！\n        maps.put(&quot;huawei&quot;,100);\n        maps.put(&quot;生活用品&quot;,10);\n        maps.put(&quot;手表&quot;,10);\n        // &#123;huawei=100, 手表=10, 生活用品=10, iphoneX=100, 娃娃=20&#125;\n        System.out.println(maps);\n\n        // 2.清空集合\n//        maps.clear();\n//        System.out.println(maps);\n\n        // 3.判断集合是否为空，为空返回true ,反之！\n        System.out.println(maps.isEmpty());\n\n        // 4.根据键获取对应值:public V get(Object key)\n        Integer key = maps.get(&quot;huawei&quot;);\n        System.out.println(key);\n        System.out.println(maps.get(&quot;生活用品&quot;)); // 10\n        System.out.println(maps.get(&quot;生活用品2&quot;)); // null\n\n        // 5.根据键删除整个元素。(删除键会返回键的值)\n        System.out.println(maps.remove(&quot;iphoneX&quot;));\n        System.out.println(maps);\n\n        // 6.判断是否包含某个键 ，包含返回true ,反之\n        System.out.println(maps.containsKey(&quot;娃娃&quot;));  // true\n        System.out.println(maps.containsKey(&quot;娃娃2&quot;));  // false\n        System.out.println(maps.containsKey(&quot;iphoneX&quot;)); // false\n\n        // 7.判断是否包含某个值。\n        System.out.println(maps.containsValue(100));  //\n        System.out.println(maps.containsValue(10));  //\n        System.out.println(maps.containsValue(22)); //\n\n        // &#123;huawei=100, 手表=10, 生活用品=10, 娃娃=20&#125;\n        // 8.获取全部键的集合：public Set&lt;K&gt; keySet()\n        Set&lt;String&gt; keys = maps.keySet();\n        System.out.println(keys);\n\n        System.out.println(&quot;------------------------------&quot;);\n        // 9.获取全部值的集合：Collection&lt;V&gt; values();\n        Collection&lt;Integer&gt; values = maps.values();\n        System.out.println(values);\n\n        // 10.集合的大小\n        System.out.println(maps.size()); // 4\n\n        // 11.合并其他Map集合。(拓展)\n        Map&lt;String , Integer&gt; map1 = new HashMap&lt;&gt;();\n        map1.put(&quot;java1&quot;, 1);\n        map1.put(&quot;java2&quot;, 100);\n        Map&lt;String , Integer&gt; map2 = new HashMap&lt;&gt;();\n        map2.put(&quot;java2&quot;, 1);\n        map2.put(&quot;java3&quot;, 100);\n        map1.putAll(map2); // 把集合map2的元素拷贝一份到map1中去\n        System.out.println(map1);\n        System.out.println(map2);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"5-3-Map集合的遍历方式\"><a href=\"#5-3-Map集合的遍历方式\" class=\"headerlink\" title=\"5.3 Map集合的遍历方式\"></a>5.3 Map集合的遍历方式</h2><p><strong>方式一 - - 键找值</strong></p>\n<ul>\n<li>先获取Map集合的全部键的Set集合。</li>\n<li>遍历键的Set集合,然后通过键提取对应值。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/9c83237f90234d0a9c2761d0beab5988.png#pic_center\"></p>\n<p>键找值涉及到的API:</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Set<K> keySet()</td>\n<td align=\"center\">获取所有键的集合</td>\n</tr>\n<tr>\n<td align=\"center\">V get(Object key)</td>\n<td align=\"center\">根据键获取值</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        Map&lt;String , Integer&gt; maps = new HashMap&lt;&gt;();\n        // 1.添加元素: 无序，不重复，无索引。\n        maps.put(&quot;娃娃&quot;,30);\n        maps.put(&quot;iphoneX&quot;,100);\n        maps.put(&quot;huawei&quot;,1000);\n        maps.put(&quot;生活用品&quot;,10);\n        maps.put(&quot;手表&quot;,10);\n        System.out.println(maps);\n        // maps = &#123;huawei=1000, 手表=10, 生活用品=10, iphoneX=100, 娃娃=30&#125;\n\n        // 1、键找值：第一步：先拿到集合的全部键。\n        Set&lt;String&gt; keys = maps.keySet();\n        // 2、第二步：遍历每个键，根据键提取值\n        for (String key : keys) &#123;\n            int value = maps.get(key);\n            System.out.println(key + &quot;===&gt;&quot; + value);\n        &#125;\n\n    &#125;\n&#125;\n</code></pre>\n<p><strong>方式二 – 键值对</strong></p>\n<ul>\n<li>先把Map集合转换成Set集合，Set集合中每 个元素都是键值对实体类型了。</li>\n<li>遍历Set集合，然后提取键以及提取值。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/b66d56effa8d48f1b262f27ae9098470.png#pic_center\"></p>\n<p>键值对涉及到的API:</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</td>\n<td align=\"center\">获取所有键值对对象的集合</td>\n</tr>\n<tr>\n<td align=\"center\">K getKey()</td>\n<td align=\"center\">获得键</td>\n</tr>\n<tr>\n<td align=\"center\">V getValue()</td>\n<td align=\"center\">获取值</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        Map&lt;String , Integer&gt; maps = new HashMap&lt;&gt;();\n        // 1.添加元素: 无序，不重复，无索引。\n        maps.put(&quot;娃娃&quot;,30);\n        maps.put(&quot;iphoneX&quot;,100);\n        maps.put(&quot;huawei&quot;,1000);\n        maps.put(&quot;生活用品&quot;,10);\n        maps.put(&quot;手表&quot;,10);\n        System.out.println(maps);\n        // maps = &#123;huawei=1000, 手表=10, 生活用品=10, iphoneX=100, 娃娃=30&#125;\n        // 1、把Map集合转换成Set集合\n        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = maps.entrySet();\n        // 2、开始遍历\n        for(Map.Entry&lt;String, Integer&gt; entry : entries)&#123;\n            String key = entry.getKey();\n            int value = entry.getValue();\n            System.out.println(key + &quot;====&gt;&quot; + value);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>方式三 – lambda表达式</strong></p>\n<p>得益于JDK 8开始的新技术Lambda表达式，提供了一种更简单、更直接的遍历集合的方式。</p>\n<p>Map结合Lambda遍历的API</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">default void forEach(Biconsumer&lt;? super K, ? super v&gt; action)</td>\n<td align=\"center\">结合lambda遍历Map集合</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">import java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.BiConsumer;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        Map&lt;String , Integer&gt; maps = new HashMap&lt;&gt;();\n        // 1.添加元素: 无序，不重复，无索引。\n        maps.put(&quot;娃娃&quot;,30);\n        maps.put(&quot;iphoneX&quot;,100);//  Map集合后面重复的键对应的元素会覆盖前面重复的整个元素！\n        maps.put(&quot;huawei&quot;,1000);\n        maps.put(&quot;生活用品&quot;,10);\n        maps.put(&quot;手表&quot;,10);\n        System.out.println(maps);\n\n        maps.forEach((k, v) -&gt; &#123;\n            System.out.println(k + &quot;---&gt;&quot; + v);\n        &#125;);\n\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"5-4-Map集合的实现类\"><a href=\"#5-4-Map集合的实现类\" class=\"headerlink\" title=\"5.4 Map集合的实现类\"></a>5.4 Map集合的实现类</h2><p><strong>HashMap</strong></p>\n<ol>\n<li>HashMap是Map里面的一个实现类。特点都是由键决定的:无序、不重复、无索引</li>\n<li>可直接使用Map里面的方法</li>\n<li>HashMap跟HashSet底层原理是一模一样的，都是哈希表结构，HashMap的每个元素包含两个值</li>\n</ol>\n<p>（实际上:Set系列集合的底层就是Map实现的，只是Set集合中的元素只要键数据，不要值数据而已。）</p>\n<pre><code class=\"java\">import com.itheima.d1_collection_set.Student;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class HashMapDemo &#123;\n    public static void main(String[] args) &#123;\n         // Map集合是根据键去除重复元素\n        Map&lt;Student, String&gt; maps = new HashMap&lt;&gt;();\n\n        Student s1 = new Student(&quot;无恙&quot;, 20, &#39;男&#39;);\n        Student s2 = new Student(&quot;无恙&quot;, 20, &#39;男&#39;);\n        Student s3 = new Student(&quot;周雄&quot;, 21, &#39;男&#39;);\n\n        maps.put(s1, &quot;北京&quot;);\n        maps.put(s2, &quot;上海&quot;);\n        maps.put(s3, &quot;广州&quot;);\n\n        System.out.println(maps);\n    &#125;\n&#125;\n</code></pre>\n<p><strong>LinkenHashMap</strong></p>\n<ul>\n<li>由键决定:有序、不重复、无索引</li>\n<li><strong>这里的有序指的是保证存储和取出的元素顺序─致</strong></li>\n<li>底层数据结构是依然哈希表，只是每个键值对元素又额外的多了一个双链表的机制记录存储的顺序。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/84cce8ea1b4a4449a02e28ce641033fd.png#pic_center\"></p>\n<pre><code class=\"java\">import java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.TreeSet;\n\n/**\n    目标：认识Map体系的特点：按照键无序，不重复，无索引。值不做要求。\n */\npublic class LinkedHashMapDemo &#123;\n    public static void main(String[] args) &#123;\n        // 1、创建一个Map集合对象\n        Map&lt;String, Integer&gt; maps = new LinkedHashMap&lt;&gt;();\n        maps.put(&quot;鸿星尔克&quot;, 3);\n        maps.put(&quot;Java&quot;, 1);\n        maps.put(&quot;枸杞&quot;, 100);\n        maps.put(&quot;Java&quot;, 100); // 覆盖前面的数据\n        maps.put(null, null);\n        System.out.println(maps);\n\n    &#125;\n&#125;\n</code></pre>\n<p><strong>TreeMap</strong></p>\n<ul>\n<li>由键决定特性:不重复、无索引、可排序。</li>\n<li><strong>可排序:按照键数据的大小默认升序(有小到大)排序。只能对键排序。</strong></li>\n<li>注意:TreeMap集合是一定要排序的，可以默认排序，也可以将键按照指定的规则进行排序。</li>\n<li>TreeMap跟TreeSet—样底层原理是一样的。</li>\n</ul>\n<p>TreeMap集合自定义排序规则有2种</p>\n<ul>\n<li>类实现Comparable接口，重写比较规则。</li>\n<li>集合自定义Comparator比较器对象，重写比较规则。</li>\n</ul>\n<pre><code class=\"java\">public class Apple implements Comparable&lt;Apple&gt;&#123;\n    private String name;\n    private String color;\n    private double price;\n    private int weight;\n\n    public Apple() &#123;\n    &#125;\n\n    public Apple(String name, String color, double price, int weight) &#123;\n        this.name = name;\n        this.color = color;\n        this.price = price;\n        this.weight = weight;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public String getColor() &#123;\n        return color;\n    &#125;\n\n    public void setColor(String color) &#123;\n        this.color = color;\n    &#125;\n\n    public double getPrice() &#123;\n        return price;\n    &#125;\n\n    public void setPrice(double price) &#123;\n        this.price = price;\n    &#125;\n\n    public int getWeight() &#123;\n        return weight;\n    &#125;\n\n    public void setWeight(int weight) &#123;\n        this.weight = weight;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Apple&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, color=&#39;&quot; + color + &#39;\\&#39;&#39; +\n                &quot;, price=&quot; + price +\n                &quot;, weight=&quot; + weight +\n                &#39;&#125;&#39;;\n    &#125;\n\n    /**\n      方式一：类自定义比较规则\n      o1.compareTo(o2)\n     * @param o\n     * @return\n     */\n    @Override\n    public int compareTo(Apple o) &#123;\n        // 按照重量进行比较的\n        return this.weight - o.weight ; // 去重重量重复的元素\n        // return this.weight - o.weight &gt;= 0 ? 1 : -1; // 保留重量重复的元素\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">import java.util.Comparator;\nimport java.util.Map;\nimport java.util.TreeMap;\n\npublic class TreeMapDemo3 &#123;\n    public static void main(String[] args) &#123;\n        Map&lt;Integer, String&gt; maps1 = new TreeMap&lt;&gt;();\n        maps1.put(13 , &quot;王麻子&quot;);\n        maps1.put(1 , &quot;张三&quot;);\n        maps1.put(3 , &quot;县长&quot;);\n        System.out.println(maps1);\n\n        // TreeMap集合自带排序。  可排序 不重复（只要大小规则一样就认为重复）  无索引\n        Map&lt;Apple, String&gt; maps2 = new TreeMap&lt;&gt;(new Comparator&lt;Apple&gt;() &#123;\n            @Override\n            public int compare(Apple o1, Apple o2) &#123;\n                return Double.compare(o2.getPrice() , o1.getPrice()); // 按照价格降序排序！\n            &#125;\n        &#125;);\n        maps2.put(new Apple(&quot;红富士&quot;, &quot;红色&quot;, 9.9, 500), &quot;山东&quot; );\n        maps2.put(new Apple(&quot;青苹果&quot;, &quot;绿色&quot;, 15.9, 300), &quot;广州&quot;);\n        maps2.put(new Apple(&quot;绿苹果&quot;, &quot;青色&quot;, 29.9, 400), &quot;江西&quot;);\n        maps2.put(new Apple(&quot;黄苹果&quot;, &quot;黄色&quot;, 9.8, 500), &quot;湖北&quot;);\n\n        System.out.println(maps2);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"5-5-集合的嵌套\"><a href=\"#5-5-集合的嵌套\" class=\"headerlink\" title=\"5.5 集合的嵌套\"></a>5.5 集合的嵌套</h2><p>需求</p>\n<ul>\n<li>某个班级多名学生，现在需要组成秋游活动，班长提供了四个景点依次是(A、B、C、D),每个学生可以选择多个景点，请统计出最终哪个景点想去的人数最多。</li>\n</ul>\n<p>分析</p>\n<ul>\n<li>将80个学生选择的数据拿到程序中去，需要记住每个学生选择的情况。</li>\n<li>定义Map集合用于存储最终统计的结果。</li>\n</ul>\n<pre><code class=\"java\">import java.util.*;\n\npublic class MapTest4 &#123;\n    public static void main(String[] args) &#123;\n        // 1、要求程序记录每个学生选择的情况。\n        // 使用一个Map集合存储。\n        Map&lt;String, List&lt;String&gt;&gt; data = new HashMap&lt;&gt;();\n\n        // 2、把学生选择的数据存入进去。\n        List&lt;String&gt; selects = new ArrayList&lt;&gt;();\n        Collections.addAll(selects, &quot;A&quot;, &quot;C&quot;);\n        data.put(&quot;罗勇&quot;, selects);\n\n        List&lt;String&gt; selects1 = new ArrayList&lt;&gt;();\n        Collections.addAll(selects1, &quot;B&quot;, &quot;C&quot; , &quot;D&quot;);\n        data.put(&quot;胡涛&quot;, selects1);\n\n        List&lt;String&gt; selects2 = new ArrayList&lt;&gt;();\n        Collections.addAll(selects2 , &quot;A&quot;,  &quot;B&quot;, &quot;C&quot; , &quot;D&quot;);\n        data.put(&quot;刘军&quot;, selects2);\n\n        System.out.println(data);\n\n        // 3、统计每个景点选择的人数。\n        Map&lt;String, Integer&gt; infos = new HashMap&lt;&gt;(); // &#123;&#125;\n\n        // 4、提取所有人选择的景点的信息。\n        Collection&lt;List&lt;String&gt;&gt; values = data.values();\n        System.out.println(values);\n        // values = [[A, B, C, D], [B, C, D], [A, C]]\n        //             value\n\n        for (List&lt;String&gt; value : values) &#123;\n            for (String s : value) &#123;\n                // 有没有包含这个景点\n                if(infos.containsKey(s))&#123;\n                    infos.put(s, infos.get(s) + 1);\n                &#125;else &#123;\n                    infos.put(s , 1);\n                &#125;\n            &#125;\n        &#125;\n\n        System.out.println(infos);\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h1 id=\"6、不可变集合\"><a href=\"#6、不可变集合\" class=\"headerlink\" title=\"6、不可变集合\"></a>6、不可变集合</h1><p>&#x3D;&#x3D;不可变集合，就是不可被修改的集合。集合的数据项在创建的时候提供，并且在整个生命周期中都不可改变。否则报错。&#x3D;&#x3D;</p>\n<p>如果某个数据不能被修改，把它防御性地拷贝到不可变集合中是个很好的实践。或者当集合对象被不可信的库调用时，不可变形式是安全的。</p>\n<p>在List、Set、Map接口中，都存在of方法，可以创建一个不可变的集合。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">static <E> List<E> of(E..elements)</td>\n<td align=\"center\">创建一个具有指定元素的List集合对象</td>\n</tr>\n<tr>\n<td align=\"center\">static <E> Set<E> of(E…elements)</td>\n<td align=\"center\">创建一个具有指定元素的Set集合对象</td>\n</tr>\n<tr>\n<td align=\"center\">static &lt;K,V&gt; Map&lt;K,V&gt; of(…elements)</td>\n<td align=\"center\">创建一个具有指定元素的Map集合对象</td>\n</tr>\n<tr>\n<td align=\"center\">这个集合不能添加，不能删除，不能修改。</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">import java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class CollectionDemo &#123;\n    public static void main(String[] args) &#123;\n        // 1、不可变的List集合\n        List&lt;Double&gt; lists = List.of(569.5, 700.5, 523.0,  570.5);\n        // lists.add(689.0);\n        // lists.set(2, 698.5);\n        // System.out.println(lists);\n        double score = lists.get(1);\n        System.out.println(score);\n\n        // 2、不可变的Set集合\n        Set&lt;String&gt; names = Set.of(&quot;迪丽热巴&quot;, &quot;迪丽热九&quot;, &quot;马尔扎哈&quot;, &quot;卡尔眨巴&quot; );\n        // names.add(&quot;三少爷&quot;);\n        System.out.println(names);\n\n        // 3、不可变的Map集合\n        Map&lt;String, Integer&gt; maps = Map.of(&quot;huawei&quot;,2, &quot;Java开发&quot;, 1 , &quot;手表&quot;, 1);\n        // maps.put(&quot;衣服&quot;, 3);\n        System.out.println(maps);\n    &#125;\n&#125;\n</code></pre>\n<hr>\n","feature":true,"text":"Java集合框架是Java编程中至关重要的组成部分，其中Set和Map是两个核心接口。Set接口代表着不含重复元素的集合，而Map接口则表示键值对的映射关系。通过Set和Map，开发者能够高效地处理各种数据，并且这两个接口提供了丰富的方法和功能，如查找、遍历、添加和删除等。...","permalink":"/post/Java程序设计 -- 集合(下)（十三）","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1%E3%80%81Set%E7%B3%BB%E5%88%97%E9%9B%86%E5%90%88\"><span class=\"toc-text\">1、Set系列集合</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-Set%E7%B3%BB%E5%88%97%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1.1 Set系列集合概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-HashSet%E5%85%83%E7%B4%A0%E6%97%A0%E5%BA%8F%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1.2 HashSet元素无序的底层原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-HashSet%E5%85%83%E7%B4%A0%E5%8E%BB%E9%87%8D%E5%A4%8D%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1.3 HashSet元素去重复的底层原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4-%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%9ALinkedHashSet\"><span class=\"toc-text\">1.4 实现类：LinkedHashSet</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-5-%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%9ATreeSet\"><span class=\"toc-text\">1.5 实现类：TreeSet</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2%E3%80%81Collection%E4%BD%93%E7%B3%BB%E7%9A%84%E7%89%B9%E7%82%B9%E3%80%81%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">2、Collection体系的特点、总结</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">3、可变参数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4%E3%80%81%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB\"><span class=\"toc-text\">4、集合工具类</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5%E3%80%81Map%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB\"><span class=\"toc-text\">5、Map集合体系</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-1-Map%E9%9B%86%E5%90%88%E7%9A%84%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">5.1 Map集合的概述及特点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-2-Map%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8API\"><span class=\"toc-text\">5.2 Map集合常用API</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-3-Map%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">5.3 Map集合的遍历方式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-4-Map%E9%9B%86%E5%90%88%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB\"><span class=\"toc-text\">5.4 Map集合的实现类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-5-%E9%9B%86%E5%90%88%E7%9A%84%E5%B5%8C%E5%A5%97\"><span class=\"toc-text\">5.5 集合的嵌套</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#6%E3%80%81%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88\"><span class=\"toc-text\">6、不可变集合</span></a></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Java程序设计--Stream流、异常","uid":"0b9a635cc4d74b69a28063082e6467ef","slug":"Java程序设计 -- Stream流、异常（十四）","date":"2022-03-28T08:27:03.000Z","updated":"2025-07-14T15:12:20.459Z","comments":true,"path":"api/articles/Java程序设计 -- Stream流、异常（十四）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","text":"Stream流和异常处理是Java编程中的关键概念。Stream提供了优雅的集合数据处理方式，简化了代码。异常处理确保程序稳定运行，通过try-catch-finally和throw机制捕获和处理错误。掌握Stream流和异常处理对于高效编程至关重要。...","permalink":"/post/Java程序设计 -- Stream流、异常（十四）","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"13 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true},"next_post":{"title":"Java程序设计--集合(上)","uid":"84c5c7d3318822a7a4ef1ba96214ecd0","slug":"Java程序设计 -- 集合(上)（十二）","date":"2022-03-22T13:26:15.000Z","updated":"2025-07-14T15:12:20.461Z","comments":true,"path":"api/articles/Java程序设计 -- 集合(上)（十二）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","text":"Java集合是编程中重要的概念，提供有序对象操作。Collection是基本接口，List是其子接口，实现有序可重复元素序列。使用List简化开发和维护工作，处理数据如员工名单、商品列表更高效方便。提供排序、查找、过滤等算法和工具类，支持泛型确保类型安全。掌握Java集合是必备技能。...","permalink":"/post/Java程序设计 -- 集合(上)（十二）","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true}}