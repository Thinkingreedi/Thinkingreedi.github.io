{"title":"树和二叉树","uid":"50552977e0ec8094596ba83ac872ee52","slug":"数据结构（C语言版）-- 树和二叉树笔记","date":"2022-02-16T04:56:11.000Z","updated":"2025-07-14T15:12:20.469Z","comments":true,"path":"api/articles/数据结构（C语言版）-- 树和二叉树笔记.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/050b725832464411bd17f7b08e4c7ff4.png","content":"<hr>\n<h1 id=\"1、树和二叉树的定义\"><a href=\"#1、树和二叉树的定义\" class=\"headerlink\" title=\"1、树和二叉树的定义\"></a>1、树和二叉树的定义</h1><h2 id=\"①-树的定义\"><a href=\"#①-树的定义\" class=\"headerlink\" title=\"①.树的定义\"></a>①.树的定义</h2><p>树( Tree)是n(n≥0)个结点的有限集，它或为空树(n&#x3D;0)；或为非空树，对于非空树T：</p>\n<p><strong>&#x3D;&#x3D;1. 有且仅有一个称之为根的结点;&#x3D;&#x3D;</strong><br><strong>&#x3D;&#x3D;2. 除根结点以外的其余结点可分为m (m&gt;0)个互不相交的有限集T<del>1</del>，T<del>2</del>,…，T<del>m</del>，其中每一个集合本身又是一棵树，并且称为根的子树( SubTree)。&#x3D;&#x3D;</strong></p>\n<p>在下图中，(a)是只有一个根结点的树；(b)是有13个结点的树，其中A是根，其余结点分成3个互不相交的子集:T<del>1</del>&#x3D;{B,E,F,K,L}，T<del>2</del> &#x3D;{C,G}，T<del>3</del>(D,H,I,J,M})。T<del>1</del>、T<del>2</del>和T<del>3</del>都是根A 的子树，且本身也是一棵树。例如T<del>1</del>，其根为B，其余结点分为两个互不相交的子集:T<del>11</del>&#x3D;{E,K,L}，T<del>12</del>&#x3D;{F}。T<del>11</del>和T<del>12</del>都是B的子树。而T<del>11</del>中E是根，{K}和(L}是E的两棵互不相交的子树,其本身又是只有一个根结点的树。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/7b6a9e683fbc4e349a1a402b1c8e2e8f.png#pic_center\"></p>\n<p>树的结构定义是一个递归的定义，即在树的定义中又用到树的定义，它道出了树的固有特性。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">线性结构</th>\n<th align=\"center\">树型结构</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">第一个数据元素（无前驱）</td>\n<td align=\"center\">根结点（无前驱）</td>\n</tr>\n<tr>\n<td align=\"center\">最后一个数据元素（无后继）</td>\n<td align=\"center\">多个叶子结点（无后继）</td>\n</tr>\n<tr>\n<td align=\"center\">其他数据元素（一个前驱，一个后继）</td>\n<td align=\"center\">树中其它结点（一个前驱，一个后继）</td>\n</tr>\n</tbody></table>\n<h2 id=\"②-树的基本术语\"><a href=\"#②-树的基本术语\" class=\"headerlink\" title=\"②.树的基本术语\"></a>②.树的基本术语</h2><p><img src=\"https://img-blog.csdnimg.cn/5c3e87b0502d4c008cb9e7d2159f88a5.png#pic_center\"></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">术语</th>\n<th align=\"center\">解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">结点</td>\n<td align=\"center\">树的数据元素；如A、B、C、D等</td>\n</tr>\n<tr>\n<td align=\"center\">根</td>\n<td align=\"center\">根节点（没有前驱）；如A</td>\n</tr>\n<tr>\n<td align=\"center\">叶子</td>\n<td align=\"center\">终端结点（没有后继）；结点K、L、F、G、M、I、J都是树的叶子</td>\n</tr>\n<tr>\n<td align=\"center\">森林</td>\n<td align=\"center\">m棵不相交的树的集合（例如删除A后的子树个数）</td>\n</tr>\n<tr>\n<td align=\"center\">有序树</td>\n<td align=\"center\">结点各子树从左到右有序，不能互换（左为第一）</td>\n</tr>\n<tr>\n<td align=\"center\">无序树</td>\n<td align=\"center\">结点各子树可互换位置</td>\n</tr>\n<tr>\n<td align=\"center\">双亲</td>\n<td align=\"center\">上层的结点（直接前驱）；B的双亲为A</td>\n</tr>\n<tr>\n<td align=\"center\">孩子</td>\n<td align=\"center\">下层结点子树的根（直接后继）；B的孩子有E和F</td>\n</tr>\n<tr>\n<td align=\"center\">兄弟</td>\n<td align=\"center\">同一双亲下的同层结点（孩子之间互称兄弟）；H、I和J互为兄弟</td>\n</tr>\n<tr>\n<td align=\"center\">堂兄弟</td>\n<td align=\"center\">双亲位于同一层的结点（并非同一双亲）；结点G与E、F和H、I、J互为堂兄弟</td>\n</tr>\n<tr>\n<td align=\"center\">祖先</td>\n<td align=\"center\">根到该结点所经分支的所有结点；M的祖先为A、D和H</td>\n</tr>\n<tr>\n<td align=\"center\">子孙</td>\n<td align=\"center\">该结点下层子树中任一结点；B的子孙为E、K、L和F</td>\n</tr>\n<tr>\n<td align=\"center\">结点的度</td>\n<td align=\"center\">结点拥有的子树数；A的度为3，C的度为1，F的度为0</td>\n</tr>\n<tr>\n<td align=\"center\">树的度</td>\n<td align=\"center\">所有结点度中的最大值；该树的度为3</td>\n</tr>\n<tr>\n<td align=\"center\">结点的层次</td>\n<td align=\"center\">根到该结点的层数（根结点算第一层)</td>\n</tr>\n<tr>\n<td align=\"center\">终端结点</td>\n<td align=\"center\">度为0的结点，即叶子</td>\n</tr>\n<tr>\n<td align=\"center\">分支结点</td>\n<td align=\"center\">度不为0的结点</td>\n</tr>\n<tr>\n<td align=\"center\">树的深度</td>\n<td align=\"center\">所有结点中最大的层数；该树的深度为4</td>\n</tr>\n</tbody></table>\n<h2 id=\"③-二叉树的定义\"><a href=\"#③-二叉树的定义\" class=\"headerlink\" title=\"③.二叉树的定义\"></a>③.二叉树的定义</h2><p>二叉树（Binary Tree)是n ( n≥0)个结点所构成的集合，它或为空树(n&#x3D;0)；或为非空树，对于非空树T:</p>\n<p> <strong>&#x3D;&#x3D;1. 有且仅有一个称之为根的结点;&#x3D;&#x3D;</strong><br> <strong>&#x3D;&#x3D;2. 除根结点以外的其余结点分为两个互不相交的子集T<del>1</del>,和T<del>2</del>,分别称为T的左子树和右子树，且T<del>1</del>和T<del>2</del>本身又都是二叉树。&#x3D;&#x3D;</strong></p>\n<p>二叉树与树—样具有递归性质，二叉树与树的<strong>区别</strong>主要有以下两点:</p>\n<p> <strong>1. 二叉树每个结点至多只有两棵子树(即二叉树中不存在度大于2的结点);</strong><br> <strong>2. 二叉树的子树有左右之分，其次序不能任意颠倒。</strong></p>\n<p><strong>二叉树的5种基本形态:</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/97037fd9329a4c059b4bf02f48aa7862.png#pic_center\"></p>\n<hr>\n<h1 id=\"2、树和二叉树的抽象数据类型定义\"><a href=\"#2、树和二叉树的抽象数据类型定义\" class=\"headerlink\" title=\"2、树和二叉树的抽象数据类型定义\"></a>2、树和二叉树的抽象数据类型定义</h1><p><strong>树的抽象数据类型定义：</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/f4d63dc300944e21a2d2448d9753b1ab.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/8144e735a43647c597d34c136bc4ecff.png#pic_center\"><br><strong>二叉树的抽象数据类型定义：</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/a004238c12cb4beb866e1c78626e2e65.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/91c2fadebd8a444bae62b2e3efd2a38e.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/8bd19e999926486995edf63148e1e6b4.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/1d3c996005334a2691ec8ab411ca7a7c.png#pic_center\"></p>\n<hr>\n<h1 id=\"3、二叉树的性质和存储结构\"><a href=\"#3、二叉树的性质和存储结构\" class=\"headerlink\" title=\"3、二叉树的性质和存储结构\"></a>3、二叉树的性质和存储结构</h1><h2 id=\"①-二叉树的性质\"><a href=\"#①-二叉树的性质\" class=\"headerlink\" title=\"①.二叉树的性质\"></a>①.二叉树的性质</h2><p>&#x3D;&#x3D;性质1：在二叉树的第i层上至多有2^i-1^个结点（i≥1）&#x3D;&#x3D;</p>\n<p> 证明：i&#x3D;1时，只有一个根结点，2^i-1^&#x3D;1成立﹔假设第i-1层至多有2^i-2^个结点，又二叉树每个结点的度至多为2;所以，第i层上最大结点数是第i-1层的2倍，即2^i-1^个结点。</p>\n<p> &#x3D;&#x3D;性质2：深度为k的二叉树至多有2^k-1^个结点（k≥1）&#x3D;&#x3D;</p>\n<p> 证明：由性质1，可得深度为k的二叉树最大结点数是2^k-1^</p>\n<p>&#x3D;&#x3D;性质3：对任何一棵二叉树T，如果其终端(叶子)结点个数为n0，度为2的结点数为n2，则n<del>0</del>&#x3D;n<del>2</del>+1。&#x3D;&#x3D;</p>\n<p>证明：n1为二叉树T中度为1的结点数，二叉树中所有结点的度均小于或等于2，其结点总数n&#x3D;n<del>0</del>+n<del>1</del>+n<del>2</del>；二叉树中，除根结点外，其余结点都只有一个分支进入，设: B为分支总数，则n&#x3D;B+1；分支由度为1和度为2的结点射出，B&#x3D;n<del>1</del>+2n<del>2</del>于是n&#x3D;B+1&#x3D;n<del>1</del>+2n<del>2</del>+1&#x3D;n<del>0</del>+n<del>1</del>+n<del>2</del>，所以no&#x3D;n<del>2</del>+1</p>\n<p>这里引入两个概念：<strong>满二叉树和完全二叉树</strong></p>\n<p><strong>满二叉树:深度为k且含有2^k^-1个结点的二叉树。</strong><br><strong>满二叉树的特点是:每一层上的结点数都是最大结点数，即每一层i的结点数都具有最大值2^i^-1。</strong></p>\n<p><strong>完全二叉树:深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点—一对应时，称之为完全二叉树。</strong><br><strong>完全二叉树的特点是:叶子结点只可能在层次最大的两层上出现;对任一结点，若其右分支下的子孙的最大层次为l，则其左分支下的子孙的最大层次必为l或l+1。</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/a42951a7ccf3404fb528bdba9a971a24.png#pic_center\"></p>\n<p>&#x3D;&#x3D;性质4：具有n个结点的完全二叉树的深度为⌊log<del>2</del>n⌋+1&#x3D;&#x3D;</p>\n<p>证明：2^k-1^-1 &lt;n ≤2^k^-1 或2^k-1^≤ n &lt;2^k^，k-1≤ log<del>2</del>n &lt;k，因为k是整数所以: k &#x3D; log<del>2</del>n+ 1</p>\n<p>&#x3D;&#x3D;性质5：如果对一棵有n个结点的完全二叉树从上至下、从左至右编号，则编号为i (1≤ i≤ n)的结点:<br>若i&#x3D;1，则该结点是二叉树的根，无双亲，否则，其双亲结点编号为⌊i&#x2F;2⌋；<br>若2i &gt; n，则该结点无左孩子，否则，其左孩子结点编号为2i ;<br>若2i+1 &gt;n，则该结点无右孩子结点，否则，其右孩子结点编号为2i+1。&#x3D;&#x3D;</p>\n<p>证明：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/e3a62d4d2aab4b1ab055cf7005882e83.png#pic_center\"></p>\n<h2 id=\"②-二叉树的存储结构\"><a href=\"#②-二叉树的存储结构\" class=\"headerlink\" title=\"②.二叉树的存储结构\"></a>②.二叉树的存储结构</h2><p><strong>顺序存储结构</strong></p>\n<pre><code class=\"c\">//二叉树的顺序存储表示\n#define MAXTSIZE 100\ntypedef TElemType SqBiTree[MAXTSIZE];\nSqBiTree bt;\n</code></pre>\n<p>顺序存储结构使用一组地址连续的存储单元来存储数据元素，为了能够在存储结构中反映出结点之间的逻辑关系，必须将二叉树中的结点依照―定的规律安排在这组单元中。</p>\n<p>对于完全二叉树，只要从根起按层序存储即可，依次自上而下、自左至右存储结点元素，即将完全二叉树上编号为i的结点元素存储在如上定义的一维数组中下标为i-1的分量中。</p>\n<p>对于一般二叉树，则应将其每个结点与完全二叉树上的结点相对照,存储在一维数组的相应分量中，图中以“0”表示不存在此结点。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/1a3dafd636c84b97ba72131b9b7a5ecf.png#pic_center\"></p>\n<p>这种顺序结构只适合完全二叉树，所以对于一般二叉树，更适合采用链式存储结构。</p>\n<p><strong>链式存储结构</strong></p>\n<p>由二叉树的定义可知，二叉树的结点有一个数据元素和分别指向其左、右子树的两个分支构成，则表示二叉树的链表中的结点至少包含3个域：<strong>数据域和左、右指针域。</strong> 有时为了方便找到结点的双亲，还可以在结点结构中增加一个指向其双亲结点的指针域。利用这两种结点结构所得二叉树的存储结构分别称之为二叉链表和三叉链表。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/00f61121f443403b9a01ba3666198a6c.png#pic_center\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/f5ab931ba3d14be6817d28d6f0bfe2e7.png#pic_center\"></p>\n<pre><code class=\"c\">//二叉树的二叉链表存储表示\ntypedef struct BiTNode\n&#123;\n    TElemType data;                 //结点数据域\n    struct BiTNode *lchild, *rchild; //左右孩子指针\n&#125; BiTNode, *BiTree;                  //二叉树结点\n</code></pre>\n<hr>\n<h1 id=\"4、遍历二叉树和线索二叉树\"><a href=\"#4、遍历二叉树和线索二叉树\" class=\"headerlink\" title=\"4、遍历二叉树和线索二叉树\"></a>4、遍历二叉树和线索二叉树</h1><h2 id=\"①-遍历二叉树\"><a href=\"#①-遍历二叉树\" class=\"headerlink\" title=\"①.遍历二叉树\"></a>①.遍历二叉树</h2><p><strong>遍历二叉树算法描述</strong></p>\n<p><strong>遍历二叉树( traversing binary tree）是指按某条搜索路径巡访树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。</strong></p>\n<p>二叉树是由3个基本单元组成:根结点、左子树和右子树。因此，若能依次遍历这三部分，便是遍历了整个二叉树。假如从L、D、R分别表示遍历左子树、访问根结点和遍历右子树，则可有DLR、LDR、LRD、DRL、RDL、RLD这6种遍历二叉树的方案。若限定先左后右，则只有前3种情况，分别称之为&#x3D;&#x3D;先(根）序遍历、中(根）序遍历和后（根)序遍历。&#x3D;&#x3D;</p>\n<p><img src=\"https://img-blog.csdnimg.cn/3e3612433bca408fbca07ab6e53cc924.png#pic_center\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/3ffdcc901e0b433fb7c62d54187e5b82.png#pic_center\"></p>\n<pre><code class=\"c\">void PreOrderTraverse(BiTree T)\n&#123;\n    if (T) //非空二叉树\n    &#123;\n        cout &lt;&lt; T-&gt;data;             //访问根结点\n        PreOrderTraverse(T-&gt;lchild); //递归遍历左子树\n        PreOrderTraverse(T-&gt;rchild); //递归遍历右子树\n    &#125;\n&#125;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/cab082ddedda442cb5869b6a953ac675.png#pic_center\"></p>\n<pre><code class=\"c\">void InOrderTraverse(BiTree T)\n&#123;\n    if (T) //非空二叉树\n    &#123;\n        InOrderTraverse(T-&gt;lchild); //递归遍历左子树\n        cout &lt;&lt; T-&gt;data;            //访问根结点\n        InOrderTraverse(T-&gt;rchild); //递归遍历右子树\n    &#125;\n&#125;\n\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/a7de0065ee38451eb0fd0c0ce127e2a2.png#pic_center\"></p>\n<pre><code class=\"c\">void PostOrderTraverse(BiTree T)\n&#123;\n    if (T) //非空二叉树\n    &#123;\n        PostOrderTraverse(T-&gt;lchild); //递归遍历左子树\n        PostOrderTraverse(T-&gt;rchild); //递归遍历右子树\n        cout &lt;&lt; T-&gt;data;              //访问根结点\n    &#125;\n&#125;\n</code></pre>\n<p><strong>用二叉树表示算术表达式</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/ecebd273852040d5a0e915683ec3f562.png#pic_center\"></p>\n<p><strong>根据遍历序列确定二叉树</strong></p>\n<p>&#x3D;&#x3D;由二叉树的<strong>先序序列和中序序列</strong>，或由其<strong>后序序列和中序序列</strong>均能唯一地确定一棵二叉树。<strong>但是</strong>由一颗二叉树的<strong>先序序列和后序序列不能</strong>唯一确定一颗二叉树。&#x3D;&#x3D;</p>\n<p>例：已知一棵二叉树的中序序列和后序序列分别是 BDCEAFHG和DECBHGFA，请画出这棵二叉树。</p>\n<ol>\n<li>由后序遍历特征，根结点必在后序序列尾部，即根结点是A;</li>\n<li>由中序遍历特征，根结点必在其中间，而且其左部必全部是左子树子孙(BDCE)，其右部必全部是右子树子孙(FHG );</li>\n<li>继而，根据后序中的DECB子树可确定B为A的左孩子，根据HGF子串可确定F为A的右孩子;依此类推，可以唯一地确定一棵二叉树，如下图所示。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/b54f2376a2d8456eaf4c4ef5016d6497.png#pic_center\"></p>\n<p>例：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/c35664488ab44cbdb581edf6598641be.png#pic_center\"></p>\n<p><strong>先序遍历的顺序建立二叉链表</strong></p>\n<ol>\n<li>扫描字符序列，读人字符ch。</li>\n<li>如果ch是一个“#”字符，则表明该二叉树为空树，即T为NULL;否则执行以下操作:<br>- 申请一个结点空间T;<br>- 将ch赋给T-&gt; data;<br>- 递归创建T的左子树;<br>- 递归创建T的右子树;</li>\n</ol>\n<pre><code class=\"c\">void CreateBiTree(BiTree &amp;T）\n&#123;\n    cin &gt;&gt; ch;\n    if (ch ==’#’)\n        T = NULL; //递归结束，建空树\n    else\n    &#123;\n        T = new BiTNode;\n        T - ＞data = ch;            //生成根结点\n        CreateBiTree(T - ＞lchild); //递归创建左子树\n        CreateBiTree(T - ＞rchild); //递归创建右子树\n    &#125;\n&#125;\n</code></pre>\n<p><strong>复制二叉树</strong></p>\n<p>如果是空树，递归结束,否则执行以下操作:</p>\n<ol>\n<li>申请一个新结点空间，复制根结点;</li>\n<li>递归复制左子树;</li>\n<li>递归复制右子树。</li>\n</ol>\n<pre><code class=\"c\">void Copy(BiTree T, BiTree &amp;NewT)\n&#123;\n    if (T = NULL)\n    &#123;\n        NewT = NULL;\n        return;\n    &#125;\n    else\n    &#123;\n        NewT = new BiTNode;\n        NewT-&gt;data = T-&gt;data;\n        Copy(T-&gt;lchild, NewT-&gt;lchild);\n        Copy(T-&gt;rchild, NewT-&gt;rchild);\n    &#125;\n&#125;\n</code></pre>\n<p><strong>计算二叉树的深度</strong></p>\n<p>如果是空树，递归结束，深度为0，否则执行以下操作:</p>\n<ol>\n<li>递归计算左子树的深度记为m;</li>\n<li>递归计算右子树的深度记为n;</li>\n<li>如果m大于n，二叉树的深度为m+1，否则为n+1。</li>\n</ol>\n<pre><code class=\"c\">int Depth(BiTree T)\n&#123; // 返回二叉树的深度\n    if (!T)\n        return 0;\n    else\n    &#123;\n        m = Depth(T-&gt;lchild);\n        n = Depth(T-&gt;rchild);\n        if (m &gt; n)\n            return (m + 1);\n        else return (n+1）;\n    &#125;\n&#125; \n</code></pre>\n<p><strong>统计二叉树中结点的个数</strong></p>\n<pre><code class=\"c\">int NodeCount(BiTree T)\n&#123;\n    if (T == NULL)\n        return 0;\n    else\n        return NodeCount(T-&gt;lchild) + NodeCount(T-&gt;rchild) + 1;\n&#125;\n</code></pre>\n<p><strong>统计二叉树中叶子结点个数</strong></p>\n<pre><code class=\"c\">int CountLeaf(BiTree T)\n&#123; // 返回指针T所指二叉树中的叶子结点的个数\n    if (!T)\n        return 0;\n    if (!T-&gt;lchild &amp;&amp; !T-&gt;rchild)\n        return 1;\n    else\n    &#123;\n        m = CountLeaf(T-&gt;lchild);\n        n = CountLeaf(T-&gt;rchild);\n        return (m + n);\n    &#125; // else\n&#125; // CountLeaf\n</code></pre>\n<h2 id=\"②-线索二叉树\"><a href=\"#②-线索二叉树\" class=\"headerlink\" title=\"②.线索二叉树\"></a>②.线索二叉树</h2><p>当以二叉链表作为存储结构时，只能找到结点的左、右孩子信息，而不能直接得到结点在任一序列中的前驱和后继信息，这种信息只有在遍历的动态过程中才能得到，为此引人线索二叉树来保存这些在动态过程中得到的有关前驱和后继的信息。</p>\n<p><strong>线索:指向前驱或后继结点的指针称为线索</strong></p>\n<p><strong>线索二叉树:加上线索的二叉链表表示的二叉树叫线索二叉树</strong></p>\n<p><strong>线索化:对二叉树按某种遍历次序使其变为线索二叉树的过程叫线索化</strong></p>\n<p>试做如下规定：若结点有左子树，则其lchild域指示其左孩子，否则令lchild域指示其前驱;若结点有右子树，则其rchild域指示其右孩子，否则令rchild域指示其后继。为了避免混淆，尚需改变结点结构，增加两个标志域。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/aa7d08d1eb02476f9c66f09c137e1158.png#pic_center\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/43f9f2371e0a4aa8921e6c48fb19e91a.png#pic_center\"></p>\n<p><strong>二叉树的二叉线索存储表示</strong></p>\n<pre><code class=\"c\">typedef struct BiThrNode\n&#123;\n    TElemType data;\n    struct BiThrNode *lchild, *rchild;//左右孩子标志\n    int LTag, RTag;//左右标志\n&#125; BiThrNode, *BiThrTree;\n</code></pre>\n<p><strong>以结点p为根的子树中序线索化</strong></p>\n<p>算法中有一全局变量:pre，在主调程序中初值为空，在整个线索化算法中pre始终指向当前结点p的前驱。</p>\n<ol>\n<li>如果p非空，左子树递归线索化。</li>\n<li>如果p的左孩子为空，则给p加上左线索，将其LTag置为1，让p的左孩子指针指向pre(前驱)﹔否则将p的LTag置为0。</li>\n<li>如果pre的右孩子为空，则给pre加上右线索，将其RTag置为1，让pre的右孩子指针指向p(后继)﹔否则将pre的RTag置为0。</li>\n<li>将pre指向刚访问过的结点p，即pre&#x3D;p。</li>\n<li>右子树递归线索化。</li>\n</ol>\n<pre><code class=\"c\">void InThreading(BiThrTree p)\n&#123; // pre是全局变量，初始化时其右孩子指针为空，便于在树的最左点开始建线索\n    if (p)\n    &#123;\n        InThreading(p-&gt;lchild); //左子树递归线索化\n        if (!p-&gt;lchild)         // p的左孩子为空\n        &#123;\n            p-&gt;LTag = 1;     //给p加上左线索\n            p-&gt;lchild = pre; // p的左孩子指针指向pre（前驱）\n        &#125;\n        else\n            p-&gt;LTag = 0;\n        if (!pre-&gt;rchild) // pre的右孩子为空\n        &#123;\n            pre-&gt;RTag = 1;   //给pre加上右线索\n            pre-&gt;rchild = p; // pre的右孩子指针指向p（后继）\n        &#125;\n        else\n            pre-&gt;RTag = 0;\n        pre = p;                //保持pre指向p的前驱\n        InThreading(p-&gt;rchild); //右子树递归线索化\n    &#125;\n\n&#125; \n</code></pre>\n<p><strong>带头结点的二叉树中序线索化</strong></p>\n<pre><code class=\"c\">void InOrderThreading(BiThrTree &amp;Thrt, BiThrTree T)\n&#123;                         //中序遍历二叉树T，并将其中序线索化，Thrt指向头结点\n    Thrt = new BiThrNode; //建头结点\n    Thrt-&gt;LTag = 0;       //头结点有左孩子，若树非空，则其左孩子为树根\n    Thrt-&gt;RTag = 1;       //头结点的右孩子指针为右线索\n    Thrt-&gt;rchild = Thrt;  //初始化时右指针指向自己\n    if (!T)\n        Thrt-&gt;lchild = Thrt; //若树为空，则左指针也指向自己\n    else\n    &#123;\n        Thrt-&gt;lchild = T;\n        pre = Thrt;         //头结点的左孩子指向根，pre初值指向头结点\n        InThreading(T);     //对以T为根的二叉树进行中序线索化\n        pre-&gt;rchild = Thrt; //算法5.7结束后，pre为最右结点，pre的右线索指向头结点\n        pre-&gt;RTag = 1;\n        Thrt-&gt;rchild = pre; //头结点的右线索指向pre\n    &#125;\n&#125;\n</code></pre>\n<p><strong>遍历中序线索二叉树</strong></p>\n<ol>\n<li>指针p指向根结点。</li>\n<li>p为非空树或遍历未结束时，循环执行以下操作:<br>- 沿左孩子向下，到达最左下结点<em>p，它是中序的第一个结点;<br>- 访问</em>p;<br>- 沿右线索反复查找当前结点*p的后继结点并访问后继结点，直至右线索为0或者遍历结束;<br>- 转向p的右子树。</li>\n</ol>\n<pre><code class=\"c\">void InOrderTraverse_Thr(BiThrTree T)\n&#123; // T指向头结点，头结点的左链lchild指向根结点，可参见线索化算法5.8。\n  //中序遍历二叉线索树T的非递归算法，对每个数据元素直接输出\n    p = T-&gt;lchild; // p指向根结点\n    while (p != T) //空树或遍历结束时，p==T\n    &#123;\n        while (p-&gt;LTag == 0) //沿左孩子向下\n            p = p-&gt;lchild;   //访问其左子树为空的结点\n        cout &lt;&lt; p-&gt;data;\n        while (p-&gt;RTag == 1 &amp;&amp; p-&gt;rchild != T)\n        &#123;\n            p = p-&gt;rchild; //沿右线索访问后继结点\n            cout &lt;&lt; p-&gt;data;\n        &#125;\n        p = p-&gt;rchild;\n    &#125;\n&#125;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/aed0af3fb85c43ca8298eef7bad0faac.png#pic_center\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/b186f2830d984a9bb747179cd400eb77.png#pic_center\"></p>\n<hr>\n<h1 id=\"5、树和森林\"><a href=\"#5、树和森林\" class=\"headerlink\" title=\"5、树和森林\"></a>5、树和森林</h1><h2 id=\"①-树的存储结构\"><a href=\"#①-树的存储结构\" class=\"headerlink\" title=\"①.树的存储结构\"></a>①.树的存储结构</h2><p><strong>双亲表示法</strong></p>\n<p>这种表示方法中，以一组连续的存储单元存储树的结点，每个结点除了数据域data外，还附设一个parent域用以指示其双亲结点的位置。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/f86a7da7287b467f9c41ef260fe94977.png#pic_center\"></p>\n<pre><code class=\"c\">#defin MAX_TREE_SIZE 100\ntypedef struct PTNode\n&#123; //结点结构\n    ElemType data;\n    int parent; //保存双亲位置\n&#125; PTNode;\n\ntypedef struct\n&#123; //树结构\n    PTNode nodes[MAX_TREE_SIZE];\n    int r, n; //根的位置和结点数\n&#125; PTree;\n</code></pre>\n<p><strong>孩子表示法</strong></p>\n<p>由于树中每个结点可能有多棵子树，则可用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/6338bf3675bd4cb0a48e90b6ea7a23aa.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/1408b3c6c5504759998c443b48a46309.png#pic_center\"></p>\n<pre><code class=\"c\">//树结构\ntypedef struct\n&#123;\n    CTBox nodes[MAX_TREE_SIZE];\n    int n, r; // 结点数和根结点的位置\n&#125; CTree;\n//孩子链表表示法的类型描述\ntypedef struct CTNode\n&#123;\n    int child;\n    struct CTNode *nextchild;\n&#125; * ChildPtr;\n//双亲结点结构\ntypedef struct\n&#123;\n    ElemType data;\n    int parent; //保存双亲位置\n    ChildPtr firstchild;\n    // 孩子链的头指针\n&#125; CTBox;\n</code></pre>\n<p><strong>孩子兄弟法</strong></p>\n<p>又称二叉树表示法，或二叉链表表示法，即以二叉链表做树的存储结构。链表中结点的两个链域分别指向该结点的第一个孩子结点和下一个兄弟结点，分别命名为firstchild域和nextsibling域。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/6338bf3675bd4cb0a48e90b6ea7a23aa.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/fa4b9b8bb20d4311990d0b19d0e14105.png#pic_center\"></p>\n<pre><code class=\"c\">typedef struct CSNode\n&#123;\n    ElemType data;\n    struct CSNode *firstchild, *nextsibling;\n&#125; CSNode, *CSTree;\n</code></pre>\n<h2 id=\"②-森林与二叉树的转换\"><a href=\"#②-森林与二叉树的转换\" class=\"headerlink\" title=\"②.森林与二叉树的转换\"></a>②.森林与二叉树的转换</h2><p>从树的二叉链表表示的定义可知，任何一棵和树对应的二叉树，其根结点的右子树必空。若把森林中第二棵树的根结点看成是第一棵树的根结点的兄弟，则同样可导出森林和二叉树的对应关系。</p>\n<p><strong>树转换成二叉树的方法</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/e16ccb1cae564e198d2ae9fece12332a.png#pic_center\"></p>\n<p><strong>二叉树转换为树的方法</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/f59ddbec01a1427db305bec1b8eaa8db.png#pic_center\"></p>\n<p><strong>森林转换成二叉树的方法</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/9bf34d1c8bc442afbec3342ff2661634.png#pic_center\"></p>\n<p><strong>二叉树转换成森林的方法</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/73971b0e4e4d4aa09ee17a541b233b54.png#pic_center\"></p>\n<p>例：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/ffaa6fa0bf744c83a2d010ceafb1831a.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/a3f5a96fd7d44d9b81d6f6a10a1dea7e.png#pic_center\"></p>\n<h2 id=\"③-树和森林的遍历\"><a href=\"#③-树和森林的遍历\" class=\"headerlink\" title=\"③.树和森林的遍历\"></a>③.树和森林的遍历</h2><p><strong>树的遍历：</strong></p>\n<p>&#x3D;&#x3D;先根(序)遍历:先访问树的根结点，然后依次先根遍历根的每棵子树后根(序)遍历:先依次后根遍历每棵子树，然后访问根结点。&#x3D;&#x3D;</p>\n<p>&#x3D;&#x3D;按层次遍历:先访问第一层上的结点，然后依次遍历第二层，…..，第n层的结点。&#x3D;&#x3D;</p>\n<p><img src=\"https://img-blog.csdnimg.cn/b00df7b712664feaa93010b59f728938.png#pic_center\"><br><strong>森林的遍历：</strong></p>\n<ol>\n<li><p>先序遍历森林<br>- 访问森林中第一棵树的根结点<br>- 先序遍历第一棵树中根结点的子树森林<br>- 先序遍历除去第一棵树之后剩余的树构成森林</p>\n</li>\n<li><p>中序遍历森林<br>- 中序遍历森林中第一棵树的根结点的子树森林<br>- 访问第一棵树的根结点<br>- 中序遍历除去第一棵树之后剩余的树构成的森林</p>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/792159a55a754c75ac2b77bc46cde323.png#pic_center\"></p>\n<hr>\n<h1 id=\"6、哈夫曼树及其应用\"><a href=\"#6、哈夫曼树及其应用\" class=\"headerlink\" title=\"6、哈夫曼树及其应用\"></a>6、哈夫曼树及其应用</h1><h2 id=\"①-哈夫曼树的基本概念\"><a href=\"#①-哈夫曼树的基本概念\" class=\"headerlink\" title=\"①.哈夫曼树的基本概念\"></a>①.哈夫曼树的基本概念</h2><p><strong>&#x3D;&#x3D;哈夫曼(Huffman )树又称最优树，是一类带权路径长度最短的树，在实际中有广泛的用途。&#x3D;&#x3D;</strong></p>\n<p><strong>路径:从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。</strong></p>\n<p><strong>路径长度:路径上的分支数目称作路径长度。</strong></p>\n<p><strong>树的路径长度:从树根到每一结点的路径长度之和。</strong></p>\n<p><strong>权:赋予某个实体的一个量，是对实体的某个或某些属性的数值化描述。</strong></p>\n<p><strong>结点的带权路径长度:从该结点到树根之间的路径长度与结点上权的乘积。</strong></p>\n<p><strong>树的带权路径长度:树中所有叶子结点的带权路径长度之和。</strong></p>\n<p><strong>哈夫曼树:假设有m个权值{w<del>1</del>，w<del>2</del>…，w<del>m</del>}，可以构造一棵含n个叶子结点的二叉树，每个叶子结点的权为w<del>i</del>，则其中带权路径长度WPL最小的二叉树称做最优二叉树或哈夫曼树。</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/86d2200a76914cb9b73b9427073097c9.png#pic_center\"></p>\n<h2 id=\"②-哈夫曼树的构造算法\"><a href=\"#②-哈夫曼树的构造算法\" class=\"headerlink\" title=\"②.哈夫曼树的构造算法\"></a>②.哈夫曼树的构造算法</h2><p><strong>哈夫曼树的构造过程</strong></p>\n<p><strong>&#x3D;&#x3D;核心思想：使权值大的结点靠近根。&#x3D;&#x3D;</strong></p>\n<ol>\n<li>根据给定的n个权值{w<del>1</del>,w<del>2</del>…….w<del>n</del>}，构造n棵只有根结点的二叉树，这n棵二叉树构成一个森林F。</li>\n<li>在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。</li>\n<li>在森林中删除这两棵树，同时将新得到的二叉树加入森林中。</li>\n<li>重复上述两步，直到只含一棵树为止，这棵树即哈夫曼树。<br><img src=\"https://img-blog.csdnimg.cn/84dfef9210fd4b3295f41d1b6cbc78ce.png#pic_center\"></li>\n</ol>\n<p><strong>哈夫曼算法的实现</strong></p>\n<p>哈夫曼树是―种二叉树，当然可以采用前面介绍过的通用存储方法，而由于哈夫曼树中没有度为1的结点,则一棵有n个叶子结点的哈夫曼树共有2n-1个结点,可以存储在一个大小为2n-1的一维数组中。</p>\n<pre><code class=\"c\">typedef struct\n&#123;\n    int weight;                 //结点的权值\n    int parent, lchild, rchild; //双亲、左孩子、右孩子的下标\n&#125; HTnode, *HuffmanTree;\n</code></pre>\n<p><strong>构造哈夫曼树</strong></p>\n<ol>\n<li>初始化:首先动态申请2n个单元;然后循环2n-1次，从1号单元开始，依次将1至2n-1所有单元中的双亲、左孩子、右孩子的下标都初始化为0;最后再循环n次，输人前n个单元中叶子结点的权值。</li>\n<li>创建树:循环n-1次，通过n-1次的选择、删除与合并来创建哈夫曼树。选择是从当前森林中选择双亲为0且权值最小的两个树根结点s1和s2;删除是指将结点sl和s2的双亲改为非0;合并就是将s1和s2的权值和作为一个新结点的权值依次存入到数组的第n+1之后的单元中，同时记录这个新结点左孩子的下标为s1，右孩子的下标为s2。</li>\n</ol>\n<pre><code class=\"c\">void CreatHuffmanTree(HuffmanTree HT, int n)\n&#123; //构造哈夫曼树HT\n    if (n &lt;= 1)\n        return;\n    m = 2 * n - 1;\n    HT = new HTNode[m + 1];  // 0号单元未用，HT[m]表示根结点\n    for (i = 1; i &lt;= m; ++i) //初始化：双亲、左孩子，右孩子的下标都为0\n    &#123;\n        HT[i].parent = 0;\n        HT[i].lchild = 0;\n        HT[i].rchild = 0;\n    &#125;\n    for (i = 1; i &lt;= n; ++i) //输入前n个单元中叶子结点的权值\n        cin &gt;&gt; HT[i].weight;\n    /*―――初始化工作结束，下面开始创建哈夫曼树――――*/\n    for (i = n + 1; i &lt;= m; ++i)\n    &#123;                              //通过n-1次的选择、删除、合并来创建哈夫曼树\n        Select(HT, i - 1, s1, s2); //选择两个其双亲域为0且权值最小的结点，\n        HT[s1].parent = i;\n        HT[s2].parent = i; //得到新结点i, 将s1和s2的双亲域由0改为i\n        HT[i].lchild = s1;\n        HT[i].rchild = s2;                            // s1,s2分别作为i的左右孩子\n        HT[i].weight = HT[s1].weight + HT[s2].weight; // i 的权值为左右孩子权值之和\n    &#125;                                                 // for\n&#125;\n</code></pre>\n<p>例：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/97ac1a3ba1794ea1a39a188558f516f4.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/7f82f6628be44a54b233172f269df188.png#pic_center\"></p>\n<h2 id=\"③-哈夫曼编码\"><a href=\"#③-哈夫曼编码\" class=\"headerlink\" title=\"③.哈夫曼编码\"></a>③.哈夫曼编码</h2><p>下面给出有关编码的两个概念。</p>\n<p> <strong>前缀编码:</strong> 如果在一个编码方案中，任一个编码都不是其他任何编码的前缀(最左子串),则称编码是前缀编码。</p>\n<p><strong>哈夫曼编码:</strong> 对一棵具有n个叶子的哈夫曼树，若对树中的每个左分支赋予0，右分支赋予1，则从根到每个叶子的路径上，各分支的赋值分别构成一个二进制串，该二进制串就称为哈夫曼编码。</p>\n<p><strong>哈夫曼编码满足下面的两个性质：</strong></p>\n<p>&#x3D;&#x3D;哈夫曼编码是前缀码&#x3D;&#x3D;<br>&#x3D;&#x3D;哈夫曼编码是最优前缀编码&#x3D;&#x3D;</p>\n<p><strong>哈夫曼编码的算法实现</strong></p>\n<p>在构造哈夫曼树之后，求哈夫曼编码的主要思想是:依次以叶子为出发点，向上回溯至根结点为止。回溯时走左分支则生成代码0，走右分支则生成代码1。由于每个哈夫曼编码是变长编码，因此使用一个指针数组来存放每个字符编码串的首地址。</p>\n<ol>\n<li>分配存储n个字符编码的编码表空间HC，长度为n +1;分配临时存储每个字符编码的动态数组空间cd, cd[n-1]置为‘\\0’</li>\n<li>逐个求解n个字符的编码，循环n次，执行以下操作:<br>设置变量start 用于记录编码在cd中存放的位置，start初始时指向最后，即编码结束符位置n -1;<br>设置变量c用于记录从叶子结点向上回溯至根结点所经过的结点下标，c初始时为当前待编码字符的下标i，f 用于记录i的双亲结点的下标;<br>从叶子结点向上回溯至根结点，求得字符i的编码，当f没有到达根结点时，循环执行以下操作:<br>回溯一次start向前指一个位置，即–start;<br>若结点c是f的左孩子，则生成代码0，否则生成代码1，生成的代码0或1保存在cd[start]中;<br>继续向上回溯，改变c和f的值。<br>根据数组cd的字符串长度为第i个字符编码分配空间HC[i]，然后将数组cd中的编码复制到HC[i]中。</li>\n<li>释放临时空间cd。</li>\n</ol>\n<pre><code class=\"c\">void CreatHuffmanCode(HuffmanTree HT, HuffmanCode &amp;HC, int n)\n&#123;                           //从叶子到根逆向求每个字符的赫夫曼编码，存储在编码表HC中\n    HC = new char *[n + 1]; //分配n个字符编码的头指针矢量\n    cd = new char[n];       //分配临时存放编码的动态数组空间\n    cd[n - 1] = &#39;\\0&#39;;       //编码结束符\n    for (i = 1; i &lt;= n; ++i)\n    &#123;                  // 逐个字符求赫夫曼编码\n        start = n - 1; // start开始时指向最后，即编码结束符位置\n        c = i;\n        f = HT[i].parent; // f指向结点c的双亲结点\n        while (f != 0)\n        &#123;            //从叶子结点开始向上回溯，直到根结点\n            --start; //回溯一次start向前指一个位置\n            if (HT[f].lchild == c)\n                cd[start] =’0’; //结点c是f的左孩子，则生成代码0\n            else\n                cd[start] =‘1’; //结点c是f的右孩子，则生成代码1\n            c = f;\n            f = HT[f].parent;        //继续向上回溯\n        &#125;                            //求出第i个字符的编码\n        HC[i] = new char[n - start]; // 为第i 个字符编码分配空间\n        strcpy(HC[i], &amp;cd[start]);   //将求得的编码从临时空间cd复制到HC的当前行中\n    &#125;\n    delete cd; //释放临时空间\n&#125;\n</code></pre>\n<p>例：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/f6f917959f35462f8a65dfb489710094.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/684a62af89e8478dae7322c3a3643ca1.png#pic_center\"></p>\n<hr>\n<h1 id=\"7、总结\"><a href=\"#7、总结\" class=\"headerlink\" title=\"7、总结\"></a>7、总结</h1><ol>\n<li>二叉树是―种最常用的树形结构，二叉树具有一些特殊的性质，<strong>而满二叉树和完全二叉树又是两种特殊形态的二叉树</strong>。</li>\n<li>二叉树有两种存储表示:<strong>顺序存储和链式存储</strong>。顺序存储就是把二叉树的所有结点按照层次顺序存储到连续的存储单元中，这种存储更适用于完全二叉树。链式存储又称二叉链表，每个结点包括两个指针，分别指向其左孩子和右孩子。链式存储是二叉树常用的存储结构。</li>\n<li>树的存储结构有三种:<strong>双亲表示法、孩子表示法和孩子兄弟表示法</strong>，孩子兄弟表示法是常用的表示法，任意一棵树都能通过孩子兄弟表示法转换为二叉树进行存储。森林与二叉树之间也存在相应的转换方法，通过这些转换，可以利用二叉树的操作解决一般树的有关问题。</li>\n<li>二叉树的遍历算法是其他运算的基础，通过遍历得到了二叉树中结点访问的线性序列，实现了非线性结构的线性化。根据访问结点的次序不同可得三种遍历:<strong>先序遍历、中序遍历、后序遍历，时间复杂度均为O(n)。</strong></li>\n<li>在线索二叉树中，利用二叉链表中的n+1个空指针域来存放指向某种遍历次序下的前驱结点和后继结点的指针，这些附加的指针就称为“线索”。<strong>引人二叉线索树的目的是加快查找结点前驱或后继的速度。</strong></li>\n<li>哈夫曼树在通信编码技术上有广泛的应用，只要构造了哈夫曼树，按分支情况在左路径上写代码0，右路径上写代码1,然后从上到下叶结点相应路径上的代码序列就是该叶结点的最优前缀码，即<strong>哈夫曼编码</strong>。</li>\n</ol>\n<hr>\n<h1 id=\"8、例题与应用\"><a href=\"#8、例题与应用\" class=\"headerlink\" title=\"8、例题与应用\"></a>8、例题与应用</h1><p><img src=\"https://img-blog.csdnimg.cn/e5162f6a1b1a499e97d10f8a5fa0d780.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/896611c6c5074d4198de6db65f3854bd.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/3995bfe0d1dc404d8082bd959999c721.png#pic_center\"></p>\n<ol>\n<li>编程实现如下功能：<br>（1）假设二叉树的结点值是字符型，根据输入的一棵二叉树的完整先序遍历序列（子树空用’#’表示），建立一棵以二叉链表存储表示的二叉树。<br>（2）对二叉树进行先序、中序和后序遍历操作，并输出遍历序列，观察输出的序列是否与逻辑上的序列一致。<br>（3）主程序中要求设计一个菜单，允许用户通过菜单来多次选择执行哪一种遍历操作。</li>\n</ol>\n<p>测试样例：ABC##DE#G##F###</p>\n<p><img src=\"https://img-blog.csdnimg.cn/026f30e023ad4961b1501d8d402e8603.png#pic_center\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/78bd754a663b4437ba711f53fada5576.png#pic_center\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/8d275e401581485fb372f80c9d86ba9a.png#pic_center\"></p>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n//二叉树的二叉线索存储表示\ntypedef struct BiNode\n&#123;\n    char data;\n    struct BiNode *lchild, *rchild;\n&#125; BiTNode, *BiTree;\n\n//先序遍历的的顺序建立二叉链表\nvoid CreateBiTree(BiTree &amp;T)\n&#123;\n    char ch;\n    cin &gt;&gt; ch;\n    if (ch == &#39;#&#39;)\n    &#123;\n        T = NULL;\n    &#125;\n    else\n    &#123;\n        T = new BiTNode;\n        T-&gt;data = ch;\n        CreateBiTree(T-&gt;lchild);\n        CreateBiTree(T-&gt;rchild);\n    &#125;\n&#125;\n\n//先序遍历的递归算法\nvoid PreOrderTraverse(BiTree T)\n&#123;\n    if (T)\n    &#123;\n        cout &lt;&lt; T-&gt;data;\n        PreOrderTraverse(T-&gt;lchild);\n        PreOrderTraverse(T-&gt;rchild);\n    &#125;\n&#125;\n\n//中序遍历的递归算法\nvoid InOrderTraverse(BiTree T)\n&#123;\n    if (T)\n    &#123;\n        InOrderTraverse(T-&gt;lchild);\n        cout &lt;&lt; T-&gt;data;\n        InOrderTraverse(T-&gt;rchild);\n    &#125;\n&#125;\n\n//后序遍历的递归算法\nvoid PostOrderTraverse(BiTree T)\n&#123;\n    if (T)\n    &#123;\n        PostOrderTraverse(T-&gt;lchild);\n        PostOrderTraverse(T-&gt;rchild);\n        cout &lt;&lt; T-&gt;data;\n    &#125;\n&#125;\nint main(void)\n&#123;\n    BiTree tree;\n    int select;\n\n    while (1)\n    &#123;\n        cout &lt;&lt; &quot;1、建立二叉树\\n&quot;;\n        cout &lt;&lt; &quot;2、先序遍历\\n&quot;;\n        cout &lt;&lt; &quot;3、中序遍历\\n&quot;;\n        cout &lt;&lt; &quot;4、后序遍历\\n&quot;;\n        cout &lt;&lt; &quot;0、退出程序\\n&quot;;\n\n        cout &lt;&lt; &quot;\\n请选择:&quot;;\n        cin &gt;&gt; select;\n\n        switch (select)\n        &#123;\n        case 1:\n            cout &lt;&lt; &quot;请输入建立二叉链表的序列：\\n&quot;;\n            CreateBiTree(tree);\n            cout &lt;&lt; endl;\n            break;\n        case 2:\n            cout &lt;&lt; &quot;所建立的二叉链表先序序列：\\n&quot;;\n            PreOrderTraverse(tree);\n            cout &lt;&lt; endl\n                 &lt;&lt; endl;\n            break;\n        case 3:\n            cout &lt;&lt; &quot;所建立的二叉链表中序序列：\\n&quot;;\n            InOrderTraverse(tree);\n            cout &lt;&lt; endl\n                 &lt;&lt; endl;\n            break;\n        case 4:\n            cout &lt;&lt; &quot;所建立的二叉链表后序序列：\\n&quot;;\n            PostOrderTraverse(tree);\n            cout &lt;&lt; endl;\n            break;\n        case 0:\n            return 0;\n            break;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<ol start=\"2\">\n<li>编程实现如下功能：<br>（1）建立由英文字符组成的文件f1（字符种类≥10，长度≥100），并统计不同字符出现的次数；<br>（2）按字符出现的次数对其建立哈夫曼树，并求出各个字符的哈夫曼编码；<br>（3）读入要编码的文件f1，编码后存入另一个文件f2；<br>（4）接着再调出编码后的文件f2，对其进行译码输出，最后存入文件f3。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"left\">f1.txt</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">TherearemomentsinlifewhenyoumisssomeonesomuchthatyoujustwanttopickthemfromyourdreamsandhugthemforrealDreamwhatyouwanttodreamgowhereyouwanttogobewhatyouwanttobebecauseyouhaveonlyonelifeandonechancetodoallthethingsyouwanttodo</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"left\">f2.txt</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">110000011010011111010111111111010110011100001101110110001110001001101101000010011101000111101110100111011110011000101001101001111001110011100100001101110010110111110010000110101110101101000010101111000110011000101110000000101111000001101111111011000000100110000110100111010111000010000101001100111101001110110000111100110001011110100101111010111111001111100111110110010110100101110001000101001100111101001001110111101011111101000001000111101011111100111101110101111000110011000101110111111101100000010000101111010111111001111000110011011101001111101011110011000101110111111101100000010011000110000100101111011101011110001100110001011101111111011000000100001001011001001011110101111101011110001111001100010110101111001000001110010110100011001100101101101000010011101000111111101100101100101101111010110101111101111010101100010000101100111101000010000001010011000101001001101111000111100110011000101110111111101100000010000101100</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"left\">f3.txt</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">TherearemomentsinlifewhenyoumisssomeonesomuchthatyoujustwanttopickthemfromyourdreamsandhugthemforrealDreamwhatyouwanttodreamgowhereyouwanttogobewhatyouwanttobebecauseyouhaveonlyonelifeandonechancetodoallthethingsyouwanttodo</td>\n</tr>\n</tbody></table>\n<p><img src=\"https://img-blog.csdnimg.cn/0a43a18e481b42ab8c90aeec4e43284e.png#pic_center\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/138dd499f89d4c8c8154b5e73a830fcc.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/44d733b34d1e4f7c85fb0aea0a999cfe.png#pic_center\"></p>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\ntypedef struct //定义哈夫曼树的结构\n&#123;\n    int weight;\n    int parent, lchild, rchild;\n&#125; HTNode, *HuffmanTree;\n\ntypedef char **HuffmanCode;\n\ntypedef struct //存储数据扫描统计结果\n&#123;\n    char *data;    //字符\n    int *quantity; //次数\n    int length;    //总长度\n&#125; TNode;\n\nvoid InitList(TNode &amp;N) //初始化TNode定义的结点\n&#123;\n    N.data = new char[256];\n    N.quantity = new int[256];\n    if (!N.data || !N.quantity)\n        exit(1);\n    N.length = 0;\n&#125;\n\nint Find(TNode N, char ch)\n&#123;\n    for (int i = 0; i &lt; N.length; i++)\n        if (ch == N.data[i])\n            return true;\n    return false;\n&#125;\n\nvoid ReadFile(vector&lt;char&gt; &amp;f) //读取文件\n&#123;\n    char ch;\n    ifstream infile(&quot;f1.txt&quot;, ios::in);\n    if (!infile) //文件不存在\n    &#123;\n        cout &lt;&lt; &quot;打开文件失败！&quot; &lt;&lt; endl;\n        exit(1);\n    &#125;\n    while (infile.peek() != EOF)\n    &#123;\n        infile.get(ch);\n        f.push_back(ch); //把字符ch推入vector\n    &#125;\n    infile.close(); //关闭文件\n    cout &lt;&lt; &quot;读取完成&quot; &lt;&lt; endl;\n    system(&quot;pause&quot;);\n&#125;\n\nvoid WriteTNode(vector&lt;char&gt; v, TNode &amp;N) //将vector中的数据存入TNode结构体中\n&#123;\n    char ch;\n    int len = v.size(), j = 0;\n    for (int i = 0; i &lt; len; i++)\n    &#123;\n        ch = v[i];\n        if (!Find(N, ch))\n        &#123;\n            N.data[j] = ch;\n            N.quantity[j] = count(v.begin(), v.end(), ch);\n            j++;\n            N.length++;\n        &#125;\n    &#125;\n    cout &lt;&lt; &quot;写入完成&quot; &lt;&lt; endl;\n    system(&quot;pause&quot;);\n&#125;\n\nvoid Select(HuffmanTree &amp;HT, int n, int &amp;min1, int &amp;min2) //查找HT中未被使用的权值最小的两个点的下标\n&#123;\n    min1 = min2 = 0; //初始化\n    for (int i = 1; i &lt; n; i++)\n    &#123;\n        if (HT[i].parent != 0)\n            continue; //略过已经加入的结点\n        if (min1 == 0)\n            min1 = min2 = i; //赋初值\n        else if (HT[i].weight &lt;= HT[min1].weight)\n        &#123; //min1是最小值\n            min2 = min1;\n            min1 = i;\n        &#125;\n        else if (HT[i].weight &lt; HT[min2].weight)\n        &#123; //min2是次小值\n            min2 = i;\n        &#125;\n        else if (HT[i].weight &gt; HT[min2].weight)\n        &#123; //防止两个值相等\n            if (min1 == min2)\n                min2 = i;\n        &#125;\n    &#125;\n&#125;\n\nvoid HuffmanCoding(HuffmanTree &amp;HT, HuffmanCode &amp;HC, TNode N) //建树函数\n&#123;\n    int m, start, n = N.length;\n    char *cd;\n    unsigned int c, f;\n    if (n &lt;= 1)\n        return;\n    m = 2 * n - 1;\n    HT = (HuffmanTree)malloc((m + 1) * sizeof(HTNode)); //0号单元未用 从1开始\n    for (int i = 1; i &lt;= n; i++)\n    &#123; //利用TNode将叶节点初始化\n        HT[i].parent = 0;\n        HT[i].lchild = HT[i].rchild = 0;\n        HT[i].weight = N.quantity[i - 1];\n    &#125;\n    for (int i = n + 1; i &lt;= m; i++)\n    &#123; //初始化非叶节点\n        HT[i].parent = HT[i].weight = 0;\n        HT[i].lchild = HT[i].rchild = 0;\n    &#125;\n    for (int i = n + 1; i &lt;= m; i++)\n    &#123;                   //构建赫夫曼树\n        int min1, min2; //选出最小的两个结点合并\n        Select(HT, i, min1, min2);\n        HT[i].weight = HT[min1].weight + HT[min2].weight;\n        HT[i].lchild = min1;\n        HT[i].rchild = min2;\n        HT[min1].parent = HT[min2].parent = i;\n    &#125;\n    //从叶子到根逆向求每个字符的赫夫曼编码\n    HC = (HuffmanCode)malloc((n + 1) * sizeof(char *)); //分配n个字符编码的头指针向量\n    cd = (char *)malloc(n * sizeof(char));              //分配求编码的工作空间\n    cd[n - 1] = &#39;\\0&#39;;                                   //编码结束符\n    for (int i = 1; i &lt;= n; i++)\n    &#123;                  //逐个字符求赫夫曼编码\n        start = n - 1; //编码结束符位置\n        for (c = i, f = HT[i].parent; f != 0; c = f, f = HT[f].parent)\n        &#123; //从叶子到根逆向求编码\n            if (HT[f].lchild == c)\n                cd[--start] = &#39;0&#39;;\n            else\n                cd[--start] = &#39;1&#39;;\n        &#125;\n        HC[i] = (char *)malloc((n - start) * sizeof(char)); //为第i个字符编码分配空间\n        strcpy(HC[i], &amp;cd[start]);                          //从cd复制编码（串）到HC\n    &#125;\n    free(cd); //释放工作空间\n    cout &lt;&lt; &quot;完成哈夫曼建树！&quot; &lt;&lt; endl;\n    system(&quot;pause&quot;);\n&#125;\n\nvoid ZipFile(HuffmanCode HC, vector&lt;char&gt; v, TNode N) //压缩文件\n&#123;\n    int i = 0, j = 0, k = 0;\n    ofstream outfile(&quot;f2.txt&quot;, ios::out);\n    if (!outfile)\n    &#123; //文件为空\n        cerr &lt;&lt; &quot;wrong open!!&quot; &lt;&lt; endl;\n        exit(1);\n    &#125;\n    for (i = 0; i &lt; v.size(); i++)\n    &#123; //遍历vector容器\n        for (j = 0; j &lt; N.length; j++)\n            if (N.data[j] == v[i])\n                break;\n        for (k = 0; HC[j + 1][k] != &#39;\\0&#39;; k++)\n            outfile &lt;&lt; HC[j + 1][k];\n    &#125;\n    outfile.close();\n    cout &lt;&lt; &quot;压缩完成！&quot; &lt;&lt; endl;\n    system(&quot;pause&quot;);\n&#125;\n\nvoid RZipFile(HuffmanCode HC, TNode N)\n&#123; //解压文件\n    int flag, flag2 = 0, m = 0, i, j;\n    char ch;\n    char ch2[55];\n    ofstream outfile(&quot;f3.txt&quot;, ios::out);\n    ifstream infile(&quot;f2.txt&quot;, ios::in);\n    if (!outfile)\n    &#123; //文件打开失败\n        cerr &lt;&lt; &quot;打开错误!&quot; &lt;&lt; endl;\n        exit(1); //运行错误，返回值1\n    &#125;\n    if (!infile)\n    &#123;\n        cerr &lt;&lt; &quot;打开错误!&quot; &lt;&lt; endl;\n        exit(1); //运行错误，返回值1\n    &#125;\n    while (infile.peek() != EOF)\n    &#123;\n        flag = 0;\n        char *cd = new char[N.length];\n        for (i = 0;; i++)\n        &#123;\n            infile &gt;&gt; ch;\n            cd[i] = ch;\n            cd[i + 1] = &#39;\\0&#39;;\n            for (int j = 1; j &lt;= N.length; j++)\n            &#123;\n                if (strcmp(HC[j], cd) == 0)\n                &#123;\n                    if (flag2 == 1)\n                    &#123;\n                        ch2[m] = N.data[j - 1];\n                        flag = 1;\n                        m++;\n                        delete cd;\n                        break;\n                    &#125;\n                    if (flag2 == 0)\n                    &#123;\n                        outfile &lt;&lt; N.data[j - 1];\n                        flag = 1;\n                        delete cd;\n                        break;\n                    &#125;\n                &#125;\n            &#125;\n            if (flag == 1)\n                break;\n        &#125;\n    &#125;\n    cout &lt;&lt; &quot;解压缩完成！&quot; &lt;&lt; endl; //提示完成解压缩\n    system(&quot;pause&quot;);\n&#125;\n\nvoid OutPutFile(vector&lt;char&gt; &amp;f)\n&#123;\n    char path[200];\n    char ch;\n    cout &lt;&lt; &quot;请输入您所要查询的文件路径&quot; &lt;&lt; endl;\n    cin &gt;&gt; path;\n\n    ifstream infile(path, ios::in);\n    if (!infile)\n    &#123; //文件不存在\n        cout &lt;&lt; &quot;打开错误!&quot; &lt;&lt; endl;\n        exit(1);\n    &#125;\n    while (infile.peek() != EOF)\n    &#123;\n        infile.get(ch);  //读取字符赋值给ch\n        f.push_back(ch); //把字符ch推入vector\n    &#125;\n    infile.close();\n    cout &lt;&lt; &quot;路径：&quot; &lt;&lt; path &lt;&lt; &quot;的文件如下&quot; &lt;&lt; endl;\n    for (int i = 0; i &lt; f.size(); i++)\n        cout &lt;&lt; f.at(i);\n    cout &lt;&lt; endl;\n    f.clear();\n    system(&quot;pause&quot;);\n&#125;\n\nint main(void)\n&#123;\n    int choose;\n    vector&lt;char&gt; V, Vr;\n    HuffmanTree HT;\n    HuffmanCode HC;\n    TNode N;\n    InitList(N);\n    while (1)\n    &#123;\n        system(&quot;cls&quot;);\n        cout &lt;&lt; &quot;1、压缩文件&quot; &lt;&lt; endl;\n        cout &lt;&lt; &quot;2、解压文件&quot; &lt;&lt; endl;\n        cout &lt;&lt; &quot;3、输出文件&quot; &lt;&lt; endl;\n        cout &lt;&lt; &quot;0、  退出  &quot; &lt;&lt; endl;\n        cout &lt;&lt; &quot;请输入您的操作:&quot; &lt;&lt; endl;\n        cin &gt;&gt; choose;\n        switch (choose)\n        &#123;\n        case 1:\n            cout &lt;&lt; &quot;*****进行压缩文件操作*****&quot; &lt;&lt; endl;\n            ReadFile(V);              //从文件读取数据存入vector容器\n            WriteTNode(V, N);         //将vector中的数据存储到NTode结构中\n            HuffmanCoding(HT, HC, N); //将TNode中的数据存到哈夫曼树中并生成哈夫曼编码\n            ZipFile(HC, V, N);        //压缩文件\n            break;\n        case 2:\n            cout &lt;&lt; &quot;*****进行解压缩文件操作*****&quot; &lt;&lt; endl;\n            RZipFile(HC, N); //对文件内容进行解码\n            break;\n        case 3:\n            cout &lt;&lt; &quot;*****进行输出文件操作*****&quot; &lt;&lt; endl;\n            OutPutFile(Vr); //将文件内容借助vector输出到终端\n            break;\n        case 0:\n            return 0;\n        default:\n            cout &lt;&lt; &quot;请正确输入！&quot;;\n            system(&quot;pause&quot;);\n            break;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n","feature":true,"text":"树( Tree)是n(n≥0)个结点的有限集，它或为空树(n=0)；或为非空树，对于非空树T：1. 有且仅有一个称之为根的结点;2. 除根结点以外的其余结点可分为m (m>0)个互不相交的有限集T1，T2,…，Tm，其中每一个集合本身又是一棵树，并且称为根的子树( SubTree)。...","permalink":"/post/数据结构（C语言版）-- 树和二叉树笔记","photos":[],"count_time":{"symbolsCount":"27k","symbolsTime":"25 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"字节跳动青训营","slug":"字节跳动青训营","count":21,"path":"api/tags/字节跳动青训营.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">1、树和二叉树的定义</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">①.树的定义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD\"><span class=\"toc-text\">②.树的基本术语</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">③.二叉树的定义</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2%E3%80%81%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">2、树和二叉树的抽象数据类型定义</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8%E5%92%8C%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">3、二叉树的性质和存储结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8\"><span class=\"toc-text\">①.二叉树的性质</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">②.二叉树的存储结构</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4%E3%80%81%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">4、遍历二叉树和线索二叉树</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">①.遍历二叉树</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">②.线索二叉树</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5%E3%80%81%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97\"><span class=\"toc-text\">5、树和森林</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">①.树的存储结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">②.森林与二叉树的转换</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A2-%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">③.树和森林的遍历</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#6%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">6、哈夫曼树及其应用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">①.哈夫曼树的基本概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">②.哈夫曼树的构造算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A2-%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81\"><span class=\"toc-text\">③.哈夫曼编码</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#7%E3%80%81%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">7、总结</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#8%E3%80%81%E4%BE%8B%E9%A2%98%E4%B8%8E%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">8、例题与应用</span></a></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"图","uid":"0b9c5318228023fdd1e179358a45ba07","slug":"数据结构（C语言版）-- 图笔记","date":"2022-02-20T12:59:01.000Z","updated":"2025-07-14T15:12:20.468Z","comments":true,"path":"api/articles/数据结构（C语言版）-- 图笔记.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/56d020cfc5f84516b5980d6710ece105.png","text":"图(Graph )G由两个集合V和E组成，记为G=(V,E)，其中V是顶点的有穷非空集合，E是V中顶点偶对的有穷集合，这些顶点偶对称为边。V(G)和E(G)通常分别表示图G的顶点集合和边集合，E(G)可以为空集。若E(G)为空，则图G只有顶点而没有边。...","permalink":"/post/数据结构（C语言版）-- 图笔记","photos":[],"count_time":{"symbolsCount":"62k","symbolsTime":"56 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"字节跳动青训营","slug":"字节跳动青训营","count":21,"path":"api/tags/字节跳动青训营.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true},"next_post":{"title":"串、数组和广义表","uid":"1d7c86a35a2f9ff3da1b325afe7a5b86","slug":"数据结构（C语言版）-- 串、数组和广义表笔记","date":"2022-02-16T04:53:52.000Z","updated":"2025-07-14T15:12:20.468Z","comments":true,"path":"api/articles/数据结构（C语言版）-- 串、数组和广义表笔记.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/e0c03943274e4aef94cf846304d75a73.png","text":"串(String)----零个或多个字符组成的有限序列，是一种特殊的线性表，其数据元素为一个字符，即内容受限的线性表。数组是由类型相同的数据元素构成的有序集合，每个元素称为数组元素。广义表：n ( ≥0)个表元素组成的有限序列。...","permalink":"/post/数据结构（C语言版）-- 串、数组和广义表笔记","photos":[],"count_time":{"symbolsCount":"9.7k","symbolsTime":"9 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"字节跳动青训营","slug":"字节跳动青训营","count":21,"path":"api/tags/字节跳动青训营.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true}}