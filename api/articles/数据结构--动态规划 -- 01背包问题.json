{"title":"动态规划--01背包问题","uid":"47cf0316f492004489404d39cb61c662","slug":"数据结构--动态规划 -- 01背包问题","date":"2022-10-07T01:48:46.000Z","updated":"2025-07-14T15:12:20.468Z","comments":true,"path":"api/articles/数据结构--动态规划 -- 01背包问题.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/direct/e8a0f072cdd64daf8e4ad0b5f663271b.png","content":"<p><strong>本文默认读者具有动态规划前置知识</strong></p>\n<hr>\n<ul>\n<li><strong>动态规划的特点：</strong></li>\n</ul>\n<ol>\n<li>重叠子问题</li>\n<li>状态转移方程</li>\n<li>最优子结构</li>\n</ol>\n<ul>\n<li>题型：<strong>求最值</strong></li>\n<li><strong>解题套路：</strong></li>\n</ul>\n<ol>\n<li>明确【状态】</li>\n<li>明确【选择】</li>\n<li>明确dp函数&#x2F;数据的定义</li>\n<li>明确base case</li>\n</ol>\n<hr>\n<ul>\n<li>例：给你一个可装载容量为W的背包和N个物品，每个物品有重量和价值两个属性。其中第i个物品的重量为wt[i]，价值为va[i]，现在让你用这个背包装物品，最多能装的价值是多少?</li>\n<li>在这里将问题具体化：现在有<strong>4</strong>  (N&#x3D;4)个物品，背包总容量为<strong>8</strong>  (W&#x3D;8),背包最多能装入价值为多少的物品?</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>物体编号</th>\n<th>物体体积</th>\n<th>物体价值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n</tr>\n<tr>\n<td>2</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3</td>\n<td>4</td>\n<td>5</td>\n</tr>\n<tr>\n<td>4</td>\n<td>5</td>\n<td>6</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p><strong>第一步，明确状态和选择</strong></p>\n</li>\n<li><p>状态：背包的空余容量剩多少；可选择的物品还有哪些</p>\n</li>\n<li><p>选择：把这个物品装进背包；把这个物品装进背包</p>\n</li>\n<li><p><strong>第二步，明确dp数组的定义：对于前1个物品，当背包的容量为w时，可以装的最大价值是 dp[i][w]</strong></p>\n</li>\n<li><p>比如说，dp[4][8]&#x3D;10的含义为:<br>对于给定的一系列物品中，若只对前4个物品进行选择，当背包容量为8时，最多可以装下的价值为10。</p>\n</li>\n<li><p>根据此定义，还可得出:base case为dp[0][..] &#x3D; dp[..][0] &#x3D;0（编号为0，不装物品；容量为0，装不下任何物体），我们想计算的结果是 dp[N][W]<br><img src=\"https://img-blog.csdnimg.cn/74b9024c428a439eb2d21fdb4281da03.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li><p>背包容量为1，物品编号可选为1，通过上表可知，物品编号为1时物品体积为2，所以此时选择不装任何物品。</p>\n</li>\n<li><p>背包容量为2，物品编号可选为1，装入则价值为3。依次往后填充该行。<img src=\"https://img-blog.csdnimg.cn/df7daea62543458683aee24ea803d3d9.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li><p>背包容量为3，物品编号可选为1、2时，装入编号为2的物品，此时价值为4。</p>\n</li>\n<li><p>背包容量为5，物品编号可选为1、2时，装入编号为1和2的物品，此时价值为7。</p>\n</li>\n<li><p>依次往后填充完该表格<br><img src=\"https://img-blog.csdnimg.cn/026e4d6ff5574cc9b45ff493d0054abd.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li><p><strong>第三步，根据[选择]写出状态转移逻辑</strong>：在w的约束下，把物品i装进背包,最大价值是多少；在w的约束下，不把物品i装进背包，最大价值是多少?</p>\n</li>\n</ul>\n<pre><code class=\"js\">for(let i=1;i&lt;=n;i++) &#123;\n    for(let v=w[i]; v&lt;=c;v++) &#123;\n      dp[i][v] = Math.max(dp[i-1][v], dp[i-1][v-w[i]]+value[i])\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<ul>\n<li>背包问题完整求解代码：</li>\n</ul>\n<pre><code class=\"js\">// 入参是物品的个数和背包的容量上限，以及物品的重量和价值数组\nfunction knapsack(n, c, w, value) &#123;\n    // dp是动态规划的状态保存数组\n    const dp = (new Array(c+1)).fill(0)  \n    // res 用来记录所有组合方案中的最大值\n    let res = -Infinity\n    for(let i=1;i&lt;=n;i++) &#123;\n        for(let v=c;v&gt;=w[i];v--) &#123;\n            // 写出状态转移方程\n            dp[v] = Math.max(dp[v], dp[v-w[i]] + value[i])\n            // 即时更新最大值\n            if(dp[v] &gt; res) &#123;\n                res = dp[v]\n            &#125;\n        &#125;\n    &#125;\n    return res\n&#125;\n</code></pre>\n<hr>\n<ul>\n<li><strong>扩展 – 最长上升子序列模型</strong></li>\n</ul>\n<pre><code class=\"Markdown\">题目描述：给定一个无序的整数数组，找到其中最长上升子序列的长度。\n示例:\n输入: [10,9,2,5,3,7,101,18]\n输出: 4\n解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。\n</code></pre>\n<ul>\n<li>代码实现</li>\n</ul>\n<pre><code class=\"js\">/**\n * @param &#123;number[]&#125; nums\n * @return &#123;number&#125;\n */\n// 入参是一个数字序列\nconst lengthOfLIS = function(nums) &#123;\n  // 缓存序列的长度\n  const len = nums.length  \n  // 处理边界条件\n  if(!len) &#123;\n      return 0\n  &#125;\n  // 初始化数组里面每一个索引位的状态值\n  const dp = (new Array(len)).fill(1)\n  // 初始化最大上升子序列的长度为1\n  let maxLen = 1 \n  // 从第2个元素开始，遍历整个数组\n  for(let i=1;i&lt;len;i++) &#123;\n      // 每遍历一个新元素，都要“回头看”，看看能不能延长原有的上升子序列\n      for(let j=0;j&lt;i;j++) &#123;  \n          // 若遇到了一个比当前元素小的值，则意味着遇到了一个可以延长的上升子序列，故更新当前元素索引位对应的状态\n          if(nums[j]&lt;nums[i]) &#123;\n              dp[i] = Math.max(dp[i], dp[j] + 1)  \n          &#125;\n      &#125;\n      // 及时更新上升子序列长度的最大值\n      if(dp[i] &gt; maxLen) &#123;\n          maxLen = dp[i]\n      &#125;\n  &#125;\n  // 遍历完毕，最后到手的就是最大上升子序列的长度\n  return maxLen\n&#125;;\n</code></pre>\n","feature":true,"text":"本文对动态规划的01背包问题进行了解释和阐述。...","permalink":"/post/数据结构--动态规划 -- 01背包问题","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":1,"path":"api/categories/数据结构.json"}],"tags":[{"name":"算法","slug":"算法","count":1,"path":"api/tags/算法.json"}],"toc":"","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"前端必备之HTML基础知识点","uid":"3f8304cf028368451948efda785c3b86","slug":"前端--HTML这一篇就够啦","date":"2022-12-03T02:41:04.000Z","updated":"2025-07-14T15:12:20.463Z","comments":true,"path":"api/articles/前端--HTML这一篇就够啦.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/de6c1a55cf774f9fa1e2cff7c25e5fc9.png","text":"HTML（超文本标记语言）是构建网页结构的基础，通过标签描述页面内容。作为前端开发的基础，掌握HTML能够搭建页面框架、嵌入多媒体内容和实现超链接等功能。在前端开发中，HTML扮演着至关重要的角色，是构建网页的基础和起点。...","permalink":"/post/前端--HTML这一篇就够啦","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"HTML","slug":"HTML","count":1,"path":"api/tags/HTML.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true},"next_post":{"title":"正则表达式(基础语法+应用案例)","uid":"cac67ac11c6c333971e5ff6f7b0aa46a","slug":"前端--正则表达式(基础语法+应用案例)","date":"2022-08-26T00:39:52.000Z","updated":"2025-07-14T15:12:20.466Z","comments":true,"path":"api/articles/前端--正则表达式(基础语法+应用案例).json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/810429d76f664c5ea6d91f9d9b85786f.jpeg","text":"本文对正则表达式进行了讲解，设计正则表达式的简介，语法，API，应用等。重点阐述了JavaScript中的正则表达式对象及其方法，在文章最后列举了常见的正则表达式语句，希望能给大家带来帮助！...","permalink":"/post/前端--正则表达式(基础语法+应用案例)","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"正则表达式","slug":"正则表达式","count":1,"path":"api/tags/正则表达式.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true}}