{"title":"串、数组和广义表","uid":"1d7c86a35a2f9ff3da1b325afe7a5b86","slug":"数据结构（C语言版）-- 串、数组和广义表笔记","date":"2022-02-16T04:53:52.000Z","updated":"2025-07-14T15:12:20.468Z","comments":true,"path":"api/articles/数据结构（C语言版）-- 串、数组和广义表笔记.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/e0c03943274e4aef94cf846304d75a73.png","content":"<hr>\n<h1 id=\"1、串\"><a href=\"#1、串\" class=\"headerlink\" title=\"1、串\"></a>1、串</h1><h2 id=\"①-串的定义\"><a href=\"#①-串的定义\" class=\"headerlink\" title=\"①.串的定义\"></a>①.串的定义</h2><p>&#x3D;&#x3D;串(String)—-零个或多个字符组成的有限序列，是一种特殊的线性表，其数据元素为一个字符，即内容受限的线性表。&#x3D;&#x3D;</p>\n<p><img src=\"https://img-blog.csdnimg.cn/8690f5e9360b4bb2bb41071fb70c6362.png#pic_center\"></p>\n<p><strong>子串：</strong></p>\n<p>串中任意个连续的字符组成的子序列</p>\n<p><strong>主串：</strong></p>\n<p> 包含子串的串</p>\n<p><strong>字符位置：</strong></p>\n<p> 字符在序列中的序号</p>\n<p><strong>子串位置：</strong></p>\n<p> 以子串的第一个字符在主串中的位置来表示</p>\n<p><strong>空格串：</strong></p>\n<p> 一个或多个空格组成的串 </p>\n<p><img src=\"https://img-blog.csdnimg.cn/d1a865fdc425412bbe6fe956cfa28699.png#pic_center\"></p>\n<p>&#x3D;&#x3D;两个串是相等的，当且仅当这两个串的值相等。也就是说，只有当两个串的<strong>长度相等</strong>，并且各个对应位置的<strong>字符都相等</strong>时才相等&#x3D;&#x3D;。例如，上例中的串a、b、c和d彼此都不相等。</p>\n<p><strong>串的抽象数据类型的定义：</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/bb92b605996b42f6b1d8d4d8c9365154.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/897d1c9fefa8497782687daccd797332.png#pic_center\"></p>\n<p>与线性表类似，串也有两种基本存储结构：顺序存储和链式存储。但考虑到存储效率和算法的方便性,串多采用顺序存储结构。</p>\n<h2 id=\"②-串的顺序存储\"><a href=\"#②-串的顺序存储\" class=\"headerlink\" title=\"②.串的顺序存储\"></a>②.串的顺序存储</h2><p>类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区，则可用定长数组如下描述:</p>\n<pre><code class=\"c\">typedef struct\n&#123;\n    char ch[MAXLEN + 1]; // MAXLEN为串的最大长度\n                         //存储串的一维数组\n    int length; //串长度\n&#125; SString;\n</code></pre>\n<p>而多数情况下，串的操作是以串的整体形式参与的，串变量之间的长度相差较大，在操作中串值长度的变化也较大，这样为串变量设定固定大小的空间不尽合理。因此最好是根据实际需要，在程序执行过程中动态地分配和释放字符数组空间。在C语言中，存在一个称之为“堆”(Heap）的自由存储区，可以为每个新产生的串动态分配一块实际串长所需的存储空间，若分配成功，则返回一个指向起始地址的指针，作为串的基址，同时为了以后处理方便，约定串长也作为存储结构的一部分。</p>\n<pre><code class=\"c\">typedef struct\n&#123;\n    char *ch;   //若串非空，则按串长分配存储区,否则ch为NULL\n    int length; //串长度\n&#125; HString;\n</code></pre>\n<h2 id=\"③-串的链式存储\"><a href=\"#③-串的链式存储\" class=\"headerlink\" title=\"③.串的链式存储\"></a>③.串的链式存储</h2><p>顺序串的插人和删除操作不方便，需要移动大量的字符。因此，可采用单链表方式存储串。</p>\n<pre><code class=\"c\">#define CHUNKSIZE 80 //可由用户定义的块大小\ntypedef struct Chunk\n&#123;\n    char ch[CHUNKSIZE]; //存储串的一维\n    struct Chunk *next;\n&#125; Chunk;\n\ntypedef struct\n&#123;\n    Chunk *head, *tail; //串的头指针和尾指针\n    int curlen;         //串的当前长度\n&#125; LString;\n</code></pre>\n<p>串值的链式存储结构对某些串操作，如联接操作等，有一定方便之处，但总地说来，不如顺序存储结构灵活，它占用存储量大且操作复杂。</p>\n<h2 id=\"④-串的模式匹配算法\"><a href=\"#④-串的模式匹配算法\" class=\"headerlink\" title=\"④.串的模式匹配算法\"></a>④.串的模式匹配算法</h2><p>&#x3D;&#x3D;子串的定位运算通常称为串的模式匹配或串匹配，主串称为正文串，子串称为模式串，该算法目的是确定主串中缩含子串第一次出现的位置（定位）&#x3D;&#x3D;。此运算的应用非常广泛,比如在搜索引擎、拼写检查、语言翻译、数据压缩等应用中，都需要进行串匹配。</p>\n<p><strong>BF（Brute-Force）算法</strong></p>\n<p>模式匹配不一定是从主串的第一个位置开始，可以指定主串中查找的起始位置pos。如果采用字符串顺序存储结构，可以写出不依赖于其他串操作的匹配算法。</p>\n<ol>\n<li><p>分别利用计数指针i和j指示主串S和模式T中当前正待比较的字符位置，i初值为pos,j初值为1。</p>\n</li>\n<li><p>如果两个串均未比较到串尾，即i和j均分别小于等于S和T的长度时，则循环执行以下操作:</p>\n<pre><code>- S[i].ch和T[j].ch 比较，若相等，则i和j分别指示串中下个位置，继续比较后续字符;\n\n- 若不等，指针后退重新开始匹配，从主串的下一个字符( i=i-j+2）起再重新和模式的第一个字符(j=1 )比较。\n</code></pre>\n</li>\n<li><p>③如果j&gt;T.length，说明模式T中的每个字符依次和主串S中的一个连续的字符序列相等，则匹配成功，返回和模式T中第一个字符相等的字符在主串S中的序号( i-T.length );否则称匹配不成功，返回0。</p>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/cbd94fd10ccc4fb29a34800cd13ed89d.png#pic_center\"></p>\n<pre><code class=\"c\">int Index(SString S, SString T, int pos)\n&#123;\n    i = pos;\n    j = 1;                              //初始化\n    while (i &lt;= S[0] &amp;&amp; j &lt;= T[0])\t\t//两个串均未比较到串尾\n    &#123;\n        if (S[i] = T[j])\n        &#123;\n            ++i;\n            ++j;\n        &#125; //继续比较后继字符\n        else\n        &#123;\n            i = i - j + 2;\n            j = 1;\n        &#125; //指针后退重新开始匹配\n    &#125;\n    if (j &gt; T[0])\n        return i-T[0]; //匹配成功\n    else\n        return 0; //匹配失败\n&#125;\n</code></pre>\n<p><strong>BF算法实例：</strong></p>\n<pre><code class=\"c\">/***字符串匹配算法***/\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\n#define OK 1\n#define ERROR 0\n#define OVERFLOW -2\ntypedef int Status;\n#define MAXSTRLEN 255                //用户可在255以内定义最长串长\ntypedef char SString[MAXSTRLEN + 1]; // 0号单元存放串的长度\n\nStatus StrAssign(SString T, char *chars)\n&#123; //生成一个其值等于chars的串T\n    int i;\n    if (strlen(chars) &gt; MAXSTRLEN)\n        return ERROR;\n    else\n    &#123;\n        T[0] = strlen(chars);\n        for (i = 1; i &lt;= T[0]; i++)\n            T[i] = *(chars + i - 1);\n        return OK;\n    &#125;\n&#125;\n\n// BF算法\nint Index(SString S, SString T, int pos)\n&#123;\n    //返回模式T在主串S中第pos个字符之后第s一次出现的位置。若不存在，则返回值为0\n    //其中，T非空，1≤pos≤StrLength(S)\n    int i = pos;\n    int j = 1;\n    while (i &lt;= S[0] &amp;&amp; j &lt;= T[0])\n    &#123;\n        if (S[i] == T[j])\n        &#123;\n            ++i;\n            ++j;\n        &#125; //继续比较后继字符\n        else\n        &#123;\n            i = i - j + 2;\n            j = 1;\n        &#125; //指针后退重新开始匹配\n    &#125;\n    if (j &gt; T[0])\n        return i - T[0];\n    else\n        return 0;\n    return 0;\n&#125; // Index\n\nint main()\n&#123;\n    SString S;\n    StrAssign(S, &quot;bbaaabbaba&quot;);\n    SString T;\n    StrAssign(T, &quot;abb&quot;);\n    cout &lt;&lt; &quot;主串和子串在第&quot; &lt;&lt; Index(S, T, 1) &lt;&lt; &quot;个字符处首次匹配\\n&quot;;\n    return 0;\n&#125;\n</code></pre>\n<p>&#x3D;&#x3D;该算法时间复杂度为：<strong>O（n*m）</strong>&#x3D;&#x3D;</p>\n<p><strong>KMP算法</strong></p>\n<p>这种改进算法是由Knuth、Morris和 Pratt同时设计实现的，因此简称KMP算法。此算法可以在O(n + m)的时间数量级上完成串的模式匹配操作。其改进在于:每当一趟匹配过程中出现字符比较不等时，不需回溯i指针，而是利用已经得到的“部分匹配”的结果将模式向右“滑动”尽可能远的一段距离后，继续进行比较。</p>\n<ol>\n<li><p>分别利用计数指针i和j指示主串S和模式T中当前正待比较的字符位置，i初值为pos,j初值为1。</p>\n</li>\n<li><p>如果两个串均未比较到串尾，即i和j均分别小于等于S和T的长度时，则循环执行以下操作:</p>\n<pre><code>- S[i].ch 和T[i].ch 比较，若相等，则i和j分别指示串中下个位置，继续比较后续字符;\n- 若不等，指针后退重新开始匹配，从主串的下一个字符(i=i-j+2）起再重新和模式的第一个字符(j=1)比较。\n</code></pre>\n</li>\n<li><p>如果j&gt;T.length，说明模式T中的每个字符依次和主串S中的一个连续的字符序列相等，则匹配成功，返回和模式T中第一个字符相等的字符在主串S中的序号(i-T.length);否则称匹配不成功，返回0。</p>\n</li>\n</ol>\n<p>该算法思想感兴趣可观看天勤公开课讲解视频，个人认为讲解比较透彻：</p>\n<p><a href=\"https://www.bilibili.com/video/BV1jb411V78H\">「天勤公开课」KMP算法易懂版</a></p>\n<p>以下对其进行简单阐述：</p>\n<p>&#x3D;&#x3D;kmp算法作用是快速的从一个主串中找到想要的子串，kmp算法可以做到仅仅后移模式串，比较指针不回溯。&#x3D;&#x3D;</p>\n<p><img src=\"https://img-blog.csdnimg.cn/1479fac823a8463d872052b5ceb9f7ab.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/038630e8a3d649a5a2e1f3182384b7cb.png#pic_center\"></p>\n<p>&#x3D;&#x3D;找出模式串不匹配处最长但不长于不匹配处左端的公共前后缀，直接移动模式串，使得前缀直接来到后缀的位置。&#x3D;&#x3D;</p>\n<p><img src=\"https://img-blog.csdnimg.cn/f65b6c7cdb6a485dba8344a32f3b9036.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/0f7807f5f3e3425787642d9becbc7feb.png#pic_center\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/a9891b9b9b0f4a6b8adbda0ce28231d5.png#pic_center\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/a14acb3106c1438abdaf1c02c4556f20.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/5f0f384e76b6447d902eb31ef4a1807d.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/a91c9c9414ab4eb192e87b33136dd81d.png#pic_center\"></p>\n<pre><code class=\"c\">int Index_KMP(SString S, SString T, int pos)\n&#123;\n    i = pos;\n    j = 1;                                 //初始化\n    while (i &lt;= S.length &amp;&amp; j &lt;= S.length) //两个串均未比较到串尾\n    &#123;\n        if (j == 0 || S[i] == T[j])\n        &#123;\n            ++i;\n            ++j;\n        &#125; //继续比较后继字符\n        else\n        &#123;\n            j = next[j];\n        &#125; //模式串向右移动\n    &#125;\n    if (j &gt; T[0])\n        return i - T[0]; //匹配成功\n    else\n        return 0; //匹配失败\n&#125;\n</code></pre>\n<pre><code class=\"c\">void get_next(SString T, int next[])\n&#123; //求模式串T的next函数值并存入数组next\n    i = 1;\n    next[1] = 0;\n    j = 0;\n    while (i &lt; T[0])\n    &#123;\n        if (j == 0 || T[i])\n        &#123;\n            ++i;\n            ++j;\n            next[i] = j;\n        &#125;\n        else\n        &#123;\n            j = next[j];\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>KMP算法实例：</strong></p>\n<pre><code class=\"c\">/***字符串匹配算法***/\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\n#define OK 1\n#define ERROR 0\n#define OVERFLOW -2\ntypedef int Status;\n#define MAXSTRLEN 255                //用户可在255以内定义最长串长\ntypedef char SString[MAXSTRLEN + 1]; // 0号单元存放串的长度\n\nStatus StrAssign(SString T, char *chars)\n&#123; //生成一个其值等于chars的串T\n    int i;\n    if (strlen(chars) &gt; MAXSTRLEN)\n        return ERROR;\n    else\n    &#123;\n        T[0] = strlen(chars);\n        for (i = 1; i &lt;= T[0]; i++)\n            T[i] = *(chars + i - 1);\n        return OK;\n    &#125;\n&#125;\n//算法4.3　计算next函数值\nvoid get_next(SString T, int next[])\n&#123; //求模式串T的next函数值并存入数组next\n    int i = 1, j = 0;\n    next[1] = 0;\n    while (i &lt; T[0])\n        if (j == 0 || T[i] == T[j])\n        &#123;\n            ++i;\n            ++j;\n            next[i] = j;\n        &#125;\n        else\n            j = next[j];\n&#125; // get_next\n\n// KMP算法\nint Index_KMP(SString S, SString T, int pos, int next[])\n&#123; // 利用模式串T的next函数求T在主串S中第pos个字符之后的位置的KMP算法\n    //其中，T非空，1≤pos≤StrLength(S)\n    int i = pos, j = 1;\n    while (i &lt;= S[0] &amp;&amp; j &lt;= T[0])\n        if (j == 0 || S[i] == T[j]) // 继续比较后继字\n        &#123;\n            ++i;\n            ++j;\n        &#125;\n        else\n            j = next[j]; // 模式串向右移动\n    if (j &gt; T[0])        // 匹配成功\n        return i - T[0];\n    else\n        return 0;\n&#125; // Index_KMP\n\nint main()\n&#123;\n    SString S;\n    StrAssign(S, &quot;aaabbaba&quot;);\n    SString T;\n    StrAssign(T, &quot;abb&quot;);\n    int *p = new int[T[0] + 1]; // 生成T的next数组\n    get_next(T, p);\n    cout &lt;&lt; &quot;主串和子串在第&quot; &lt;&lt; Index_KMP(S, T, 1, p) &lt;&lt; &quot;个字符处首次匹配\\n&quot;;\n    return 0;\n&#125;\n</code></pre>\n<p>&#x3D;&#x3D;时间复杂度：O（n+m）&#x3D;&#x3D;</p>\n<hr>\n<h1 id=\"2、数组\"><a href=\"#2、数组\" class=\"headerlink\" title=\"2、数组\"></a>2、数组</h1><h2 id=\"①-数组的定义\"><a href=\"#①-数组的定义\" class=\"headerlink\" title=\"①.数组的定义\"></a>①.数组的定义</h2><p>数组是由类型相同的数据元素构成的有序集合，每个元素称为数组元素，每个元素受n(n≥1 )个线性关系的约束，每个元素在n个线性关系中的序号i<del>1</del>，i<del>2</del>，…，i<del>n</del>称为该元素的下标，可以通过下标访问该数据元素。因为数组中每个元素处于n (n≥1)个关系中，故称该数组为n维数组。数组可以看成是线性表的推广，其特点是结构中的元素本身可以是具有某种结构的数据，但属于同一数据类型。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/32ab897605c54a318ef827c7b7e0a1a3.png#pic_center\"></p>\n<h2 id=\"②-数组的顺序存储\"><a href=\"#②-数组的顺序存储\" class=\"headerlink\" title=\"②.数组的顺序存储\"></a>②.数组的顺序存储</h2><p>由于数组一般不做插人或删除操作，也就是说;一旦建立了数组，则结构中的数据元素个数和元素之间的关系就不再发生变动。因此，采用顺序存储结构表示数组比较合适。<br>二维数组可有两种存储方式：<strong>一种是以列序为主序的存储方式；一种是以行序为主序的存储方式。</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/89a1e286031746ab914e084a3c5179c0.png#pic_center\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/188225e7fe244f5fbd0c6e8fb6ddea8b.png#pic_center\" alt=\"插\"></p>\n<p><strong>三维数组的顺序存储：</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/f207775aaa544457916251d2b573ab87.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/008bc3c7febf4434a3ab60cca3b1be3f.png#pic_center\"></p>\n<h2 id=\"③-特殊矩阵的压缩存储\"><a href=\"#③-特殊矩阵的压缩存储\" class=\"headerlink\" title=\"③.特殊矩阵的压缩存储\"></a>③.特殊矩阵的压缩存储</h2><p><strong>特殊矩阵:</strong> 值相同的元素或0元素在矩阵中的分布有一定的规律。如:对称矩阵、三角矩阵、对角矩阵等。</p>\n<p><strong>压缩存储:</strong> 压缩存储是指为多个值相同的元只分配一个存储空间,且对零元不分配存储空间。目的是节省大量存储空间。</p>\n<p><strong>什么样的矩阵能够压缩?</strong><br>特殊矩阵、稀疏矩阵等。</p>\n<p><strong>对称矩阵</strong></p>\n<p>若n阶矩阵A中的元满足a<del>ij</del> &#x3D; a<del>ji</del>  1≤i，j≤ n 则称为n阶对称矩阵。对于对称矩阵,可以为每一对对称元分配一个存储空间,则可将n^2^个元压缩存储到n(n+1)&#x2F;2个元的空间中，不失一般性，可以行序为主序存储其下三角（包括对角线）中的元。<br>假设以一维数组sa[r(n+1)&#x2F;2]作为n阶对称矩阵A的存储结构,则 sa[k]和矩阵元aj之间存在着一一对应的关系:</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2711afc684cd4dcf91ad9157df19a28c.png#pic_center\"></p>\n<p><strong>三角矩阵</strong></p>\n<p>以主对角线划分,三角矩阵有上三角矩阵和下三角矩阵两种。上三角矩阵是指矩阵下三角(不包括对角线）中的元均为常数c或零的n阶矩阵，下三角矩阵与之相反。对三角矩阵进行压缩存储时，除了和对称矩阵一样，只存储其上(下)三角中的元素之外，再加一个存储常数c的存储空间即可。</p>\n<p>上三角矩阵<br>sa[k]和矩阵元a<del>ij</del>之间的对应关系为：<br><img src=\"https://img-blog.csdnimg.cn/022e76c4d85c41fdbb79e3381ef6e4fd.png#pic_center\"></p>\n<p>下三角矩阵<br>sa[k]和矩阵元a<del>ij</del>之间的对应关系为:<br><img src=\"https://img-blog.csdnimg.cn/1dc77f9ba9614048bae2f9f260c34bc8.png#pic_center\"></p>\n<p><strong>对角矩阵</strong></p>\n<p>对角矩阵所有的非零元都集中在以主对角线为中心的带状区域中，即除了主对角线上和直接在对角线上、下方若干条对角线上的元之外，所有其他的元皆为零。<br><img src=\"https://img-blog.csdnimg.cn/9e0fad26cd0c4c9c9c61242dabcf085c.png#pic_center\"></p>\n<hr>\n<h1 id=\"3、广义表\"><a href=\"#3、广义表\" class=\"headerlink\" title=\"3、广义表\"></a>3、广义表</h1><h2 id=\"①-广义表的定义\"><a href=\"#①-广义表的定义\" class=\"headerlink\" title=\"①.广义表的定义\"></a>①.广义表的定义</h2><p>&#x3D;&#x3D;广义表：n ( ≥0)个表元素组成的有限序列,记作LS&#x3D;（a<del>1</del>，a<del>2</del>，…，a<del>n</del>）。LS是表名，a<del>i</del>是表元素，它可以是表(称为子表)，可以是数据元素(称为原子)。n为表的长度，n&#x3D;0的广义表称为空表。&#x3D;&#x3D;</p>\n<p>&#x3D;&#x3D;<strong>求表头GetHead(L)</strong>:<strong>非空广义表的第一个元素，可以是一个原子,也可以是一个子表。</strong>&#x3D;&#x3D;<br>&#x3D;&#x3D;<strong>求表尾GetTail(L)</strong>:<strong>非空广义表除去表头元素以外其它所有元素所构成的表。表尾一定是一个表。</strong>&#x3D;&#x3D;</p>\n<p><img src=\"https://img-blog.csdnimg.cn/0d7e1a74bd9c41628b1a9949f4e39b5c.png#pic_center\"></p>\n<h2 id=\"②-广义表的存储结构\"><a href=\"#②-广义表的存储结构\" class=\"headerlink\" title=\"②.广义表的存储结构\"></a>②.广义表的存储结构</h2><p>由于广义表中的数据元素可以有不同的结构(或是原子，或是列表)，因此难以用顺序存储结构表示，通常采用链式存储结构。</p>\n<p><strong>头尾链表的存储结构</strong></p>\n<p>由于广义表中的数据元素可能为原子或广义表，由此需要两种结构的结点:一种是表结点，用以表示广义表;一种是原子结点，用以表示原子。从上节得知:若广义表不空，则可分解成表头和表尾，因此，一对确定的表头和表尾可唯一确定广义表。一个表结点可由3个域组成:标志域、指示表头的指针域和指示表尾的指针域。而原子结点只需两个域:标志域和值域。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/def7b6fd948c47648baa356c6a066429.png#pic_center\"></p>\n<pre><code class=\"c\">typedef enum\n&#123;\n    ATOM,\n    LIST\n&#125; ElemTag;\n// ATOM==0:原子,LIST==1:子表\ntypedef struct GLNode\n&#123;\n    ElemTag tag; //公共部分,用于区分原子结点和表结点\n    union        //原子结点和表结点的联合部分\n    &#123;\n        AtomType atom; // atom是原子结点的值域,AtomType由用户定义\n        struct\n        &#123;\n            struct GLNode *hp, *tp;\n        &#125; ptr;\n        // ptr是表结点的指针域,prt.hp和ptr.tp分别指向表头和表尾\n    &#125;;\n&#125; * GList, GLNode; /* 广义表类型 */\n</code></pre>\n<p><strong>扩展线性链表的存储结构</strong></p>\n<p>在这种结构中，无论是原子结点还是表结点均由三个域组成</p>\n<p><img src=\"https://img-blog.csdnimg.cn/b87e7e24a25d410da6cf2d9273ed174d.png#pic_center\"></p>\n<pre><code class=\"c\">typedef struct glnode\n&#123;\n    int tag; // 0 原子结点；1 子表结点\n    union\n    &#123;\n        atomtype atom;     //原子结点的值域\n        struct glnode *hp; //子表表头指针\n    &#125; struct glnode *tp;   //下一元素指针\n&#125; * glist;\n</code></pre>\n<hr>\n<h1 id=\"4、总结\"><a href=\"#4、总结\" class=\"headerlink\" title=\"4、总结\"></a>4、总结</h1><ol>\n<li><p>串是内容受限的线性表，它限定了表中的元素为字符。串有两种基本存储结构:顺序存储和链式存储，但多采用顺序存储结构。串的常用算法是模式匹配算法，主要有BF算法和KMP算法。BF算法实现简单，但存在回溯，效率低，时间复杂度为O(m ×n)。KMP算法对BF算法进行改进，消除回溯，提高了效率，时间复杂度为O(m+n)。</p>\n</li>\n<li><p>多维数组可以看成是线性表的推广,其特点是结构中的元素本身可以是具有某种结构的数据，但属于同一数据类型。一个n维数组实质上是n个线性表的组合，其每一维都是一个线性表。数组一般采用顺序存储结构，故存储多维数组时，应先将其确定转换为一维结构，有按“行”转换和按“列”转换两种。科学与工程计算中的矩阵通常用二维数组来表示，为了节省存储空间，对于几种常见形式的特殊矩阵，比如对称矩阵、三角矩阵和对角矩阵，在存储时可进行压缩存储，即为多个值相同的元只分配一个存储空间，对零元不分配空间。</p>\n</li>\n<li><p>广义表是另外一种线性表的推广形式，表中的元素可以是称为原子的单个元素，也可以是一个子表，所以线性表可以看成广义表的特例。广义表的结构相当灵活，在某种前提下，它可以兼容线性表、数组、树和有向图等各种常用的数据结构。广义表的常用操作有取表头和取表尾。广义表通常采用链式存储结构:头尾链表的存储结构和扩展线性链表的存储结构。</p>\n</li>\n</ol>\n<hr>\n<h1 id=\"5、例题与应用\"><a href=\"#5、例题与应用\" class=\"headerlink\" title=\"5、例题与应用\"></a>5、例题与应用</h1><p><img src=\"https://img-blog.csdnimg.cn/6c4b451e3750463ab27ca27b6bff819b.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/2b35c0d34f7843cfb0c6b52c77aad04d.png#pic_center\"></p>\n","feature":true,"text":"串(String)----零个或多个字符组成的有限序列，是一种特殊的线性表，其数据元素为一个字符，即内容受限的线性表。数组是由类型相同的数据元素构成的有序集合，每个元素称为数组元素。广义表：n ( ≥0)个表元素组成的有限序列。...","permalink":"/post/数据结构（C语言版）-- 串、数组和广义表笔记","photos":[],"count_time":{"symbolsCount":"9.7k","symbolsTime":"9 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"字节跳动青训营","slug":"字节跳动青训营","count":21,"path":"api/tags/字节跳动青训营.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1%E3%80%81%E4%B8%B2\"><span class=\"toc-text\">1、串</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">①.串的定义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E4%B8%B2%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">②.串的顺序存储</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A2-%E4%B8%B2%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">③.串的链式存储</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A3-%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">④.串的模式匹配算法</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2%E3%80%81%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">2、数组</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">①.数组的定义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E6%95%B0%E7%BB%84%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">②.数组的顺序存储</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A2-%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">③.特殊矩阵的压缩存储</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%B9%BF%E4%B9%89%E8%A1%A8\"><span class=\"toc-text\">3、广义表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E5%B9%BF%E4%B9%89%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">①.广义表的定义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E5%B9%BF%E4%B9%89%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">②.广义表的存储结构</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4%E3%80%81%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">4、总结</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5%E3%80%81%E4%BE%8B%E9%A2%98%E4%B8%8E%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">5、例题与应用</span></a></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"树和二叉树","uid":"50552977e0ec8094596ba83ac872ee52","slug":"数据结构（C语言版）-- 树和二叉树笔记","date":"2022-02-16T04:56:11.000Z","updated":"2025-07-14T15:12:20.469Z","comments":true,"path":"api/articles/数据结构（C语言版）-- 树和二叉树笔记.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/050b725832464411bd17f7b08e4c7ff4.png","text":"树( Tree)是n(n≥0)个结点的有限集，它或为空树(n=0)；或为非空树，对于非空树T：1. 有且仅有一个称之为根的结点;2. 除根结点以外的其余结点可分为m (m>0)个互不相交的有限集T1，T2,…，Tm，其中每一个集合本身又是一棵树，并且称为根的子树( SubTree)。...","permalink":"/post/数据结构（C语言版）-- 树和二叉树笔记","photos":[],"count_time":{"symbolsCount":"27k","symbolsTime":"25 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"字节跳动青训营","slug":"字节跳动青训营","count":21,"path":"api/tags/字节跳动青训营.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true},"next_post":{"title":"栈和队列","uid":"32e8754bc216ad5a6afe6dae9987332f","slug":"数据结构（C语言版）-- 栈和队列笔记","date":"2022-02-13T02:39:25.000Z","updated":"2025-07-14T15:12:20.469Z","comments":true,"path":"api/articles/数据结构（C语言版）-- 栈和队列笔记.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/68983f406bb44b89b7de3accaf6351a4.png","text":"栈( stack）是限定仅在表尾进行插人或删除操作的线性表。因此，对栈来说，表尾端有其特殊含义，称为栈顶( top )，相应地，表头端称为栈底（ bottom )。不含元素的空表称为空栈。...","permalink":"/post/数据结构（C语言版）-- 栈和队列笔记","photos":[],"count_time":{"symbolsCount":"28k","symbolsTime":"25 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"字节跳动青训营","slug":"字节跳动青训营","count":21,"path":"api/tags/字节跳动青训营.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true}}