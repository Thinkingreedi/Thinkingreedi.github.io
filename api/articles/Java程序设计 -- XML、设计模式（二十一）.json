{"title":"Java程序设计--XML、设计模式","uid":"95d5eb05aae54932675ce4d24d2c2637","slug":"Java程序设计 -- XML、设计模式（二十一）","date":"2022-04-19T12:38:36.000Z","updated":"2025-07-14T15:12:20.459Z","comments":true,"path":"api/articles/Java程序设计 -- XML、设计模式（二十一）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","content":"<hr>\n<h1 id=\"1、XML\"><a href=\"#1、XML\" class=\"headerlink\" title=\"1、XML\"></a>1、XML</h1><h2 id=\"1-1-XML概述\"><a href=\"#1-1-XML概述\" class=\"headerlink\" title=\"1.1 XML概述\"></a>1.1 XML概述</h2><p>&#x3D;&#x3D;XML是可扩展标记语言（eXtensible Markup Language)的缩写，它是是一种数据表示格式，可以描述非常复杂的数据结构，常用于传输和存储数据。&#x3D;&#x3D;</p>\n<p><strong>XML的几个特点和使用场景</strong></p>\n<ul>\n<li>一是纯文本，默认使用UTF-8编码;二是可嵌套</li>\n<li>如果把XML内容存为文件，那么它就是一个XML文件</li>\n<li>XML的使用场景:XML内容经常被当成消息进行网络传输，或者作为配置文件用于存储系统的信息</li>\n</ul>\n<h2 id=\"1-2-XML的创建、语法规则\"><a href=\"#1-2-XML的创建、语法规则\" class=\"headerlink\" title=\"1.2 XML的创建、语法规则\"></a>1.2 XML的创建、语法规则</h2><p>XML的创建就是创建一个XML类型的文件，要求文件的后缀必须使用xml，如hello_world.xml</p>\n<p><img src=\"https://img-blog.csdnimg.cn/c68c10125f0146c99c192acc474edcfe.png#pic_center\"><br><strong>XML语法规则</strong></p>\n<ul>\n<li>XML文件的后缀名为: xml</li>\n<li>文档声明必须是第一行<br><img src=\"https://img-blog.csdnimg.cn/5d8e16323cc94cc6838845316bf1c735.png#pic_center\"><br><strong>XML的标签(元素)规则</strong></li>\n<li>标签由一对尖括号和合法标识符组成:&lt; name &gt;&lt; &#x2F;name &gt;，必须存在一个根标签，有且只能有一个。</li>\n<li>标签必须成对出现，有开始，有结束: &lt; name &gt;&lt; &#x2F;name &gt;</li>\n<li>特殊的标签可以不成对，但是必须有结束标记，如:&lt; br&#x2F;&gt;</li>\n<li>标签中可以定义属性，属性和标签名空格隔开,属性值必须用引号引起来&lt; student id &#x3D; “1” &gt;&lt; &#x2F;name &gt;</li>\n<li>标签需要正确的嵌套</li>\n</ul>\n<p><strong>XML的其他组成</strong></p>\n<ul>\n<li>XML文件中可以定义注释信息:&lt;！- -注释内容 - -&gt;</li>\n<li>XML文件中可以存在以下特殊字符</li>\n<li>XML文件中可以存在CDATA区:&lt;! [CDATA[ ..内容…]] &gt;</li>\n</ul>\n<h2 id=\"1-3-XML文档约束\"><a href=\"#1-3-XML文档约束\" class=\"headerlink\" title=\"1.3 XML文档约束\"></a>1.3 XML文档约束</h2><p><strong>文档约束:是用来限定xml文件中的标签以及属性应该怎么写。</strong></p>\n<p><strong>DTD约束</strong></p>\n<ol>\n<li><p>编写DTD约束文档，后缀必须是.dtd<br><img src=\"https://img-blog.csdnimg.cn/22287ceea4b24e6393c1ff4b51d2dd4e.png#pic_center\"></p>\n</li>\n<li><p>在需要编写的XML文件中导入该DTD约束文档</p>\n</li>\n<li><p>按照约束的规定编写XML文件的内容</p>\n</li>\n</ol>\n<p>(&#x3D;&#x3D;不能约束具体的数据类型&#x3D;&#x3D;)</p>\n<p><strong>schema</strong></p>\n<ul>\n<li>&#x3D;&#x3D;schema可以约束具体的数据类型，约束能力上更强大&#x3D;&#x3D;。</li>\n<li>schema本身也是一个xml文件，本身也受到其他约束文件的要求，所以编写的更加严谨</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/6d14991452d1450f97b5ed9da3825b16.png#pic_center\"></p>\n<hr>\n<h1 id=\"2、XML解析技术\"><a href=\"#2、XML解析技术\" class=\"headerlink\" title=\"2、XML解析技术\"></a>2、XML解析技术</h1><h2 id=\"2-1-XML解析技术概述\"><a href=\"#2-1-XML解析技术概述\" class=\"headerlink\" title=\"2.1 XML解析技术概述\"></a>2.1 XML解析技术概述</h2><p>XML解析就是使用程序读取XML中的数据</p>\n<p><strong>两种解析方式</strong></p>\n<ul>\n<li>SAX解析</li>\n<li>DOM解析</li>\n</ul>\n<p><strong>Dom常见的解析工具</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">JAXP</td>\n<td align=\"center\">SUN公司提供的一套XML的解析的API</td>\n</tr>\n<tr>\n<td align=\"center\">JDOM</td>\n<td align=\"center\">JDOM是一个开源项目，它基于树型结构，利用纯JAVA的技术对XML文档实现解析、生成、序列化以及多种操作。</td>\n</tr>\n<tr>\n<td align=\"center\">dom4j</td>\n<td align=\"center\">是JDOM的升级品，用来读写XML文件的。具有性能优异、功能强大和极其易使用的特点，它的性能超过sun公司官方的dom技术，同时它也是一个开放源代码的软件，Hibernate也用它来读写配置文件。</td>\n</tr>\n<tr>\n<td align=\"center\">jsoup</td>\n<td align=\"center\">功能强大DOM方式的XML解析开发包，尤其对HTML解析更加方便</td>\n</tr>\n</tbody></table>\n<p><img src=\"https://img-blog.csdnimg.cn/6280ed11cbcf4d79ba6433f44e07e356.png#pic_center\"></p>\n<h2 id=\"2-2-Dom4J解析XML文件\"><a href=\"#2-2-Dom4J解析XML文件\" class=\"headerlink\" title=\"2.2 Dom4J解析XML文件\"></a>2.2 Dom4J解析XML文件</h2><p>使用Dom4J把一个XML文件的数据进行解析</p>\n<ul>\n<li>下载Dom4j框架，官网下载</li>\n<li>在项目中创建一个文件夹:lib</li>\n<li>将dom4j-2.1.1.jar文件复制到lib文件夹</li>\n<li>在jar文件上点右键，选择Add as Library -&gt;点击OK</li>\n<li>在类中导包使用</li>\n</ul>\n<pre><code class=\"java\">import org.dom4j.Attribute;\nimport org.dom4j.Document;\nimport org.dom4j.DocumentException;\nimport org.dom4j.Element;\nimport org.dom4j.io.SAXReader;\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.util.List;\n\n/**\n   目标：学会使用dom4j解析XML文件中的数据。\n    1、导入dom4j框架。\n    2、准备一个XML文件。\n */\npublic class Dom4JHelloWorldDemo1 &#123;\n    @Test\n    public void parseXMLData() throws Exception &#123;\n        // 1、创建一个Dom4j的解析器对象，代表了整个dom4j框架\n        SAXReader saxReader = new SAXReader();\n\n        // 2、把XML文件加载到内存中成为一个Document文档对象\n        // Document document = saxReader.read(new File(&quot;xml-app\\\\src\\\\Contacts.xml&quot;)); // 需要通过模块名去定位\n        // Document document = saxReader.read(new FileInputStream(&quot;xml-app\\\\src\\\\Contacts.xml&quot;));\n\n        // 注意: getResourceAsStream中的/是直接去src下寻找的文件\n        InputStream is = Dom4JHelloWorldDemo1.class.getResourceAsStream(&quot;/Contacts.xml&quot;);\n        Document document = saxReader.read(is);\n\n        // 3、获取根元素对象\n        Element root = document.getRootElement();\n        System.out.println(root.getName());\n\n        // 4、拿根元素下的全部子元素对象(一级)\n        // List&lt;Element&gt; sonEles =  root.elements();\n        List&lt;Element&gt; sonEles =  root.elements(&quot;contact&quot;);\n        for (Element sonEle : sonEles) &#123;\n            System.out.println(sonEle.getName());\n        &#125;\n\n        // 拿某个子元素\n        Element userEle = root.element(&quot;user&quot;);\n        System.out.println(userEle.getName());\n\n        // 默认提取第一个子元素对象 (Java语言。)\n        Element contact = root.element(&quot;contact&quot;);\n        // 获取子元素文本\n        System.out.println(contact.elementText(&quot;name&quot;));\n        // 去掉前后空格\n        System.out.println(contact.elementTextTrim(&quot;name&quot;));\n        // 获取当前元素下的子元素对象\n        Element email = contact.element(&quot;email&quot;);\n        System.out.println(email.getText());\n        // 去掉前后空格\n        System.out.println(email.getTextTrim());\n\n        // 根据元素获取属性值\n        Attribute idAttr = contact.attribute(&quot;id&quot;);\n        System.out.println(idAttr.getName() + &quot;--&gt;&quot; + idAttr.getValue());\n        // 直接提取属性值\n        System.out.println(contact.attributeValue(&quot;id&quot;));\n        System.out.println(contact.attributeValue(&quot;vip&quot;));\n    &#125;\n&#125;\n</code></pre>\n<p>Dom4j解析XML-得到Document对象,从中获取元素对象和内容。</p>\n<p><strong>SAXReader类</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">构造器&#x2F;方法</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public SAXReader()</td>\n<td align=\"center\">创建Dom4J的解析器对象</td>\n</tr>\n<tr>\n<td align=\"center\">Document read(String url)</td>\n<td align=\"center\">加载XML文件成为Document对象</td>\n</tr>\n</tbody></table>\n<p><strong>Document类</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Element getRootElement()</td>\n<td align=\"center\">获得根元素对象</td>\n</tr>\n</tbody></table>\n<p><strong>Dom4j解析XML的元素、属性、文本</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">List&lt; Element &gt; elements()</td>\n<td align=\"center\">得到当前元素下所有子元素</td>\n</tr>\n<tr>\n<td align=\"center\">List&lt; Element &gt; elements(String name)</td>\n<td align=\"center\">得到当前元素下指定名字的子元素返回集合</td>\n</tr>\n<tr>\n<td align=\"center\">Element element(String name)</td>\n<td align=\"center\">得到当前元素下指定名字的子元素,如果有很多名字相同的返回第一个</td>\n</tr>\n<tr>\n<td align=\"center\">String getName()</td>\n<td align=\"center\">得到元素名字</td>\n</tr>\n<tr>\n<td align=\"center\">String attributeValue(String name)</td>\n<td align=\"center\">通过属性名直接得到属性值</td>\n</tr>\n<tr>\n<td align=\"center\">String elementText(子元素名)</td>\n<td align=\"center\">得到指定名称的子元素的文本</td>\n</tr>\n<tr>\n<td align=\"center\">String getText()</td>\n<td align=\"center\">得到文本</td>\n</tr>\n</tbody></table>\n<hr>\n<h1 id=\"3、XML检索技术\"><a href=\"#3、XML检索技术\" class=\"headerlink\" title=\"3、XML检索技术\"></a>3、XML检索技术</h1><p>XPath介绍</p>\n<ul>\n<li>XPath在解析XML文档方面提供了一独树一帜的路径思想，更加优雅，高效</li>\n<li>XPath使用路径表达式来定位XML文档中的元素节点或属性节点。</li>\n</ul>\n<p>使用Xpath检索出XML文件</p>\n<ol>\n<li>导入jar包(dom4j和jaxen-1.1.2.jar)，Xpath技术依赖Dom4j技术</li>\n<li>通过dom4j的SAXReader获取Document对象</li>\n<li>利用XPath提供的API,结合XPath的语法完成选取XML文档元素节点进行解析操作。</li>\n<li>Document中与Xpath相关的API如下:</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Node selectSingleNode</td>\n<td align=\"center\">(“表达式”)获取符合表达式的唯一元素</td>\n</tr>\n<tr>\n<td align=\"center\">List&lt; Node &gt; selectNodes</td>\n<td align=\"center\">(“表达式”)获取符合表达式的元素集合</td>\n</tr>\n</tbody></table>\n<p><strong>XPath:绝对路径</strong></p>\n<p>采用绝对路径获取从根节点开始逐层的查找&#x2F;contactList&#x2F;contact&#x2F;name节点列表并打印信息</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">&#x2F;根元素&#x2F;子元素&#x2F;孙元素</td>\n<td align=\"center\">从根元素开始，一级一级向下查找，不能跨级</td>\n</tr>\n</tbody></table>\n<p><strong>XPath:相对路径</strong></p>\n<p>先得到根节点contactList,再采用相对路径获取下一级contact节点的name子节点并打印信息</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">.&#x2F;子元素&#x2F;孙元素</td>\n<td align=\"center\">从当前元素开始，一级一级向下查找，不能跨级</td>\n</tr>\n</tbody></table>\n<p><strong>XPath:全文搜索</strong></p>\n<p>·<br>直接全文搜索所有的name元素并打印</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">&#x2F;&#x2F;contact</td>\n<td align=\"center\">找contact元素，无论元素在哪里</td>\n</tr>\n<tr>\n<td align=\"center\">&#x2F;&#x2F;contact&#x2F;name</td>\n<td align=\"center\">找contact，无论在哪一级，但name一定是contact的子节点</td>\n</tr>\n<tr>\n<td align=\"center\">&#x2F;&#x2F;contact&#x2F;&#x2F;name</td>\n<td align=\"center\">contact无论在哪一种，name只要是contact的子孙元素都可以找到</td>\n</tr>\n</tbody></table>\n<p><strong>XPath:属性查找</strong></p>\n<p>在全文中搜索属性，或者带属性的元素</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">&#x2F;&#x2F;@属性名</td>\n<td align=\"center\">查找属性对象，无论是哪个元素，只要有这个属性即可。</td>\n</tr>\n<tr>\n<td align=\"center\">&#x2F;&#x2F;元素[@属性名]</td>\n<td align=\"center\">查找元素对象，全文搜索指定元素名和属性名。</td>\n</tr>\n<tr>\n<td align=\"center\">&#x2F;&#x2F;元素&#x2F;&#x2F;@属性名&#x3D;‘值’]</td>\n<td align=\"center\">查找元素对象，全文搜索指定元素名和属性名，并且属性值相等。</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">import org.dom4j.Attribute;\nimport org.dom4j.Document;\nimport org.dom4j.Element;\nimport org.dom4j.Node;\nimport org.dom4j.io.SAXReader;\nimport org.junit.Test;\n\nimport java.util.List;\n\npublic class XPathDemo &#123;\n    /**\n     1.绝对路径: /根元素/子元素/子元素。\n     */\n    @Test\n    public void parse01() throws Exception &#123;\n        // a、创建解析器对象\n        SAXReader saxReader = new SAXReader();\n        // b、把XML加载成Document文档对象\n        Document document =\n                saxReader.read(XPathDemo.class.getResourceAsStream(&quot;/Contacts2.xml&quot;));\n        // c、检索全部的名称\n        List&lt;Node&gt; nameNodes = document.selectNodes(&quot;/contactList/contact/name&quot;);\n        for (Node nameNode : nameNodes) &#123;\n            Element  nameEle = (Element) nameNode;\n            System.out.println(nameEle.getTextTrim());\n        &#125;\n    &#125;\n\n    /**\n     2.相对路径： ./子元素/子元素。 (.代表了当前元素)\n     */\n    @Test\n    public void parse02() throws Exception &#123;\n        // a、创建解析器对象\n        SAXReader saxReader = new SAXReader();\n        // b、把XML加载成Document文档对象\n        Document document =\n                saxReader.read(XPathDemo.class.getResourceAsStream(&quot;/Contacts2.xml&quot;));\n        Element root = document.getRootElement();\n        // c、检索全部的名称\n        List&lt;Node&gt; nameNodes = root.selectNodes(&quot;./contact/name&quot;);\n        for (Node nameNode : nameNodes) &#123;\n            Element  nameEle = (Element) nameNode;\n            System.out.println(nameEle.getTextTrim());\n        &#125;\n    &#125;\n\n    /**\n     3.全文搜索：\n     //元素  在全文找这个元素\n     //元素1/元素2  在全文找元素1下面的一级元素2\n     //元素1//元素2  在全文找元素1下面的全部元素2\n     */\n    @Test\n    public void parse03() throws Exception &#123;\n        // a、创建解析器对象\n        SAXReader saxReader = new SAXReader();\n        // b、把XML加载成Document文档对象\n        Document document =\n                saxReader.read(XPathDemo.class.getResourceAsStream(&quot;/Contacts2.xml&quot;));\n        // c、检索数据\n        //List&lt;Node&gt; nameNodes = document.selectNodes(&quot;//name&quot;);\n        // List&lt;Node&gt; nameNodes = document.selectNodes(&quot;//contact/name&quot;);\n        List&lt;Node&gt; nameNodes = document.selectNodes(&quot;//contact//name&quot;);\n        for (Node nameNode : nameNodes) &#123;\n            Element  nameEle = (Element) nameNode;\n            System.out.println(nameEle.getTextTrim());\n        &#125;\n    &#125;\n\n    /**\n     4.属性查找。\n     //@属性名称  在全文检索属性对象。\n     //元素[@属性名称]  在全文检索包含该属性的元素对象。\n     //元素[@属性名称=值]  在全文检索包含该属性的元素且属性值为该值的元素对象。\n     */\n    @Test\n    public void parse04() throws Exception &#123;\n        // a、创建解析器对象\n        SAXReader saxReader = new SAXReader();\n        // b、把XML加载成Document文档对象\n        Document document =\n                saxReader.read(XPathDemo.class.getResourceAsStream(&quot;/Contacts2.xml&quot;));\n        // c、检索数据\n        List&lt;Node&gt; nodes = document.selectNodes(&quot;//@id&quot;);\n        for (Node node : nodes) &#123;\n            Attribute attr = (Attribute) node;\n            System.out.println(attr.getName() + &quot;===&gt;&quot; + attr.getValue());\n        &#125;\n\n        // 查询name元素（包含id属性的）\n//      Node node = document.selectSingleNode(&quot;//name[@id]&quot;);\n        Node node = document.selectSingleNode(&quot;//name[@id=888]&quot;);\n        Element ele = (Element) node;\n        System.out.println(ele.getTextTrim());\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h1 id=\"4、设计模式\"><a href=\"#4、设计模式\" class=\"headerlink\" title=\"4、设计模式\"></a>4、设计模式</h1><h2 id=\"4-1-工厂模式\"><a href=\"#4-1-工厂模式\" class=\"headerlink\" title=\"4.1 工厂模式\"></a>4.1 工厂模式</h2><p>&#x3D;&#x3D;工厂模式(Factory Pattern)是Java 中最常用的设计模式之一，这种类型的设计模式属于创建型模式，它提供了一种获取对象的方式。&#x3D;&#x3D;</p>\n<p><strong>工厂设计模式的作用:</strong></p>\n<ol>\n<li>工厂的方法可以封装对象的创建细节，比如:为该对象进行加工和数据注入。</li>\n<li>可以实现类与类之间的解耦操作（核心思想)。</li>\n</ol>\n<pre><code class=\"java\">public abstract class Computer &#123;\n    private String name;\n    private double price;\n\n    public abstract void start();\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public double getPrice() &#123;\n        return price;\n    &#125;\n\n    public void setPrice(double price) &#123;\n        this.price = price;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">\npublic class Huawei extends Computer&#123;\n    @Override\n    public void start() &#123;\n        System.out.println(getName() + &quot;开机了，展示了华为的菊花图标~~~~&quot;);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Mac extends Computer&#123;\n    @Override\n    public void start() &#123;\n        System.out.println(getName() + &quot;以非常优雅的方法启动了，展示了一个苹果logo&quot;);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class FactoryPattern &#123;\n    /**\n       定义一个方法，创建对象返回\n     */\n    public static Computer createComputer(String info)&#123;\n        switch (info)&#123;\n            case &quot;huawei&quot;:\n                Computer c = new Huawei();\n                c.setName(&quot;huawei pro 16&quot;);\n                c.setPrice(5999);\n                return c;\n            case &quot;mac&quot;:\n                Computer c2 = new Mac();\n                c2.setName(&quot;MacBook pro&quot;);\n                c2.setPrice(11999);\n                return c2;\n            default:\n                return null;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class FactoryDemo &#123;\n    public static void main(String[] args) &#123;\n        Computer c1 = FactoryPattern.createComputer(&quot;huawei&quot;);\n        c1.start();\n\n        Computer c2 = FactoryPattern.createComputer(&quot;mac&quot;);\n        c2.start();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"4-2-装饰模式\"><a href=\"#4-2-装饰模式\" class=\"headerlink\" title=\"4.2 装饰模式\"></a>4.2 装饰模式</h2><p>&#x3D;&#x3D;装饰设计模式是创建一个新类，包装原始类，从而在新类中提升原来类的功能。&#x3D;&#x3D;</p>\n<p><strong>装饰设计模式的作用:</strong></p>\n<p>作用:装饰模式指的是在不改变原类的基础上，动态地扩展─个类的功能。</p>\n<ol>\n<li>定义父类</li>\n<li>定义原始类，继承父类，定义功能。</li>\n<li>定义装饰类，继承父类，包装原始类，增强功能!!</li>\n</ol>\n<pre><code class=\"java\">/**\n   共同父类\n */\npublic abstract class InputStream &#123;\n    public abstract int read();\n    public abstract int read(byte[] buffer);\n&#125;\n</code></pre>\n<pre><code class=\"java\">import java.util.Arrays;\n\n/**\n   原始类\n */\npublic class FileInputStream extends InputStream&#123;\n    @Override\n    public int read() &#123;\n        System.out.println(&quot;低性能的方式读取了一个字节a&quot;);\n        return 97;\n    &#125;\n\n    @Override\n    public int read(byte[] buffer) &#123;\n        buffer[0] = 97;\n        buffer[1] = 98;\n        buffer[2] = 99;\n        System.out.println(&quot;低性能的方式读取了一个字节数组：&quot; + Arrays.toString(buffer));\n        return 3;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">/**\n   装饰类：继承InputStream 拓展原始类的功能\n */\npublic class BufferedInputStream extends InputStream&#123;\n    private InputStream is;\n    public BufferedInputStream(InputStream is)&#123;\n        this.is = is;\n    &#125;\n    @Override\n    public int read() &#123;\n        System.out.println(&quot;提供8KB的缓冲区，提高读数据性能~~~~&quot;);\n        return is.read();\n    &#125;\n\n    @Override\n    public int read(byte[] buffer) &#123;\n        System.out.println(&quot;提供8KB的缓冲区，提高读数据性能~~~~&quot;);\n        return is.read(buffer);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">/**\n  装饰模式\n\n    定义父类：InputStream\n    定义实现类：FileInputStream 继续父类 定义功能\n    定义装饰实现类：BufferedInputStream 继承父类 定义功能 包装原始类，增强功能。\n */\npublic class DecoratorPattern &#123;\n    public static void main(String[] args) &#123;\n        InputStream is = new BufferedInputStream(new FileInputStream());\n        System.out.println(is.read());\n        System.out.println(is.read(new byte[3]));\n    &#125;\n&#125;\n\n</code></pre>\n<hr>\n","feature":true,"text":"XML（可扩展标记语言）是一种用于描述数据结构和信息传递的标记语言。它具有自定义标签和结构化数据的特点，被广泛应用于配置文件、数据交换和Web服务等领域。设计模式是在软件设计中常用的解决问题的经验总结，如单例模式、工厂模式等。合理使用XML和设计模式可以提高程序的可读性、可维护性和灵活性，使开发过程更加高效和可靠。...","permalink":"/post/Java程序设计 -- XML、设计模式（二十一）","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1%E3%80%81XML\"><span class=\"toc-text\">1、XML</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-XML%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1.1 XML概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-XML%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99\"><span class=\"toc-text\">1.2 XML的创建、语法规则</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-XML%E6%96%87%E6%A1%A3%E7%BA%A6%E6%9D%9F\"><span class=\"toc-text\">1.3 XML文档约束</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2%E3%80%81XML%E8%A7%A3%E6%9E%90%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">2、XML解析技术</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-XML%E8%A7%A3%E6%9E%90%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">2.1 XML解析技术概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-Dom4J%E8%A7%A3%E6%9E%90XML%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">2.2 Dom4J解析XML文件</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3%E3%80%81XML%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">3、XML检索技术</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">4、设计模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">4.1 工厂模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">4.2 装饰模式</span></a></li></ol></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"JAVA图形化基础--GUI编程","uid":"ac07147ebfe9ea11673ae70bed7f524c","slug":"Java图形化基础 -- GUI编程","date":"2022-04-23T03:10:12.000Z","updated":"2025-07-14T15:12:20.458Z","comments":true,"path":"api/articles/Java图形化基础 -- GUI编程.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","text":"JavaGUI是Java语言提供的一套图形用户界面开发工具，包括AWT和Swing两个主要库。AWT（抽象窗口工具集）是Java最早的GUI库，提供了跨平台的界面组件，但界面风格受系统影响。Swing则是AWT的增强版，提供更丰富的界面组件和更灵活的自定义机制，同时支持跨平台和外观管理器。合理选择AWT或Swing库可根据具体应用场景决定。...","permalink":"/post/Java图形化基础 -- GUI编程","photos":[],"count_time":{"symbolsCount":"30k","symbolsTime":"28 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true},"next_post":{"title":"Java程序设计--Java高级技术","uid":"bec3c05a6e5145a0f9bf9077827e54de","slug":"Java程序设计 -- Java高级技术（二十）","date":"2022-04-17T08:21:11.000Z","updated":"2025-07-14T15:12:20.459Z","comments":true,"path":"api/articles/Java程序设计 -- Java高级技术（二十）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","text":"Java单元测试是一种测试方法，用于确保程序模块的正确性。反射是Java语言提供的一组API，能够在运行时动态获取类信息和操作对象。注解是一种元数据机制，可用于标记、配置和描述程序元素。动态代理则是一种设计模式，为其他对象提供一个代理，以控制对该对象的访问。合理运用Java单元测试、反射、注解和动态代理可以提升程序的可维护性和可扩展性。...","permalink":"/post/Java程序设计 -- Java高级技术（二十）","photos":[],"count_time":{"symbolsCount":"22k","symbolsTime":"20 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true}}