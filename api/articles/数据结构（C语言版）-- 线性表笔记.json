{"title":"线性表","uid":"b96df039eaa03d2a5634c2cc83e5cad0","slug":"数据结构（C语言版）-- 线性表笔记","date":"2022-02-10T01:41:07.000Z","updated":"2025-07-14T15:12:20.469Z","comments":true,"path":"api/articles/数据结构（C语言版）-- 线性表笔记.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/cc67f280b3744197a9dfe94df485796b.png","content":"<hr>\n<h1 id=\"1、线性表的定义与特点\"><a href=\"#1、线性表的定义与特点\" class=\"headerlink\" title=\"1、线性表的定义与特点\"></a>1、线性表的定义与特点</h1><p><strong>线性结构特性：</strong></p>\n<p>若结构是非空有限集，除第一个数据元素无直接前驱，最后一个数据元素无直接后继之外，其他每个数据元素都有一个直接前趋和一个直接后继。</p>\n<p><strong>典型线性结构：</strong></p>\n<p>线性表、堆栈、队列、字符串、数组等等。</p>\n<p><strong>线性表：</strong></p>\n<p>数据元素虽然不同，但同一线性表中的元素必定具有相同的特性，即属于同一数据对象，相邻数据元素之间存在着序偶关系。诸如此类由n (n≥0)个数据特性相同的元素构成的有限序列称为<strong>线性表</strong>。线性表中元素的个数n (n≥0)定义为线性表的长度，n &#x3D;0时称为<strong>空表</strong>。</p>\n<p>对于非空的线性表或线性结构，其特点是:</p>\n<ol>\n<li>存在唯一的一个被称作“第一个”的数据元素;</li>\n<li>存在唯一的一个被称作“最后一个”的数据元素;</li>\n<li>除第一个之外，结构中的每个数据元素均只有一个前驱;</li>\n<li>除最后一个之外，结构中的每个数据元素均只有一个后继。</li>\n</ol>\n<hr>\n<h1 id=\"2、线性表的类型定义\"><a href=\"#2、线性表的类型定义\" class=\"headerlink\" title=\"2、线性表的类型定义\"></a>2、线性表的类型定义</h1><p>线性表的抽象数据类型定义：<br><img src=\"https://img-blog.csdnimg.cn/b10b7030d7be4d6db75a6f50231b5785.png\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/0abafab5d1e04bfeb6008e63d5b56879.png#pic_center\"></p>\n<hr>\n<h1 id=\"3、线性表的顺序实现和表示\"><a href=\"#3、线性表的顺序实现和表示\" class=\"headerlink\" title=\"3、线性表的顺序实现和表示\"></a>3、线性表的顺序实现和表示</h1><h2 id=\"①-线性表的顺序存储表示\"><a href=\"#①-线性表的顺序存储表示\" class=\"headerlink\" title=\"①.线性表的顺序存储表示\"></a>①.线性表的顺序存储表示</h2><p>线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素，这种表示也称作线性表的顺序存储结构或顺序映像。通常，称这种存储结构的线性表为**顺序表(Sequent ialList)**。其特点是：逻辑上相邻的数据元素，其物理次序也是相邻的。</p>\n<p>如果线性表的每个元素需占用L个存储单元：</p>\n<ul>\n<li>LOC(a<del>i</del>)表示a<del>i</del>的存储地址</li>\n<li>LOC(a<del>1</del>)表示a<del>1</del>的存储地址，称为线性表的起始位置或基地址</li>\n<li>LOC(a<del>i+1</del>) &#x3D; LOC(a<del>i</del>)+L </li>\n<li>LOC(a<del>i</del>) &#x3D; LOC(a<del>1</del>)+(i-1)*L</li>\n</ul>\n<p>确定了存储线性表的起始位置，线性表中任一数据元素都可随机存取。&#x3D;&#x3D;线性表的顺序存储结构是一种随机存取的存储结构。&#x3D;&#x3D;</p>\n<p><img src=\"https://img-blog.csdnimg.cn/02f89c6afdc842b39ac5da247cfded23.png#pic_center\"></p>\n<pre><code class=\"c\">//顺序表的存储结构\n#define MAXSIZE 100  //顺序表最大长度 \ntypedef struct\n&#123;\n    ElemType *elem;  //存储空间的基地址 \n    int Length;\t\t //当前长度 \n &#125; SqList;           //顺序表的结构类型为 SqList\n</code></pre>\n<h2 id=\"②-顺序表中基本操作的实现\"><a href=\"#②-顺序表中基本操作的实现\" class=\"headerlink\" title=\"②.顺序表中基本操作的实现\"></a>②.顺序表中基本操作的实现</h2><p><strong>顺序表的初始化</strong></p>\n<ol>\n<li>为顺序表L动态分配一个预定义大小的数组空间，使elem指向这段空间的基地址。</li>\n<li>将表的当前长度设为0。</li>\n</ol>\n<pre><code class=\"c\">Status InitList(SqList &amp;L)         //构造一个空的顺序表L\n&#123;\n    L.elem=new ElemType[MAXSIZE];  //为顺序表分配空间\n    if(!L.elem) exit(OVERFLOW);    //存储分配失败\n    L.length=0;\t\t\t\t       //空表长度为0\n    return OK;\n&#125;\n</code></pre>\n<p><strong>顺序表的取值</strong></p>\n<ol>\n<li>判断指定的位置序号i值是否合理( 1≤i≤L.length )，若不合理，则返回ERROR。</li>\n<li>若i值合理，则将第i个数据元素L.elem[i-1]赋给参数e，通过e返回第i个数据元素的传值。</li>\n</ol>\n<pre><code class=\"c\">Status GetElem(SqList L,int i,ElemType &amp;e)\n&#123;\n    if(i&lt;1||i&gt;L.length)\n        return ERROR;\n    e = L.elme[i-1];\n    return OK;\n&#125;\n</code></pre>\n<p><strong>顺序表的查找</strong></p>\n<ol>\n<li>从第一个元素起，依次和e相比较，若找到与e相等的元素L.elem[i]，则查找成功，返回该元素的序号i+1。</li>\n<li>若查遍整个顺序表都没有找到，则查找失败,返回0。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/b3aca3f53630464f9f1194d8838e0ffe.png#pic_center\"></p>\n<pre><code class=\"c\">int LocateElem(SqList L,ElemType e)\n&#123;        \n    for (i=0;i&lt; L.length;i++)  //i为下标序号\n        if (L.elem[i]==e) \n            return i+1;  //查找成功，返回序号i+1                \n    return 0;  //查找失败，返回0\n&#125;\n</code></pre>\n<p>在查找时，为确定元素在顺序表中的位置，需和给定值进行比较的数据元素个数的期望值称为查找算法在查找成功时的<strong>平均查找长度</strong>(Average Search L ength, ASL)。</p>\n<p><strong>顺序表的插入</strong></p>\n<ol>\n<li>判断插入位置i是否合法（ i值的合法范围是1≤i≤n+1)，若不合法则返回ERROR。</li>\n<li>判断顺序表的存储空间是否已满,若满则返回ERROR。</li>\n<li>将第n个至第i个位置的元素依次向后移动一个位置，空出第i个位置(i&#x3D;n+1时无需移动）</li>\n<li>将要插入的新元素e放入第i个位置。</li>\n<li>表长加1。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/490480883d2a40d4a3e225b1036546c9.png#pic_center\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/f55b96f9651f4537ab259342220af869.png#pic_center\"></p>\n<pre><code class=\"c\">Status ListInsert(SqList &amp;L，int i，ElemType e)\n&#123;\n    if (i &lt; 1 || i &gt; L.length + 1)\n        return ERROR;\n    if (L.length == MAXSIZE)\n        return ERROR;\n    for (j = L.length - 1; j &gt;= i - 1; j--)\n        L.elem[j + 1] = L.elem[j];\n    L.elem[i - 1] = e;\n    ++L.length;\n    return OK;\n&#125;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/d3cfb5ea56e041d89ffca963985f56f4.png#pic_center\"></p>\n<p><strong>顺序表的删除</strong></p>\n<ol>\n<li>判断删除位置i是否合法(合法值为1≤i≤n),若不合法则返回ERROR。</li>\n<li>将第i+1个至第n个的元素依次向前移动一个位置( i&#x3D;n时无需移动)。</li>\n<li>表长减1。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/9784ac200cef4cd795217f13372b0975.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/f0ce119684714ca8a44497b83cf7c9a5.png#pic_center\"></p>\n<pre><code class=\"c\">Status ListDelete(SqList &amp;L, int i)\n&#123;\n    if (i &lt; 1 || i &gt; L.length)\n        return ERROR;\n    for (j = i; j &lt;= L.length - 1; j++)\n        L.elem[j - 1] = L.elem[j];\n    --L.length;\n    return OK;\n&#125;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/5325bb98d0a74fc89a3f90b18ecc293b.png#pic_center\"></p>\n<h2 id=\"③-顺序表的顺序表示和实现实例\"><a href=\"#③-顺序表的顺序表示和实现实例\" class=\"headerlink\" title=\"③.顺序表的顺序表示和实现实例\"></a>③.顺序表的顺序表示和实现实例</h2><p>测试样例：book.txt</p>\n<p><img src=\"https://img-blog.csdnimg.cn/03f6321c659c46148515e623f10fb0f1.png#pic_center\"></p>\n<pre><code class=\"c\">#include&lt;iostream&gt;\n#include&lt;fstream&gt;\n#include&lt;string&gt;\n#include&lt;iomanip&gt;\nusing namespace std;\n#define OK 1\n#define ERROR 0\n#define OVERFLOW -2\ntypedef int Status; //Status 是函数返回值类型，其值是函数结果状态代码。\ntypedef int ElemType; //ElemType 为可定义的数据类型，此设为int类型\n\n#define MAXSIZE 100\t\t\t//顺序表可能达到的最大长度\nstruct Book &#123;\n    string id;//ISBN\n    string name;//书名\n    double price;//定价\n&#125;;\ntypedef struct &#123;\n    Book *elem; //存储空间的基地址\n    int length; //当前长度\n&#125; SqList;\n\nStatus InitList_Sq(SqList &amp;L) &#123; //顺序表的初始化\n    //构造一个空的顺序表L\n    L.elem = new Book[MAXSIZE]; //为顺序表分配一个大小为MAXSIZE的数组空间\n    if (!L.elem)\n        exit(OVERFLOW); //存储分配失败退出\n    L.length = 0; //空表长度为0\n    return OK;\n&#125;\n\nStatus GetElem(SqList L, int i, Book &amp;e) &#123;//顺序表的取值\n    if (i &lt; 1 || i &gt; L.length)\n        return ERROR; //判断i值是否合理，若不合理，返回ERROR\n    e = L.elem[i - 1]; //elem[i-1]单元存储第i个数据元素\n    return OK;\n&#125;\n\nint LocateElem_Sq(SqList L, double e) &#123; //顺序表的查找\n    //顺序表的查找\n    for (int i = 0; i &lt; L.length; i++)\n        if (L.elem[i].price == e)\n            return i + 1;//查找成功，返回序号i+1\n    return 0;//查找失败，返回0\n&#125;\n\nStatus ListInsert_Sq(SqList &amp;L, int i, Book e) &#123; //顺序表的插入\n    //在顺序表L中第i个位置之前插入新的元素e\n    //i值的合法范围是1&lt;=i&lt;=L.length+1\n    if ((i &lt; 1) || (i &gt; L.length + 1))\n        return ERROR; //i值不合法\n    if (L.length == MAXSIZE)\n        return ERROR; //当前存储空间已满\n    for (int j = L.length - 1; j &gt;= i - 1; j--)\n        L.elem[j + 1] = L.elem[j]; //插入位置及之后的元素后移\n    L.elem[i - 1] = e; //将新元素e放入第i个位置\n    ++L.length; //表长增1\n    return OK;\n&#125;\n\nStatus ListDelete_Sq(SqList &amp;L, int i) &#123; //顺序表的删除\n    //在顺序表L中删除第i个元素，并用e返回其值\n    //i值的合法范围是1&lt;=i&lt;=L.length\n    if ((i &lt; 1) || (i &gt; L.length))\n        return ERROR; //i值不合法\n    for (int j = i; j &lt;= L.length; j++)\n        L.elem[j - 1] = L.elem[j]; //被删除元素之后的元素前移\n    --L.length; //表长减1\n    return OK;\n&#125;\n\nint main() &#123;\n    SqList L;\n    int i = 0, temp, a, c, choose;\n    double price;\n    Book e;\n    string head_1, head_2, head_3;\n    cout &lt;&lt; &quot;1. 建立\\n&quot;;\n    cout &lt;&lt; &quot;2. 输入\\n&quot;;\n    cout &lt;&lt; &quot;3. 取值\\n&quot;;\n    cout &lt;&lt; &quot;4. 查找\\n&quot;;\n    cout &lt;&lt; &quot;5. 插入\\n&quot;;\n    cout &lt;&lt; &quot;6. 删除\\n&quot;;\n    cout &lt;&lt; &quot;7. 输出\\n&quot;;\n    cout &lt;&lt; &quot;0. 退出\\n\\n&quot;;\n\n    choose = -1;\n    while (choose != 0) &#123;\n        cout &lt;&lt; &quot;请选择:&quot;;\n        cin &gt;&gt; choose;\n        switch (choose) &#123;\n        case 1://创建顺序表\n            if (InitList_Sq(L))\n                cout &lt;&lt; &quot;成功建立顺序表\\n\\n&quot;;\n            else\n                cout &lt;&lt; &quot;顺序表建立失败\\n\\n&quot;;\n            break;\n        case 2: &#123;//顺序表信息输入\n            i = 0;\n            L.elem = new Book[MAXSIZE];\n            if (!L.elem)\n                exit(OVERFLOW);\n            L.length = 0;\n            fstream file;\n            file.open(&quot;book.txt&quot;);\n            if (!file) &#123;\n                cout &lt;&lt; &quot;错误！未找到文件！&quot; &lt;&lt; endl;\n                exit(ERROR);\n            &#125;\n            file &gt;&gt; head_1 &gt;&gt; head_2 &gt;&gt; head_3;\n            while (!file.eof()) &#123;\n                file &gt;&gt; L.elem[i].id &gt;&gt; L.elem[i].name &gt;&gt; L.elem[i].price;\n                i++;\n            &#125;\n            cout &lt;&lt; &quot;输入 book.txt 信息完毕\\n\\n&quot;;\n            L.length = i;\n            file.close();\n        &#125;\n            break;\n        case 3://顺序表的取值\n            cout &lt;&lt; &quot;请输入一个位置用来取值：\\n&quot;;\n            cin &gt;&gt; i;\n            temp = GetElem(L, i, e);\n            if (temp != 0) &#123;\n                cout &lt;&lt; &quot;查找成功\\n&quot;;\n                cout &lt;&lt; &quot;第&quot; &lt;&lt; i &lt;&lt; &quot;本图书的信息是：\\n&quot;;\n                cout &lt;&lt; left &lt;&lt; setw(15) &lt;&lt; e.id &lt;&lt; &quot;\\t&quot; &lt;&lt; left &lt;&lt; setw(50)\n                        &lt;&lt; e.name &lt;&lt; &quot;\\t&quot; &lt;&lt; left &lt;&lt; setw(5) &lt;&lt; e.price &lt;&lt; endl\n                        &lt;&lt; endl;\n            &#125; else\n                cout &lt;&lt; &quot;查找失败！位置超出范围\\n\\n&quot;;\n            break;\n        case 4: //顺序表的查找\n            cout &lt;&lt; &quot;请输入所要查找价格:&quot;;\n            cin &gt;&gt; price;\n            temp = LocateElem_Sq(L, price);\n            if (temp != 0) &#123;\n                cout &lt;&lt; &quot;查找成功\\n&quot;;\n                cout &lt;&lt; &quot;该价格对应的书名为：&quot; &lt;&lt; L.elem[temp - 1].name &lt;&lt; endl &lt;&lt; endl;\n            &#125; else\n                cout &lt;&lt; &quot;查找失败！没有这个价格对应的书籍\\n\\n&quot;;\n            break;\n        case 5: //顺序表的插入\n            cout &lt;&lt; &quot;请输入插入的位置和书本信息，包括：编号 书名 价格（用空格隔开）:&quot;;\n            cin &gt;&gt; a;\n            cin &gt;&gt; e.id &gt;&gt; e.name &gt;&gt; e.price; //输入a和b，a代表插入的位置，b代表插入的数值（书本信息）\n            if (ListInsert_Sq(L, a, e))\n                cout &lt;&lt; &quot;插入成功.\\n\\n&quot;;\n            else\n                cout &lt;&lt; &quot;插入失败.\\n\\n&quot;;\n            break;\n        case 6: //顺序表的删除\n            cout &lt;&lt; &quot;请输入所要删除的书籍的位置:&quot;;\n            cin &gt;&gt; c;\n            if (ListDelete_Sq(L, c))\n                cout &lt;&lt; &quot;删除成功.\\n\\n&quot;;\n            else\n                cout &lt;&lt; &quot;删除失败.\\n\\n&quot;;\n            break;\n        case 7: //顺序表的输出\n            cout &lt;&lt; &quot;当前图书系统信息（顺序表）读出:\\n&quot;;\n            for (i = 0; i &lt; L.length; i++)\n                cout &lt;&lt; left &lt;&lt; setw(15) &lt;&lt; L.elem[i].id &lt;&lt; &quot;\\t&quot; &lt;&lt; left\n                        &lt;&lt; setw(50) &lt;&lt; L.elem[i].name &lt;&lt; &quot;\\t&quot; &lt;&lt; left\n                        &lt;&lt; setw(5) &lt;&lt; L.elem[i].price &lt;&lt; endl;\n            cout &lt;&lt; endl;\n            break;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<hr>\n<h1 id=\"4、线性表的链式表示和实现\"><a href=\"#4、线性表的链式表示和实现\" class=\"headerlink\" title=\"4、线性表的链式表示和实现\"></a>4、线性表的链式表示和实现</h1><h2 id=\"①-单链表的定义和表示\"><a href=\"#①-单链表的定义和表示\" class=\"headerlink\" title=\"①.单链表的定义和表示\"></a>①.单链表的定义和表示</h2><p><strong>线性表链式存储结构的特点：</strong></p>\n<p>用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。</p>\n<p><strong>结点:</strong></p>\n<p>数据元素的存储映像。由&#x3D;&#x3D;数据域&#x3D;&#x3D;和&#x3D;&#x3D;指针域&#x3D;&#x3D;两部分组成。</p>\n<p><strong>数据域:</strong></p>\n<p>存储数据元素信息。</p>\n<p><strong>指针域:</strong></p>\n<p>存储反映元素关系的存储位置，称作指针或链。</p>\n<p><strong>头指针:</strong></p>\n<p>指向第一个结点的指针。</p>\n<p><strong>链表:</strong></p>\n<p>n个结点由指针链组成一个链表。称为线性表的链式存储结构。</p>\n<p>结点只有一个指针域的链表，称为单链表或线性链。最后一个结点的指针域为空，逻辑上相邻的元素在物理上不一定相邻，链表链接的顺序和数据元素的逻辑顺序一致，结点的物理位置可任意安排，不能出现“断链”现象。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/66a0d362134249839b4c29ed2d95af7c.png#pic_center\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/8ae89823c3c04588843b3121909e209c.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/5bc87672028a44739ea03c41a322b0ad.png#pic_center\"></p>\n<pre><code class=\"c\">//单链表的存储结构\ntypedef struct LNode\n&#123;\n    ElemType data;      //结点的数据域\n    sturct LNode *next; //结点的指针域\n&#125; LNode, *LinkList;     // LinkList为指向结构体LNode的指针类型\n</code></pre>\n<p><strong>头指针、头结点和首元结点</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/c1fa82edec9a4eaab439454ab46c582b.png#pic_center\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/96fe035efc1a410490c4363bd15bcb0a.png#pic_center\"><br>问：头结点的作用？</p>\n<p>答：便于首元结点的处理；便于空表和非空表的统一处理（无头结点：L&#x3D;&#x3D;NULL;有头结点：L-&gt;next&#x3D;NULL）</p>\n<p>问：头结点的数据域内装的是什么？</p>\n<p>答：头结点的数据域可以为空，也可以存放线性表长度等附加信息，但此结点不能计入链表长度值。</p>\n<h2 id=\"②-单链表基本操作的实现\"><a href=\"#②-单链表基本操作的实现\" class=\"headerlink\" title=\"②.单链表基本操作的实现\"></a>②.单链表基本操作的实现</h2><p><strong>单链表的初始化</strong></p>\n<ol>\n<li>生成新结点作为头结点，用头指针L指向头结点。 </li>\n<li>头结点的指针域置空。</li>\n</ol>\n<pre><code class=\"c\">Status InitList_L(LinkList &amp;L)\n&#123;                   //构造一个空的单链表L\n    L = new LNode;  //生成新结点作为头结点，用头指针L指向头结点\n    L-&gt;next = NULL; //头结点的指针域置空\n    return OK;\n&#125;\n</code></pre>\n<p><strong>单链表的取值</strong></p>\n<ol>\n<li><p>用指针p指向首元结点,用j做计数器初值赋为1。</p>\n</li>\n<li><p>从首元结点开始依次顺着链域next向下访问，只要指向当前结点的指针 p 不为空(NULL)，并且没有到达序号为i的结点，则循环执行以下操作:</p>\n<ul>\n<li>p指向下一个结点。</li>\n<li>计数器j相应加1。</li>\n</ul>\n</li>\n<li><p>退出循环时，如果指针p为空，或者计数器j大于i，说明指定的序号i值不合法(i大于表长n或i小于等于0)，取值失败返回ERROR;否则取值成功，此时j&#x3D;i时，p所指的结点就是要找的第i个结点，用参数e保存当前结点的数据域，返回OK。</p>\n</li>\n</ol>\n<pre><code class=\"c\">Status GetElem(LinkList L, int i, ElemType &amp;e)\n&#123;\n    p = L-&gt;next;\n    j = 1;\n    while（p &amp;&amp;j &lt; i）\n    &#123;\n        p = p-&gt;next;\n        ++j;\n    &#125;\n    if（ !p || j &gt; i） \n        return ERROR；\n    e = p-&gt;data;\n    return OK;\n&#125;\n</code></pre>\n<p><strong>单链表的按值查找</strong></p>\n<ol>\n<li>用指针p指向首元结点。</li>\n<li>从首元结点开始依次顺着链域next向下查找，只要指向当前结点的指针p不为空，并且p所指结点的数据域不等于给定值e，则循环执行以下操作:p指向下一个结点。</li>\n<li>返回p。若查找成功，p此时即为结点的地址值，若查找失败，p的值即为NULL。</li>\n</ol>\n<pre><code class=\"c\">LNode *LocateElem(LinkList L, Elemtype e)\n&#123;\n    p = L-&gt;next;\n    while (p &amp;&amp; p-&gt;next != e)\n        p = p-&gt;next;\n    return p;\n&#125;\n</code></pre>\n<p><strong>单链表的插入</strong></p>\n<ol>\n<li>查找结点a<del>i-1</del>并由指针p指向该结点。</li>\n<li>生成一个新结点*s。</li>\n<li>将新结点*s的数据域置为e。</li>\n<li>将新结点*s 的指针域指向结点a<del>i</del>。（s-&gt;next &#x3D; p-&gt;next）</li>\n<li>将结点<em>p的指针域指向新结点</em>s。（p-&gt;next &#x3D; s）</li>\n</ol>\n<p>（&#x3D;&#x3D;步骤4、5不能互换，若掉换顺序，后结点丢失，找不到结点并造成内存泄露&#x3D;&#x3D;）</p>\n<p><img src=\"https://img-blog.csdnimg.cn/b607c2eab8564d27984e7a9734bdafcf.png#pic_center\"></p>\n<pre><code class=\"c\">Status ListInsert(LinkList &amp;L, int i, ElemType &amp;e)\n&#123; //在带头结点的单链表L中第i个位置之前插入元素e\n    p = L;\n    j = 0;\n    while (p &amp;&amp; j &lt; i - 1)\n    &#123;\n        p = p-&gt;next;\n        ++j;\n    &#125;\n    if (!p || j &gt; i - 1)\n        return ERROR;\n    s = new LNode;\n    s-&gt;data = e;\n    s-&gt;next = p-&gt;next;\n    p-&gt;next = s;\n    return OK;\n&#125;\n</code></pre>\n<p><strong>单链表的删除</strong></p>\n<ol>\n<li>查找结点a<del>i-1</del>并由指针p指向该结点。</li>\n<li>临时保存待删除结点a<del>i</del>的地址在q中，以备释放。</li>\n<li>将结点*p的指针域指向a<del>i</del>的直接后继结点。</li>\n<li>释放结点a<del>i</del>的空间。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/110a043a889f4b3e9bce8684fea9731a.png#pic_center\"></p>\n<pre><code class=\"c\">Status ListDelete（LinkList &amp;L, int i）\n&#123; //在带头结点的单链表 L 中，删除第 i 个元素\n    p = L;\n    j = 0;\n    while ((p-&gt;next) &amp;&amp; (j &lt; i - 1))\n          \n        &#123;\n            p = p-&gt;next;\n            ++j;\n        &#125;\n    if (!(p-&gt;next) || (j &gt; i - 1))\n         return ERROR;\n    q = p-&gt;next;\n    p-&gt;next = q-&gt;next;\n    delete q;\n    return OK;\n     \n&#125;\n</code></pre>\n<p><strong>前插法单链表</strong></p>\n<p>前插法是通过将新结点逐个插入链表的头部(头结点之后)来创建链表，每次申请一个新结点，读入相应的数据元素值，然后将新结点插入到头结点之后。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20db5409df8e41d39f5f888db6a21aff.png#pic_center\"></p>\n<ol>\n<li>创建一个只有头结点的空链表。</li>\n<li>根据待创建链表包括的元素个数n，循环n次执行以下操作:<br> - 生成一个新结点<em>p;<br>- 输人元素值赋给新结点</em>p 的数据域;<br>- 将新结点*p插人到头结点之后。</li>\n</ol>\n<pre><code class=\"c\">void CreateList_H(LinkList &amp;L, int n)\n&#123; //逆位序输入 n 个元素的值，建立带表头结点的单链表 L\n    L = new LNode;\n    L-&gt;next = NULL;\n    for (i = 0; i &lt; n; ++i)\n    &#123;\n        p = new LNode;\n        cin &gt;&gt; p-&gt;data;\n        p-&gt;next = L-&gt;next;\n        L-&gt;next = p;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>尾插法单链表</strong></p>\n<p>尾插法是通过将新结点逐个插入到链表的尾部来创建链表。同前插法样，每次申请一个新结点，读入相应的数据元素值。不同的是，为了使新结点能够插入到表尾，需要增加一个尾指针r指向链表的尾结点。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/ee0e882ab8434a7f82c807035ad0ccc8.png#pic_center\"></p>\n<ol>\n<li>创建一个只有头结点的空链表。</li>\n<li>尾指针r初始化，指向头结点。</li>\n<li>根据创建链表包括的元素个数n,循环n次执行以下操作:<br>- 生成一个新结点<em>p;<br>- 输人元素值赋给新结点</em>p的数据域;<br>- 将新结点<em>p插入到尾结点</em>r之后;<br>- 尾指针r指向新的尾结点*p。</li>\n</ol>\n<pre><code class=\"c\">void CreateList_L(LinkList &amp;L, int n)\n&#123; //正位序输入n个元素的值，建立带表头结点的单链表L\n    L = new LNode;\n    L-&gt;next = NULL;\n    r = L;\n    for (i = 0; i &lt; n; ++i)\n    &#123;\n        p = new LNode;\n        cin &gt;&gt; p-&gt;data;\n        p-&gt;next = NULL;\n        r-&gt;next = p;\n        r = p;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>循环列表</strong></p>\n<p>表中最后一个结点的指针域指向头结点，整个链表形成一个环。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/4c621cb477994234a86edfc14ed6ffc8.png#pic_center\"></p>\n<p>循环列表的任何一个位置可以找到其他所有结点。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/08435057daa94fdca282f2b30b772492.png#pic_center\"><br>循环列表的合并</p>\n<p><img src=\"https://img-blog.csdnimg.cn/cd5c07d0842e4bc7893489f39ddd5afd.png#pic_center\"><br><strong>双向链表</strong></p>\n<p>结点有两个指针域的链表，称为双向链表。</p>\n<pre><code class=\"c\">typedef struct DuLNode\n&#123;\n    ElemType data;\n    struct DuLNode *prior;\n    struct DuLNode *next;\n&#125; DuLNode, *DuLinkList\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/9266a160b18e4c05ac7faa0124d17a7d.png#pic_center\"><br>双向链表的插入</p>\n<p><img src=\"https://img-blog.csdnimg.cn/6bb787d8f49244ff9d6c6ad937a2df59.png#pic_center\"></p>\n<pre><code class=\"c\">Status ListInsert_DuL(DuLinkList &amp;L, int i, ElemType e)\n&#123;\n    if (!(p = GetElem_Dul(L, i)))\n        return ERROR;\n    s = new DuLNode;\n    s-&gt;date = e;\n    s-&gt;prior = p-&gt;prior;\n    p-&gt;prior-&gt;next = s;\n    s-&gt;next = p;\n    p-&gt;prior = s;\n    return OK;\n&#125;\n</code></pre>\n<p>双向链表的删除</p>\n<p><img src=\"https://img-blog.csdnimg.cn/8a03c507aeb04b91a1e847afdb86c408.png#pic_center\"></p>\n<pre><code class=\"c\">Status ListInsert_DuL(DuLinkList &amp;L, int i)\n&#123;\n    if (!(p = GetElem_Dul(L, i)))\n        return ERROR;\n    p-&gt;prior-&gt;next = p-&gt;next;\n    p-&gt;next-&gt;prior = p-&gt;prior;\n    delete p;\n    return OK;\n&#125;\n</code></pre>\n<h2 id=\"③-单链表的顺序表示和实现实例\"><a href=\"#③-单链表的顺序表示和实现实例\" class=\"headerlink\" title=\"③.单链表的顺序表示和实现实例\"></a>③.单链表的顺序表示和实现实例</h2><p>测试样例：book.txt</p>\n<p><img src=\"https://img-blog.csdnimg.cn/03f6321c659c46148515e623f10fb0f1.png#pic_center\"></p>\n<pre><code class=\"c\">#include&lt;iostream&gt;\n#include&lt;string&gt;\n#include&lt;iomanip&gt;\n#include&lt;fstream&gt;\nusing namespace std;\n\n#define OK 1\n#define ERROR 0\n#define OVERFLOW -2\ntypedef int Status; //Status 是函数返回值类型，其值是函数结果状态代码。\ntypedef int ElemType; //ElemType 为可定义的数据类型，此设为int类型\n\nstruct Book &#123;\n    string id;//ISBN\n    string name;//书名\n    double price;//定价\n&#125;;\ntypedef struct LNode &#123;\n    Book data; //结点的数据域\n    struct LNode *next; //结点的指针域\n&#125; LNode, *LinkList; //LinkList为指向结构体LNode的指针类型\n\nstring head_1, head_2, head_3;\nint length;\n\nStatus InitList_L(LinkList &amp;L) &#123; //单链表的初始化\n    //构造一个空的单链表L\n    L = new LNode; //生成新结点作为头结点，用头指针L指向头结点\n    L-&gt;next = NULL; //头结点的指针域置空\n    return OK;\n&#125;\n\nStatus GetElem_L(LinkList L, int i, Book &amp;e) &#123; //单链表的取值\n    //在带头结点的单链表L中查找第i个元素\n    //用e返回L中第i个数据元素的值\n    int j;\n    LinkList p;\n    p = L-&gt;next;\n    j = 1; //初始化，p指向第一个结点，j为计数器\n    while (j &lt; i &amp;&amp; p) &#123; //顺链域向后扫描，直到p指向第i个元素或p为空\n        p = p-&gt;next; //p指向下一个结点\n        ++j; //计数器j相应加1\n    &#125;\n    if (!p || j &gt; i)\n        return ERROR; //i值不合法i＞n或i&lt;=0\n    e = p-&gt;data; //取第i个结点的数据域\n    return OK;\n&#125; //GetElem_L\n\nLNode *LocateElem_L(LinkList L, int e) &#123; //按值查找\n    //在带头结点的单链表L中查找值为e的元素\n    LinkList p;\n    p = L-&gt;next;\n    while (p &amp;&amp; p-&gt;data.price != e)//顺链域向后扫描，直到p为空或p所指结点的数据域等于e\n        p = p-&gt;next; //p指向下一个结点\n    return p; //查找成功返回值为e的结点地址p，查找失败p为NULL \n&#125; //LocateElem_L\n\nStatus ListInsert_L(LinkList &amp;L, int i, Book &amp;e) &#123; //单链表的插入\n    //在带头结点的单链表L中第i个位置插入值为e的新结点\n    int j;\n    LinkList p, s;\n    p = L;\n    j = 0;\n    while (p &amp;&amp; j &lt; i - 1) &#123;\n        p = p-&gt;next;\n        ++j;\n    &#125;//查找第i?1个结点，p指向该结点\n    if (!p || j &gt; i - 1)\n        return ERROR; //i＞n+1或者i＜1\n    s = new LNode; //生成新结点*s \n    s-&gt;data = e; //将结点*s的数据域置为e\n    s-&gt;next = p-&gt;next; //将结点*s的指针域指向结点ai\n    p-&gt;next = s; //将结点*p的指针域指向结点*s\n    ++length;\n    return OK;\n&#125; //ListInsert_L\n\nStatus ListDelete_L(LinkList &amp;L, int i) &#123; //单链表的删除\n    //在带头结点的单链表L中，删除第i个位置\t\n    LinkList p, q;\n    int j;\n    p = L;\n    j = 0;\n    while ((p-&gt;next) &amp;&amp; (j &lt; i - 1)) //查找结点，p指向该结点\n    &#123;\n        p = p-&gt;next;\n        ++j;\n    &#125;\n    if (!(p-&gt;next) || (j &gt; i - 1))\n        return ERROR; //当i&gt;n或i&lt;1时，删除位置不合理 \n    q = p-&gt;next; //临时保存被删结点的地址以备释放 \n    p-&gt;next = q-&gt;next; //改变删除结点前驱结点的指针域 \n    delete q; //释放删除结点的空间 \n    --length;\n    return OK;\n&#125; //ListDelete_L\n\nvoid CreateList_H(LinkList &amp;L, int n) &#123; //前插法创建单链表\n    //逆位序输入n个元素的值，建立到头结点的单链表L\n    LinkList p;\n    L = new LNode;\n    L-&gt;next = NULL; //先建立一个带头结点的空链表\n    length = 0;\n    fstream file;\n    file.open(&quot;book.txt&quot;);\n    if (!file) &#123;\n        cout &lt;&lt; &quot;未找到相关文件，无法打开！&quot; &lt;&lt; endl;\n        exit(ERROR);\n    &#125;\n    file &gt;&gt; head_1 &gt;&gt; head_2 &gt;&gt; head_3;\n    while (!file.eof()) &#123;\n        p = new LNode; //生成新结点*p\n        file &gt;&gt; p-&gt;data.id &gt;&gt; p-&gt;data.name &gt;&gt; p-&gt;data.price; //输入元素值赋给新结点*p的数据域\n        p-&gt;next = L-&gt;next;\n        L-&gt;next = p; //将新结点*p插入到头结点之后\n        length++;//同时对链表长度进行统计\n    &#125;\n    file.close();\n&#125; //CreateList_F\n\nvoid CreateList_R(LinkList &amp;L, int n) &#123; //后插法创建单链表\n    //正位序输入n个元素的值，建立带表头结点的单链表L \n    LinkList p, r;\n    L = new LNode;\n    L-&gt;next = NULL; //先建立一个带头结点的空链表\n    r = L; //尾指针r指向头结点\n    length = 0;\n    fstream file; //打开文件进行读写操作\n    file.open(&quot;book.txt&quot;);\n    if (!file) &#123;\n        cout &lt;&lt; &quot;未找到相关文件，无法打开！&quot; &lt;&lt; endl;\n        exit(ERROR);\n    &#125;\n    file &gt;&gt; head_1 &gt;&gt; head_2 &gt;&gt; head_3;\n    while (!file.eof()) &#123; //将文件中的信息运用后插法插入到链表中\n        p = new LNode;//生成新结点\n        file &gt;&gt; p-&gt;data.id &gt;&gt; p-&gt;data.name &gt;&gt; p-&gt;data.price;//输入元素值赋给新结点*p的数据域\n        p-&gt;next = NULL;\n        r-&gt;next = p;//将新结点*p插入尾结点*r之后 \t\t\n        r = p;//r指向新的尾结点*p\n        length++; //同时对链表长度进行统计\n    &#125;\n    file.close();\n&#125; //CreateList_L\n\nint main() &#123;\n    int a, n, choose;\n    double price;\n    Book e;\n    LinkList L, p;\n    cout &lt;&lt; &quot;1. 建立\\n&quot;;\n    cout &lt;&lt; &quot;2. 输入\\n&quot;;\n    cout &lt;&lt; &quot;3. 取值\\n&quot;;\n    cout &lt;&lt; &quot;4. 查找\\n&quot;;\n    cout &lt;&lt; &quot;5. 插入\\n&quot;;\n    cout &lt;&lt; &quot;6. 删除\\n&quot;;\n    cout &lt;&lt; &quot;7. 输出\\n&quot;;\n    cout &lt;&lt; &quot;0. 退出\\n\\n&quot;;\n\n    choose = -1;\n    while (choose != 0) &#123;\n        cout &lt;&lt; &quot;请选择:&quot;;\n        cin &gt;&gt; choose;\n        switch (choose) &#123;\n        case 1: //建立一个单链表\n            if (InitList_L(L))\n                cout &lt;&lt; &quot;成功建立链表!\\n\\n&quot;;\n            break;\n        case 2: //使用后插法创建单链表\n            CreateList_R(L, length);\n            cout &lt;&lt; &quot;输入 book.txt 信息完毕\\n\\n&quot;;\n            break;\n        case 3: //单链表的按序号取值\n            cout &lt;&lt; &quot;请输入一个位置用来取值:&quot;;\n            cin &gt;&gt; a;\n            if (GetElem_L(L, a, e)) &#123;\n                cout &lt;&lt; &quot;查找成功\\n&quot;;\n                cout &lt;&lt; &quot;第&quot; &lt;&lt; a &lt;&lt; &quot;本图书的信息是：\\n&quot;;\n                cout &lt;&lt; left &lt;&lt; setw(15) &lt;&lt; e.id &lt;&lt; &quot;\\t&quot; &lt;&lt; left &lt;&lt; setw(50)\n                        &lt;&lt; e.name &lt;&lt; &quot;\\t&quot; &lt;&lt; left &lt;&lt; setw(5) &lt;&lt; e.price &lt;&lt; endl\n                        &lt;&lt; endl;\n            &#125; else\n                cout &lt;&lt; &quot;查找失败\\n\\n&quot;;\n            break;\n        case 4: //单链表的按值查找\n            cout &lt;&lt; &quot;请输入所要查找价格:&quot;;\n            cin &gt;&gt; price;\n            if (LocateElem_L(L, price) != NULL) &#123;\n                cout &lt;&lt; &quot;查找成功\\n&quot;;\n                cout &lt;&lt; &quot;该价格对应的书名为：&quot; &lt;&lt; LocateElem_L(L, price)-&gt;data.name\n                        &lt;&lt; endl &lt;&lt; endl;\n            &#125; else\n                cout &lt;&lt; &quot;查找失败! 定价&quot; &lt;&lt; price &lt;&lt; &quot; 没有找到\\n\\n&quot;;\n            break;\n        case 5: //单链表的插入\n            cout &lt;&lt; &quot;请输入插入的位置和书的信息，包括：编号 书名 价格（用空格隔开）:&quot;;\n            cin &gt;&gt; a;\n            cin &gt;&gt; e.id &gt;&gt; e.name &gt;&gt; e.price;\n            if (ListInsert_L(L, a, e))\n                cout &lt;&lt; &quot;插入成功.\\n\\n&quot;;\n            else\n                cout &lt;&lt; &quot;插入失败!\\n\\n&quot;;\n            break;\n        case 6: //单链表的删除\n            cout &lt;&lt; &quot;请输入所要删除的书籍的位置:&quot;;\n            cin &gt;&gt; a;\n            if (ListDelete_L(L, a))\n                cout &lt;&lt; &quot;删除成功!\\n\\n&quot;;\n            else\n                cout &lt;&lt; &quot;删除失败!\\n\\n&quot;;\n            break;\n        case 7: //单链表的输出\n            cout &lt;&lt; &quot;当前图书系统信息（链表）读出:\\n&quot;;\n            p = L-&gt;next;\n            while (p) &#123;\n                cout &lt;&lt; left &lt;&lt; setw(15) &lt;&lt; p-&gt;data.id &lt;&lt; &quot;\\t&quot; &lt;&lt; left &lt;&lt; setw(\n                        50) &lt;&lt; p-&gt;data.name &lt;&lt; &quot;\\t&quot; &lt;&lt; left &lt;&lt; setw(5)\n                        &lt;&lt; p-&gt;data.price &lt;&lt; endl;\n                p = p-&gt;next;\n            &#125;\n            cout &lt;&lt; endl;\n            break;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<hr>\n<h1 id=\"5、顺序表和链表的比较\"><a href=\"#5、顺序表和链表的比较\" class=\"headerlink\" title=\"5、顺序表和链表的比较\"></a>5、顺序表和链表的比较</h1><p><img src=\"https://img-blog.csdnimg.cn/7164d32e1fb84314aab40afd3eb21ab9.png#pic_center\"></p>\n<hr>\n<h1 id=\"6、例题与应用\"><a href=\"#6、例题与应用\" class=\"headerlink\" title=\"6、例题与应用\"></a>6、例题与应用</h1><p><img src=\"https://img-blog.csdnimg.cn/e05176cd594c4a708b3a92e2398e8efc.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/bf7991a9fc1a445bb0769da6ce1d90e8.png#pic_center\"><br><strong>线性表的典型算法实现：</strong></p>\n<ol>\n<li>   假设有两个按元素值递增有序排列的线性表A和B，均以单链表作为存储结构，请编写算法将A表和B表归并成一个按元素值递减有序（即非递增有序，允许表中含有值相同的元素）排列的线性表C，并要求利用原表（即A表和B表）的结点空间构造C表。</li>\n<li>   编程实现如下功能：<br>（1）根据输入的一系列整数，以0标志结束，用头插法建立单链表，并输出单链表中各元素值，观察输入的内容与输出的内容是否一致。<br>（2）在单链表的第i个元素之前插入一个值为x的元素，并输出插入后的单链表中各元素值。<br>（3）删除单链表中第i个元素，并输出删除后的单链表中各元素值。<br>（4）在单链表中查找第i个元素，如果查找成功，则显示该元素的值，否则显示该元素不存在。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/6fd318d71e40452ab690c6432e3c90dd.png#pic_center\"></p>\n<pre><code class=\"c\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\ntypedef struct Node\n&#123;\n    int data;\n    struct Node *next;\n&#125; LNode, *LinkList;\n\nLinkList CreateList() //创建单链表\n&#123;\n    LinkList L;\n    LNode *p;\n    int c;\n    L = new LNode;\n    L-&gt;next = NULL; //建立带头结点的空链表\n    cin &gt;&gt; c;\n    while (c != 0)\n    &#123;\n        p = new LNode;\n        p-&gt;data = c;\n        p-&gt;next = L-&gt;next; //将新结点插入到头结点之后\n        L-&gt;next = p;\n        cin &gt;&gt; c;\n    &#125;\n    return L;\n&#125;\n\nvoid ShowList(LinkList L) //显示单链表\n&#123;\n    LNode *p;\n    p = L-&gt;next;      //指向首元结点\n    while (p != NULL) //对单链表进行遍历\n    &#123;\n        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;\n        p = p-&gt;next;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid ReverseList(LinkList L) //逆置单链表\n&#123;\n    LNode *p, *q;\n    p = L-&gt;next;\n    L-&gt;next = NULL; //将已有的数据元素再次插入，实现逆序\n    while (p != NULL)\n    &#123;\n        q = p-&gt;next;\n        p-&gt;next = L-&gt;next;\n        L-&gt;next = p;\n        p = q;\n    &#125;\n&#125;\n\nLinkList MergeList(LinkList LA, LinkList LB) //合并单链表\n&#123;\n    ReverseList(LA); //逆置链表LA\n    ReverseList(LB); //逆置链表LB\n    LinkList LC;\n    LNode *pa, *pb, *r;\n    pa = LA-&gt;next;\n    pb = LB-&gt;next;\n    LC = LA;\n    LC-&gt;next = NULL;\n    r = LC;\n    while (pa != NULL &amp;&amp; pb != NULL)\n    &#123;\n        if (pa-&gt;data &lt;= pb-&gt;data) //比较数据元素大小\n        &#123;\n            r-&gt;next = pb;\n            r = pb;\n            pb = pb-&gt;next;\n        &#125;\n        else\n        &#123;\n            r-&gt;next = pa;\n            r = pa;\n            pa = pa-&gt;next;\n        &#125;\n\n        if (pa)\n        &#123;\n            r-&gt;next = pa;\n        &#125;\n        else\n        &#123;\n            r-&gt;next = pb;\n        &#125;\n    &#125;\n    return LC;\n&#125;\n\nint Insert(LinkList &amp;L, int i, int e) //插入数据元素\n&#123;\n    LinkList t, p;\n    int j = 1;\n    t = L;\n    if (i &lt; 1)\n    &#123;\n        cout &lt;&lt; &quot;插入错误&quot; &lt;&lt; endl;\n        return 0;\n    &#125;\n    if (i == 1) //插入位置在表头\n    &#123;\n        p = new LNode;\n        p-&gt;data = e;\n        p-&gt;next = t-&gt;next;\n        L-&gt;next = p;\n        cout &lt;&lt; &quot;插入成功&quot; &lt;&lt; endl;\n        return 0;\n    &#125;\n    while (j &lt; i - 1 &amp;&amp; L) //异常判断\n    &#123;\n        t = t-&gt;next;\n        j++;\n        if (t == NULL)\n        &#123;\n            cout &lt;&lt; &quot;插入错误&quot; &lt;&lt; endl;\n            return 0;\n        &#125;\n    &#125;\n    t = t-&gt;next; //插在非表头\n    p = new LNode;\n    p-&gt;data = e;\n    p-&gt;next = t-&gt;next;\n    t-&gt;next = p;\n    cout &lt;&lt; &quot;插入成功&quot; &lt;&lt; endl;\n&#125;\n\nint Delete(LinkList &amp;L, int i) //删除数据元素\n&#123;\n    LinkList p, t;\n    int j = 0;\n    p = L;\n    if (i &lt; 1)\n    &#123;\n        cout &lt;&lt; &quot;删除失败&quot; &lt;&lt; endl;\n        return 0;\n    &#125;\n    while (j &lt; i - 1 &amp;&amp; L)\n    &#123;\n        p = p-&gt;next;\n        j++;\n        if (p == NULL)\n        &#123;\n            cout &lt;&lt; &quot;删除失败&quot; &lt;&lt; endl;\n            return 0;\n        &#125;\n    &#125;\n    t = p-&gt;next;\n    p-&gt;next = t-&gt;next;\n    cout &lt;&lt; &quot;删除成功&quot; &lt;&lt; endl;\n    delete t;\n&#125;\n\nint SecrchList(LinkList &amp;L, int i) //查找数据元素\n&#123;\n    LinkList p;\n    int j = 0, e;\n    p = L;\n    if (i &lt; 1)\n    &#123;\n        cout &lt;&lt; &quot;查找失败，该元素不存在&quot; &lt;&lt; endl;\n        return 0;\n    &#125;\n    while (j &lt; i &amp;&amp; L)\n    &#123;\n        p = p-&gt;next;\n        j++;\n        if (p == NULL)\n        &#123;\n            cout &lt;&lt; &quot;查找失败，该元素不存在&quot; &lt;&lt; endl;\n            return 0;\n        &#125;\n    &#125;\n    e = p-&gt;data;\n    cout &lt;&lt; &quot;查找成功，第&quot; &lt;&lt; i &lt;&lt; &quot;个元素为&quot; &lt;&lt; e &lt;&lt; endl;\n&#125;\n\nint main(void)\n&#123;\n    int i, e, select;\n\n    LinkList LA;\n    cout &lt;&lt; &quot;请输入单链表A的数据元素：&quot; &lt;&lt; endl;\n    LA = CreateList();\n    getchar();\n    cout &lt;&lt; &quot;请输入单链表B的数据元素：&quot; &lt;&lt; endl;\n    LinkList LB;\n    LB = CreateList();\n\n    cout &lt;&lt; &quot;单链表LA:&quot; &lt;&lt; endl;\n    ShowList(LA);\n    cout &lt;&lt; &quot;单链表LB:&quot; &lt;&lt; endl;\n    ShowList(LB);\n\n    LinkList LC;\n    LC = MergeList(LA, LB);\n    cout &lt;&lt; &quot;合并单链表LA和单链表LB:&quot; &lt;&lt; endl;\n    ShowList(LC);\n    while (1)\n    &#123;\n        cout &lt;&lt; &quot;\\n*****1.插入  2.删除  3.查找  4.退出*****\\n&quot;;\n        cin &gt;&gt; select;\n        switch (select)\n        &#123;\n        case 1:\n            cout &lt;&lt; &quot;输入位置和要插入的元素:&quot; &lt;&lt; endl;\n            cin &gt;&gt; i &gt;&gt; e;\n            Insert(LC, i, e);\n            ShowList(LC);\n            break;\n        case 2:\n            cout &lt;&lt; &quot;输入要删除的元素的位置&quot; &lt;&lt; endl;\n            cin &gt;&gt; i;\n            Delete(LC, i);\n            ShowList(LC);\n            break;\n        case 3:\n            cout &lt;&lt; &quot;输入要查找的元素的位置&quot; &lt;&lt; endl;\n            cin &gt;&gt; i;\n            SecrchList(LC, i);\n            break;\n        case 4:\n            return 0;\n            break;\n        default:\n            cout &lt;&lt; &quot;输入错误，请重新输入！&quot; &lt;&lt; endl;\n            break;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n","feature":true,"text":"线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素，这种表示也称作线性表的顺序存储结构或顺序映像。线性表链式存储结构的特点：用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。...","permalink":"/post/数据结构（C语言版）-- 线性表笔记","photos":[],"count_time":{"symbolsCount":"26k","symbolsTime":"24 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"字节跳动青训营","slug":"字节跳动青训营","count":21,"path":"api/tags/字节跳动青训营.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">1、线性表的定义与特点</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">2、线性表的类型定义</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%92%8C%E8%A1%A8%E7%A4%BA\"><span class=\"toc-text\">3、线性表的顺序实现和表示</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA\"><span class=\"toc-text\">①.线性表的顺序存储表示</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%AD%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">②.顺序表中基本操作的实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A2-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%AE%9E%E4%BE%8B\"><span class=\"toc-text\">③.顺序表的顺序表示和实现实例</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">4、线性表的链式表示和实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%A1%A8%E7%A4%BA\"><span class=\"toc-text\">①.单链表的定义和表示</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E5%8D%95%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">②.单链表基本操作的实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A2-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%AE%9E%E4%BE%8B\"><span class=\"toc-text\">③.单链表的顺序表示和实现实例</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5%E3%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">5、顺序表和链表的比较</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#6%E3%80%81%E4%BE%8B%E9%A2%98%E4%B8%8E%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">6、例题与应用</span></a></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"栈和队列","uid":"32e8754bc216ad5a6afe6dae9987332f","slug":"数据结构（C语言版）-- 栈和队列笔记","date":"2022-02-13T02:39:25.000Z","updated":"2025-07-14T15:12:20.469Z","comments":true,"path":"api/articles/数据结构（C语言版）-- 栈和队列笔记.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/68983f406bb44b89b7de3accaf6351a4.png","text":"栈( stack）是限定仅在表尾进行插人或删除操作的线性表。因此，对栈来说，表尾端有其特殊含义，称为栈顶( top )，相应地，表头端称为栈底（ bottom )。不含元素的空表称为空栈。...","permalink":"/post/数据结构（C语言版）-- 栈和队列笔记","photos":[],"count_time":{"symbolsCount":"28k","symbolsTime":"25 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"字节跳动青训营","slug":"字节跳动青训营","count":21,"path":"api/tags/字节跳动青训营.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true},"next_post":{"title":"小游戏开发","uid":"aaa9ceedcc6e20da90d5782857e132e7","slug":"青训营--小游戏开发","date":"2022-02-08T02:41:06.000Z","updated":"2025-07-14T15:12:20.472Z","comments":true,"path":"api/articles/青训营--小游戏开发.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/3112c385d3c845d4b0305beebbc3ffdf.jpeg","text":"小游戏开发是当前热门的领域之一，它结合了游戏设计和软件开发技术。本文将介绍常见的小游戏开发平台和工具，如Unity、Cocos Creator等，并深入讨论游戏场景设计、角色控制、碰撞检测、音效处理等关键技术。...","permalink":"/post/青训营--小游戏开发","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"字节跳动青训营","slug":"字节跳动青训营","count":21,"path":"api/tags/字节跳动青训营.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":false}}