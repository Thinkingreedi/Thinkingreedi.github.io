{"title":"Node.js入门指南","uid":"49049ff97839855eecbcd2b661106a8a","slug":"前端--详解Node.js(快速入门)","date":"2023-01-26T00:36:42.000Z","updated":"2025-07-14T15:12:20.467Z","comments":true,"path":"api/articles/前端--详解Node.js(快速入门).json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/b0f0273b8a054a6d9c9e5d3f2a5c267f.png","content":"<h1 id=\"Node-js\"><a href=\"#Node-js\" class=\"headerlink\" title=\"Node.js\"></a>Node.js</h1><h2 id=\"1、初识Node-js与内置模块\"><a href=\"#1、初识Node-js与内置模块\" class=\"headerlink\" title=\"1、初识Node.js与内置模块\"></a>1、初识Node.js与内置模块</h2><h3 id=\"1-1-Node-js初识\"><a href=\"#1-1-Node-js初识\" class=\"headerlink\" title=\"1.1 Node.js初识\"></a>1.1 Node.js初识</h3><p><strong>JavaScript可以在浏览器中执行</strong></p>\n<ul>\n<li>不同的浏览器使用不同的JavaScript解析引擎:<ul>\n<li>Chrome浏览器 &#x3D;&gt;  v8</li>\n<li>Firefox浏览器 &#x3D;&gt;  OdinMonkey(奥丁猴)</li>\n<li>Safri浏览器 &#x3D;&gt;  JSCore</li>\n<li>IE浏览器 &#x3D;&gt; Chakra(查克拉)</li>\n<li>etc…</li>\n</ul>\n</li>\n<li>其中，<strong>Chrome浏览器的V8解析引擎性能最好</strong>!</li>\n</ul>\n<p><strong>JavaScript操作DOM和BOM</strong></p>\n<ul>\n<li>每个浏览器都内置了DOM、BOM这样的API函数，因此，浏览器中的JavaScript才可以调用它们</li>\n</ul>\n<p><strong>浏览器中的JavaScript运行环境</strong></p>\n<ul>\n<li>运行环境是指代码正常运行所需的必要环境</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/38f6ee6b630349f0bd93d9c91520a37f.png#pic_center\"></p>\n<ul>\n<li>总结:<ul>\n<li>v8引擎负责解析和执行JavaScript 代码</li>\n<li>内置API是由运行环境提供的特殊接口，只能在所属的运行环境中被调用</li>\n</ul>\n</li>\n</ul>\n<p><strong>Node.js简介</strong></p>\n<ul>\n<li><p>Node.js is a JavaScript runtime built on Chrome’s V8 JavaScript engine</p>\n</li>\n<li><p>Node.js是一个基于Chrome V8引擎的<strong>JavaScript运行环境</strong></p>\n</li>\n<li><p>Node.js 的官网地址: <a href=\"https://nodejs.org/zh-cn/\">https://nodejs.org/zh-cn/</a></p>\n</li>\n<li><p>注意：</p>\n<ul>\n<li><strong>浏览器</strong>是JavaScript的前端运行环境</li>\n<li><strong>Node.js</strong>是JavaScript的后端运行环境</li>\n<li>Node.js中<strong>无法调用DOM和 BOM等浏览器内置API</strong></li>\n</ul>\n</li>\n<li><p>用途：</p>\n<ul>\n<li>基于Express框架（<a href=\"http://www.expressjs.com.cn/)%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BAWeb%E5%BA%94%E7%94%A8\">http://www.expressjs.com.cn/)，可以快速构建Web应用</a></li>\n<li>基于Electron框架(<a href=\"https://electronjs.org/)%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%9E%84%E5%BB%BA%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8\">https://electronjs.org/)，可以构建跨平台的桌面应用</a></li>\n<li>基于restify框架(<a href=\"http://restify.com/)%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BAAPI%E6%8E%A5%E5%8F%A3%E9%A1%B9%E7%9B%AE\">http://restify.com/)，可以快速构建API接口项目</a></li>\n<li>读写和操作数据库、创建实用的命令行工具辅助前端开发、etc…</li>\n</ul>\n</li>\n</ul>\n<p><strong>Node.js的安装</strong></p>\n<ul>\n<li><p>安装包可以从Node.js的官网首页直接下载，进入到Node.js的官网首页(<a href=\"https://nodejs.org/en/\">https://nodejs.org/en/</a>) node.js中文网 (<a href=\"http://nodejs.cn/\">Node.js 中文网 (nodejs.cn)</a>)，点击绿色的按钮，下载所需的版本后，双击直接安装即可</p>\n</li>\n<li><p>LTS为长期稳定版，对于追求稳定性的企业级项目来说，推荐安装LTS版本的Node.js</p>\n</li>\n<li><p>Current为新特性尝鲜版，对热衷于尝试新特性的用户来说，推荐安装Current版本的Node.js。但是，Current 版本中可能存在隐藏的Bug 或安全性漏洞，因此不推荐在企业级项目中使用Current版本的Node.js</p>\n</li>\n<li><p>打开终端，在终端输入命令node -v后，按下回车键，即可查看已安装的Node.js的版本号</p>\n</li>\n<li><p>在Node.js环境中执行JavaScript 代码</p>\n<ol>\n<li>打开终端</li>\n<li>输入node要执行的js文件的路径</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"1-2-fs文件系统模块\"><a href=\"#1-2-fs文件系统模块\" class=\"headerlink\" title=\"1.2 fs文件系统模块\"></a>1.2 fs文件系统模块</h3><p><strong>fs文件系统模块概述</strong></p>\n<ul>\n<li>fs模块是Node.js官方提供的、用来操作文件的模块。它提供了一系列的方法和属性，用来满足用户对文件的操作需求、例如:<ul>\n<li>fs.readFile()方法，用来<strong>读取</strong>指定文件中的内容</li>\n<li>fs.writeFile()方法，用来向指定的文件中<strong>写入</strong>内容</li>\n</ul>\n</li>\n</ul>\n<p><strong>读取指定文件中的内容</strong></p>\n<ul>\n<li>使用fs.readFile()方法，可以读取指定文件中的内容，语法格式如下:</li>\n</ul>\n<pre><code class=\"js\">fs.readFile(path[, options], callback)\n</code></pre>\n<ul>\n<li>参数解读:<ul>\n<li>参数1:<strong>必选</strong>参数，字符串，表示文件的路径</li>\n<li>参数2:可选参数，表示以什么<strong>编码格式</strong>来读取文件</li>\n<li>参数3:<strong>必选</strong>参数，文件读取完成后，通过回调函数拿到读取的结果</li>\n</ul>\n</li>\n<li>代码：</li>\n</ul>\n<pre><code class=\"js\">// 1. 导入 fs 模块，来操作文件\nconst fs = require(&#39;fs&#39;)\n\n// 2. 调用 fs.readFile() 方法读取文件\n//    参数1：读取文件的存放路径\n//    参数2：读取文件时候采用的编码格式，一般默认指定 utf8\n//    参数3：回调函数，拿到读取失败和成功的结果  err  dataStr\nfs.readFile(&#39;./files/1.txt&#39;, &#39;utf8&#39;, function (err, dataStr) &#123;\n  // 2.1 打印失败的结果\n  // 如果读取成功，则 err 的值为 null\n  // 如果读取失败，则 err 的值为 错误对象，dataStr 的值为 undefined\n  console.log(err)\n  console.log(&#39;-------&#39;)\n  // 2.2 打印成功的结果\n  console.log(dataStr)\n&#125;)\n</code></pre>\n<ul>\n<li>判断文件是否读取成功：</li>\n</ul>\n<pre><code class=\"js\">const fs = require(&#39;fs&#39;)\n\nfs.readFile(&#39;./files/1.txt&#39;, &#39;utf8&#39;, function(err, dataStr) &#123;\n  if (err) &#123;\n    return console.log(&#39;读取文件失败！&#39; + err.message)\n  &#125;\n  console.log(&#39;读取文件成功！&#39; + dataStr)\n&#125;)\n</code></pre>\n<p><strong>向指定文件写入内容</strong></p>\n<ul>\n<li>使用fs.writeFile()方法，可以向指定的文件中写入内容，语法格式如下:</li>\n</ul>\n<pre><code class=\"js\">fs.writeFile(file,data[, options], callback)\n</code></pre>\n<ul>\n<li>参数解读:<ul>\n<li>参数1:<strong>必选</strong>参数，需要指定一个文件路径的字符串，表示文件的存放路径</li>\n<li>参数2:<strong>必选</strong>参数，表示要写入的内容</li>\n<li>参数3:可选参数，表示以什么格式写入文件内容，默认值是utf-8</li>\n<li>参数4:<strong>必选</strong>参数，文件写入完成后的回调函数</li>\n</ul>\n</li>\n<li>代码：</li>\n</ul>\n<pre><code class=\"js\">// 1. 导入 fs 文件系统模块\nconst fs = require(&#39;fs&#39;)\n\n// 2. 调用 fs.writeFile() 方法，写入文件的内容\n//    参数1：表示文件的存放路径\n//    参数2：表示要写入的内容\n//    参数3：回调函数\nfs.writeFile(&#39;./files/2.txt&#39;, &#39;Hello&#39;, function (err) &#123;\n  // 2.1 如果文件写入成功，则 err 的值等于 null\n  // 2.2 如果文件写入失败，则 err 的值等于一个 错误对象\n  // console.log(err)\n\n  if (err) &#123;\n    return console.log(&#39;文件写入失败！&#39; + err.message)\n  &#125;\n  console.log(&#39;文件写入成功！&#39;)\n&#125;)\n</code></pre>\n<p><strong>fs模块–路径动态拼接的问题</strong></p>\n<ul>\n<li><p>在使用fs 模块操作文件时，如果提供的操作路径是以.&#x2F;或..&#x2F;开头的相对路径时，(非当前目录时)很容易出现路径动态拼接错误的问题</p>\n</li>\n<li><p>原因:代码在运行的时候，会以执行node命令时所处的目录，动态拼接出被操作文件的完整路径</p>\n</li>\n<li><p>解决方案:在使用fs模块操作文件时，直接提供完整的路径，不要提供.&#x2F;或..&#x2F;开头的相对路径，从而防止路径动态拼接的问题</p>\n</li>\n<li><p>代码：</p>\n</li>\n</ul>\n<pre><code class=\"JavaScript\">// __dirname 表示当前文件所处的目录\nfs.readFile(__dirname + &#39;/files/1.txt&#39;, &#39;utf8&#39;, function(err, dataStr) &#123;\n  if (err) &#123;\n    return console.log(&#39;读取文件失败！&#39; + err.message)\n  &#125;\n  console.log(&#39;读取文件成功！&#39; + dataStr)\n&#125;)\n</code></pre>\n<h3 id=\"1-3-path路径模块\"><a href=\"#1-3-path路径模块\" class=\"headerlink\" title=\"1.3 path路径模块\"></a>1.3 path路径模块</h3><p><strong>path路径模块概述</strong></p>\n<ul>\n<li>path模块是Node.js官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理需求</li>\n<li>例如:<ul>\n<li>path.join()方法，用来将多个路径片段拼接成一个完整的路径字符串</li>\n<li>path.basename()方法，用来从路径字符串中，将文件名解析出来</li>\n</ul>\n</li>\n</ul>\n<p><strong>路径拼接</strong></p>\n<ul>\n<li>使用path.join(方法，可以把多个路径片段拼接为完整的路径字符串，语法格式如下:</li>\n</ul>\n<pre><code class=\"js\">path.join( [ .. .paths])\n</code></pre>\n<ul>\n<li>参数解读:<ul>\n<li>…paths &lt; string &gt;路径片段的序列</li>\n<li>返回值: &lt; string &gt;</li>\n</ul>\n</li>\n<li>代码：</li>\n</ul>\n<pre><code class=\"js\">//注意：  ../ 会抵消前面的路径\nconst pathStr = path.join(&#39;/a&#39;, &#39;/b/c&#39;, &#39;../&#39;, &#39;./d&#39;, &#39;e&#39;)\nconsole.log(pathStr)  // \\a\\b\\d\\e\n</code></pre>\n<ul>\n<li>注意:今后凡是涉及到路径拼接的操作，都要使用path.join()方法进行处理，不要直接使用＋进行字符串的拼接</li>\n<li>代码：</li>\n</ul>\n<pre><code class=\"js\">fs.readFile(path.join(__dirname, &#39;./files/1.txt&#39;), &#39;utf8&#39;, function (err, dataStr) &#123;\n  if (err) &#123;\n    return console.log(err.message)\n  &#125;\n  console.log(dataStr)\n&#125;)\n</code></pre>\n<p><strong>获取路径中的文件名</strong></p>\n<ul>\n<li>使用path.basename()方法，可以获取路径中的最后一部分，经常通过这个方法获取路径中的文件名，语法格式如下:</li>\n</ul>\n<pre><code class=\"js\">path.basename(path[, ext])\n</code></pre>\n<ul>\n<li><p>参数解读:</p>\n<ul>\n<li>path &lt; string &gt;必选参数，表示—个路径的字符串</li>\n<li>ext &lt; string &gt;可选参数，表示文件扩展名</li>\n<li>返回: &lt; string &gt;表示路径中的最后—部分</li>\n</ul>\n</li>\n<li><p>代码：</p>\n</li>\n</ul>\n<pre><code class=\"js\">const path = require(&#39;path&#39;)\n\n// 定义文件的存放路径\nconst fpath = &#39;/a/b/c/index.html&#39;\n\nconst fullName = path.basename(fpath)\nconsole.log(fullName)//index.html\n\nconst nameWithoutExt = path.basename(fpath, &#39;.html&#39;)\nconsole.log(nameWithoutExt)//index\n</code></pre>\n<p><strong>获取路径中的文件扩展名</strong></p>\n<ul>\n<li>使用path.extname)方法，可以获取路径中的扩展名部分，语法格式如下:</li>\n</ul>\n<pre><code class=\"js\">path.extname(path)\n</code></pre>\n<ul>\n<li><p>参数解读:</p>\n<ul>\n<li>path &lt; string &gt;必选参数，表示—个路径的字符串</li>\n<li>返回:&lt; string &gt;返回得到的扩展名字符串</li>\n</ul>\n</li>\n<li><p>代码：</p>\n</li>\n</ul>\n<pre><code class=\"js\">const path = require(&#39;path&#39;)\n\n// 这是文件的存放路径\nconst fpath = &#39;/a/b/c/index.html&#39;\n\nconst fext = path.extname(fpath)\nconsole.log(fext)\n</code></pre>\n<h3 id=\"1-4-http模块\"><a href=\"#1-4-http模块\" class=\"headerlink\" title=\"1.4 http模块\"></a>1.4 http模块</h3><p> <strong>http模块概述</strong></p>\n<ul>\n<li>在网络节点中，负责消费资源的电脑，叫做<strong>客户端</strong>;负责对外提供网络资源的电脑，叫做<strong>服务器</strong></li>\n<li>http模块是Node.js官方提供的、用来创建web服务器的模块。通过http模块提供的 http.createServer(方法，就能方便的把一台普通的电脑，变成一台Web服务器，从而对外提供Web 资源服务</li>\n<li>服务器和普通电脑的区别在于，服务器上安装了web服务器软件，例如:lIS、Apache等。通过安装这些服务器软件，就能把一台普通的电脑变成一台web服务器</li>\n<li>在Node.js 中，我们不需要使用IIS、Apache等这些第三方web服务器软件。因为我们可以基于Node.js 提供的http模块，通过几行简单的代码，就能轻松的手写一个服务器软件，从而对外提供web服务</li>\n</ul>\n<p><strong>服务器相关概念：</strong></p>\n<p>1、IP地址</p>\n<ul>\n<li>IP地址就是互联网上每台计算机的唯一地址，因此IP地址具有唯一性。如果把“个人电脑”比作“一台电话”，那么“IP地址”就相当于“电话号码”，只有在知道对方IP地址的前提下，才能与对应的电脑之间进行数据通信</li>\n<li>IP地址的格式:通常用“点分十进制”表示成(a.b.c.d)的形式其中，a,b,c,d都是0~255之间的十进制整数。例如:用点分十进表示的IP地址(192.168.1.1)</li>\n<li>注意:<ul>\n<li>互联网中每台Web服务器，都有自己的IP地址，例如:大家可以在Windows的终端中运行<strong>ping <a href=\"http://www.baidu.com/\">www.baidu.com</a> 命令</strong>，即可查看到百度服务器的IP地址</li>\n<li>在开发期间，自己的电脑既是一台服务器，也是一个客户端，为了方便测试，可以在自己的浏览器中输入<strong>127.0.0.1</strong>这个IP地址，就能把自己的电脑当做一台服务器进行访问了</li>\n</ul>\n</li>\n</ul>\n<p>2、域名和域名服务器</p>\n<ul>\n<li>尽管IP地址能够唯一地标记网络上的计算机，但IP地址是一长串数字，不直观，而且不便于记忆，于是人们又发明了另一套字符型的地址方案，即所谓的域名(Domain Name)地址</li>\n<li>IP地址和域名是——对应的关系，这份对应关系存放在一种叫做域名服务器(DNS,Domain name server)的电脑中。使用者只需通过好记的域名访问对应的服务器即可，对应的转换工作由域名服务器实现。因此，域名服务器就是提供IР地址和域名之问的转换服务的服务器</li>\n<li>注意:<ul>\n<li>单纯使用IP地址，互联网中的电脑也能够正常工作。但是有了域名的加持，能让互联网的世界变得更加方便</li>\n<li>在开发测试期间，<strong>127.0.0.1对应的域名是localhost</strong>，它们都代表我们自己的这台电脑，在使用效果上没有任何区别</li>\n</ul>\n</li>\n</ul>\n<p>3、端口号</p>\n<ul>\n<li>计算机中的端口号，就好像是现实生活中的门牌号一样。通过门牌号，外卖小哥可以在整栋大楼众多的房间中，准确把外卖送到你的手中</li>\n<li>同样的道理，在一台电脑中，可以运行成百上千个web服务。每个web服务都对应一个唯一的端口号。客户端发送过来的网络请求，通过端口号，可以被准确地交给对应的web服务进行处理</li>\n<li>注意:<ul>\n<li>每个端口号不能同时被多个web 服务占用</li>\n<li><strong>在实际应用中，URL中的80端口可以被省略</strong></li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/75e1bcc05c9f463f9726e1ed9802fff5.png#pic_center\"></p>\n<p><strong>创建最基本的web服务器</strong></p>\n<ul>\n<li>步骤</li>\n</ul>\n<ol>\n<li>导入http模块</li>\n</ol>\n<ul>\n<li>如果希望在自己的电脑上创建一个web服务器，从而对外提供web 服务，则需要导入http模块</li>\n</ul>\n<ol start=\"2\">\n<li>创建web 服务器实例</li>\n</ol>\n<ul>\n<li>调用http.createServer()方法，即可快速创建一个 web 服务器实例</li>\n</ul>\n<ol start=\"3\">\n<li>为服务器实例绑定request事件，监听客户端的请求</li>\n</ol>\n<ul>\n<li>为服务器实例绑定request事件，即可监听客户端发送过来的网络请求</li>\n</ul>\n<ol start=\"4\">\n<li>启动服务器</li>\n</ol>\n<ul>\n<li>调用服务器实例的.listen0方法，即可启动当前的web 服务器实例</li>\n<li>代码：</li>\n</ul>\n<pre><code class=\"js\">// 1. 导入 http 模块\nconst http = require(&#39;http&#39;)\n// 2. 创建 web 服务器实例\nconst server = http.createServer()\n// 3. 为服务器实例绑定 request 事件，监听客户端的请求\nserver.on(&#39;request&#39;, function (req, res) &#123;\n  console.log(&#39;Someone visit our web server.&#39;)\n&#125;)\n// 4. 启动服务器\nserver.listen(8080, function () &#123;  \n  console.log(&#39;server running at http://127.0.0.1:8080&#39;)\n&#125;)\n</code></pre>\n<ul>\n<li><p>req请求对象</p>\n</li>\n<li><p>只要服务器接收到了客户端的请求，就会调用通过server.on为服务器绑定的 request事件处理函数。如果想在事件处理函数中，访问与客户端相关的数据或属性，可以使用如下的方式:</p>\n</li>\n<li><p>res响应对象</p>\n</li>\n<li><p>在服务器的request事件处理函数中，如果想访问与服务器相关的数据或属性，可以使用如下的方式:</p>\n</li>\n</ul>\n<pre><code class=\"js\">server.on(&#39;request&#39;, (req, res) =&gt; &#123;\n  // req.url 是客户端请求的 URL 地址\n  const url = req.url\n  // req.method 是客户端请求的 method 类型\n  const method = req.method\n  const str = `Your request url is $&#123;url&#125;, and request method is $&#123;method&#125;`\n  console.log(str)\n  // 调用 res.end() 方法，向客户端响应一些内容\n  res.end(str)\n&#125;)\n</code></pre>\n<ul>\n<li>解决中文乱码问题</li>\n<li>当调用res.end()方法，向客户端发送中文内容的时候，会出现乱码问题，此时，需要手动设置内容的编码格式:</li>\n</ul>\n<pre><code class=\"js\">server.on(&#39;request&#39;, (req, res) =&gt; &#123;\n  // 定义一个字符串，包含中文的内容\n  const str = `您请求的 URL 地址是 $&#123;req.url&#125;，请求的 method 类型为 $&#123;req.method&#125;`\n  // 调用 res.setHeader() 方法，设置 Content-Type 响应头，解决中文乱码的问题\n  res.setHeader(&#39;Content-Type&#39;, &#39;text/html; charset=utf-8&#39;)\n  // res.end() 将内容响应给客户端\n  res.end(str)\n&#125;)\n</code></pre>\n<p><strong>根据不同的url响应不同的html内容</strong></p>\n<ol>\n<li>获取请求的url地址</li>\n<li>设置默认的响应内容为404 Not found</li>\n<li>判断用户请求的是否为&#x2F;或&#x2F;index.html首页</li>\n<li>判断用户请求的是否为&#x2F;about.html关于页面</li>\n<li>设置Content-Type响应头，防止中文乱码</li>\n<li>使用res.end()把内容响应给客户端</li>\n</ol>\n<ul>\n<li>代码：</li>\n</ul>\n<pre><code class=\"js\">const http = require(&#39;http&#39;)\nconst server = http.createServer()\n\nserver.on(&#39;request&#39;, (req, res) =&gt; &#123;\n  // 1. 获取请求的 url 地址\n  const url = req.url\n  // 2. 设置默认的响应内容为 404 Not found\n  let content = &#39;&lt;h1&gt;404 Not found!&lt;/h1&gt;&#39;\n  // 3. 判断用户请求的是否为 / 或 /index.html 首页\n  // 4. 判断用户请求的是否为 /about.html 关于页面\n  if (url === &#39;/&#39; || url === &#39;/index.html&#39;) &#123;\n    content = &#39;&lt;h1&gt;首页&lt;/h1&gt;&#39;\n  &#125; else if (url === &#39;/about.html&#39;) &#123;\n    content = &#39;&lt;h1&gt;关于页面&lt;/h1&gt;&#39;\n  &#125;\n  // 5. 设置 Content-Type 响应头，防止中文乱码\n  res.setHeader(&#39;Content-Type&#39;, &#39;text/html; charset=utf-8&#39;)\n  // 6. 使用 res.end() 把内容响应给客户端\n  res.end(content)\n&#125;)\n\nserver.listen(80, () =&gt; &#123;\n  console.log(&#39;server running at http://127.0.0.1&#39;)\n&#125;)\n</code></pre>\n<h2 id=\"2、模块化\"><a href=\"#2、模块化\" class=\"headerlink\" title=\"2、模块化\"></a>2、模块化</h2><h3 id=\"2-1-模块化的基本概念\"><a href=\"#2-1-模块化的基本概念\" class=\"headerlink\" title=\"2.1 模块化的基本概念\"></a>2.1 模块化的基本概念</h3><p><strong>什么是模块化</strong></p>\n<ul>\n<li>模块化是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过程，对于整个系统来说，模块是可组合、分解和更换的单元</li>\n<li>编程领域中的模块化，就是遵守固定的规则，把一个大文件拆成独立并互相依赖的多个小模块。</li>\n<li>把代码进行模块化拆分的好处:<ul>\n<li>提高了代码的<strong>复用性</strong></li>\n<li>提高了代码的<strong>可维护性</strong></li>\n<li>可以实现<strong>按需加载</strong></li>\n</ul>\n</li>\n</ul>\n<p><strong>模块化规范</strong></p>\n<ul>\n<li>模块化规范就是对代码进行模块化的拆分与组合时，需要遵守的那些规则</li>\n<li>例如:<ul>\n<li>使用什么样的语法格式来引用模块</li>\n<li>在模块中使用什么样的语法格式向外暴露成员</li>\n</ul>\n</li>\n<li>模块化规范的好处:大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块之间的相互调用，利人利己</li>\n</ul>\n<h3 id=\"2-2-Node-js中模块化\"><a href=\"#2-2-Node-js中模块化\" class=\"headerlink\" title=\"2.2 Node.js中模块化\"></a>2.2 Node.js中模块化</h3><p><strong>Node.js中模块的分类</strong></p>\n<ul>\n<li>Node.js 中根据模块来源的不同，将模块分为了3大类，分别是:<ul>\n<li>内置模块(内置模块是由Node.js官方提供的，例如fs、path、http 等)</li>\n<li>自定义模块(用户创建的每个.js 文件，都是自定义模块)</li>\n<li>第三方模块（由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载)</li>\n</ul>\n</li>\n</ul>\n<p><strong>加载模块</strong></p>\n<ul>\n<li>使用强大的require()方法，可以加载需要的内置模块、用户自定义模块、第三方模块进行使用</li>\n<li>注意:使用require0方法加载其它模块时，会执行被加载模块中的代码**(加载且执行)**</li>\n</ul>\n<p><strong>Node.js中模块作用域</strong></p>\n<ul>\n<li>和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种<strong>模块级别的访问限制</strong>，叫做模块作用域</li>\n<li><strong>防止全局变量污染问题</strong></li>\n</ul>\n<p><strong>向外共享模块作用域中的成员</strong></p>\n<ol>\n<li><p>module对象<br>在每个.js自定义模块中都有一个module对象，它里面<strong>存储了和当前模块有关的信息</strong></p>\n</li>\n<li><p>module.exports对象<br>在自定义模块中，可以使用module.exports对象，将模块内的成员共享出去，供外界使用。外界用require(方法导入自定义模块时，得到的就是 module.exports 所指向的对象</p>\n</li>\n<li><p>共享成员时的注意点<br>使用require()方法导入模块时，导入的结果，<strong>永远以module.exports指向的对象为准</strong></p>\n</li>\n</ol>\n<ul>\n<li>代码：</li>\n</ul>\n<pre><code class=\"js\">// 在外界使用 require 导入一个自定义模块的时候，得到的成员，\n// 就是 那个模块中，通过 module.exports 指向的那个对象\nconst m = require(&#39;./自定义模块&#39;)\n\nconsole.log(m)\n</code></pre>\n<pre><code class=\"js\">// 在一个自定义模块中，默认情况下， module.exports = &#123;&#125;\n\nconst age = 20//*\n\n// 1、向 module.exports 对象上挂载 username 属性\nmodule.exports.username = &#39;zs&#39;\n// 2、向 module.exports 对象上挂载 sayHello 方法\nmodule.exports.sayHello = function () &#123;\n  console.log(&#39;Hello!&#39;)\n&#125;\nmodule.exports.age = age//*\n\n///3、让 module.exports 指向一个全新的对象\nmodule.exports = &#123;\n  nickname: &#39;小黑&#39;,\n  sayHi() &#123;\n    console.log(&#39;Hi!&#39;)\n  &#125;\n&#125;\n</code></pre>\n<ol start=\"4\">\n<li>exports 对象<br>由于module.exports单词写起来比较复杂，为了简化向外共享成员的代码，Node 提供了exports对象。默认情况下，<strong>exports和module.exports 指向同一个对象</strong>。最终共享的结果，还是以module.exports 指向的对象为准<ul>\n<li>时刻谨记,require()模块时，得到的永远是module.exports指向的对象</li>\n<li>注意:为了防止混乱，建议大家不要在同一个模块中同时使用exports和module.exports</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/b2dc523a30f84990b9ec36df37423e39.png#pic_center\"></p>\n<ul>\n<li>一开始指向同一个对象，得到的永远是module.exports指向的对象，关键看有没有指向新的对象！！！</li>\n</ul>\n<p><strong>Node.js中的模块化规范</strong></p>\n<ul>\n<li>Node.js遵循了CommonJS模块化规范，CommonJS规定了模块的特性和各模块之间如何相互依赖</li>\n<li>CommonJS规定:<ul>\n<li>每个模块内部,module变量代表当前模块</li>\n<li>module变量是一个对象，它的exports 属性(即module.exports）是对外的接口</li>\n<li>加载某个模块，其实是加载该模块的module.exports 属性。require()方法用于加载模块</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-3-npm与包\"><a href=\"#2-3-npm与包\" class=\"headerlink\" title=\"2.3 npm与包\"></a>2.3 npm与包</h3><p><strong>包</strong></p>\n<ul>\n<li>Node.js 中的第三方模块又叫做包</li>\n<li>不同于Node.js 中的内置模块与自定义模块，包是由第三方个人或团队开发出来的，免费供所有人使用(免费且开源)</li>\n<li>由于Node.js的内置模块仅提供了一些底层的API，导致在基于内置模块进行项目开发的时，效率很低。包是基于内置模块封装出来的，提供了更高级、更方便的API，极大的提高了开发效率；包和内置模块之间的关系，类似于jQuery和浏览器内置API之间的关系</li>\n<li>注意:<ul>\n<li>从<a href=\"https://www.npmjs.com/\">https://www.npmjs.com/</a> 网站上<strong>搜索</strong>自己所需要的包</li>\n<li>从<a href=\"https://registry.npmjs.org/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A**%E4%B8%8B%E8%BD%BD**%E8%87%AA%E5%B7%B1%E9%9C%80%E8%A6%81%E7%9A%84%E5%8C%85\">https://registry.npmjs.org/服务器上**下载**自己需要的包</a></li>\n</ul>\n</li>\n<li>这个包管理工具的名字叫做Node Package Manager(简称npm包管理工具)，这个包管理工具随着Node.js 的安装包一起被安装到了用户的电脑上</li>\n<li>大家可以在终端中执行npm -v命令，来查看自己电脑上所安装的npm包管理工具的版本号</li>\n</ul>\n<p><strong>npm</strong></p>\n<ul>\n<li>在项目中安装指定名称的包：<code>npm install 包的完整名称</code> ;可简写为：<code>npm i 包的完整名称</code></li>\n<li>初次装包完成后，在项目文件夹下多一个叫做node_modules的文件夹和package-lock.json的配置文件</li>\n<li>其中:<ul>\n<li>node modules文件夹用来存放所有已安装到项目中的包；require()导入第三方包时，就是从这个目录中查找并加载包</li>\n<li>package-lockjson配置文件用来记录node_modules目录下的每一个包的下载信息，例如包的名字、版本号、下载地址等</li>\n<li>注意:程序员不要手动修改node modules或package-lock.json文件中的任何代码，npm 包管理工具会自动维护它们</li>\n</ul>\n</li>\n<li>默认情况下，使用npm install命令安装包的时候，会自动安装最新版本的包。如果需要安装指定版本的包，可以在包名之后，通过**@符号指定具体的版本**，例如:<code>npm i moment@2.22.2</code></li>\n<li>包的版本号是以“点分十进制”形式进行定义的，总共有三位数字，例如2.24.0其中每一位数字所代表的的含义如下:<ul>\n<li>第1位数字:大版本</li>\n<li>第2位数字:功能版本</li>\n<li>第3位数字: Bug修复版本</li>\n<li>版本号提升的规则:只要前面的版本号增长了，则后面的版本号归零</li>\n</ul>\n</li>\n</ul>\n<p><strong>包管理配置文件</strong></p>\n<ul>\n<li><p>npm 规定，在项目根目录中，必须提供一个叫做 package.json的包管理配置文件。用来记录与项目有关的一些配置信息。例如:</p>\n<ul>\n<li>项目的名称、版本号、描述等</li>\n<li>项目中都用到了哪些包</li>\n<li>哪些包只在开发期间会用到</li>\n<li>那些包在开发和部署时都需要用到</li>\n</ul>\n</li>\n<li><p>多人协作 – <strong>共享时剔除node_modules</strong></p>\n</li>\n<li><p>在项目根目录中，创建一个叫做package,json的配置文件，即可用来记录项目中安装了哪些包。从而方便剔除node_modules 目录之后，在团队成员之间共享项目的源代码</p>\n</li>\n<li><p>注意:今后在项目开发中，一定要把node_modules文件夹，添加到.gitignore忽略文件中</p>\n</li>\n</ul>\n<p><strong>快速创建package.json</strong></p>\n<ul>\n<li>npm包管理工具提供了一个快捷命令，可以在执行命令时所处的目录中，快速创建package.json这个包管理配置文件:<code> npm init -y</code></li>\n<li>注意:<ul>\n<li>上述命令只能在英文的目录下成功运行！所以，项目文件夹的名称一定要使用英文命名，不要使用中文，不能出现空格</li>\n<li>运行npm install 命令安装包的时候，npm包管理工具会自动把包的名称和版本号，记录到 package.json 中</li>\n</ul>\n</li>\n</ul>\n<p><strong>dependencies节点</strong></p>\n<ul>\n<li>package.json文件中，有一个dependencies节点，专门用来记录您使用npm install命令安装了哪些包</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/d583082ce22544ee923d6a1af72b8cd6.png#pic_center\"></p>\n<p><strong>一次性安装所有的包</strong></p>\n<ul>\n<li>可以运行<code>npm install</code>命令(或<code>npm i</code>)一次性安装所有的依赖包</li>\n<li>执行npm install 命令时，npm包管理工具会先读取package.json 中的 dependencies节点</li>\n<li>读取到记录的所有依赖包名称和版本号之后，npm包管理工具会把这些包一次性下载到项目中</li>\n</ul>\n<p><strong>卸载包</strong></p>\n<ul>\n<li>可以运行<code>npm uninstall</code>命令，来卸载指定的包</li>\n<li>注意: npm uninstall 命令执行成功后，会把卸载的包，自动从packagejson的dependencies中移除掉。</li>\n</ul>\n<p><strong>devDependencies节点</strong></p>\n<ul>\n<li>如果某些包只在项目开发阶段会用到，在项目上线之后不会用到，则建议把这些包记录到devDependencies节点中;与之对应的，如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到dependencies节点中</li>\n<li>可以使用如下的命令，将包记录到devDependencies节点中:<code>npm i 包名-D</code> (简写) <code>npm install包名--save-dev</code>(完整)</li>\n</ul>\n<p><strong>npm下包速度慢的解决</strong></p>\n<ul>\n<li>在使用npm下包的时候，默认从国外的 <a href=\"https://registry.npmjs.org/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E4%B8%8B%E8%BD%BD%EF%BC%8C%E6%AD%A4%E6%97%B6%EF%BC%8C%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BC%A0%E8%BE%93%E9%9C%80%E8%A6%81%E7%BB%8F%E8%BF%87%E6%BC%AB%E9%95%BF%E7%9A%84%E6%B5%B7%E5%BA%95%E5%85%89%E7%BC%86%EF%BC%8C%E5%9B%A0%E6%AD%A4%E4%B8%8B%E5%8C%85%E9%80%9F%E5%BA%A6%E4%BC%9A%E5%BE%88%E6%85%A2\">https://registry.npmjs.org/服务器进行下载，此时，网络数据的传输需要经过漫长的海底光缆，因此下包速度会很慢</a></li>\n<li>淘宝在国内搭建了一个服务器，专门把国外官方服务器上的包同步到国内的服务器，然后在国内提供下包的服务；从而极大的提高了下包的速度</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/044db0f2b7a546b29cf0be5aed15c785.png#pic_center\"></p>\n<ul>\n<li>切换npm的下包镜像源</li>\n</ul>\n<pre><code class=\"Markdown\"># 查看当前的下包镜像源\nnpm config get registry\n\n# 将下包的镜像源切换为淘宝镜像源\nnpm config set registry=https : /lregistry.npm.taobao.org/\n\n# 检查镜像源是否下载成功\nnpm config get registry\n</code></pre>\n<ul>\n<li>为了更方便的切换下包的镜像源，我们可以安装nrm这个小工具，利用nrm提供的终端命令，可以快速查看和切换下包的镜像源。</li>\n</ul>\n<pre><code class=\"Markdown\"># 通过npm包管理器，将nrm安装为全局可用的工具\nnpm i nrm -g\n\n# 查看所有可用的镜像源\nnrm ls\n\n# 将下包的镜像源切换为taobao镜像\nnrm use taobao\n</code></pre>\n<p><strong>包的分类</strong></p>\n<ul>\n<li>使用npm包管理工具下载的包，共分为两大类，分别是:<ul>\n<li>项目包<ul>\n<li>那些被安装到项目的node_modules目录中的包，都是项目包</li>\n<li>项目包又分为两类，分别是:<ul>\n<li>开发依赖包(被记录到devDependencies节点中的包，只在开发期间会用到)</li>\n<li>核心依赖包（被记录到dependencies节点中的包，在开发期间和项目上线之后都会用到)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>全局包<ul>\n<li>在执行npm install 命令时，如果提供了 -g参数，则会把包安装为全局包</li>\n<li>全局包会被安装到C:\\Users用户目录\\AppData\\Roaminginpm\\node_modules目录下</li>\n<li>注意:<ul>\n<li>只有工具性质的包，才有全局安装的必要性，因为它们提供了好用的终端命令</li>\n<li>判断某个包是否需要全局安装后才能使用，可以参考官方提供的使用说明即可</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>i5ting_toc</strong></p>\n<ul>\n<li>i5ting_toc是一个可以把md文档转为 html页面的小工具，使用步骤如下:</li>\n</ul>\n<pre><code class=\"markdown\"># 将i5ting_toc安装为全局包\nnpm install -g i5ting toc\n\n# 调用i5ting_toc，轻松实现md转html的功能\ni5ting_toc -f 要转换的md文件路径 -o\n</code></pre>\n<p><strong>规范的包结构</strong></p>\n<ul>\n<li>一个规范的包，它的组成结构，必须符合以下3点要求:<ul>\n<li>包必须以单独的目录而存在</li>\n<li>包的顶级目录下要必须包含package.json这个包管理配置文件</li>\n<li>package.json中必须包含name，version，main这三个属性，分别代表包的名字、版本号、包的入口</li>\n</ul>\n</li>\n<li>更多约束：<a href=\"https://yarnpkg.com/zh-Hans/docs/package-json\">https://yarnpkg.com/zh-Hans/docs/package-json</a></li>\n</ul>\n<p><strong>编写包 – 发布包 – 使用包</strong></p>\n<h3 id=\"2-4-模块的加载机制\"><a href=\"#2-4-模块的加载机制\" class=\"headerlink\" title=\"2.4 模块的加载机制\"></a>2.4 模块的加载机制</h3><p><strong>优先从缓存中加载</strong></p>\n<ul>\n<li>模块在第一次加载后会被缓存，这也意味着<strong>多次调用require()不会导致模块的代码被执行多次</strong></li>\n<li>注意:不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而提高模块的加载效率</li>\n</ul>\n<p><strong>内置模块的加载机制</strong></p>\n<ul>\n<li>内置模块是由Node.js官方提供的模块，<strong>内置模块的加载优先级最高</strong></li>\n<li>例如，require(‘fs’)始终返回内置的fs模块，即使在node_modules目录下有名字相同的包也叫做fs</li>\n</ul>\n<p><strong>自定义模块的加载机制</strong></p>\n<ul>\n<li>使用require()加载自定义模块时，必须指定以.&#x2F;或..&#x2F;开头的路径标识符。在加载自定义模块时，如果没有指定.&#x2F;或..&#x2F;这样的路径标识符，则node 会把它当作内置模块或第三方模块进行加载</li>\n<li>同时，在使用require()导入自定义模块时，如果省略了文件的扩展名，则Nodejs 会按顺序分别尝试加载以下的文件:</li>\n</ul>\n<ol>\n<li>按照确切的文件名进行加载</li>\n<li>补全js扩展名进行加载</li>\n<li>补全 .json扩展名进行加载</li>\n<li>补全.node扩展名进行加载</li>\n<li>加载失败，终端报错</li>\n</ol>\n<p><strong>第三方模块的加载机制</strong></p>\n<ul>\n<li><p>如果传递给require()的模块标识符不是一个内置模块，也没有以.&#x2F;或..&#x2F;开头，则Node.js 会从当前模块的父目录开始，尝试从&#x2F;node_modules文件夹中加载第三方模块</p>\n</li>\n<li><p>如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录</p>\n</li>\n<li><p>例如，假设在’C:\\Users\\itheima\\project\\foojs’文件里调用require(“tools’)，则 Node.js 会按以下顺序找:</p>\n</li>\n</ul>\n<ol>\n<li>C:\\Users\\heima\\project\\node_modules\\tools</li>\n<li>C:\\Users\\heima\\node_modules\\tools</li>\n<li>C:\\Users\\node_modules\\tools</li>\n<li>C:\\node_modules\\tools</li>\n</ol>\n<p><strong>目录作为模块</strong></p>\n<ul>\n<li>当把目录作为模块标识符，传递给require(进行加载的时候，有三种加载方式:</li>\n</ul>\n<ol>\n<li>在被加载的目录下查找一个叫做 package.json的文件，并寻找main属性，作为require()加载的入口</li>\n<li>如果目录里没有package.json 文件，或者main入口不存在或无法解析，则Node.js将会试图加载目录下的 index.js文件</li>\n<li>如果以上两步都失败了，则Nodejs 会在终端打印错误消息，报告模块的缺失: Error. Cannot find module ‘xxx’</li>\n</ol>\n<h2 id=\"3、Express\"><a href=\"#3、Express\" class=\"headerlink\" title=\"3、Express\"></a>3、Express</h2><h3 id=\"3-1-初识Express\"><a href=\"#3-1-初识Express\" class=\"headerlink\" title=\"3.1 初识Express\"></a>3.1 初识Express</h3><p><strong>Express简介</strong></p>\n<ul>\n<li><p>官方给出的概念: Express是基于Node.js平台，快速、开放、极简的Web开发框架</p>\n</li>\n<li><p>通俗的理解: Express 的作用和Node.,js 内置的http模块类似，是专门用来创建Web服务器的</p>\n</li>\n<li><p>Express 的本质:就是一个npm 上的第三方包，提供了快速创建web服务器的便捷方法</p>\n</li>\n<li><p>Express 的中文官网: <a href=\"http://www.expressjs.com.cn/\">http://www.expressjs.com.cn/</a></p>\n</li>\n<li><p>对于前端程序员来说，最常见的两种服务器，分别是:</p>\n<ul>\n<li><p>Web 网站服务器:专门对外提供Web 网页资源的服务器</p>\n</li>\n<li><p>API接口服务器:专门对外提供API接口的服务器</p>\n</li>\n</ul>\n</li>\n<li><p>使用Express，我们可以方便、快速的创建Web 网站的服务器或API接口的服务器</p>\n</li>\n</ul>\n<p><strong>Express基本使用</strong></p>\n<ol>\n<li>安装：<code>npm i express@4.17.1</code></li>\n<li>创建基本的Web服务器</li>\n<li>监听GET请求</li>\n<li>监听POST请求</li>\n<li>把内容响应给客户端</li>\n<li>获取URL中携带的查询参数</li>\n<li>获取URL中的动态参数</li>\n</ol>\n<ul>\n<li>代码：</li>\n</ul>\n<pre><code class=\"js\">// 1. 导入 express\nconst express = require(&#39;express&#39;)\n// 2. 创建 web 服务器\nconst app = express()\n\n// 3. 监听客户端的 GET 和 POST 请求，并向客户端响应具体的内容\napp.get(&#39;/user&#39;, (req, res) =&gt; &#123;\n  // 调用 express 提供的 res.send() 方法，向客户端响应一个 JSON 对象\n  res.send(&#123; name: &#39;zs&#39;, age: 20, gender: &#39;男&#39; &#125;)\n&#125;)\napp.post(&#39;/user&#39;, (req, res) =&gt; &#123;\n  // 调用 express 提供的 res.send() 方法，向客户端响应一个 文本字符串\n  res.send(&#39;请求成功&#39;)\n&#125;)\napp.get(&#39;/&#39;, (req, res) =&gt; &#123;\n  // 通过 req.query 可以获取到客户端发送过来的 查询参数\n  // 注意：默认情况下，req.query 是一个空对象\n  console.log(req.query)\n  res.send(req.query)\n&#125;)\n// 注意：这里的 :id 是一个动态的参数\napp.get(&#39;/user/:ids/:username&#39;, (req, res) =&gt; &#123;\n  // req.params 是动态匹配到的 URL 参数，默认也是一个空对象\n  console.log(req.params)\n  res.send(req.params)\n&#125;)\n\n// 4. 启动 web 服务器\napp.listen(80, () =&gt; &#123;\n  console.log(&#39;express server running at http://127.0.0.1&#39;)\n&#125;)\n</code></pre>\n<p><strong>托管静态资源</strong></p>\n<ul>\n<li>express提供了一个非常好用的函数，叫做 express.static()，通过它，我们可以非常方便地创建一个静态资源服务器例如，通过如下代码就可以将public目录下的图片、CSS文件、JavaScript文件对外开放访问了</li>\n<li>注意:Express在指定的静态目录中查找文件，并对外提供资源的访问路径。因此，存放静态文件的目录名不会出现在URL中</li>\n<li>访问静态资源文件时，express.static()函数会根据目录的添加顺序查找所需的文件</li>\n<li>代码：</li>\n</ul>\n<pre><code class=\"js\">const express = require(&#39;express&#39;)\nconst app = express()\n\n// 在这里，调用 express.static() 方法，快速的对外提供静态资源\napp.use(&#39;/files&#39;, express.static(&#39;./files&#39;))//按添加顺序查找所需文件，挂载路径前缀\napp.use(express.static(&#39;./clock&#39;))\n\napp.listen(80, () =&gt; &#123;\n  console.log(&#39;express server running at http://127.0.0.1&#39;)\n&#125;)\n</code></pre>\n<p><strong>nodemon</strong></p>\n<ul>\n<li>在编写调试Nodejs项目的时候，如果修改了项目的代码，则需要频繁的手动close掉，然后再重新启动，非常繁琐；我们可以使用nodemon (<a href=\"https://www.npmjs.com/package/nodemon)%E8%BF%99%E4%B8%AA%E5%B7%A5%E5%85%B7%EF%BC%8C%E5%AE%83%E8%83%BD%E5%A4%9F%E7%9B%91%E5%90%AC%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8F%98%E5%8A%A8%EF%BC%8C%E5%BD%93%E4%BB%A3%E7%A0%81%E8%A2%AB%E4%BF%AE%E6%94%B9%E5%90%8E%EF%BC%8Cnodemon\">https://www.npmjs.com/package/nodemon)这个工具，它能够监听项目文件的变动，当代码被修改后，nodemon</a> 会自动帮我们重启项目，极大方便了开发和调试</li>\n<li>在终端中，运行如下命令，即可将nodemon安装为全局可用的工具：<code>npm install -g nodemon</code></li>\n<li>使用：<code>node app.js</code> &#x3D;&gt; <code>nodemon app.js</code></li>\n</ul>\n<h3 id=\"3-2-Express路由\"><a href=\"#3-2-Express路由\" class=\"headerlink\" title=\"3.2 Express路由\"></a>3.2 Express路由</h3><p><strong>路由的概念</strong></p>\n<ul>\n<li><p>广义上来讲，路由就是映射关系</p>\n</li>\n<li><p>在Express 中，路由指的是客户端的请求与服务器处理函数之间的映射关系</p>\n</li>\n<li><p>Express 中的路由分3部分组成，分别是请求的类型、请求的URL地址、处理函数，格式如下:<code>app.METHOD(PATH，HANDLER)</code></p>\n</li>\n<li><p>每当一个请求到达服务器之后，需要先经过路由的匹配，只有匹配成功之后，才会调用对应的处理函数</p>\n</li>\n<li><p>在匹配时，会按照路由的顺序进行匹配，如果请求类型和请求的URL同时匹配成功，则Express 会将这次请求，转交给对应的function函数进行处理</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/bd7fe7e957244c38bcdb36d9df5345da.png#pic_center\"></p>\n<ul>\n<li>路由匹配的注意点:<ul>\n<li>按照定义的先后顺序进行匹配</li>\n<li>请求类型和请求的URL同时匹配成功，才会调用对应的处理函数</li>\n</ul>\n</li>\n</ul>\n<p><strong>路由的使用</strong></p>\n<ul>\n<li>最简单路由代码：</li>\n</ul>\n<pre><code class=\"js\">const express = require(&#39;express&#39;)\nconst app = express()\n\n// 挂载路由\napp.get(&#39;/&#39;, (req, res) =&gt; &#123;\n  res.send(&#39;hello world.&#39;)\n&#125;)\napp.post(&#39;/&#39;, (req, res) =&gt; &#123;\n  res.send(&#39;Post Request.&#39;)\n&#125;)\n\napp.listen(80, () =&gt; &#123;\n  console.log(&#39;http://127.0.0.1&#39;)\n&#125;)\n</code></pre>\n<ul>\n<li><p>模块化路由 – 为了方便对路由进行模块化的管理，Express 不建议将路由直接挂载到app 上，而是推荐将路由抽离为单独的模块。将路由抽离为单独模块的步骤如下:</p>\n<ol>\n<li>创建路由模块对应的.js 文件</li>\n<li>调用express.Router()函数创建路由对象</li>\n<li>向路由对象上挂载具体的路由</li>\n<li>使用module.exports向外共享路由对象</li>\n<li>使用app.use()函数注册路由模块</li>\n</ol>\n</li>\n<li><p>创建路由模块代码：</p>\n</li>\n</ul>\n<pre><code class=\"js\">// 1. 导入 express\nconst express = require(&#39;express&#39;)\n// 2. 创建路由对象\nconst router = express.Router()\n\n// 3. 挂载具体的路由\nrouter.get(&#39;/user/list&#39;, (req, res) =&gt; &#123;\n  res.send(&#39;Get user list.&#39;)\n&#125;)\nrouter.post(&#39;/user/add&#39;, (req, res) =&gt; &#123;\n  res.send(&#39;Add new user.&#39;)\n&#125;)\n\n// 4. 向外导出路由对象\nmodule.exports = router\n</code></pre>\n<ul>\n<li>注册路由模块代码：</li>\n</ul>\n<pre><code class=\"js\">// 1．导入路由模块\nconst userRouter = require( &#39; ./router/user.js &#39;)\n\n// 2．使用app.use()注册路由模块\napp.use(userRouter)\n// 注意： app.use() 函数的作用，就是来注册全局中间件\n</code></pre>\n<ul>\n<li>为路由模块添加前缀代码：</li>\n</ul>\n<pre><code class=\"js\">//使用app.use()注册路由模块，并添加统的访问前缀\napp.use( &#39; /api &#39;, userRouter)\n</code></pre>\n<h3 id=\"3-3-Express中间件\"><a href=\"#3-3-Express中间件\" class=\"headerlink\" title=\"3.3 Express中间件\"></a>3.3 Express中间件</h3><p><strong>中间件的概念</strong></p>\n<ul>\n<li>中间件(Middleware ) ，特指业务流程的中间处理环节</li>\n<li>当一个请求到达Express 的服务器之后，可以连续调用多个中间件，从而对这次请求进行预处理</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/e4b9ab872f9442d29ecb7a64a45b3ad5.png#pic_center\"></p>\n<ul>\n<li>Express的中间件，本质上就是一个function处理函数，Express中间件的格式如下:</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/4961e383611b4212aa28e891656fa8a6.png#pic_center\"></p>\n<ul>\n<li>注意:中间件函数的形参列表中，必须包含next参数，而路由处理函数中只包含req和res</li>\n<li>next函数是实现多个中间件连续调用的关键，它表示把流转关系转交给下一个中间件或路由</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/16569adf38044122ba47720a6119cb54.png#pic_center\"></p>\n<p><strong>中间件初体验</strong></p>\n<ul>\n<li>最简单的中间件函数：</li>\n</ul>\n<pre><code class=\"js\">//常量mw所指向的,就是一个中间件函数\nconst mw = function (req. res,next) &#123;\n    console.log(&#39;这是一个最简单的中间件函数&quot;)\n    //注意:在当前中间件的业务处理完毕后，必须调用next()函数\n    //表示把流转关系转交给下一个中间件或路由\n    next()\n&#125;\n</code></pre>\n<ul>\n<li>全局生效的中间件：</li>\n</ul>\n<pre><code class=\"js\">//常量mw所指向的,就是一个中间件函数\nconst mw = function (req. res,next) &#123;\n    console.log( &quot;这是一个最简单的中间件函数&quot;)\n    next()\n&#125;\n//全局生效的中间件\napp.use(mw)\n</code></pre>\n<ul>\n<li>全局中间件的简化形式：</li>\n</ul>\n<pre><code class=\"js\">//全局生效的中间件\napp.use(function (req,res,next) &#123;\n    console.log( &#39;这是一个最简单的中间件函数&#39;)\n    next()\n&#125;)\n</code></pre>\n<ul>\n<li>多个中间件之间，共享同一份req和res。基于这样的特性，我们可以在上游的中间件中，统一为req或 res对象添加自定义的属性或方法，供下游的中间件或路由进行使用</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/8c207cb2f09043d5974b3ce9570b815e.png#pic_center\"></p>\n<ul>\n<li>定义多个全局中间件</li>\n</ul>\n<pre><code class=\"js\">app.use( function(req, res, next) //第1个全局中间\n    console.1og(&#39;调用了第1个全局中间件&#39;)\n    next()\n&#125;)\napp.use( function(req, res, next) //第2个全局中间件\n    console.log(&#39;调用了第2个全局中间件&quot;)\n    next()\n&#125;)\napp.get( &#39; /user &#39;, (req, res) =&gt; &#123;//请求这个路由，会依次触发上述两个全局中间件\n    res.send( &#39; Home page.&quot;)\n&#125;)\n</code></pre>\n<ul>\n<li>局部生效的中间件</li>\n</ul>\n<pre><code class=\"js\">//定义中间件函数mw1\nconst mw1 = function(req. res,next) &#123;\n    console.log(&quot;这是中间件函数&quot;)\n    next()\n&#125;\n// mw1(中间件函数)这个中间件只在&quot;当前路由中生效&quot;，这种用法属于&quot;局部生效的中间件&quot;\napp.get( &#39;/&#39;，mw1,function(req, res) &#123;\n    res.send(&#39;Home page.&#39;)\n&#125;)\n//mw1这个中间件不会影响下面这个路由↓↓↓\napp.get( &#39; /user &#39;， function(req，res) &#123; \n    res.send( &#39;User page.&#39;) \n&#125;)\n</code></pre>\n<ul>\n<li>定义多个局部中间件</li>\n</ul>\n<pre><code class=\"js\">//以下两种写法是&quot;完全等价&quot;的，可根据自己的喜好，选择任意一种方式进行使用\napp.get( &#39; / &#39; ,mw1,mw2，(req，res) =&gt; &#123; res.send( &#39;Home page. &#39;)&#125;)\napp.get( &#39; / &#39;，[mw1，mw2]，(req，res) =&gt; &#123; res.send( &#39;Home page.&#39;)&#125;)\n</code></pre>\n<ul>\n<li>注意事项：</li>\n</ul>\n<ol>\n<li>—定要在路由之前注册中间件</li>\n<li>客户端发送过来的请求，可以连续调用多个中间件进行处理</li>\n<li>执行完中间件的业务代码之后，不要忘记调用next()函数</li>\n<li>为了防止代码逻辑混乱，调用next()函数后不要再写额外的代码</li>\n<li>连续调用多个中间件时，多个中间件之间，共享req和res对象</li>\n</ol>\n<p><strong>中间件分类</strong></p>\n<ol>\n<li><p>应用级别的中间件</p>\n<ul>\n<li>通过app.use()或 app.get()或app.post()，绑定到app实例上的中间件，叫做应用级别的中间件</li>\n</ul>\n</li>\n<li><p>路由级别的中间件</p>\n<ul>\n<li>绑定到express.Router()实例上的中间件，叫做路由级别的中间件，它的用法和应用级别中间件没有任何区别，只不过，应用级别中间件是绑定到app实例上，路由级别中间件绑定到 router 实例上</li>\n</ul>\n</li>\n<li><p>错误级别的中间件</p>\n<ul>\n<li>错误级别中间件的作用:专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题</li>\n<li>格式:错误级别中间件的 function 处理函数中，必须有4个形参，形参顺序从前到后，分别是(err,req, res, next)</li>\n<li>代码：</li>\n</ul>\n<pre><code class=\"js\">// 导入 express 模块\nconst express = require(&#39;express&#39;)\n// 创建 express 的服务器实例\nconst app = express()\n\n// 1. 定义路由\napp.get(&#39;/&#39;, (req, res) =&gt; &#123;\n  // 1.1 人为的制造错误\n  throw new Error(&#39;服务器内部发生了错误！&#39;)\n  res.send(&#39;Home page.&#39;)\n&#125;)\n\n// 2. 定义错误级别的中间件，捕获整个项目的异常错误，从而防止程序的崩溃,注册在所有路由之后\napp.use((err, req, res, next) =&gt; &#123;\n  console.log(&#39;发生了错误！&#39; + err.message)\n  res.send(&#39;Error：&#39; + err.message)\n&#125;)\n\n// 调用 app.listen 方法，指定端口号并启动web服务器\napp.listen(80, function () &#123;\n  console.log(&#39;Express server running at http://127.0.0.1&#39;)\n&#125;)\n</code></pre>\n</li>\n<li><p>Express内置的中间件</p>\n<ul>\n<li><p>自Express 4.16.0版本开始，Express内置了3个常用的中间件，极大的提高了Express 项目的开发效率和体验:</p>\n<ol>\n<li>express.static快速托管静态资源的内置中间件，例如:HTML文件、图片、CSS样式等(无兼容性)</li>\n<li>express.json解析JSON格式的请求体数据（有兼容性，仅在4.16.0+版本中可用)</li>\n<li>express.urlencoded解析URL-encoded格式的请求体数据（有兼容性，仅在4.16.0+版本中可用)</li>\n</ol>\n</li>\n<li><p>代码：</p>\n</li>\n</ul>\n<pre><code class=\"js\">// 导入 express 模块\nconst express = require(&#39;express&#39;)\n// 创建 express 的服务器实例\nconst app = express()\n\n// 注意：除了错误级别的中间件，其他的中间件，必须在路由之前进行配置\n// 通过 express.json() 这个中间件，解析表单中的 JSON 格式的数据\napp.use(express.json())\n// 通过 express.urlencoded() 这个中间件，来解析 表单中的 url-encoded 格式的数据\napp.use(express.urlencoded(&#123; extended: false &#125;))\n\napp.post(&#39;/user&#39;, (req, res) =&gt; &#123;\n  // 在服务器，可以使用 req.body 这个属性，来接收客户端发送过来的请求体数据\n  // 默认情况下，如果不配置解析表单数据的中间件，则 req.body 默认等于 undefined\n  console.log(req.body)\n  res.send(&#39;ok&#39;)\n&#125;)\n\napp.post(&#39;/book&#39;, (req, res) =&gt; &#123;\n  // 在服务器端，可以通过 req,body 来获取 JSON 格式的表单数据和 url-encoded 格式的数据\n  console.log(req.body)\n  res.send(&#39;ok&#39;)\n&#125;)\n\n// 调用 app.listen 方法，指定端口号并启动web服务器\napp.listen(80, function () &#123;\n  console.log(&#39;Express server running at http://127.0.0.1&#39;)\n&#125;)\n</code></pre>\n</li>\n<li><p>第三方的中间件</p>\n<ul>\n<li><p>非Express 官方内置的，而是由第三方开发出来的中间件，叫做第三方中间件。在项目中，大家可以按需下载并配置第三方中间件，从而提高项目的开发效率</p>\n</li>\n<li><p>例如:在 <a href=\"mailto:&#x65;&#120;&#112;&#x72;&#101;&#x73;&#115;&#x40;&#x34;&#x2e;&#x31;&#x36;&#x2e;&#x30;\">&#x65;&#120;&#112;&#x72;&#101;&#x73;&#115;&#x40;&#x34;&#x2e;&#x31;&#x36;&#x2e;&#x30;</a>之前的版本中，经常使用body-parser这个第三方中间件，来解析请求体数据。</p>\n</li>\n<li><p>使用步骤如下:</p>\n<ol>\n<li><p>运行npm install body-parser安装中间件</p>\n</li>\n<li><p>使用require导入中间件</p>\n</li>\n<li><p>调用app.use()注册并使用中间件</p>\n</li>\n</ol>\n</li>\n<li><p>注意: Express 内置的express.urlencoded 中间件，就是基于body-parser这个第三方中间件进一步封装出来的</p>\n</li>\n</ul>\n</li>\n</ol>\n<p><strong>自定义中间件</strong></p>\n<ol>\n<li>定义中间件</li>\n<li>监听req的data 事件</li>\n<li>监听req的end事件</li>\n<li>使用querystring模块解析请求体数据</li>\n<li>将解析出来的数据对象挂载为req.body</li>\n<li>将自定义中间件封装为模块</li>\n</ol>\n<ul>\n<li>代码：</li>\n</ul>\n<pre><code class=\"js\">// 导入 express 模块\nconst express = require(&#39;express&#39;)\n// 创建 express 的服务器实例\nconst app = express()\n// 导入 Node.js 内置的 querystring 模块\nconst qs = require(&#39;querystring&#39;)\n\n// 这是解析表单数据的中间件\napp.use((req, res, next) =&gt; &#123;\n  // 定义中间件具体的业务逻辑\n  // 1. 定义一个 str 字符串，专门用来存储客户端发送过来的请求体数据\n  let str = &#39;&#39;\n  // 2. 监听 req 的 data 事件\n  req.on(&#39;data&#39;, (chunk) =&gt; &#123;\n    str += chunk\n  &#125;)\n  // 3. 监听 req 的 end 事件\n  req.on(&#39;end&#39;, () =&gt; &#123;\n    // 在 str 中存放的是完整的请求体数据\n    // console.log(str)\n    // TODO: 把字符串格式的请求体数据，解析成对象格式\n    const body = qs.parse(str)\n    req.body = body\n    next()\n  &#125;)\n&#125;)\n\napp.post(&#39;/user&#39;, (req, res) =&gt; &#123;\n  res.send(req.body)\n&#125;)\n\n// 调用 app.listen 方法，指定端口号并启动web服务器\napp.listen(80, function () &#123;\n  console.log(&#39;Express server running at http://127.0.0.1&#39;)\n&#125;)\n</code></pre>\n<h3 id=\"3-4-使用Express写接口\"><a href=\"#3-4-使用Express写接口\" class=\"headerlink\" title=\"3.4 使用Express写接口\"></a>3.4 使用Express写接口</h3><ul>\n<li>解决接口跨域问题的方案主要有两种:</li>\n</ul>\n<ol>\n<li>CORS (主流的解决方案，推荐使用)<ul>\n<li>CORS 是 Express的一个第三方中间件,通过安装和配置cors 中间件，可以很方便地解决跨域问题。使用步骤分为如下3步:<ol>\n<li>运行npm install cors安装中间件</li>\n<li>使用const cors &#x3D; require(‘cors’)导入中间件在路由之前调用</li>\n<li>app.use(cors())配置中间件</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>JSONP (有缺陷的解决方案:只支持GET请求)</li>\n</ol>\n<p><strong>CORS跨域资源共享</strong></p>\n<ul>\n<li>CORS (Cross-Origin Resource Sharing，跨域资源共享）由一系列HTTP响应头组成，这些HTTP响应头决定浏览器是否阻止前端JS代码跨域获取资源</li>\n<li>浏览器的同源安全策略默认会阻止网页“跨域”获取资源。但如果接口服务器配置了CORS相关的HTTP响应头，就可以解除浏览器端的跨域访问限制</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/85b3a6273893455e9800539fba03d987.png#pic_center\"></p>\n<ul>\n<li><p>CORS的注意事项</p>\n<ol>\n<li>CORS主要在服务器端进行配置。客户端浏览器无须做任何额外的配置，即可请求开启了CORS的接口</li>\n<li>CORS在浏览器中有兼容性。只有支持XMLHttpRequest Level2的浏览器，才能正常访问开启了CORS的服务端接口**(例如:IE10+、Chrome4+、FireFox3.5+)**</li>\n</ol>\n</li>\n<li><p>响应头部中可以携带一个Access-Control-Allow-Origin字段，其语法如下:<br><code>Access-Control-Allow-origin: &lt;origin&gt; | *</code>其中,origin参数的值指定了允许访问该资源的外域URL</p>\n</li>\n</ul>\n<pre><code class=\"js\">res.setHeader( &#39; Access-Control-Allow-Origin &#39;, &#39;http: /litcast.cn&#39;)\n</code></pre>\n<ul>\n<li>默认情况下，CORS仅支持客户端向服务器发送如下的9个请求头:<br><code>Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type (值仅限于text/plain、multipart/form-data、application/x-www-form-urlencoded三者之一)</code>;如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过Access-Control-Allow-Headers 对额外的请求头进行声明，否则这次请求会失败!</li>\n</ul>\n<pre><code class=\"js\">//允许客户端额外向服务器发送Content-Type 请求头和X-Custom-Header请求头//注意:多个请求头之间使用英文的逗号进行分割\nres.setHeader( &#39; Access-Control-Allow-Headers &#39; ，&#39;Content-Type，x-Custom-Header &#39;)\n</code></pre>\n<ul>\n<li>默认情况下，CORS仅支持客户端发起<code>GET、POST、HEAD</code>请求。<br>如果客户端希望通过PUT、DELETE等方式请求服务器的资源，则需要在服务器端，通过Access-Control-Alow-Method来指明实际请求所允许使用的HTTP方法</li>\n</ul>\n<pre><code class=\"js\">//只允许POST、GET、DELETE、HEAD请求方法\nres.setHeader ( &#39; Access-Control-Allow-Methods &#39;,&#39;POST，GET，DELETE，HEAD&quot; )\n//允许所有的 HTTP请求方法\nres.setHeader( &#39;Access-Control-Allow-Methods &quot; , &#39;*&#39;)\n</code></pre>\n<ul>\n<li><p>客户端在请求CORS接口时，根据请求方式和请求头的不同，可以将CORS的请求分为两大类，分别是:</p>\n<ol>\n<li>简单请求 <strong>(客户端与服务器之间只会发生一次请求)</strong></li>\n</ol>\n<ul>\n<li>请求方式: GET、POST、HEAD三者之一</li>\n<li>HTTP头部信息不超过以下几种字段:无自定义头部字段、Accept、Accept-Language、Content-Language、DPR,Downlink、Save-Data、Viewport-Width、Width 、Content-Type(只有三个值application&#x2F;x-www-form-<br>urlencoded、multipart&#x2F;form-data、text&#x2F;plain)</li>\n</ul>\n<ol start=\"2\">\n<li>预检请求 <strong>(客户端与服务器之间会发生两次请求，OPTION预检请求成功之后，才会发起真正的请求)</strong></li>\n</ol>\n<ul>\n<li>请求方式为GET、POST、HEAD之外的请求Method类型</li>\n<li>请求头中包含自定义头部字段</li>\n<li>向服务器发送了application&#x2F;ison格式的数据</li>\n</ul>\n</li>\n</ul>\n<p><strong>JSONP接口</strong></p>\n<ul>\n<li><p>概念:浏览器端通过&lt; scrip t&gt;标签的src 属性，请求服务器上的数据，同时，服务器返回一个函数的调用。这种请求数据的方式叫做JSONP</p>\n</li>\n<li><p>特点:</p>\n<ol>\n<li>JSONP 不属于真正的Ajax请求，因为它没有使用XMLHttpRequest这个对象</li>\n<li>JSONP仅支持GET请求，不支持 POST、PUT、DELETE 等请求</li>\n</ol>\n</li>\n<li><p>如果项目中已经配置了CORS跨域资源共享，为了防止冲突，必须在配置CORS中间件之前声明JSONP的接口</p>\n</li>\n<li><p>步骤：</p>\n<ol>\n<li>获取客户端发送过来的回调函数的名字</li>\n<li>得到要通过JSONP形式发送给客户端的数据</li>\n<li>根据前两步得到的数据，拼接出—个函数调用的字符串</li>\n<li>把上一步拼接得到的字符串，响应给客户端的&lt; script &gt;标签进行解析执行</li>\n</ol>\n</li>\n<li><p>代码：</p>\n</li>\n</ul>\n<pre><code class=\"js\">// 导入 express\nconst express = require(&#39;express&#39;)\n// 创建服务器实例\nconst app = express()\n\n// 配置解析表单数据的中间件\napp.use(express.urlencoded(&#123; extended: false &#125;))\n\n// 必须在配置 cors 中间件之前，配置 JSONP 的接口\napp.get(&#39;/api/jsonp&#39;, (req, res) =&gt; &#123;\n  // TODO: 定义 JSONP 接口具体的实现过程\n  // 1. 得到函数的名称\n  const funcName = req.query.callback\n  // 2. 定义要发送到客户端的数据对象\n  const data = &#123; name: &#39;zs&#39;, age: 22 &#125;\n  // 3. 拼接出一个函数的调用\n  const scriptStr = `$&#123;funcName&#125;($&#123;JSON.stringify(data)&#125;)`\n  // 4. 把拼接的字符串，响应给客户端\n  res.send(scriptStr)\n&#125;)\n\n// 一定要在路由之前，配置 cors 这个中间件，从而解决接口跨域的问题\nconst cors = require(&#39;cors&#39;)\napp.use(cors())\n\n// 导入路由模块\nconst router = require(&#39;./apiRouter&#39;)\n// 把路由模块，注册到 app 上\napp.use(&#39;/api&#39;, router)\n\n// 启动服务器\napp.listen(80, () =&gt; &#123;\n  console.log(&#39;express server running at http://127.0.0.1&#39;)\n&#125;)\n</code></pre>\n<pre><code class=\"js\">const express = require(&#39;express&#39;)\nconst router = express.Router()\n\n// 在这里挂载对应的路由\nrouter.get(&#39;/get&#39;, (req, res) =&gt; &#123;\n  // 通过 req.query 获取客户端通过查询字符串，发送到服务器的数据\n  const query = req.query\n  // 调用 res.send() 方法，向客户端响应处理的结果\n  res.send(&#123;\n    status: 0, // 0 表示处理成功，1 表示处理失败\n    msg: &#39;GET 请求成功！&#39;, // 状态的描述\n    data: query, // 需要响应给客户端的数据\n  &#125;)\n&#125;)\n\n// 定义 POST 接口\nrouter.post(&#39;/post&#39;, (req, res) =&gt; &#123;\n  // 通过 req.body 获取请求体中包含的 url-encoded 格式的数据\n  const body = req.body\n  // 调用 res.send() 方法，向客户端响应结果\n  res.send(&#123;\n    status: 0,\n    msg: &#39;POST 请求成功！&#39;,\n    data: body,\n  &#125;)\n&#125;)\n\n// 定义 DELETE 接口\nrouter.delete(&#39;/delete&#39;, (req, res) =&gt; &#123;\n  res.send(&#123;\n    status: 0,\n    msg: &#39;DELETE请求成功&#39;,\n  &#125;)\n&#125;)\n\nmodule.exports = router\n</code></pre>\n<h2 id=\"4、数据库与身份认证\"><a href=\"#4、数据库与身份认证\" class=\"headerlink\" title=\"4、数据库与身份认证\"></a>4、数据库与身份认证</h2><h3 id=\"4-1-数据库的基本概念\"><a href=\"#4-1-数据库的基本概念\" class=\"headerlink\" title=\"4.1 数据库的基本概念\"></a>4.1 数据库的基本概念</h3><p><strong>数据库的概念</strong></p>\n<ul>\n<li>数据库(database）是用来组织、存储和管理数据的仓库</li>\n<li>为了方便管理互联网世界中的数据，就有了数据库管理系统的概念（简称:数据库)</li>\n<li>用户可以对数据库中的数据进行新增、查询、更新、删除等操作</li>\n</ul>\n<p><strong>常见数据库及分类</strong></p>\n<ul>\n<li><p>市面上的数据库有很多种，最常见的数据库有如下几个:</p>\n<ul>\n<li>MySQL数据库（目前使用最广泛、流行度最高的开源免费数据库;Community + Enterprise)</li>\n<li>Oracle数据库（收费)</li>\n<li>SQL Server数据库（收费)</li>\n<li>Mongodb数据库(Community + Enterprise)</li>\n</ul>\n</li>\n<li><p>其中，MySQL、Oracle、SQL Server属于<strong>传统型数据库</strong>(又叫做:关系型数据库或SQL数据库)，这三者的设计理念相同，用法比较类似</p>\n</li>\n<li><p>而Mongodb属于<strong>新型数据库</strong>(又叫做:非关系型数据库或NoSQL数据库)，它在一定程度上弥补了传统型数据库的缺陷</p>\n</li>\n</ul>\n<p><strong>传统型数据库的数据组织结构</strong></p>\n<ul>\n<li><p>数据的组织结构:指的就是数据以什么样的结构进行存储</p>\n</li>\n<li><p>传统型数据库的数据组织结构，与Excel 中数据的组织结构比较类似</p>\n<ul>\n<li>Excel的数据组织结构</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/65ba32fc283647d7aaafef31a23d7676.png#pic_center\"></p>\n<pre><code>* 整个Excel叫做工作簿\n* users和books是工作表\n* users 工作表中有3行数据\n* 每行数据由6列信息组成，每列信息都有对应的数据类型\n</code></pre>\n<ul>\n<li><p>传统型数据库的数据组织结构</p>\n<ul>\n<li>在传统型数据库中，数据的组织结构分为**数据库(database)、数据表(table)、数据行(row)、字段(field)**这4大部分组成。</li>\n<li><strong>数据库</strong>类似于Excel的<strong>工作簿</strong></li>\n<li><strong>数据表</strong>类似于Excel的<strong>工作表</strong></li>\n<li><strong>数据行</strong>类似于Excel的<strong>每一行数据</strong></li>\n<li><strong>字段</strong>类似于Excel的<strong>列</strong>，每个字段都有对应的数据类型</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-2-安装并配置MySQL\"><a href=\"#4-2-安装并配置MySQL\" class=\"headerlink\" title=\"4.2 安装并配置MySQL\"></a>4.2 安装并配置MySQL</h3><ul>\n<li><p>MySQL Server:专门用来提供数据存储和服务的软件</p>\n</li>\n<li><p>MySQL Workbench:可视化的 MySQL管理工具，通过它，可以方便的操作存储在MySQL Server中的数据</p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/ASHIYI66/article/details/125046816\">MySQL的安装（Windows系统）</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/ASHIYI66/article/details/125047739\">Mac 系统配置 MySql 数据库</a></p>\n</li>\n</ul>\n<h3 id=\"4-3-MySQL的基本使用\"><a href=\"#4-3-MySQL的基本使用\" class=\"headerlink\" title=\"4.3 MySQL的基本使用\"></a>4.3 MySQL的基本使用</h3><p><strong>使用MySQL Workbench管理数据库</strong></p>\n<ol>\n<li>连接数据库</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/465310c6a09b4f7088255111b67fea9f.png#pic_center\"></p>\n<ol start=\"2\">\n<li>主界面的组成部分</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/8c95b8f2ae4d49279a71db4fccc9e793.png#pic_center\"></p>\n<ol start=\"3\">\n<li>创建数据库</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/3e4cd8dadda84dc98532201f8de245b8.png#pic_center\"></p>\n<ol start=\"4\">\n<li>创建数据表</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/529ae3f2dffa406c8812e0df7e3d9316.png#pic_center\"></p>\n<ul>\n<li><p>DataType数据类型:</p>\n<ul>\n<li><p>int 整数</p>\n</li>\n<li><p>varchar(len) 字符串</p>\n</li>\n<li><p>tinyint(1) 布尔值</p>\n</li>\n</ul>\n</li>\n<li><p>字段的特殊标识:</p>\n<ul>\n<li><p>PK (Primary Key) 主键、唯一标识</p>\n</li>\n<li><p>NN (Not Null) 值不允许为空</p>\n</li>\n<li><p>UQ(Unique) 值唯一</p>\n</li>\n<li><p>Al (Auto Increment) 值自动增长</p>\n</li>\n</ul>\n</li>\n</ul>\n<ol start=\"5\">\n<li>向表中写入数据</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/35f1eb192e8742e5bc2e44e7705b32d3.png#pic_center\"></p>\n<p><strong>使用SQL管理数据库</strong></p>\n<ul>\n<li><p>SQL(英文全称: Structured Query Language)是<strong>结构化查询语言</strong>，专门用来访问和处理数据库的编程语言。能够让我们以编程的形式，操作数据库里面的数据</p>\n</li>\n<li><p>三个关键点:</p>\n<ul>\n<li>SQL是一门<strong>数据库编程语言</strong></li>\n<li>使用SQL语言编写出来的代码，叫做<strong>SQL语句</strong></li>\n<li>SQL语言<strong>只能在关系型数据库中使用</strong>（例如MySQL、Oracle、SQL Server)；非关系型数据库（例如Mongodb)不支持SQL语言</li>\n</ul>\n</li>\n<li><p>作用：</p>\n<ol>\n<li>从数据库中查询数据(查)</li>\n<li>向数据库中插入新的数据(增)</li>\n<li>更新数据库中的数据(改)</li>\n<li>从数据库删除数据(删)</li>\n<li>可以创建新数据库</li>\n<li>可在数据库中创建新表</li>\n<li>可在数据库中创建存储过程、视图</li>\n<li>etc…</li>\n</ol>\n</li>\n</ul>\n<p><strong>SQL的SELECT语句</strong></p>\n<ul>\n<li>SELECT语句用于从表中查询数据。执行的结果被存储在一个结果表中（称为结果集)。语法格式如下:</li>\n</ul>\n<pre><code class=\"sql\">--这是注释\n--从　FROM　指定的［表中］，查询出［所有的］数据。　　*　表示［所有列］\nSELECT　*　FROM　表名称\n \n--从　FROM　指定的［表中］，查询出指定　　列名称　（字段）　的数据\nSELECT 列名称 FROM 表名称\n</code></pre>\n<ul>\n<li><p>注意:SQL语句中的关键字对大小写不敏感。SELECT等效于select，FROM等效于from</p>\n</li>\n<li><p>我们希望从users表中选取所有的列，可以使用符号*取代列的名称，示例如下:</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/603c9efc765c436bb30a2852719ec54b.png#pic_center\"></p>\n<ul>\n<li>如需获取名为“username”和”password”的列的内容(从名为”users”的数据库表)，请使用下面的SELECT语句:</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/4b70aedcc7ef4255a90e7bfb9b67415d.png#pic_center\"></p>\n<p><strong>SQL的INSERT INTO语句</strong></p>\n<ul>\n<li>INSERT INTO语句用于向数据表中插入新的数据行，语法格式如下:</li>\n</ul>\n<pre><code class=\"sql\">--语法解读：向指定的表中，插入如下几列数据，列的值通过 values  -----指定\n--注意：列和值要一一对应，多个列和多个值之间，使用英文的逗号分隔\ninsert into table_name (列1,列2...) values (值1,值2...)\n</code></pre>\n<ul>\n<li>向users 表中，插入一条username为 tony stark，password为098123的用户数据，示例如下:</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/a80befe850e548fdb1de8f23a56d9644.png#pic_center\"></p>\n<p><strong>SQL的UPDATE语句</strong></p>\n<ul>\n<li>Update语句用于修改表中的数据。语法格式如下:</li>\n</ul>\n<pre><code class=\"sql\">--语法解读：\n--1.用update 指定要更新哪个表中的数据\n--2.用 set 指定列对应的新值\n--3.用 where 指定更新的条件\n \n update 表名称 set 列名称 = 新值 where 列名称 = 某值\n</code></pre>\n<ul>\n<li>UPDATE示例–更新某一行中的一个列，把users表中id为7的用户密码，更新为888888。示例如下:</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/5dc1ab1c716b49e1b183c9b0f0b327b7.png#pic_center\"></p>\n<ul>\n<li>UPDATE示例–更新某一行中的若干列，把users表中id为2的用户密码和用户状态，分别更新为admin123和1。示例如下:</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/709f651be5dd454490d760414e718156.png#pic_center\"></p>\n<p><strong>SQL的DELETE语句</strong></p>\n<ul>\n<li>DELETE语句用于删除表中的行。语法格式如下:</li>\n</ul>\n<pre><code class=\"sql\">--语法解读：\n--从指定的表中，根据where条件，删除对应的数据行\ndelete from 表名称 where 列名称 = 值\n</code></pre>\n<ul>\n<li>从users表中，删除id为4的用户，示例如下:</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/edecca5696f84d30a65300393ca834c0.png#pic_center\"></p>\n<p><strong>SQL的WHERE子句</strong></p>\n<ul>\n<li>WHERE子句用于限定选择的标准。在SELECT、UPDATE、DELETE语句中，皆可使用WHERE子句来限定选择的标准</li>\n</ul>\n<pre><code class=\"sql\">--查询语句中的 where 条件\nselect 列名称 from 表名称 where 列 运算符 值\n\n--更新语句中的 where 条件\nupdate 表名称 set 列=新值 where 列 运算符 值\n\n--删除语句中的 where 条件\ndelete from 表名称 where 列 运算符 值\n</code></pre>\n<ul>\n<li>下面的运算符可在WHERE子句中使用，用来限定选择的标准:</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/c54df7d6f6f4451db8dbe8a380572b7c.png#pic_center\"></p>\n<ul>\n<li><p>注意:在某些版本的SQL中，操作符&lt;&gt;可以写为!&#x3D;</p>\n</li>\n<li><p>可以通过WHERE子句来限定SELECT的查询条件:</p>\n</li>\n</ul>\n<pre><code class=\"sql\">--查询status为1的所有用户\nSELECT * FROM users WHERE status=1\n\n--查询id 大于2的所有用户\nSELECT * FROM users WHERE id&gt;2\n\n--查询username 不等于admin的所有用户\nSELECT * FROM users WHERE username&lt;&gt; &#39;admin&#39;\n</code></pre>\n<p><strong>SQL的AND和OR运算符</strong></p>\n<ul>\n<li><p>AND和OR可在WHERE子语句中把两个或多个条件结合起来</p>\n</li>\n<li><p>AND表示必须同时满足多个条件，相当于JavaScript中的&amp;&amp;运算符，例如 if (a !&#x3D;&#x3D; 10 &amp;&amp; a !&#x3D;&#x3D; 20)</p>\n</li>\n<li><p>OR表示只要满足任意一个条件即可，相当于JavaScript中||运算符，例如if(a !&#x3D;&#x3D; 10||a !&#x3D;&#x3D; 20)</p>\n</li>\n<li><p>使用AND来显示所有status为0，并且id小于3的用户:</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/d1f2bd4aee6344c8b88e1b800315786b.png#pic_center\"></p>\n<ul>\n<li>使用OR来显示所有status为1，或者username为zs 的用户:</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/4f648717ef29475289d41ee3ffdb2e03.png#pic_center\"></p>\n<p><strong>SQL的OEDED BY子句</strong></p>\n<ul>\n<li><p>ORDER BY语句用于根据指定的列对结果集进行排序</p>\n</li>\n<li><p>RDER BY语句<strong>默认</strong>按照<strong>升序</strong>对记录进行排序</p>\n</li>\n<li><p>如果您希望按照<strong>降序</strong>对记录进行排序，可以使用<strong>DESC关键字</strong></p>\n</li>\n<li><p>升序排序：对users表中的数据，按照status字段进行升序排序，示例如下:</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/9245cd5675e7419b8329e050f4f15f48.png#pic_center\"></p>\n<ul>\n<li>降序排序：对users表中的数据，按照id字段进行降序排序，示例如下:</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/9c499cc6a46f4ed4870d212f7e9ab0e5.png#pic_center\"></p>\n<ul>\n<li>多重排序：对users 表中的数据，先按照status字段进行降序排序，再按照username的字母顺序，进行升序排序，示例如下:</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/dfa4cfd7661c4770ada543d287bde471.png#pic_center\"></p>\n<p><strong>SQL的COUNT(*)语句</strong></p>\n<ul>\n<li>COUNT(*)函数用于返回查询结果的总数据条数，语法格式如下:</li>\n</ul>\n<pre><code class=\"sql\">SELECT COUNT(*) FROM 表名称\n</code></pre>\n<ul>\n<li>杳询users表中status为0的总数据条数:</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/047ef7c623814bceb44c5720fbf2dcde.png#pic_center\"></p>\n<ul>\n<li>如果希望给查询出来的列名称设置别名，可以使用AS关键字，示例如下:</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/1eb7afa84e12450cbe039149ca8aa0d8.png#pic_center\"></p>\n<h3 id=\"4-4-在项目中操作MySql\"><a href=\"#4-4-在项目中操作MySql\" class=\"headerlink\" title=\"4.4 在项目中操作MySql\"></a>4.4 在项目中操作MySql</h3><p><strong>步骤：</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/19b32916bc994cc0a82c9a1ac7f62faf.png#pic_center\"></p>\n<ol>\n<li><p>安装操作MySQL数据库的第三方模块(mysql)</p>\n<ul>\n<li><code>npm install mysql</code></li>\n</ul>\n</li>\n<li><p>通过mysql模块连接到MySQL数据库</p>\n<pre><code class=\"js\">//1.导入mysql模块\nconst mysql = require(&#39;mysql&#39;)\n//2.建立与mysql数据库的连接关系\nconst db = mysql.createPool(&#123;\n    host: &#39;127.0.0.1&#39;,      //数据库的IP地址\n    user: &#39;root&#39;,           //登录数据库的账号\n    password: &#39;123456&#39;,     //登录数据库的密码\n    database: &#39;my_db_01&#39;,   //待操作的数据库\n&#125;)\n</code></pre>\n</li>\n<li><p>通过mysql模块执行SQL语句</p>\n<pre><code class=\"js\">//测试mysql模块能否正常工作\ndb.query(&#39;select 1&#39;, (err, results) =&gt; &#123;\n    //报错\n    if (err) return console.log(err.message)\n    //正常\n    console.log(results)\n&#125;)\n</code></pre>\n</li>\n</ol>\n<ul>\n<li>查：</li>\n</ul>\n<pre><code class=\"js\">//查询user表中所有的数据\nconst sqlStr = &#39;select * from users&#39;\ndb.query(sqlStr, (err, results) =&gt; &#123;\n    //报错\n    if (err) return console.log(err.message)\n    //正常\n    console.log(results)\n&#125;)\n</code></pre>\n<ul>\n<li>增：</li>\n</ul>\n<pre><code class=\"js\">//新增数据\nconst user = &#123; username: &#39;ironman&#39;, password: &#39;123456&#39; &#125;\n//定义待执行的SQL语句\nconst sqlStr = &#39;insert into users (username,password) values(?,?)&#39;\n//执行SQL语句\ndb.query(sqlStr, [user.username, user.password], (err, results) =&gt; &#123;\n    //报错\n    if (err) return console.log(err.message)\n    //正常\n    if (results.affectedRows === 1) &#123;\n        console.log(&#39;插入数据成功!&#39;)\n    &#125;\n&#125;)\n</code></pre>\n<pre><code class=\"js\">//向表中新增数据时，如果数据对象的每个属性和数据表的字段一一对应，则可以通过如下方式快速插入数据\n//新增数据\nconst user = &#123; username: &#39;ironman&#39;, password: &#39;123456&#39; &#125;\n//定义待执行的SQL语句\nconst sqlStr = &#39;insert into users set ?&#39;\n//执行SQL语句\ndb.query(sqlStr, user, (err, results) =&gt; &#123;\n    //报错\n    if (err) return console.log(err.message)\n    //正常\n    if (results.affectedRows === 1) &#123;\n        console.log(&#39;插入数据成功!&#39;)\n    &#125;\n&#125;)\n</code></pre>\n<ul>\n<li>改：</li>\n</ul>\n<pre><code class=\"js\">//更新用户信息\nconst user = &#123; id: 6, username: &#39;aaa&#39;, password: &#39;000&#39; &#125;\n//定义SQL语句\nconst sqlStr = &#39;update users set username=?,password=? where id=?&#39;\n//执行SQL语句\ndb.query(sqlStr, [user.ueername, user.password, user.id], (err, results) =&gt; &#123;\n    //报错\n    if (err) return console.log(err.message)\n    //正常\n    if (results.affectedRows === 1) &#123;\n        console.log(&#39;更新数据成功!&#39;)\n    &#125;\n&#125;)\n</code></pre>\n<pre><code class=\"js\">//向表中新增数据时，如果数据对象的每个属性和数据表的字段—一对应，则可以通过如下方式快速更新数据\n//更新用户信息\nconst user = &#123; id: 6, username: &#39;aaa&#39;, password: &#39;000&#39; &#125;\n//定义SQL语句\nconst sqlStr = &#39;update users set ? where id=?&#39;\n//执行SQL语句\ndb.query(sqlStr, [user, user.id], (err, results) =&gt; &#123;\n    //报错\n    if (err) return console.log(err.message)\n    //正常\n    if (results.affectedRows === 1) &#123;\n        console.log(&#39;更新数据成功!&#39;)\n    &#125;\n&#125;)\n</code></pre>\n<ul>\n<li>删：</li>\n</ul>\n<pre><code class=\"js\">// 1．要执行的SQL语句\nconst sqlStr = &#39;DELETE FROM users WHERE id=?&#39;\n//2．调用db.query()执行SQL语句的同时，为占位符指定具体的值\n//注意:如果SQL语句中有多个占位符，则必须使用数组为每个占位符指定具体的值&quot;\n//如果SQL语句中只有一个占位符，则可以省略数组\ndb.query(sqlStr, 5, (err, results) =&gt; &#123;\n    if (err) return console.log(err.message)// 失败\n    if (results.affectedRows === 1) &#123;\n        console.log(&#39;删除数据成功! &#39;)\n    &#125; // 成功\n&#125;)\n</code></pre>\n<pre><code class=\"js\">//所谓的标记删除，就是在表中设置类似于status这样的状态字段，来标记当前这条数据是否被删除\n</code></pre>\n<h3 id=\"4-5-前后端的身份认证\"><a href=\"#4-5-前后端的身份认证\" class=\"headerlink\" title=\"4.5 前后端的身份认证\"></a>4.5 前后端的身份认证</h3><p><strong>Web开发模式</strong></p>\n<ol>\n<li>基于服务端渲染的传统Web开发模式(企业级网站)<ul>\n<li>服务端渲染的概念:服务器发送给客户端的HTML页面，是在服务器通过字符串的拼接，动态生成的。因此，客户端不需要使用Ajax这样的技术额外请求页面的数据</li>\n<li>优点：前端耗时少，有利于SEO</li>\n<li>缺点：占用服务器资源，不利于前后端分离，开发效率低</li>\n</ul>\n</li>\n<li>基于前后端分吉的新型web开发模式(后台管理项目)<ul>\n<li>前后端分离的概念:前后端分离的开发模式，依赖于Ajax技术的广泛应用。简而言之，前后端分离的Web开发模式，就是后端只负责提供API接口，前端使用Ajax调用接口的开发模式</li>\n<li>优点：开发体验好，用户体验好，减轻了服务器端的渲染压力</li>\n<li>缺点：不利于SEO</li>\n</ul>\n</li>\n</ol>\n<p> <strong>身份认证</strong></p>\n<ul>\n<li>身份认证(Authentication)又称“身份验证”、“鉴权”，是指通过一定的手段，完成对用户身份的确认</li>\n<li>如手机验证码登录、邮箱密码登录、二维码登录等等</li>\n<li>对于服务端渲染和前后端分离这两种开发模式来说，分别有着不同的身份认证方案:<ol>\n<li>服务端渲染推荐使用Session认证机制</li>\n<li>前后端分离推荐使用JWT认证机制</li>\n</ol>\n</li>\n</ul>\n<p><strong>Session 认证机制</strong></p>\n<ul>\n<li>HTTP协议的无状态性，指的是客户端的每次HTTP请求都是独立的，连续多个请求之间没有直接的关系，服务器不会主动保留每次HTTP请求的状态</li>\n<li>Cookie 是存储在用户浏览器中的一段不超过4KB的字符串。它由一个名称(Name)、一个值(Value)和其它几个用于控制Cookie 有效期、安全性、使用范围的可选属性组成</li>\n<li>不同域名下的Cookie<strong>各自独立</strong>，每当客户端发起请求时，会自动把当前域名下所有未过期的Cookie一同发送到服务器</li>\n<li>Cookie的几大特性:<ol>\n<li>自动发送</li>\n<li>域名独立</li>\n<li>过期时限</li>\n<li>4KB限制</li>\n</ol>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/e860467aac4e405db2597cb1613b2d8b.png#pic_center\"></p>\n<ul>\n<li>由于Cookie 是存储在浏览器中的，而且浏览器也提供了读写Cookie的API，因此Cookie很容易被伪造，不具有安全性。因此不建议服务器将重要的隐私数据， 通过Cookie的形式发送给浏览器**(Cookie不具有安全性)**</li>\n<li>Session认证机制：</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/6eb70135413c4904a57a67ca65a1f6b6.png#pic_center\"></p>\n<p><strong>在Express中使用Session 认证</strong></p>\n<ol>\n<li>安装express-session中间件：<code>npm install express-session</code></li>\n<li>配置express-session中间件</li>\n<li>向session中存数据</li>\n<li>从session中取数据</li>\n<li>清空session</li>\n</ol>\n<ul>\n<li>代码：</li>\n</ul>\n<pre><code class=\"js\">// 导入 express 模块\nconst express = require(&#39;express&#39;)\n// 创建 express 的服务器实例\nconst app = express()\n\n// TODO_01：请配置 Session 中间件\nconst session = require(&#39;express-session&#39;)\napp.use(\n  session(&#123;\n    secret: &#39;itheima&#39;,\n    resave: false,\n    saveUninitialized: true,\n  &#125;)\n)\n\n// 托管静态页面\napp.use(express.static(&#39;./pages&#39;))\n// 解析 POST 提交过来的表单数据\napp.use(express.urlencoded(&#123; extended: false &#125;))\n\n// 登录的 API 接口\napp.post(&#39;/api/login&#39;, (req, res) =&gt; &#123;\n  // 判断用户提交的登录信息是否正确\n  if (req.body.username !== &#39;admin&#39; || req.body.password !== &#39;000000&#39;) &#123;\n    return res.send(&#123; status: 1, msg: &#39;登录失败&#39; &#125;)\n  &#125;\n\n  // TODO_02：请将登录成功后的用户信息，保存到 Session 中\n  // 注意：只有成功配置了 express-session 这个中间件之后，才能够通过 req 点出来 session 这个属性\n  req.session.user = req.body // 用户的信息\n  req.session.islogin = true // 用户的登录状态\n\n  res.send(&#123; status: 0, msg: &#39;登录成功&#39; &#125;)\n&#125;)\n\n// 获取用户姓名的接口\napp.get(&#39;/api/username&#39;, (req, res) =&gt; &#123;\n  // TODO_03：请从 Session 中获取用户的名称，响应给客户端\n  if (!req.session.islogin) &#123;\n    return res.send(&#123; status: 1, msg: &#39;fail&#39; &#125;)\n  &#125;\n  res.send(&#123;\n    status: 0,\n    msg: &#39;success&#39;,\n    username: req.session.user.username,\n  &#125;)\n&#125;)\n\n// 退出登录的接口\napp.post(&#39;/api/logout&#39;, (req, res) =&gt; &#123;\n  // TODO_04：清空 Session 信息\n  req.session.destroy()\n  res.send(&#123;\n    status: 0,\n    msg: &#39;退出登录成功&#39;,\n  &#125;)\n&#125;)\n\n// 调用 app.listen 方法，指定端口号并启动web服务器\napp.listen(80, function () &#123;\n  console.log(&#39;Express server running at http://127.0.0.1:80&#39;)\n&#125;)\n</code></pre>\n<p><strong>JWT认证机制</strong></p>\n<ul>\n<li>当前端请求后端接口不存在跨域问题的时候，推荐使用<strong>Session身份认证机制</strong></li>\n<li>当前端需要跨域请求后端接口的时候，不推荐使用Session身份认证机制，推荐使用<strong>JWT认证机制</strong>(JSON Web Token目前最流行的跨域认证解决方案)</li>\n<li>JWT工作原理：用户的信息通过Token字符串的形式，保存在客户端浏览器中。服务器通过还原Token 字符串的形式来认证用户的身份</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/d67ee49d87cd4217849eb3d02f49e5ae.png#pic_center\"></p>\n<ul>\n<li>JWT通常由三部分组成，分别是Header (头部) 、Payload(有效荷载） 、Signature(签名)，三者之间使用英文的“.”分隔；<strong>Payload部分</strong>才是<strong>真正的用户信息</strong>，它是用户信息经过加密之后生成的字符串，Header和Signature<strong>是</strong>安全性相关**的部分，只是为了保证Token的安全性</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/c5eb4a7a31a2422e97a2aaa1dd263b11.png#pic_center\"></p>\n<ul>\n<li>客户端收到服务器返回的JWT之后，通常会将它储存在localStorage或sessionStorage 中；此后，客户端每次与服务器通信，都要带上这个JWT的字符串，从而进行身份认证；推荐的做法是把JWT放在HTTP请求头的Authorization字段中：<code>Authorization: Bearer &lt;token&gt;</code></li>\n</ul>\n<p><strong>在Express中使用JWT</strong></p>\n<ol>\n<li>安装JWT相关的包：<code>npm install jsonwebtoken express-jwt</code></li>\n<li>导入JWT相关的包</li>\n<li>定义secret密钥</li>\n<li>在登录成功后生成JWT字符串</li>\n<li>将JWT字符串还原为JSON对象</li>\n<li>使用req.user获取用户信息</li>\n<li>捕获解析JWT失败后产生的错误</li>\n</ol>\n<ul>\n<li>代码：</li>\n</ul>\n<pre><code class=\"js\">// 导入 express 模块\nconst express = require(&#39;express&#39;)\n// 创建 express 的服务器实例\nconst app = express()\n\n// TODO_01：安装并导入 JWT 相关的两个包，分别是 jsonwebtoken 和 express-jwt\nconst jwt = require(&#39;jsonwebtoken&#39;)\nconst expressJWT = require(&#39;express-jwt&#39;)\n\n// 允许跨域资源共享\nconst cors = require(&#39;cors&#39;)\napp.use(cors())\n\n// 解析 post 表单数据的中间件\nconst bodyParser = require(&#39;body-parser&#39;)\napp.use(bodyParser.urlencoded(&#123; extended: false &#125;))\n\n// TODO_02：定义 secret 密钥，建议将密钥命名为 secretKey\nconst secretKey = &#39;itheima No1 ^_^&#39;\n\n// TODO_04：注册将 JWT 字符串解析还原成 JSON 对象的中间件\n// 注意：只要配置成功了 express-jwt 这个中间件，就可以把解析出来的用户信息，挂载到 req.user 属性上\napp.use(expressJWT(&#123; secret: secretKey &#125;).unless(&#123; path: [/^\\/api\\//] &#125;))\n\n// 登录接口\napp.post(&#39;/api/login&#39;, function (req, res) &#123;\n  // 将 req.body 请求体中的数据，转存为 userinfo 常量\n  const userinfo = req.body\n  // 登录失败\n  if (userinfo.username !== &#39;admin&#39; || userinfo.password !== &#39;000000&#39;) &#123;\n    return res.send(&#123;\n      status: 400,\n      message: &#39;登录失败！&#39;,\n    &#125;)\n  &#125;\n  // 登录成功\n  // TODO_03：在登录成功之后，调用 jwt.sign() 方法生成 JWT 字符串。并通过 token 属性发送给客户端\n  // 参数1：用户的信息对象\n  // 参数2：加密的秘钥\n  // 参数3：配置对象，可以配置当前 token 的有效期\n  // 记住：千万不要把密码加密到 token 字符中\n  const tokenStr = jwt.sign(&#123; username: userinfo.username &#125;, secretKey, &#123; expiresIn: &#39;30s&#39; &#125;)\n  res.send(&#123;\n    status: 200,\n    message: &#39;登录成功！&#39;,\n    token: tokenStr, // 要发送给客户端的 token 字符串\n  &#125;)\n&#125;)\n\n// 这是一个有权限的 API 接口\napp.get(&#39;/admin/getinfo&#39;, function (req, res) &#123;\n  // TODO_05：使用 req.user 获取用户信息，并使用 data 属性将用户信息发送给客户端\n  console.log(req.user)\n  res.send(&#123;\n    status: 200,\n    message: &#39;获取用户信息成功！&#39;,\n    data: req.user, // 要发送给客户端的用户信息\n  &#125;)\n&#125;)\n\n// TODO_06：使用全局错误处理中间件，捕获解析 JWT 失败后产生的错误\napp.use((err, req, res, next) =&gt; &#123;\n  // 这次错误是由 token 解析失败导致的\n  if (err.name === &#39;UnauthorizedError&#39;) &#123;\n    return res.send(&#123;\n      status: 401,\n      message: &#39;无效的token&#39;,\n    &#125;)\n  &#125;\n  res.send(&#123;\n    status: 500,\n    message: &#39;未知的错误&#39;,\n  &#125;)\n&#125;)\n\n// 调用 app.listen 方法，指定端口号并启动web服务器\napp.listen(8888, function () &#123;\n  console.log(&#39;Express server running at http://127.0.0.1:8888&#39;)\n&#125;)\n</code></pre>\n<p>码：</p>\n<pre><code class=\"js\">// 导入 express 模块\nconst express = require(&#39;express&#39;)\n// 创建 express 的服务器实例\nconst app = express()\n\n// TODO_01：安装并导入 JWT 相关的两个包，分别是 jsonwebtoken 和 express-jwt\nconst jwt = require(&#39;jsonwebtoken&#39;)\nconst expressJWT = require(&#39;express-jwt&#39;)\n\n// 允许跨域资源共享\nconst cors = require(&#39;cors&#39;)\napp.use(cors())\n\n// 解析 post 表单数据的中间件\nconst bodyParser = require(&#39;body-parser&#39;)\napp.use(bodyParser.urlencoded(&#123; extended: false &#125;))\n\n// TODO_02：定义 secret 密钥，建议将密钥命名为 secretKey\nconst secretKey = &#39;itheima No1 ^_^&#39;\n\n// TODO_04：注册将 JWT 字符串解析还原成 JSON 对象的中间件\n// 注意：只要配置成功了 express-jwt 这个中间件，就可以把解析出来的用户信息，挂载到 req.user 属性上\napp.use(expressJWT(&#123; secret: secretKey &#125;).unless(&#123; path: [/^\\/api\\//] &#125;))\n\n// 登录接口\napp.post(&#39;/api/login&#39;, function (req, res) &#123;\n  // 将 req.body 请求体中的数据，转存为 userinfo 常量\n  const userinfo = req.body\n  // 登录失败\n  if (userinfo.username !== &#39;admin&#39; || userinfo.password !== &#39;000000&#39;) &#123;\n    return res.send(&#123;\n      status: 400,\n      message: &#39;登录失败！&#39;,\n    &#125;)\n  &#125;\n  // 登录成功\n  // TODO_03：在登录成功之后，调用 jwt.sign() 方法生成 JWT 字符串。并通过 token 属性发送给客户端\n  // 参数1：用户的信息对象\n  // 参数2：加密的秘钥\n  // 参数3：配置对象，可以配置当前 token 的有效期\n  // 记住：千万不要把密码加密到 token 字符中\n  const tokenStr = jwt.sign(&#123; username: userinfo.username &#125;, secretKey, &#123; expiresIn: &#39;30s&#39; &#125;)\n  res.send(&#123;\n    status: 200,\n    message: &#39;登录成功！&#39;,\n    token: tokenStr, // 要发送给客户端的 token 字符串\n  &#125;)\n&#125;)\n\n// 这是一个有权限的 API 接口\napp.get(&#39;/admin/getinfo&#39;, function (req, res) &#123;\n  // TODO_05：使用 req.user 获取用户信息，并使用 data 属性将用户信息发送给客户端\n  console.log(req.user)\n  res.send(&#123;\n    status: 200,\n    message: &#39;获取用户信息成功！&#39;,\n    data: req.user, // 要发送给客户端的用户信息\n  &#125;)\n&#125;)\n\n// TODO_06：使用全局错误处理中间件，捕获解析 JWT 失败后产生的错误\napp.use((err, req, res, next) =&gt; &#123;\n  // 这次错误是由 token 解析失败导致的\n  if (err.name === &#39;UnauthorizedError&#39;) &#123;\n    return res.send(&#123;\n      status: 401,\n      message: &#39;无效的token&#39;,\n    &#125;)\n  &#125;\n  res.send(&#123;\n    status: 500,\n    message: &#39;未知的错误&#39;,\n  &#125;)\n&#125;)\n\n// 调用 app.listen 方法，指定端口号并启动web服务器\napp.listen(8888, function () &#123;\n  console.log(&#39;Express server running at http://127.0.0.1:8888&#39;)\n&#125;)\n</code></pre>\n","feature":true,"text":"Node.js是建立在Chrome V8引擎之上的JavaScript运行时环境，可用于快速构建可伸缩的网络应用。它采用事件驱动、非阻塞I/O模型，适用于实时数据处理。Node.js还拥有丰富的包管理工具，如npm，使得前端开发者能够方便地共享和重复使用代码。...","permalink":"/post/前端--详解Node.js(快速入门)","photos":[],"count_time":{"symbolsCount":"43k","symbolsTime":"39 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"Node","slug":"Node","count":1,"path":"api/tags/Node.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Node-js\"><span class=\"toc-text\">Node.js</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%88%9D%E8%AF%86Node-js%E4%B8%8E%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">1、初识Node.js与内置模块</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-Node-js%E5%88%9D%E8%AF%86\"><span class=\"toc-text\">1.1 Node.js初识</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">1.2 fs文件系统模块</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-path%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">1.3 path路径模块</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-http%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">1.4 http模块</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96\"><span class=\"toc-text\">2、模块化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">2.1 模块化的基本概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-Node-js%E4%B8%AD%E6%A8%A1%E5%9D%97%E5%8C%96\"><span class=\"toc-text\">2.2 Node.js中模块化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-npm%E4%B8%8E%E5%8C%85\"><span class=\"toc-text\">2.3 npm与包</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">2.4 模块的加载机制</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3%E3%80%81Express\"><span class=\"toc-text\">3、Express</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-%E5%88%9D%E8%AF%86Express\"><span class=\"toc-text\">3.1 初识Express</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-Express%E8%B7%AF%E7%94%B1\"><span class=\"toc-text\">3.2 Express路由</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-Express%E4%B8%AD%E9%97%B4%E4%BB%B6\"><span class=\"toc-text\">3.3 Express中间件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-%E4%BD%BF%E7%94%A8Express%E5%86%99%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">3.4 使用Express写接口</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81\"><span class=\"toc-text\">4、数据库与身份认证</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">4.1 数据库的基本概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEMySQL\"><span class=\"toc-text\">4.2 安装并配置MySQL</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-MySQL%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">4.3 MySQL的基本使用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%93%8D%E4%BD%9CMySql\"><span class=\"toc-text\">4.4 在项目中操作MySql</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-5-%E5%89%8D%E5%90%8E%E7%AB%AF%E7%9A%84%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81\"><span class=\"toc-text\">4.5 前后端的身份认证</span></a></li></ol></li></ol></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"从回调地狱到Promise天堂：前端异步革命","uid":"0da050a8ade26330ecd92d326adb320f","slug":"前端--Promise详解与手写实现","date":"2023-01-28T00:56:24.000Z","updated":"2025-07-14T15:12:20.464Z","comments":true,"path":"api/articles/前端--Promise详解与手写实现.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/direct/ea4f563866fc420facc03cf475d9ad7a.png","text":"在前端开发中，Promise是一种用于处理异步操作的对象，可简化回调函数嵌套，有效管理复杂的异步代码。通过Promise，可以更清晰地表达和处理异步操作的结果，避免回调地狱问题，提高代码的可读性和可维护性。...","permalink":"/post/前端--Promise详解与手写实现","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"Promise","slug":"Promise","count":1,"path":"api/tags/Promise.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true},"next_post":{"title":"Git版本控制：提升开发效率的利器","uid":"ad76127bba596077a6c93849dfcec704","slug":"前端--详解Git(快速入门)","date":"2023-01-17T02:06:29.000Z","updated":"2025-07-14T15:12:20.467Z","comments":true,"path":"api/articles/前端--详解Git(快速入门).json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/6796a1b23dba46b1a5cb2263314b0bc4.jpeg","text":"Git是一种分布式版本控制系统，广泛应用于软件开发中。它可以记录和管理项目的历史修改，并支持多人协作开发。通过Git，开发者可以轻松地跟踪代码变更、合并分支、回退版本等操作，保证代码的稳定性和可追溯性。...","permalink":"/post/前端--详解Git(快速入门)","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"Git","slug":"Git","count":1,"path":"api/tags/Git.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true}}