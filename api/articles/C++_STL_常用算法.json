{"title":"C++_STL_常用算法","uid":"9e5f4d79310e12911a75fefd0392a14d","slug":"C++_STL_常用算法","date":"2022-01-15T08:40:57.000Z","updated":"2025-07-14T15:12:20.457Z","comments":true,"path":"api/articles/C++_STL_常用算法.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/506e6842fd8542408c76ef139e90ebd3.png","content":"<hr>\n<h2 id=\"C-STL-常用算法\"><a href=\"#C-STL-常用算法\" class=\"headerlink\" title=\"C++ STL-常用算法\"></a>C++ STL-常用算法</h2><p><strong>概述</strong>:</p>\n<ul>\n<li><p>算法主要是由头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code>组成。</p>\n</li>\n<li><p><code>&lt;algorithm&gt;</code>是所有 STL 头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</p>\n</li>\n<li><p><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</p>\n</li>\n<li><p><code>&lt;functional&gt;</code>定义了一些模板类,用以声明函数对象。</p>\n</li>\n</ul>\n<h3 id=\"1-常用遍历算法\"><a href=\"#1-常用遍历算法\" class=\"headerlink\" title=\"1 常用遍历算法\"></a>1 常用遍历算法</h3><p><strong>学习目标：</strong></p>\n<ul>\n<li>掌握常用的遍历算法</li>\n</ul>\n<p><strong>算法简介：</strong></p>\n<ul>\n<li><code>for_each</code> &#x2F;&#x2F;遍历容器</li>\n<li><code>transform</code> &#x2F;&#x2F;搬运容器到另一个容器中</li>\n</ul>\n<h4 id=\"1-1-for-each\"><a href=\"#1-1-for-each\" class=\"headerlink\" title=\"1.1 for_each\"></a>1.1 for_each</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>实现遍历容器</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><p><code>for_each(iterator beg, iterator end, _func);  </code></p>\n<p>&#x2F;&#x2F; 遍历算法 遍历容器元素</p>\n<p>&#x2F;&#x2F; beg 开始迭代器</p>\n<p>&#x2F;&#x2F; end 结束迭代器</p>\n<p>&#x2F;&#x2F; _func 函数或者函数对象</p>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\n//普通函数\nvoid print01(int val)\n&#123;\n    cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n&#125;\n//函数对象\nclass print02\n&#123;\n public:\n    void operator()(int val)\n    &#123;\n        cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\n//for_each算法基本用法\nvoid test01() &#123;\n\n    vector&lt;int&gt; v;\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        v.push_back(i);\n    &#125;\n\n    //遍历算法\n    for_each(v.begin(), v.end(), print01);\n    cout &lt;&lt; endl;\n\n    for_each(v.begin(), v.end(), print02());\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p><strong>总结</strong>：for_each 在实际开发中是最常用遍历算法，需要熟练掌握</p>\n<h4 id=\"1-2-transform\"><a href=\"#1-2-transform\" class=\"headerlink\" title=\"1.2 transform\"></a>1.2 transform</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>搬运容器到另一个容器中</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code></li>\n</ul>\n<p>&#x2F;&#x2F;beg1 源容器开始迭代器</p>\n<p>&#x2F;&#x2F;end1 源容器结束迭代器</p>\n<p>&#x2F;&#x2F;beg2 目标容器开始迭代器</p>\n<p>&#x2F;&#x2F;_func 函数或者函数对象</p>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include&lt;vector&gt;\n#include&lt;algorithm&gt;\n\n//常用遍历算法  搬运 transform\n\nclass TransForm\n&#123;\npublic:\n    int operator()(int val)\n    &#123;\n        return val;\n    &#125;\n\n&#125;;\n\nclass MyPrint\n&#123;\npublic:\n    void operator()(int val)\n    &#123;\n        cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt;v;\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        v.push_back(i);\n    &#125;\n\n    vector&lt;int&gt;vTarget; //目标容器\n\n    vTarget.resize(v.size()); // 目标容器需要提前开辟空间\n\n    transform(v.begin(), v.end(), vTarget.begin(), TransForm());\n\n    for_each(vTarget.begin(), vTarget.end(), MyPrint());\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p><strong>总结：</strong> 搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p>\n<h3 id=\"2-常用查找算法\"><a href=\"#2-常用查找算法\" class=\"headerlink\" title=\"2 常用查找算法\"></a>2 常用查找算法</h3><p>学习目标：</p>\n<ul>\n<li>掌握常用的查找算法</li>\n</ul>\n<p><strong>算法简介：</strong></p>\n<ul>\n<li><code>find</code> &#x2F;&#x2F;查找元素</li>\n<li><code>find_if</code> &#x2F;&#x2F;按条件查找元素</li>\n<li><code>adjacent_find</code> &#x2F;&#x2F;查找相邻重复元素</li>\n<li><code>binary_search</code> &#x2F;&#x2F;二分查找法</li>\n<li><code>count</code> &#x2F;&#x2F;统计元素个数</li>\n<li><code>count_if</code> &#x2F;&#x2F;按条件统计元素个数</li>\n</ul>\n<h4 id=\"2-1-find\"><a href=\"#2-1-find\" class=\"headerlink\" title=\"2.1 find\"></a>2.1 find</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器 end()</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><p><code>find(iterator beg, iterator end, value);  </code></p>\n<p>&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>\n<p>&#x2F;&#x2F; beg 开始迭代器</p>\n<p>&#x2F;&#x2F; end 结束迭代器</p>\n<p>&#x2F;&#x2F; value 查找的元素</p>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\nvoid test01() &#123;\n\n    vector&lt;int&gt; v;\n    for (int i = 0; i &lt; 10; i++) &#123;\n        v.push_back(i + 1);\n    &#125;\n    //查找容器中是否有 5 这个元素\n    vector&lt;int&gt;::iterator it = find(v.begin(), v.end(), 5);\n    if (it == v.end())\n    &#123;\n        cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl;\n    &#125;\n&#125;\n\nclass Person &#123;\npublic:\n    Person(string name, int age)\n    &#123;\n        this-&gt;m_Name = name;\n        this-&gt;m_Age = age;\n    &#125;\n    //重载==\n    bool operator==(const Person&amp; p)\n    &#123;\n        if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)\n        &#123;\n            return true;\n        &#125;\n        return false;\n    &#125;\n\npublic:\n    string m_Name;\n    int m_Age;\n&#125;;\n\nvoid test02() &#123;\n\n    vector&lt;Person&gt; v;\n\n    //创建数据\n    Person p1(&quot;aaa&quot;, 10);\n    Person p2(&quot;bbb&quot;, 20);\n    Person p3(&quot;ccc&quot;, 30);\n    Person p4(&quot;ddd&quot;, 40);\n\n    v.push_back(p1);\n    v.push_back(p2);\n    v.push_back(p3);\n    v.push_back(p4);\n\n    vector&lt;Person&gt;::iterator it = find(v.begin(), v.end(), p2);\n    if (it == v.end())\n    &#123;\n        cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;\n    &#125;\n&#125;\n</code></pre>\n<p>总结： 利用 find 可以在容器中找指定的元素，返回值是<strong>迭代器</strong></p>\n<h4 id=\"2-2-find-if\"><a href=\"#2-2-find-if\" class=\"headerlink\" title=\"2.2 find_if\"></a>2.2 find_if</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>按条件查找元素</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><p><code>find_if(iterator beg, iterator end, _Pred);  </code></p>\n<p>&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>\n<p>&#x2F;&#x2F; beg 开始迭代器</p>\n<p>&#x2F;&#x2F; end 结束迭代器</p>\n<p>&#x2F;&#x2F; _Pred 函数或者谓词（返回 bool 类型的仿函数）</p>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n\n//内置数据类型\nclass GreaterFive\n&#123;\npublic:\n    bool operator()(int val)\n    &#123;\n        return val &gt; 5;\n    &#125;\n&#125;;\n\nvoid test01() &#123;\n\n    vector&lt;int&gt; v;\n    for (int i = 0; i &lt; 10; i++) &#123;\n        v.push_back(i + 1);\n    &#125;\n\n    vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());\n    if (it == v.end()) &#123;\n        cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;\n    &#125;\n    else &#123;\n        cout &lt;&lt; &quot;找到大于5的数字:&quot; &lt;&lt; *it &lt;&lt; endl;\n    &#125;\n&#125;\n\n//自定义数据类型\nclass Person &#123;\npublic:\n    Person(string name, int age)\n    &#123;\n        this-&gt;m_Name = name;\n        this-&gt;m_Age = age;\n    &#125;\npublic:\n    string m_Name;\n    int m_Age;\n&#125;;\n\nclass Greater20\n&#123;\npublic:\n    bool operator()(Person &amp;p)\n    &#123;\n        return p.m_Age &gt; 20;\n    &#125;\n\n&#125;;\n\nvoid test02() &#123;\n\n    vector&lt;Person&gt; v;\n\n    //创建数据\n    Person p1(&quot;aaa&quot;, 10);\n    Person p2(&quot;bbb&quot;, 20);\n    Person p3(&quot;ccc&quot;, 30);\n    Person p4(&quot;ddd&quot;, 40);\n\n    v.push_back(p1);\n    v.push_back(p2);\n    v.push_back(p3);\n    v.push_back(p4);\n\n    vector&lt;Person&gt;::iterator it = find_if(v.begin(), v.end(), Greater20());\n    if (it == v.end())\n    &#123;\n        cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;\n    &#125;\n&#125;\n\nint main() &#123;\n\n    //test01();\n\n    test02();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：find_if 按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p>\n<h4 id=\"2-3-adjacent-find\"><a href=\"#2-3-adjacent-find\" class=\"headerlink\" title=\"2.3 adjacent_find\"></a>2.3 adjacent_find</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>查找相邻重复元素</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><p><code>adjacent_find(iterator beg, iterator end);  </code></p>\n<p>&#x2F;&#x2F; 查找相邻重复元素,返回相邻元素的第一个位置的迭代器</p>\n<p>&#x2F;&#x2F; beg 开始迭代器</p>\n<p>&#x2F;&#x2F; end 结束迭代器</p>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt; v;\n    v.push_back(1);\n    v.push_back(2);\n    v.push_back(5);\n    v.push_back(2);\n    v.push_back(4);\n    v.push_back(4);\n    v.push_back(3);\n\n    //查找相邻重复元素\n    vector&lt;int&gt;::iterator it = adjacent_find(v.begin(), v.end());\n    if (it == v.end()) &#123;\n        cout &lt;&lt; &quot;找不到!&quot; &lt;&lt; endl;\n    &#125;\n    else &#123;\n        cout &lt;&lt; &quot;找到相邻重复元素为:&quot; &lt;&lt; *it &lt;&lt; endl;\n    &#125;\n&#125;\n</code></pre>\n<p>总结：面试题中如果出现查找相邻重复元素，记得用 STL 中的 adjacent_find 算法</p>\n<h4 id=\"2-4-binary-search\"><a href=\"#2-4-binary-search\" class=\"headerlink\" title=\"2.4 binary_search\"></a>2.4 binary_search</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>查找指定元素是否存在</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><p><code>bool binary_search(iterator beg, iterator end, value);  </code></p>\n<p>&#x2F;&#x2F; 查找指定的元素，查到 返回 true 否则 false</p>\n<p>&#x2F;&#x2F; 注意: 在<strong>无序序列中不可用</strong></p>\n<p>&#x2F;&#x2F; beg 开始迭代器</p>\n<p>&#x2F;&#x2F; end 结束迭代器</p>\n<p>&#x2F;&#x2F; value 查找的元素</p>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt;v;\n\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        v.push_back(i);\n    &#125;\n    //二分查找\n    bool ret = binary_search(v.begin(), v.end(),2);\n    if (ret)\n    &#123;\n        cout &lt;&lt; &quot;找到了&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;\n    &#125;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p><strong>总结</strong>：二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</p>\n<h4 id=\"2-5-count\"><a href=\"#2-5-count\" class=\"headerlink\" title=\"2.5 count\"></a>2.5 count</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>统计元素个数</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><p><code>count(iterator beg, iterator end, value);  </code></p>\n<p>&#x2F;&#x2F; 统计元素出现次数</p>\n<p>&#x2F;&#x2F; beg 开始迭代器</p>\n<p>&#x2F;&#x2F; end 结束迭代器</p>\n<p>&#x2F;&#x2F; value 统计的元素</p>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\n//内置数据类型\nvoid test01()\n&#123;\n    vector&lt;int&gt; v;\n    v.push_back(1);\n    v.push_back(2);\n    v.push_back(4);\n    v.push_back(5);\n    v.push_back(3);\n    v.push_back(4);\n    v.push_back(4);\n\n    int num = count(v.begin(), v.end(), 4);\n\n    cout &lt;&lt; &quot;4的个数为： &quot; &lt;&lt; num &lt;&lt; endl;\n&#125;\n\n//自定义数据类型\nclass Person\n&#123;\npublic:\n    Person(string name, int age)\n    &#123;\n        this-&gt;m_Name = name;\n        this-&gt;m_Age = age;\n    &#125;\n    bool operator==(const Person &amp; p)\n    &#123;\n        if (this-&gt;m_Age == p.m_Age)\n        &#123;\n            return true;\n        &#125;\n        else\n        &#123;\n            return false;\n        &#125;\n    &#125;\n    string m_Name;\n    int m_Age;\n&#125;;\n\nvoid test02()\n&#123;\n    vector&lt;Person&gt; v;\n\n    Person p1(&quot;刘备&quot;, 35);\n    Person p2(&quot;关羽&quot;, 35);\n    Person p3(&quot;张飞&quot;, 35);\n    Person p4(&quot;赵云&quot;, 30);\n    Person p5(&quot;曹操&quot;, 25);\n\n    v.push_back(p1);\n    v.push_back(p2);\n    v.push_back(p3);\n    v.push_back(p4);\n    v.push_back(p5);\n\n    Person p(&quot;诸葛亮&quot;,35);\n\n    int num = count(v.begin(), v.end(), p);\n    cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;\n&#125;\nint main() &#123;\n\n    //test01();\n\n    test02();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p><strong>总结：</strong> 统计自定义数据类型时候，需要配合重载 <code>operator==</code></p>\n<h4 id=\"2-6-count-if\"><a href=\"#2-6-count-if\" class=\"headerlink\" title=\"2.6 count_if\"></a>2.6 count_if</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>按条件统计元素个数</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><p><code>count_if(iterator beg, iterator end, _Pred);  </code></p>\n<p>&#x2F;&#x2F; 按条件统计元素出现次数</p>\n<p>&#x2F;&#x2F; beg 开始迭代器</p>\n<p>&#x2F;&#x2F; end 结束迭代器</p>\n<p>&#x2F;&#x2F; _Pred 谓词</p>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nclass Greater4\n&#123;\npublic:\n    bool operator()(int val)\n    &#123;\n        return val &gt;= 4;\n    &#125;\n&#125;;\n\n//内置数据类型\nvoid test01()\n&#123;\n    vector&lt;int&gt; v;\n    v.push_back(1);\n    v.push_back(2);\n    v.push_back(4);\n    v.push_back(5);\n    v.push_back(3);\n    v.push_back(4);\n    v.push_back(4);\n\n    int num = count_if(v.begin(), v.end(), Greater4());\n\n    cout &lt;&lt; &quot;大于4的个数为： &quot; &lt;&lt; num &lt;&lt; endl;\n&#125;\n\n//自定义数据类型\nclass Person\n&#123;\npublic:\n    Person(string name, int age)\n    &#123;\n        this-&gt;m_Name = name;\n        this-&gt;m_Age = age;\n    &#125;\n\n    string m_Name;\n    int m_Age;\n&#125;;\n\nclass AgeLess35\n&#123;\npublic:\n    bool operator()(const Person &amp;p)\n    &#123;\n        return p.m_Age &lt; 35;\n    &#125;\n&#125;;\nvoid test02()\n&#123;\n    vector&lt;Person&gt; v;\n\n    Person p1(&quot;刘备&quot;, 35);\n    Person p2(&quot;关羽&quot;, 35);\n    Person p3(&quot;张飞&quot;, 35);\n    Person p4(&quot;赵云&quot;, 30);\n    Person p5(&quot;曹操&quot;, 25);\n\n    v.push_back(p1);\n    v.push_back(p2);\n    v.push_back(p3);\n    v.push_back(p4);\n    v.push_back(p5);\n\n    int num = count_if(v.begin(), v.end(), AgeLess35());\n    cout &lt;&lt; &quot;小于35岁的个数：&quot; &lt;&lt; num &lt;&lt; endl;\n&#125;\n\n\nint main() &#123;\n\n    //test01();\n\n    test02();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p><strong>总结</strong>：按值统计用 count，按条件统计用 count_if</p>\n<h3 id=\"3-常用排序算法\"><a href=\"#3-常用排序算法\" class=\"headerlink\" title=\"3 常用排序算法\"></a>3 常用排序算法</h3><p><strong>学习目标：</strong></p>\n<ul>\n<li>掌握常用的排序算法</li>\n</ul>\n<p><strong>算法简介：</strong></p>\n<ul>\n<li><code>sort</code> &#x2F;&#x2F;对容器内元素进行排序</li>\n<li><code>random_shuffle</code> &#x2F;&#x2F;洗牌 指定范围内的元素随机调整次序</li>\n<li><code>merge </code> &#x2F;&#x2F; 容器元素合并，并存储到另一容器中</li>\n<li><code>reverse</code> &#x2F;&#x2F; 反转指定范围的元素</li>\n</ul>\n<h4 id=\"3-1-sort\"><a href=\"#3-1-sort\" class=\"headerlink\" title=\"3.1 sort\"></a>3.1 sort</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>对容器内元素进行排序</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><p><code>sort(iterator beg, iterator end, _Pred);  </code></p>\n<p>&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>\n<p>&#x2F;&#x2F; beg 开始迭代器</p>\n<p>&#x2F;&#x2F; end 结束迭代器</p>\n<p>&#x2F;&#x2F; _Pred 谓词</p>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nvoid myPrint(int val)\n&#123;\n    cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n&#125;\n\nvoid test01() &#123;\n    vector&lt;int&gt; v;\n    v.push_back(10);\n    v.push_back(30);\n    v.push_back(50);\n    v.push_back(20);\n    v.push_back(40);\n\n    //sort默认从小到大排序\n    sort(v.begin(), v.end());\n    for_each(v.begin(), v.end(), myPrint);\n    cout &lt;&lt; endl;\n\n    //从大到小排序\n    sort(v.begin(), v.end(), greater&lt;int&gt;());\n    for_each(v.begin(), v.end(), myPrint);\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p><strong>总结</strong>：sort 属于开发中最常用的算法之一，需熟练掌握</p>\n<h4 id=\"3-2-random-shuffle\"><a href=\"#3-2-random-shuffle\" class=\"headerlink\" title=\"3.2 random_shuffle\"></a>3.2 random_shuffle</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>洗牌 指定范围内的元素随机调整次序</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><p><code>random_shuffle(iterator beg, iterator end);  </code></p>\n<p>&#x2F;&#x2F; 指定范围内的元素随机调整次序</p>\n<p>&#x2F;&#x2F; beg 开始迭代器</p>\n<p>&#x2F;&#x2F; end 结束迭代器</p>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include &lt;ctime&gt;\n\nclass myPrint\n&#123;\npublic:\n    void operator()(int val)\n    &#123;\n        cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\nvoid test01()\n&#123;\n    srand((unsigned int)time(NULL));\n    vector&lt;int&gt; v;\n    for(int i = 0 ; i &lt; 10;i++)\n    &#123;\n        v.push_back(i);\n    &#125;\n    for_each(v.begin(), v.end(), myPrint());\n    cout &lt;&lt; endl;\n\n    //打乱顺序\n    random_shuffle(v.begin(), v.end());\n    for_each(v.begin(), v.end(), myPrint());\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p><strong>总结</strong>：random_shuffle 洗牌算法比较实用，使用时记得加随机数种子</p>\n<h4 id=\"3-3-merge\"><a href=\"#3-3-merge\" class=\"headerlink\" title=\"3.3 merge\"></a>3.3 merge</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>两个容器元素合并，并存储到另一容器中</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><p><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>\n<p>&#x2F;&#x2F; 容器元素合并，并存储到另一容器中</p>\n<p>&#x2F;&#x2F; 注意: 两个容器必须是<strong>有序的</strong></p>\n<p>&#x2F;&#x2F; beg1 容器 1 开始迭代器<br>&#x2F;&#x2F; end1 容器 1 结束迭代器<br>&#x2F;&#x2F; beg2 容器 2 开始迭代器<br>&#x2F;&#x2F; end2 容器 2 结束迭代器<br>&#x2F;&#x2F; dest 目标容器开始迭代器</p>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nclass myPrint\n&#123;\npublic:\n    void operator()(int val)\n    &#123;\n        cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt; v1;\n    vector&lt;int&gt; v2;\n    for (int i = 0; i &lt; 10 ; i++)\n    &#123;\n        v1.push_back(i);\n        v2.push_back(i + 1);\n    &#125;\n\n    vector&lt;int&gt; vtarget;\n    //目标容器需要提前开辟空间\n    vtarget.resize(v1.size() + v2.size());\n    //合并  需要两个有序序列\n    merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vtarget.begin());\n    for_each(vtarget.begin(), vtarget.end(), myPrint());\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p><strong>总结</strong>：merge 合并的两个容器必须的有序序列</p>\n<h4 id=\"3-4-reverse\"><a href=\"#3-4-reverse\" class=\"headerlink\" title=\"3.4 reverse\"></a>3.4 reverse</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>将容器内元素进行反转</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><p><code>reverse(iterator beg, iterator end);  </code></p>\n<p>&#x2F;&#x2F; 反转指定范围的元素</p>\n<p>&#x2F;&#x2F; beg 开始迭代器</p>\n<p>&#x2F;&#x2F; end 结束迭代器</p>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nclass myPrint\n&#123;\npublic:\n    void operator()(int val)\n    &#123;\n        cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt; v;\n    v.push_back(10);\n    v.push_back(30);\n    v.push_back(50);\n    v.push_back(20);\n    v.push_back(40);\n\n    cout &lt;&lt; &quot;反转前： &quot; &lt;&lt; endl;\n    for_each(v.begin(), v.end(), myPrint());\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;反转后： &quot; &lt;&lt; endl;\n\n    reverse(v.begin(), v.end());\n    for_each(v.begin(), v.end(), myPrint());\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p><strong>总结</strong>：reverse 反转区间内元素，面试题可能涉及到</p>\n<h3 id=\"4-常用拷贝和替换算法\"><a href=\"#4-常用拷贝和替换算法\" class=\"headerlink\" title=\"4 常用拷贝和替换算法\"></a>4 常用拷贝和替换算法</h3><p><strong>学习目标：</strong></p>\n<ul>\n<li>掌握常用的拷贝和替换算法</li>\n</ul>\n<p><strong>算法简介：</strong></p>\n<ul>\n<li><code>copy</code> &#x2F;&#x2F; 容器内指定范围的元素拷贝到另一容器中</li>\n<li><code>replace</code> &#x2F;&#x2F; 将容器内指定范围的旧元素修改为新元素</li>\n<li><code>replace_if </code> &#x2F;&#x2F; 容器内指定范围满足条件的元素替换为新元素</li>\n<li><code>swap</code> &#x2F;&#x2F; 互换两个容器的元素</li>\n</ul>\n<h4 id=\"4-1-copy\"><a href=\"#4-1-copy\" class=\"headerlink\" title=\"4.1 copy\"></a>4.1 copy</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>容器内指定范围的元素拷贝到另一容器中</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><p><code>copy(iterator beg, iterator end, iterator dest);  </code></p>\n<p>&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>\n<p>&#x2F;&#x2F; beg 开始迭代器</p>\n<p>&#x2F;&#x2F; end 结束迭代器</p>\n<p>&#x2F;&#x2F; dest 目标起始迭代器</p>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nclass myPrint\n&#123;\npublic:\n    void operator()(int val)\n    &#123;\n        cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt; v1;\n    for (int i = 0; i &lt; 10; i++) &#123;\n        v1.push_back(i + 1);\n    &#125;\n    vector&lt;int&gt; v2;\n    v2.resize(v1.size());\n    copy(v1.begin(), v1.end(), v2.begin());\n\n    for_each(v2.begin(), v2.end(), myPrint());\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p><strong>总结</strong>：利用 copy 算法在拷贝时，目标容器记得提前开辟空间</p>\n<h4 id=\"4-2-replace\"><a href=\"#4-2-replace\" class=\"headerlink\" title=\"4.2 replace\"></a>4.2 replace</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>将容器内指定范围的旧元素修改为新元素</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><p><code>replace(iterator beg, iterator end, oldvalue, newvalue);  </code></p>\n<p>&#x2F;&#x2F; 将区间内旧元素 替换成 新元素</p>\n<p>&#x2F;&#x2F; beg 开始迭代器</p>\n<p>&#x2F;&#x2F; end 结束迭代器</p>\n<p>&#x2F;&#x2F; oldvalue 旧元素</p>\n<p>&#x2F;&#x2F; newvalue 新元素</p>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nclass myPrint\n&#123;\npublic:\n    void operator()(int val)\n    &#123;\n        cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt; v;\n    v.push_back(20);\n    v.push_back(30);\n    v.push_back(20);\n    v.push_back(40);\n    v.push_back(50);\n    v.push_back(10);\n    v.push_back(20);\n\n    cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl;\n    for_each(v.begin(), v.end(), myPrint());\n    cout &lt;&lt; endl;\n\n    //将容器中的20 替换成 2000\n    cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl;\n    replace(v.begin(), v.end(), 20,2000);\n    for_each(v.begin(), v.end(), myPrint());\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p><strong>总结</strong>：replace 会替换区间内满足条件的元素</p>\n<h4 id=\"4-3-replace-if\"><a href=\"#4-3-replace-if\" class=\"headerlink\" title=\"4.3 replace_if\"></a>4.3 replace_if</h4><p><strong>功能描述:</strong></p>\n<ul>\n<li>将区间内满足条件的元素，替换成指定元素</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><p><code>replace_if(iterator beg, iterator end, _pred, newvalue);  </code></p>\n<p>&#x2F;&#x2F; 按条件替换元素，满足条件的替换成指定元素</p>\n<p>&#x2F;&#x2F; beg 开始迭代器</p>\n<p>&#x2F;&#x2F; end 结束迭代器</p>\n<p>&#x2F;&#x2F; _pred 谓词</p>\n<p>&#x2F;&#x2F; newvalue 替换的新元素</p>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nclass myPrint\n&#123;\npublic:\n    void operator()(int val)\n    &#123;\n        cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\nclass ReplaceGreater30\n&#123;\npublic:\n    bool operator()(int val)\n    &#123;\n        return val &gt;= 30;\n    &#125;\n\n&#125;;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt; v;\n    v.push_back(20);\n    v.push_back(30);\n    v.push_back(20);\n    v.push_back(40);\n    v.push_back(50);\n    v.push_back(10);\n    v.push_back(20);\n\n    cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl;\n    for_each(v.begin(), v.end(), myPrint());\n    cout &lt;&lt; endl;\n\n    //将容器中大于等于的30 替换成 3000\n    cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl;\n    replace_if(v.begin(), v.end(), ReplaceGreater30(), 3000);\n    for_each(v.begin(), v.end(), myPrint());\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p><strong>总结</strong>：replace_if 按条件查找，可以利用仿函数灵活筛选满足的条件</p>\n<h4 id=\"4-4-swap\"><a href=\"#4-4-swap\" class=\"headerlink\" title=\"4.4 swap\"></a>4.4 swap</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>互换两个容器的元素</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><p><code>swap(container c1, container c2);  </code></p>\n<p>&#x2F;&#x2F; 互换两个容器的元素</p>\n<p>&#x2F;&#x2F; c1 容器 1</p>\n<p>&#x2F;&#x2F; c2 容器 2</p>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nclass myPrint\n&#123;\npublic:\n    void operator()(int val)\n    &#123;\n        cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt; v1;\n    vector&lt;int&gt; v2;\n    for (int i = 0; i &lt; 10; i++) &#123;\n        v1.push_back(i);\n        v2.push_back(i+100);\n    &#125;\n\n    cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl;\n    for_each(v1.begin(), v1.end(), myPrint());\n    cout &lt;&lt; endl;\n    for_each(v2.begin(), v2.end(), myPrint());\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl;\n    swap(v1, v2);\n    for_each(v1.begin(), v1.end(), myPrint());\n    cout &lt;&lt; endl;\n    for_each(v2.begin(), v2.end(), myPrint());\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p><strong>总结</strong>：swap 交换容器时，注意交换的容器要同种类型</p>\n<h3 id=\"5-常用算术生成算法\"><a href=\"#5-常用算术生成算法\" class=\"headerlink\" title=\"5 常用算术生成算法\"></a>5 常用算术生成算法</h3><p><strong>学习目标：</strong></p>\n<ul>\n<li>掌握常用的算术生成算法</li>\n</ul>\n<p><strong>注意：</strong></p>\n<ul>\n<li>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code></li>\n</ul>\n<p><strong>算法简介：</strong></p>\n<ul>\n<li><p><code>accumulate</code> &#x2F;&#x2F; 计算容器元素累计总和</p>\n</li>\n<li><p><code>fill</code> &#x2F;&#x2F; 向容器中添加元素</p>\n</li>\n</ul>\n<h4 id=\"5-1-accumulate\"><a href=\"#5-1-accumulate\" class=\"headerlink\" title=\"5.1 accumulate\"></a>5.1 accumulate</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>计算区间内 容器元素累计总和</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><p><code>accumulate(iterator beg, iterator end, value);  </code></p>\n<p>&#x2F;&#x2F; 计算容器元素累计总和</p>\n<p>&#x2F;&#x2F; beg 开始迭代器</p>\n<p>&#x2F;&#x2F; end 结束迭代器</p>\n<p>&#x2F;&#x2F; value 起始值</p>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;numeric&gt;\n#include &lt;vector&gt;\nvoid test01()\n&#123;\n    vector&lt;int&gt; v;\n    for (int i = 0; i &lt;= 100; i++) &#123;\n        v.push_back(i);\n    &#125;\n\n    int total = accumulate(v.begin(), v.end(), 0);\n\n    cout &lt;&lt; &quot;total = &quot; &lt;&lt; total &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p><strong>总结</strong>：accumulate 使用时头文件注意是 numeric，这个算法很实用</p>\n<h4 id=\"5-2-fill\"><a href=\"#5-2-fill\" class=\"headerlink\" title=\"5.2 fill\"></a>5.2 fill</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>向容器中填充指定的元素</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><p><code>fill(iterator beg, iterator end, value);  </code></p>\n<p>&#x2F;&#x2F; 向容器中填充元素</p>\n<p>&#x2F;&#x2F; beg 开始迭代器</p>\n<p>&#x2F;&#x2F; end 结束迭代器</p>\n<p>&#x2F;&#x2F; value 填充的值</p>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;numeric&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nclass myPrint\n&#123;\npublic:\n    void operator()(int val)\n    &#123;\n        cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\nvoid test01()\n&#123;\n\n    vector&lt;int&gt; v;\n    v.resize(10);\n    //填充\n    fill(v.begin(), v.end(), 100);\n\n    for_each(v.begin(), v.end(), myPrint());\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p><strong>总结</strong>：利用 fill 可以将容器区间内元素填充为 指定的值</p>\n<h3 id=\"6-常用集合算法\"><a href=\"#6-常用集合算法\" class=\"headerlink\" title=\"6 常用集合算法\"></a>6 常用集合算法</h3><p><strong>学习目标：</strong></p>\n<ul>\n<li>掌握常用的集合算法</li>\n</ul>\n<p><strong>算法简介：</strong></p>\n<ul>\n<li><p><code>set_intersection</code> &#x2F;&#x2F; 求两个容器的交集</p>\n</li>\n<li><p><code>set_union</code> &#x2F;&#x2F; 求两个容器的并集</p>\n</li>\n<li><p><code>set_difference </code> &#x2F;&#x2F; 求两个容器的差集</p>\n</li>\n</ul>\n<h4 id=\"6-1-set-intersection\"><a href=\"#6-1-set-intersection\" class=\"headerlink\" title=\"6.1 set_intersection\"></a>6.1 set_intersection</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>求两个容器的交集</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><p><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>\n<p>&#x2F;&#x2F; 求两个集合的交集</p>\n<p>&#x2F;&#x2F; <strong>注意:两个集合必须是有序序列</strong></p>\n<p>&#x2F;&#x2F; beg1 容器 1 开始迭代器<br>&#x2F;&#x2F; end1 容器 1 结束迭代器<br>&#x2F;&#x2F; beg2 容器 2 开始迭代器<br>&#x2F;&#x2F; end2 容器 2 结束迭代器<br>&#x2F;&#x2F; dest 目标容器开始迭代器</p>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nclass myPrint\n&#123;\npublic:\n    void operator()(int val)\n    &#123;\n        cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt; v1;\n    vector&lt;int&gt; v2;\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        v1.push_back(i);\n        v2.push_back(i+5);\n    &#125;\n\n    vector&lt;int&gt; vTarget;\n    //取两个里面较小的值给目标容器开辟空间\n    vTarget.resize(min(v1.size(), v2.size()));\n\n    //返回目标容器的最后一个元素的迭代器地址\n    vector&lt;int&gt;::iterator itEnd =\n        set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());\n\n    for_each(vTarget.begin(), itEnd, myPrint());\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p><strong>总结：</strong></p>\n<ul>\n<li>求交集的两个集合必须的有序序列</li>\n<li>目标容器开辟空间需要从<strong>两个容器中取小值</strong></li>\n<li>set_intersection 返回值既是交集中最后一个元素的位置</li>\n</ul>\n<h4 id=\"6-2-set-union\"><a href=\"#6-2-set-union\" class=\"headerlink\" title=\"6.2 set_union\"></a>6.2 set_union</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>求两个集合的并集</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><p><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>\n<p>&#x2F;&#x2F; 求两个集合的并集</p>\n<p>&#x2F;&#x2F; <strong>注意:两个集合必须是有序序列</strong></p>\n<p>&#x2F;&#x2F; beg1 容器 1 开始迭代器<br>&#x2F;&#x2F; end1 容器 1 结束迭代器<br>&#x2F;&#x2F; beg2 容器 2 开始迭代器<br>&#x2F;&#x2F; end2 容器 2 结束迭代器<br>&#x2F;&#x2F; dest 目标容器开始迭代器</p>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nclass myPrint\n&#123;\npublic:\n    void operator()(int val)\n    &#123;\n        cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt; v1;\n    vector&lt;int&gt; v2;\n    for (int i = 0; i &lt; 10; i++) &#123;\n        v1.push_back(i);\n        v2.push_back(i+5);\n    &#125;\n\n    vector&lt;int&gt; vTarget;\n    //取两个容器的和给目标容器开辟空间\n    vTarget.resize(v1.size() + v2.size());\n\n    //返回目标容器的最后一个元素的迭代器地址\n    vector&lt;int&gt;::iterator itEnd =\n        set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());\n\n    for_each(vTarget.begin(), itEnd, myPrint());\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p><strong>总结：</strong></p>\n<ul>\n<li>求并集的两个集合必须的有序序列</li>\n<li>目标容器开辟空间需要<strong>两个容器相加</strong></li>\n<li>set_union 返回值既是并集中最后一个元素的位置</li>\n</ul>\n<h4 id=\"6-3-set-difference\"><a href=\"#6-3-set-difference\" class=\"headerlink\" title=\"6.3 set_difference\"></a>6.3 set_difference</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>求两个集合的差集</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><p><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>\n<p>&#x2F;&#x2F; 求两个集合的差集</p>\n<p>&#x2F;&#x2F; <strong>注意:两个集合必须是有序序列</strong></p>\n<p>&#x2F;&#x2F; beg1 容器 1 开始迭代器<br>&#x2F;&#x2F; end1 容器 1 结束迭代器<br>&#x2F;&#x2F; beg2 容器 2 开始迭代器<br>&#x2F;&#x2F; end2 容器 2 结束迭代器<br>&#x2F;&#x2F; dest 目标容器开始迭代器</p>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nclass myPrint\n&#123;\npublic:\n    void operator()(int val)\n    &#123;\n        cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n    &#125;\n&#125;;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt; v1;\n    vector&lt;int&gt; v2;\n    for (int i = 0; i &lt; 10; i++) &#123;\n        v1.push_back(i);\n        v2.push_back(i+5);\n    &#125;\n\n    vector&lt;int&gt; vTarget;\n    //取两个里面较大的值给目标容器开辟空间\n    vTarget.resize( max(v1.size() , v2.size()));\n\n    //返回目标容器的最后一个元素的迭代器地址\n    cout &lt;&lt; &quot;v1与v2的差集为： &quot; &lt;&lt; endl;\n    vector&lt;int&gt;::iterator itEnd =\n        set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());\n    for_each(vTarget.begin(), itEnd, myPrint());\n    cout &lt;&lt; endl;\n\n\n    cout &lt;&lt; &quot;v2与v1的差集为： &quot; &lt;&lt; endl;\n    itEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin());\n    for_each(vTarget.begin(), itEnd, myPrint());\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p><strong>总结：</strong></p>\n<ul>\n<li>求差集的两个集合必须的有序序列</li>\n<li>目标容器开辟空间需要从<strong>两个容器取较大值</strong></li>\n<li>set_difference 返回值既是差集中最后一个元素的位置</li>\n</ul>\n","feature":true,"text":"C++标准模板库（STL）是C++编程中不可或缺的部分，它提供了丰富的数据结构和算法。本文我们将对每种容器和算法进行简要介绍，并给出示例代码加深理解。...","permalink":"/post/C++_STL_常用算法","photos":[],"count_time":{"symbolsCount":"25k","symbolsTime":"22 mins."},"categories":[{"name":"C++","slug":"C","count":6,"path":"api/categories/C.json"}],"tags":[{"name":"STL","slug":"STL","count":3,"path":"api/tags/STL.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#C-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">C++ STL-常用算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%B8%B8%E7%94%A8%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">1 常用遍历算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-for-each\"><span class=\"toc-text\">1.1 for_each</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-transform\"><span class=\"toc-text\">1.2 transform</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%B8%B8%E7%94%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">2 常用查找算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-find\"><span class=\"toc-text\">2.1 find</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-find-if\"><span class=\"toc-text\">2.2 find_if</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-adjacent-find\"><span class=\"toc-text\">2.3 adjacent_find</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-4-binary-search\"><span class=\"toc-text\">2.4 binary_search</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-5-count\"><span class=\"toc-text\">2.5 count</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-6-count-if\"><span class=\"toc-text\">2.6 count_if</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">3 常用排序算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-sort\"><span class=\"toc-text\">3.1 sort</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-random-shuffle\"><span class=\"toc-text\">3.2 random_shuffle</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-3-merge\"><span class=\"toc-text\">3.3 merge</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-4-reverse\"><span class=\"toc-text\">3.4 reverse</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%B8%B8%E7%94%A8%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">4 常用拷贝和替换算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-1-copy\"><span class=\"toc-text\">4.1 copy</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-2-replace\"><span class=\"toc-text\">4.2 replace</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-3-replace-if\"><span class=\"toc-text\">4.3 replace_if</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-4-swap\"><span class=\"toc-text\">4.4 swap</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%9C%AF%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">5 常用算术生成算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-1-accumulate\"><span class=\"toc-text\">5.1 accumulate</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-2-fill\"><span class=\"toc-text\">5.2 fill</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">6 常用集合算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-1-set-intersection\"><span class=\"toc-text\">6.1 set_intersection</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-2-set-union\"><span class=\"toc-text\">6.2 set_union</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-3-set-difference\"><span class=\"toc-text\">6.3 set_difference</span></a></li></ol></li></ol></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"前端必须知道的开发调试知识","uid":"c724a6391cb1c094df5a91070462b271","slug":"青训营--前端开发调试知识","date":"2022-01-17T15:35:19.000Z","updated":"2025-07-14T15:12:20.471Z","comments":true,"path":"api/articles/青训营--前端开发调试知识.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/3112c385d3c845d4b0305beebbc3ffdf.jpeg","text":"前端开发调试是在开发过程中解决和修复代码问题的关键步骤。本文将介绍一些常见的前端调试技巧和工具，包括浏览器开发者工具的使用、调试工具的配置和断点调试等。...","permalink":"/post/青训营--前端开发调试知识","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"字节跳动青训营","slug":"字节跳动青训营","count":21,"path":"api/tags/字节跳动青训营.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":false},"next_post":{"title":"C++_STL_常用容器","uid":"ccfaee9dae4598dc22f175fda2e90c05","slug":"C++_STL_常用容器","date":"2022-01-14T04:16:24.000Z","updated":"2025-07-14T15:12:20.457Z","comments":true,"path":"api/articles/C++_STL_常用容器.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/506e6842fd8542408c76ef139e90ebd3.png","text":"C++标准模板库(STL)是C++编程中不可或缺的部分，它提供了丰富的数据结构和算法。本文我们将对每种容器和算法进行简要介绍，并给出示例代码加深理解。...","permalink":"/post/C++_STL_常用容器","photos":[],"count_time":{"symbolsCount":"56k","symbolsTime":"51 mins."},"categories":[{"name":"C++","slug":"C","count":6,"path":"api/categories/C.json"}],"tags":[{"name":"STL","slug":"STL","count":3,"path":"api/tags/STL.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true}}