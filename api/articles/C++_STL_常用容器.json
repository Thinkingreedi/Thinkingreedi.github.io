{"title":"C++_STL_常用容器","uid":"ccfaee9dae4598dc22f175fda2e90c05","slug":"C++_STL_常用容器","date":"2022-01-14T04:16:24.000Z","updated":"2025-07-14T15:12:20.457Z","comments":true,"path":"api/articles/C++_STL_常用容器.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/506e6842fd8542408c76ef139e90ebd3.png","content":"<h2 id=\"STL-常用容器\"><a href=\"#STL-常用容器\" class=\"headerlink\" title=\"STL 常用容器\"></a>STL 常用容器</h2><h3 id=\"1-string-容器\"><a href=\"#1-string-容器\" class=\"headerlink\" title=\"1 string 容器\"></a>1 string 容器</h3><h4 id=\"1-1-string-基本概念\"><a href=\"#1-1-string-基本概念\" class=\"headerlink\" title=\"1.1 string 基本概念\"></a>1.1 string 基本概念</h4><p><strong>本质：</strong></p>\n<ul>\n<li>string 是 C++风格的字符串，而 string 本质上是一个类</li>\n</ul>\n<p><strong>string 和 char * 区别：</strong></p>\n<ul>\n<li>char * 是一个指针</li>\n<li>string 是一个类，类内部封装了 char*，管理这个字符串，是一个 char*型的容器。</li>\n</ul>\n<p><strong>特点：</strong></p>\n<p>string 类内部封装了很多成员方法</p>\n<p>例如：查找 find，拷贝 copy，删除 delete 替换 replace，插入 insert</p>\n<p>string 管理 char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p>\n<h4 id=\"1-2-string-构造函数\"><a href=\"#1-2-string-构造函数\" class=\"headerlink\" title=\"1.2 string 构造函数\"></a>1.2 string 构造函数</h4><p>构造函数原型：</p>\n<ul>\n<li><code>string();</code> &#x2F;&#x2F;创建一个空的字符串 例如: string str;<br><code>string(const char* s);</code> &#x2F;&#x2F;使用字符串 s 初始化</li>\n<li><code>string(const string&amp; str);</code> &#x2F;&#x2F;使用一个 string 对象初始化另一个 string 对象</li>\n<li><code>string(int n, char c);</code> &#x2F;&#x2F;使用 n 个字符 c 初始化</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;string&gt;\n//string构造\nvoid test01()\n&#123;\n    string s1; //创建空字符串，调用无参构造函数\n    cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; s1 &lt;&lt; endl;\n\n    const char* str = &quot;hello world&quot;;\n    string s2(str); //把c_string转换成了string\n\n    cout &lt;&lt; &quot;str2 = &quot; &lt;&lt; s2 &lt;&lt; endl;\n\n    string s3(s2); //调用拷贝构造函数\n    cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; s3 &lt;&lt; endl;\n\n    string s4(10, &#39;a&#39;);\n    cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; s3 &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：string 的多种构造方式没有可比性，灵活使用即可</p>\n<h4 id=\"1-3-string-赋值操作\"><a href=\"#1-3-string-赋值操作\" class=\"headerlink\" title=\"1.3 string 赋值操作\"></a>1.3 string 赋值操作</h4><p>功能描述：</p>\n<ul>\n<li>给 string 字符串进行赋值</li>\n</ul>\n<p>赋值的函数原型：</p>\n<ul>\n<li><code>string&amp; operator=(const char* s);</code> &#x2F;&#x2F;char*类型字符串 赋值给当前的字符串</li>\n<li><code>string&amp; operator=(const string &amp;s);</code> &#x2F;&#x2F;把字符串 s 赋给当前的字符串</li>\n<li><code>string&amp; operator=(char c);</code> &#x2F;&#x2F;字符赋值给当前的字符串</li>\n<li><code>string&amp; assign(const char *s);</code> &#x2F;&#x2F;把字符串 s 赋给当前的字符串</li>\n<li><code>string&amp; assign(const char *s, int n);</code> &#x2F;&#x2F;把字符串 s 的前 n 个字符赋给当前的字符串</li>\n<li><code>string&amp; assign(const string &amp;s);</code> &#x2F;&#x2F;把字符串 s 赋给当前字符串</li>\n<li><code>string&amp; assign(int n, char c);</code> &#x2F;&#x2F;用 n 个字符 c 赋给当前字符串</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">//赋值\nvoid test01()\n&#123;\n    string str1;\n    str1 = &quot;hello world&quot;;\n    cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;\n\n    string str2;\n    str2 = str1;\n    cout &lt;&lt; &quot;str2 = &quot; &lt;&lt; str2 &lt;&lt; endl;\n\n    string str3;\n    str3 = &#39;a&#39;;\n    cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl;\n\n    string str4;\n    str4.assign(&quot;hello c++&quot;);\n    cout &lt;&lt; &quot;str4 = &quot; &lt;&lt; str4 &lt;&lt; endl;\n\n    string str5;\n    str5.assign(&quot;hello c++&quot;,5);\n    cout &lt;&lt; &quot;str5 = &quot; &lt;&lt; str5 &lt;&lt; endl;\n\n\n    string str6;\n    str6.assign(str5);\n    cout &lt;&lt; &quot;str6 = &quot; &lt;&lt; str6 &lt;&lt; endl;\n\n    string str7;\n    str7.assign(5, &#39;x&#39;);\n    cout &lt;&lt; &quot;str7 = &quot; &lt;&lt; str7 &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：</p>\n<p>string 的赋值方式很多，<code>operator=</code> 这种方式是比较实用的</p>\n<h4 id=\"1-4-string-字符串拼接\"><a href=\"#1-4-string-字符串拼接\" class=\"headerlink\" title=\"1.4 string 字符串拼接\"></a>1.4 string 字符串拼接</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>实现在字符串末尾拼接字符串</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><code>string&amp; operator += (const char* str);</code> &#x2F;&#x2F;重载 +&#x3D; 操作符</li>\n<li><code>string&amp; operator += (const char c);</code> &#x2F;&#x2F;重载 +&#x3D; 操作符</li>\n<li><code>string&amp; operator += (const string&amp; str);</code> &#x2F;&#x2F;重载 +&#x3D; 操作符</li>\n<li><code>string&amp; append(const char *s); </code> &#x2F;&#x2F;把字符串 s 连接到当前字符串结尾</li>\n<li><code>string&amp; append(const char *s, int n);</code> &#x2F;&#x2F;把字符串 s 的前 n 个字符连接到当前字符串结尾</li>\n<li><code>string&amp; append(const string &amp;s);</code> &#x2F;&#x2F;同 operator +&#x3D; (const string&amp; str)</li>\n<li><code>string&amp; append(const string &amp;s, int pos, int n);</code>&#x2F;&#x2F;字符串 s 中从 pos 开始的 n 个字符连接到字符串结尾</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">//字符串拼接\nvoid test01()\n&#123;\n    string str1 = &quot;我&quot;;\n\n    str1 += &quot;爱玩游戏&quot;;\n\n    cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;\n\n    str1 += &#39;:&#39;;\n\n    cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;\n\n    string str2 = &quot;LOL DNF&quot;;\n\n    str1 += str2;\n\n    cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;\n\n    string str3 = &quot;I&quot;;\n    str3.append(&quot; love &quot;);\n    str3.append(&quot;game abcde&quot;, 4);\n    //str3.append(str2);\n    str3.append(str2, 4, 3); // 从下标4位置开始 ，截取3个字符，拼接到字符串末尾\n    cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl;\n&#125;\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：字符串拼接的重载版本很多，初学阶段记住几种即可</p>\n<h4 id=\"1-5-string-查找和替换\"><a href=\"#1-5-string-查找和替换\" class=\"headerlink\" title=\"1.5 string 查找和替换\"></a>1.5 string 查找和替换</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>查找：查找指定字符串是否存在</li>\n<li>替换：在指定的位置替换字符串</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><code>int find(const string&amp; str, int pos = 0) const;</code> &#x2F;&#x2F;查找 str 第一次出现位置,从 pos 开始查找</li>\n<li><code>int find(const char* s, int pos = 0) const; </code> &#x2F;&#x2F;查找 s 第一次出现位置,从 pos 开始查找</li>\n<li><code>int find(const char* s, int pos, int n) const; </code> &#x2F;&#x2F;从 pos 位置查找 s 的前 n 个字符第一次位置</li>\n<li><code>int find(const char c, int pos = 0) const; </code> &#x2F;&#x2F;查找字符 c 第一次出现位置</li>\n<li><code>int rfind(const string&amp; str, int pos = npos) const;</code> &#x2F;&#x2F;查找 str 最后一次位置,从 pos 开始查找</li>\n<li><code>int rfind(const char* s, int pos = npos) const;</code> &#x2F;&#x2F;查找 s 最后一次出现位置,从 pos 开始查找</li>\n<li><code>int rfind(const char* s, int pos, int n) const;</code> &#x2F;&#x2F;从 pos 查找 s 的前 n 个字符最后一次位置</li>\n<li><code>int rfind(const char c, int pos = 0) const;  </code> &#x2F;&#x2F;查找字符 c 最后一次出现位置</li>\n<li><code>string&amp; replace(int pos, int n, const string&amp; str); </code> &#x2F;&#x2F;替换从 pos 开始 n 个字符为字符串 str</li>\n<li><code>string&amp; replace(int pos, int n,const char* s); </code> &#x2F;&#x2F;替换从 pos 开始的 n 个字符为字符串 s</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">//查找和替换\nvoid test01()\n&#123;\n    //查找\n    string str1 = &quot;abcdefgde&quot;;\n\n    int pos = str1.find(&quot;de&quot;);\n\n    if (pos == -1)\n    &#123;\n        cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl;\n    &#125;\n\n\n    pos = str1.rfind(&quot;de&quot;);\n\n    cout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl;\n\n&#125;\n\nvoid test02()\n&#123;\n    //替换\n    string str1 = &quot;abcdefgde&quot;;\n    str1.replace(1, 3, &quot;1111&quot;);\n\n    cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    //test01();\n    //test02();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：</p>\n<ul>\n<li>find 查找是从左往后，rfind 从右往左</li>\n<li>find 找到字符串后返回查找的第一个字符位置，找不到返回-1</li>\n<li>replace 在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li>\n</ul>\n<h4 id=\"1-6-string-字符串比较\"><a href=\"#1-6-string-字符串比较\" class=\"headerlink\" title=\"1.6 string 字符串比较\"></a>1.6 string 字符串比较</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>字符串之间的比较</li>\n</ul>\n<p><strong>比较方式：</strong></p>\n<ul>\n<li>字符串比较是按字符的 ASCII 码进行对比</li>\n</ul>\n<p>&#x3D; 返回 0</p>\n<p>&gt; 返回 1</p>\n<p>&lt; 返回 -1</p>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><code>int compare(const string &amp;s) const; </code> &#x2F;&#x2F;与字符串 s 比较</li>\n<li><code>int compare(const char *s) const;</code> &#x2F;&#x2F;与字符串 s 比较</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">//字符串比较\nvoid test01()\n&#123;\n\n    string s1 = &quot;hello&quot;;\n    string s2 = &quot;aello&quot;;\n\n    int ret = s1.compare(s2);\n\n    if (ret == 0) &#123;\n        cout &lt;&lt; &quot;s1 等于 s2&quot; &lt;&lt; endl;\n    &#125;\n    else if (ret &gt; 0)\n    &#123;\n        cout &lt;&lt; &quot;s1 大于 s2&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;s1 小于 s2&quot; &lt;&lt; endl;\n    &#125;\n\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p>\n<h4 id=\"1-7-string-字符存取\"><a href=\"#1-7-string-字符存取\" class=\"headerlink\" title=\"1.7 string 字符存取\"></a>1.7 string 字符存取</h4><p>string 中单个字符存取方式有两种</p>\n<ul>\n<li><code>char&amp; operator[](int n); </code> &#x2F;&#x2F;通过[]方式取字符</li>\n<li><code>char&amp; at(int n);   </code> &#x2F;&#x2F;通过 at 方法获取字符</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">void test01()\n&#123;\n    string str = &quot;hello world&quot;;\n\n    for (int i = 0; i &lt; str.size(); i++)\n    &#123;\n        cout &lt;&lt; str[i] &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n\n    for (int i = 0; i &lt; str.size(); i++)\n    &#123;\n        cout &lt;&lt; str.at(i) &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n\n\n    //字符修改\n    str[0] = &#39;x&#39;;\n    str.at(1) = &#39;x&#39;;\n    cout &lt;&lt; str &lt;&lt; endl;\n\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：string 字符串中单个字符存取有两种方式，利用 [ ] 或 at</p>\n<h4 id=\"1-8-string-插入和删除\"><a href=\"#1-8-string-插入和删除\" class=\"headerlink\" title=\"1.8 string 插入和删除\"></a>1.8 string 插入和删除</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>对 string 字符串进行插入和删除字符操作</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><code>string&amp; insert(int pos, const char* s);  </code> &#x2F;&#x2F;插入字符串</li>\n<li><code>string&amp; insert(int pos, const string&amp; str); </code> &#x2F;&#x2F;插入字符串</li>\n<li><code>string&amp; insert(int pos, int n, char c);</code> &#x2F;&#x2F;在指定位置插入 n 个字符 c</li>\n<li><code>string&amp; erase(int pos, int n = npos);</code> &#x2F;&#x2F;删除从 Pos 开始的 n 个字符</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">//字符串插入和删除\nvoid test01()\n&#123;\n    string str = &quot;hello&quot;;\n    str.insert(1, &quot;111&quot;);\n    cout &lt;&lt; str &lt;&lt; endl;\n\n    str.erase(1, 3);  //从1号位置开始3个字符\n    cout &lt;&lt; str &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p><strong>总结：</strong>插入和删除的起始下标都是从 0 开始</p>\n<h4 id=\"1-9-string-子串\"><a href=\"#1-9-string-子串\" class=\"headerlink\" title=\"1.9 string 子串\"></a>1.9 string 子串</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>从字符串中获取想要的子串</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><code>string substr(int pos = 0, int n = npos) const;</code> &#x2F;&#x2F;返回由 pos 开始的 n 个字符组成的字符串</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">//子串\nvoid test01()\n&#123;\n\n    string str = &quot;abcdefg&quot;;\n    string subStr = str.substr(1, 3);\n    cout &lt;&lt; &quot;subStr = &quot; &lt;&lt; subStr &lt;&lt; endl;\n\n    string email = &quot;hello@sina.com&quot;;\n    int pos = email.find(&quot;@&quot;);\n    string username = email.substr(0, pos);\n    cout &lt;&lt; &quot;username: &quot; &lt;&lt; username &lt;&lt; endl;\n\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p><strong>总结</strong>：灵活的运用求子串功能，可以在实际开发中获取有效的信息</p>\n<h3 id=\"2-vector-容器\"><a href=\"#2-vector-容器\" class=\"headerlink\" title=\"2 vector 容器\"></a>2 vector 容器</h3><h4 id=\"2-1-vector-基本概念\"><a href=\"#2-1-vector-基本概念\" class=\"headerlink\" title=\"2.1 vector 基本概念\"></a>2.1 vector 基本概念</h4><p><strong>功能：</strong></p>\n<ul>\n<li>vector 数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组</strong></li>\n</ul>\n<p><strong>vector 与普通数组区别：</strong></p>\n<ul>\n<li>不同之处在于数组是静态空间，而 vector 可以<strong>动态扩展</strong></li>\n</ul>\n<p><strong>动态扩展：</strong></p>\n<ul>\n<li><p>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</p>\n</li>\n<li><p>vector 容器的迭代器是支持随机访问的迭代器</p>\n</li>\n</ul>\n<h4 id=\"2-2-vector-构造函数\"><a href=\"#2-2-vector-构造函数\" class=\"headerlink\" title=\"2.2 vector 构造函数\"></a>2.2 vector 构造函数</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>创建 vector 容器</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><code>vector&lt;T&gt; v; </code> &#x2F;&#x2F;采用模板实现类实现，默认构造函数</li>\n<li><code>vector(v.begin(), v.end());   </code> &#x2F;&#x2F;将 v[begin(), end())区间中的元素拷贝给本身。</li>\n<li><code>vector(n, elem);</code> &#x2F;&#x2F;构造函数将 n 个 elem 拷贝给本身。</li>\n<li><code>vector(const vector &amp;vec);</code> &#x2F;&#x2F;拷贝构造函数。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;vector&gt;\n\nvoid printVector(vector&lt;int&gt;&amp; v) &#123;\n\n    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt; v1; //无参构造\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        v1.push_back(i);\n    &#125;\n    printVector(v1);\n\n    vector&lt;int&gt; v2(v1.begin(), v1.end());\n    printVector(v2);\n\n    vector&lt;int&gt; v3(10, 100);\n    printVector(v3);\n\n    vector&lt;int&gt; v4(v3);\n    printVector(v4);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p><strong>总结</strong>：vector 的多种构造方式没有可比性，灵活使用即可</p>\n<h4 id=\"2-3-vector-赋值操作\"><a href=\"#2-3-vector-赋值操作\" class=\"headerlink\" title=\"2.3 vector 赋值操作\"></a>2.3 vector 赋值操作</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>给 vector 容器进行赋值</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><p><code>vector&amp; operator=(const vector &amp;vec);</code>&#x2F;&#x2F;重载等号操作符</p>\n</li>\n<li><p><code>assign(beg, end);</code> &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</p>\n</li>\n<li><p><code>assign(n, elem);</code> &#x2F;&#x2F;将 n 个 elem 拷贝赋值给本身。</p>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;vector&gt;\n\nvoid printVector(vector&lt;int&gt;&amp; v) &#123;\n\n    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\n//赋值操作\nvoid test01()\n&#123;\n    vector&lt;int&gt; v1; //无参构造\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        v1.push_back(i);\n    &#125;\n    printVector(v1);\n\n    vector&lt;int&gt;v2;\n    v2 = v1;\n    printVector(v2);\n\n    vector&lt;int&gt;v3;\n    v3.assign(v1.begin(), v1.end());\n    printVector(v3);\n\n    vector&lt;int&gt;v4;\n    v4.assign(10, 100);\n    printVector(v4);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结： vector 赋值方式比较简单，使用 operator&#x3D;，或者 assign 都可以</p>\n<h4 id=\"2-4-vector-容量和大小\"><a href=\"#2-4-vector-容量和大小\" class=\"headerlink\" title=\"2.4 vector 容量和大小\"></a>2.4 vector 容量和大小</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>对 vector 容器的容量和大小操作</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><p><code>empty(); </code> &#x2F;&#x2F;判断容器是否为空</p>\n</li>\n<li><p><code>capacity();</code> &#x2F;&#x2F;容器的容量</p>\n</li>\n<li><p><code>size();</code> &#x2F;&#x2F;返回容器中元素的个数</p>\n</li>\n<li><p><code>resize(int num);</code> &#x2F;&#x2F;重新指定容器的长度为 num，若容器变长，则以默认值填充新位置。</p>\n<p>&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</p>\n</li>\n<li><p><code>resize(int num, elem);</code> &#x2F;&#x2F;重新指定容器的长度为 num，若容器变长，则以 elem 值填充新位置。</p>\n<p>&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除</p>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;vector&gt;\n\nvoid printVector(vector&lt;int&gt;&amp; v) &#123;\n\n    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt; v1;\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        v1.push_back(i);\n    &#125;\n    printVector(v1);\n    if (v1.empty())\n    &#123;\n        cout &lt;&lt; &quot;v1为空&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;v1不为空&quot; &lt;&lt; endl;\n        cout &lt;&lt; &quot;v1的容量 = &quot; &lt;&lt; v1.capacity() &lt;&lt; endl;\n        cout &lt;&lt; &quot;v1的大小 = &quot; &lt;&lt; v1.size() &lt;&lt; endl;\n    &#125;\n\n    //resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充\n    v1.resize(15,10);\n    printVector(v1);\n\n    //resize 重新指定大小 ，若指定的更小，超出部分元素被删除\n    v1.resize(5);\n    printVector(v1);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：</p>\n<ul>\n<li>判断是否为空 — empty</li>\n<li>返回元素个数 — size</li>\n<li>返回容器容量 — capacity</li>\n<li>重新指定大小 — resize</li>\n</ul>\n<h4 id=\"2-5-vector-插入和删除\"><a href=\"#2-5-vector-插入和删除\" class=\"headerlink\" title=\"2.5 vector 插入和删除\"></a>2.5 vector 插入和删除</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>对 vector 容器进行插入、删除操作</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><code>push_back(ele);</code> &#x2F;&#x2F;尾部插入元素 ele</li>\n<li><code>pop_back();</code> &#x2F;&#x2F;删除最后一个元素</li>\n<li><code>insert(const_iterator pos, ele);</code> &#x2F;&#x2F;迭代器指向位置 pos 插入元素 ele</li>\n<li><code>insert(const_iterator pos, int count,ele);</code>&#x2F;&#x2F;迭代器指向位置 pos 插入 count 个元素 ele</li>\n<li><code>erase(const_iterator pos);</code> &#x2F;&#x2F;删除迭代器指向的元素</li>\n<li><code>erase(const_iterator start, const_iterator end);</code>&#x2F;&#x2F;删除迭代器从 start 到 end 之间的元素</li>\n<li><code>clear();</code> &#x2F;&#x2F;删除容器中所有元素</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">\n#include &lt;vector&gt;\n\nvoid printVector(vector&lt;int&gt;&amp; v) &#123;\n\n    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\n//插入和删除\nvoid test01()\n&#123;\n    vector&lt;int&gt; v1;\n    //尾插\n    v1.push_back(10);\n    v1.push_back(20);\n    v1.push_back(30);\n    v1.push_back(40);\n    v1.push_back(50);\n    printVector(v1);\n    //尾删\n    v1.pop_back();\n    printVector(v1);\n    //插入\n    v1.insert(v1.begin(), 100);\n    printVector(v1);\n\n    v1.insert(v1.begin(), 2, 1000);\n    printVector(v1);\n\n    //删除\n    v1.erase(v1.begin());\n    printVector(v1);\n\n    //清空\n    v1.erase(v1.begin(), v1.end());\n    v1.clear();\n    printVector(v1);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：</p>\n<ul>\n<li>尾插 — push_back</li>\n<li>尾删 — pop_back</li>\n<li>插入 — insert (位置迭代器)</li>\n<li>删除 — erase （位置迭代器）</li>\n<li>清空 — clear</li>\n</ul>\n<h4 id=\"2-6-vector-数据存取\"><a href=\"#2-6-vector-数据存取\" class=\"headerlink\" title=\"2.6 vector 数据存取\"></a>2.6 vector 数据存取</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>对 vector 中的数据的存取操作</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><code>at(int idx); </code> &#x2F;&#x2F;返回索引 idx 所指的数据</li>\n<li><code>operator[]; </code> &#x2F;&#x2F;返回索引 idx 所指的数据</li>\n<li><code>front(); </code> &#x2F;&#x2F;返回容器中第一个数据元素</li>\n<li><code>back();</code> &#x2F;&#x2F;返回容器中最后一个数据元素</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;vector&gt;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt;v1;\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        v1.push_back(i);\n    &#125;\n\n    for (int i = 0; i &lt; v1.size(); i++)\n    &#123;\n        cout &lt;&lt; v1[i] &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n\n    for (int i = 0; i &lt; v1.size(); i++)\n    &#123;\n        cout &lt;&lt; v1.at(i) &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;v1的第一个元素为： &quot; &lt;&lt; v1.front() &lt;&lt; endl;\n    cout &lt;&lt; &quot;v1的最后一个元素为： &quot; &lt;&lt; v1.back() &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：</p>\n<ul>\n<li>除了用迭代器获取 vector 容器中元素，[ ]和 at 也可以</li>\n<li>front 返回容器第一个元素</li>\n<li>back 返回容器最后一个元素</li>\n</ul>\n<h4 id=\"2-7-vector-互换容器\"><a href=\"#2-7-vector-互换容器\" class=\"headerlink\" title=\"2.7 vector 互换容器\"></a>2.7 vector 互换容器</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>实现两个容器内元素进行互换</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><code>swap(vec);</code> &#x2F;&#x2F; 将 vec 与本身的元素互换</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;vector&gt;\n\nvoid printVector(vector&lt;int&gt;&amp; v) &#123;\n\n    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt;v1;\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        v1.push_back(i);\n    &#125;\n    printVector(v1);\n\n    vector&lt;int&gt;v2;\n    for (int i = 10; i &gt; 0; i--)\n    &#123;\n        v2.push_back(i);\n    &#125;\n    printVector(v2);\n\n    //互换容器\n    cout &lt;&lt; &quot;互换后&quot; &lt;&lt; endl;\n    v1.swap(v2);\n    printVector(v1);\n    printVector(v2);\n&#125;\n\nvoid test02()\n&#123;\n    vector&lt;int&gt; v;\n    for (int i = 0; i &lt; 100000; i++) &#123;\n        v.push_back(i);\n    &#125;\n\n    cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;\n    cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;\n\n    v.resize(3);\n\n    cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;\n    cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;\n\n    //收缩内存\n    vector&lt;int&gt;(v).swap(v); //匿名对象\n\n    cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;\n    cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    test02();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：swap 可以使两个容器互换，可以达到实用的收缩内存效果</p>\n<h4 id=\"2-8-vector-预留空间\"><a href=\"#2-8-vector-预留空间\" class=\"headerlink\" title=\"2.8 vector 预留空间\"></a>2.8 vector 预留空间</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>减少 vector 在动态扩展容量时的扩展次数</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><code>reserve(int len);</code>&#x2F;&#x2F;容器预留 len 个元素长度，预留位置不初始化，元素不可访问。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;vector&gt;\n\nvoid test01()\n&#123;\n    vector&lt;int&gt; v;\n\n    //预留空间\n    v.reserve(100000);\n\n    int num = 0;\n    int* p = NULL;\n    for (int i = 0; i &lt; 100000; i++) &#123;\n        v.push_back(i);\n        if (p != &amp;v[0]) &#123;\n            p = &amp;v[0];\n            num++;\n        &#125;\n    &#125;\n\n    cout &lt;&lt; &quot;num:&quot; &lt;&lt; num &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：如果数据量较大，可以一开始利用 reserve 预留空间</p>\n<h3 id=\"3-deque-容器\"><a href=\"#3-deque-容器\" class=\"headerlink\" title=\"3 deque 容器\"></a>3 deque 容器</h3><h4 id=\"3-1-deque-容器基本概念\"><a href=\"#3-1-deque-容器基本概念\" class=\"headerlink\" title=\"3.1 deque 容器基本概念\"></a>3.1 deque 容器基本概念</h4><p><strong>功能：</strong></p>\n<ul>\n<li>双端数组，可以对头端进行插入删除操作</li>\n</ul>\n<p><strong>deque 与 vector 区别：</strong></p>\n<ul>\n<li>vector 对于头部的插入删除效率低，数据量越大，效率越低</li>\n<li>deque 相对而言，对头部的插入删除速度回比 vector 快</li>\n<li>vector 访问元素时的速度会比 deque 快,这和两者内部实现有关</li>\n</ul>\n<p>deque 内部工作原理:</p>\n<p>deque 内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据</p>\n<p>中控器维护的是每个缓冲区的地址，使得使用 deque 时像一片连续的内存空间</p>\n<ul>\n<li>deque 容器的迭代器也是支持随机访问的</li>\n</ul>\n<h4 id=\"3-2-deque-构造函数\"><a href=\"#3-2-deque-构造函数\" class=\"headerlink\" title=\"3.2 deque 构造函数\"></a>3.2 deque 构造函数</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>deque 容器构造</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><code>deque&lt;T&gt;</code> deqT; &#x2F;&#x2F;默认构造形式</li>\n<li><code>deque(beg, end);</code> &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。</li>\n<li><code>deque(n, elem);</code> &#x2F;&#x2F;构造函数将 n 个 elem 拷贝给本身。</li>\n<li><code>deque(const deque &amp;deq);</code> &#x2F;&#x2F;拷贝构造函数</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;deque&gt;\n\nvoid printDeque(const deque&lt;int&gt;&amp; d)\n&#123;\n    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n//deque构造\nvoid test01() &#123;\n\n    deque&lt;int&gt; d1; //无参构造函数\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        d1.push_back(i);\n    &#125;\n    printDeque(d1);\n    deque&lt;int&gt; d2(d1.begin(),d1.end());\n    printDeque(d2);\n\n    deque&lt;int&gt;d3(10,100);\n    printDeque(d3);\n\n    deque&lt;int&gt;d4 = d3;\n    printDeque(d4);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p><strong>总结</strong>：deque 容器和 vector 容器的构造方式几乎一致，灵活使用即可</p>\n<h4 id=\"3-3-deque-赋值操作\"><a href=\"#3-3-deque-赋值操作\" class=\"headerlink\" title=\"3.3 deque 赋值操作\"></a>3.3 deque 赋值操作</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>给 deque 容器进行赋值</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><p><code>deque&amp; operator=(const deque &amp;deq); </code> &#x2F;&#x2F;重载等号操作符</p>\n</li>\n<li><p><code>assign(beg, end);</code> &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</p>\n</li>\n<li><p><code>assign(n, elem);</code> &#x2F;&#x2F;将 n 个 elem 拷贝赋值给本身。</p>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;deque&gt;\n\nvoid printDeque(const deque&lt;int&gt;&amp; d)\n&#123;\n    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n//赋值操作\nvoid test01()\n&#123;\n    deque&lt;int&gt; d1;\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        d1.push_back(i);\n    &#125;\n    printDeque(d1);\n\n    deque&lt;int&gt;d2;\n    d2 = d1;\n    printDeque(d2);\n\n    deque&lt;int&gt;d3;\n    d3.assign(d1.begin(), d1.end());\n    printDeque(d3);\n\n    deque&lt;int&gt;d4;\n    d4.assign(10, 100);\n    printDeque(d4);\n\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：deque 赋值操作也与 vector 相同，需熟练掌握</p>\n<h4 id=\"3-4-deque-大小操作\"><a href=\"#3-4-deque-大小操作\" class=\"headerlink\" title=\"3.4 deque 大小操作\"></a>3.4 deque 大小操作</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>对 deque 容器的大小进行操作</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><p><code>deque.empty();</code> &#x2F;&#x2F;判断容器是否为空</p>\n</li>\n<li><p><code>deque.size();</code> &#x2F;&#x2F;返回容器中元素的个数</p>\n</li>\n<li><p><code>deque.resize(num);</code> &#x2F;&#x2F;重新指定容器的长度为 num,若容器变长，则以默认值填充新位置。</p>\n<p>&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</p>\n</li>\n<li><p><code>deque.resize(num, elem);</code> &#x2F;&#x2F;重新指定容器的长度为 num,若容器变长，则以 elem 值填充新位置。</p>\n<p>&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</p>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;deque&gt;\n\nvoid printDeque(const deque&lt;int&gt;&amp; d)\n&#123;\n    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\n//大小操作\nvoid test01()\n&#123;\n    deque&lt;int&gt; d1;\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        d1.push_back(i);\n    &#125;\n    printDeque(d1);\n\n    //判断容器是否为空\n    if (d1.empty()) &#123;\n        cout &lt;&lt; &quot;d1为空!&quot; &lt;&lt; endl;\n    &#125;\n    else &#123;\n        cout &lt;&lt; &quot;d1不为空!&quot; &lt;&lt; endl;\n        //统计大小\n        cout &lt;&lt; &quot;d1的大小为：&quot; &lt;&lt; d1.size() &lt;&lt; endl;\n    &#125;\n\n    //重新指定大小\n    d1.resize(15, 1);\n    printDeque(d1);\n\n    d1.resize(5);\n    printDeque(d1);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：</p>\n<ul>\n<li>deque 没有容量的概念</li>\n<li>判断是否为空 — empty</li>\n<li>返回元素个数 — size</li>\n<li>重新指定个数 — resize</li>\n</ul>\n<h4 id=\"3-5-deque-插入和删除\"><a href=\"#3-5-deque-插入和删除\" class=\"headerlink\" title=\"3.5 deque 插入和删除\"></a>3.5 deque 插入和删除</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>向 deque 容器中插入和删除数据</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<p>两端插入操作：</p>\n<ul>\n<li><code>push_back(elem);</code> &#x2F;&#x2F;在容器尾部添加一个数据</li>\n<li><code>push_front(elem);</code> &#x2F;&#x2F;在容器头部插入一个数据</li>\n<li><code>pop_back();</code> &#x2F;&#x2F;删除容器最后一个数据</li>\n<li><code>pop_front();</code> &#x2F;&#x2F;删除容器第一个数据</li>\n</ul>\n<p>指定位置操作：</p>\n<ul>\n<li><p><code>insert(pos,elem);</code> &#x2F;&#x2F;在 pos 位置插入一个 elem 元素的拷贝，返回新数据的位置。</p>\n</li>\n<li><p><code>insert(pos,n,elem);</code> &#x2F;&#x2F;在 pos 位置插入 n 个 elem 数据，无返回值。</p>\n</li>\n<li><p><code>insert(pos,beg,end);</code> &#x2F;&#x2F;在 pos 位置插入[beg,end)区间的数据，无返回值。</p>\n</li>\n<li><p><code>clear();</code> &#x2F;&#x2F;清空容器的所有数据</p>\n</li>\n<li><p><code>erase(beg,end);</code> &#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</p>\n</li>\n<li><p><code>erase(pos);</code> &#x2F;&#x2F;删除 pos 位置的数据，返回下一个数据的位置。</p>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;deque&gt;\n\nvoid printDeque(const deque&lt;int&gt;&amp; d)\n&#123;\n    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n//两端操作\nvoid test01()\n&#123;\n    deque&lt;int&gt; d;\n    //尾插\n    d.push_back(10);\n    d.push_back(20);\n    //头插\n    d.push_front(100);\n    d.push_front(200);\n\n    printDeque(d);\n\n    //尾删\n    d.pop_back();\n    //头删\n    d.pop_front();\n    printDeque(d);\n&#125;\n\n//插入\nvoid test02()\n&#123;\n    deque&lt;int&gt; d;\n    d.push_back(10);\n    d.push_back(20);\n    d.push_front(100);\n    d.push_front(200);\n    printDeque(d);\n\n    d.insert(d.begin(), 1000);\n    printDeque(d);\n\n    d.insert(d.begin(), 2,10000);\n    printDeque(d);\n\n    deque&lt;int&gt;d2;\n    d2.push_back(1);\n    d2.push_back(2);\n    d2.push_back(3);\n\n    d.insert(d.begin(), d2.begin(), d2.end());\n    printDeque(d);\n\n&#125;\n\n//删除\nvoid test03()\n&#123;\n    deque&lt;int&gt; d;\n    d.push_back(10);\n    d.push_back(20);\n    d.push_front(100);\n    d.push_front(200);\n    printDeque(d);\n\n    d.erase(d.begin());\n    printDeque(d);\n\n    d.erase(d.begin(), d.end());\n    d.clear();\n    printDeque(d);\n&#125;\n\nint main() &#123;\n\n    //test01();\n\n    //test02();\n\n    test03();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：</p>\n<ul>\n<li>插入和删除提供的位置是迭代器！</li>\n<li>尾插 — push_back</li>\n<li>尾删 — pop_back</li>\n<li>头插 — push_front</li>\n<li>头删 — pop_front</li>\n</ul>\n<h4 id=\"3-6-deque-数据存取\"><a href=\"#3-6-deque-数据存取\" class=\"headerlink\" title=\"3.6 deque 数据存取\"></a>3.6 deque 数据存取</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>对 deque 中的数据的存取操作</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><code>at(int idx); </code> &#x2F;&#x2F;返回索引 idx 所指的数据</li>\n<li><code>operator[]; </code> &#x2F;&#x2F;返回索引 idx 所指的数据</li>\n<li><code>front(); </code> &#x2F;&#x2F;返回容器中第一个数据元素</li>\n<li><code>back();</code> &#x2F;&#x2F;返回容器中最后一个数据元素</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;deque&gt;\n\nvoid printDeque(const deque&lt;int&gt;&amp; d)\n&#123;\n    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\n//数据存取\nvoid test01()\n&#123;\n\n    deque&lt;int&gt; d;\n    d.push_back(10);\n    d.push_back(20);\n    d.push_front(100);\n    d.push_front(200);\n\n    for (int i = 0; i &lt; d.size(); i++) &#123;\n        cout &lt;&lt; d[i] &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n\n\n    for (int i = 0; i &lt; d.size(); i++) &#123;\n        cout &lt;&lt; d.at(i) &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;front:&quot; &lt;&lt; d.front() &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;back:&quot; &lt;&lt; d.back() &lt;&lt; endl;\n\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：</p>\n<ul>\n<li>除了用迭代器获取 deque 容器中元素，[ ]和 at 也可以</li>\n<li>front 返回容器第一个元素</li>\n<li>back 返回容器最后一个元素</li>\n</ul>\n<h4 id=\"3-7-deque-排序\"><a href=\"#3-7-deque-排序\" class=\"headerlink\" title=\"3.7 deque 排序\"></a>3.7 deque 排序</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>利用算法实现对 deque 容器进行排序</li>\n</ul>\n<p><strong>算法：</strong></p>\n<ul>\n<li><code>sort(iterator beg, iterator end)</code> &#x2F;&#x2F;对 beg 和 end 区间内元素进行排序</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;deque&gt;\n#include &lt;algorithm&gt;\n\nvoid printDeque(const deque&lt;int&gt;&amp; d)\n&#123;\n    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid test01()\n&#123;\n\n    deque&lt;int&gt; d;\n    d.push_back(10);\n    d.push_back(20);\n    d.push_front(100);\n    d.push_front(200);\n\n    printDeque(d);\n    sort(d.begin(), d.end());\n    printDeque(d);\n\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：sort 算法非常实用，使用时包含头文件 algorithm 即可</p>\n<h3 id=\"4-案例-评委打分\"><a href=\"#4-案例-评委打分\" class=\"headerlink\" title=\"4 案例-评委打分\"></a>4 案例-评委打分</h3><h4 id=\"4-1-案例描述\"><a href=\"#4-1-案例描述\" class=\"headerlink\" title=\"4.1 案例描述\"></a>4.1 案例描述</h4><p>有 5 名选手：选手 ABCDE，10 个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。</p>\n<h4 id=\"4-2-实现步骤\"><a href=\"#4-2-实现步骤\" class=\"headerlink\" title=\"4.2 实现步骤\"></a>4.2 实现步骤</h4><ol>\n<li>创建五名选手，放到 vector 中</li>\n<li>遍历 vector 容器，取出来每一个选手，执行 for 循环，可以把 10 个评分打分存到 deque 容器中</li>\n<li>sort 算法对 deque 容器中分数排序，去除最高和最低分</li>\n<li>deque 容器遍历一遍，累加总分</li>\n<li>获取平均分</li>\n</ol>\n<p><strong>示例代码：</strong></p>\n<pre><code class=\"c\">//选手类\nclass Person\n&#123;\npublic:\n    Person(string name, int score)\n    &#123;\n        this-&gt;m_Name = name;\n        this-&gt;m_Score = score;\n    &#125;\n\n    string m_Name; //姓名\n    int m_Score;  //平均分\n&#125;;\n\nvoid createPerson(vector&lt;Person&gt;&amp;v)\n&#123;\n    string nameSeed = &quot;ABCDE&quot;;\n    for (int i = 0; i &lt; 5; i++)\n    &#123;\n        string name = &quot;选手&quot;;\n        name += nameSeed[i];\n\n        int score = 0;\n\n        Person p(name, score);\n\n        //将创建的person对象 放入到容器中\n        v.push_back(p);\n    &#125;\n&#125;\n\n//打分\nvoid setScore(vector&lt;Person&gt;&amp;v)\n&#123;\n    for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)\n    &#123;\n        //将评委的分数 放入到deque容器中\n        deque&lt;int&gt;d;\n        for (int i = 0; i &lt; 10; i++)\n        &#123;\n            int score = rand() % 41 + 60;  // 60 ~ 100\n            d.push_back(score);\n        &#125;\n\n        //cout &lt;&lt; &quot;选手： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 打分： &quot; &lt;&lt; endl;\n        //for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)\n        //&#123;\n        //\tcout &lt;&lt; *dit &lt;&lt; &quot; &quot;;\n        //&#125;\n        //cout &lt;&lt; endl;\n\n        //排序\n        sort(d.begin(), d.end());\n\n        //去除最高和最低分\n        d.pop_back();\n        d.pop_front();\n\n        //取平均分\n        int sum = 0;\n        for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)\n        &#123;\n            sum += *dit; //累加每个评委的分数\n        &#125;\n\n        int avg = sum / d.size();\n\n        //将平均分 赋值给选手身上\n        it-&gt;m_Score = avg;\n    &#125;\n\n&#125;\n\nvoid showScore(vector&lt;Person&gt;&amp;v)\n&#123;\n    for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)\n    &#123;\n        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 平均分： &quot; &lt;&lt; it-&gt;m_Score &lt;&lt; endl;\n    &#125;\n&#125;\n\nint main() &#123;\n\n    //随机数种子\n    srand((unsigned int)time(NULL));\n\n    //1、创建5名选手\n    vector&lt;Person&gt;v;  //存放选手容器\n    createPerson(v);\n\n    //测试\n    //for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)\n    //&#123;\n    //\tcout &lt;&lt; &quot;姓名： &quot; &lt;&lt; (*it).m_Name &lt;&lt; &quot; 分数： &quot; &lt;&lt; (*it).m_Score &lt;&lt; endl;\n    //&#125;\n\n    //2、给5名选手打分\n    setScore(v);\n\n    //3、显示最后得分\n    showScore(v);\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p><strong>总结：</strong> 选取不同的容器操作数据，可以提升代码的效率</p>\n<h3 id=\"5-stack-容器\"><a href=\"#5-stack-容器\" class=\"headerlink\" title=\"5 stack 容器\"></a>5 stack 容器</h3><h4 id=\"5-1-stack-基本概念\"><a href=\"#5-1-stack-基本概念\" class=\"headerlink\" title=\"5.1 stack 基本概念\"></a>5.1 stack 基本概念</h4><p><strong>概念：</strong>stack 是一种<strong>先进后出</strong>(First In Last Out,FILO)的数据结构，它只有一个出口</p>\n<p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p>\n<p>栈中进入数据称为 — <strong>入栈</strong> <code>push</code></p>\n<p>栈中弹出数据称为 — <strong>出栈</strong> <code>pop</code></p>\n<h4 id=\"5-2-stack-常用接口\"><a href=\"#5-2-stack-常用接口\" class=\"headerlink\" title=\"5.2 stack 常用接口\"></a>5.2 stack 常用接口</h4><p>功能描述：栈容器常用的对外接口</p>\n<p>构造函数：</p>\n<ul>\n<li><code>stack&lt;T&gt; stk;</code> &#x2F;&#x2F;stack 采用模板类实现， stack 对象的默认构造形式</li>\n<li><code>stack(const stack &amp;stk);</code> &#x2F;&#x2F;拷贝构造函数</li>\n</ul>\n<p>赋值操作：</p>\n<ul>\n<li><code>stack&amp; operator=(const stack &amp;stk);</code> &#x2F;&#x2F;重载等号操作符</li>\n</ul>\n<p>数据存取：</p>\n<ul>\n<li><code>push(elem);</code> &#x2F;&#x2F;向栈顶添加元素</li>\n<li><code>pop();</code> &#x2F;&#x2F;从栈顶移除第一个元素</li>\n<li><code>top(); </code> &#x2F;&#x2F;返回栈顶元素</li>\n</ul>\n<p>大小操作：</p>\n<ul>\n<li><code>empty();</code> &#x2F;&#x2F;判断堆栈是否为空</li>\n<li><code>size(); </code> &#x2F;&#x2F;返回栈的大小</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;stack&gt;\n\n//栈容器常用接口\nvoid test01()\n&#123;\n    //创建栈容器 栈容器必须符合先进后出\n    stack&lt;int&gt; s;\n\n    //向栈中添加元素，叫做 压栈 入栈\n    s.push(10);\n    s.push(20);\n    s.push(30);\n\n    while (!s.empty()) &#123;\n        //输出栈顶元素\n        cout &lt;&lt; &quot;栈顶元素为： &quot; &lt;&lt; s.top() &lt;&lt; endl;\n        //弹出栈顶元素\n        s.pop();\n    &#125;\n    cout &lt;&lt; &quot;栈的大小为：&quot; &lt;&lt; s.size() &lt;&lt; endl;\n\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：</p>\n<ul>\n<li>入栈 — push</li>\n<li>出栈 — pop</li>\n<li>返回栈顶 — top</li>\n<li>判断栈是否为空 — empty</li>\n<li>返回栈大小 — size</li>\n</ul>\n<h3 id=\"6-queue-容器\"><a href=\"#6-queue-容器\" class=\"headerlink\" title=\"6 queue 容器\"></a>6 queue 容器</h3><h4 id=\"6-1-queue-基本概念\"><a href=\"#6-1-queue-基本概念\" class=\"headerlink\" title=\"6.1 queue 基本概念\"></a>6.1 queue 基本概念</h4><p><strong>概念：</strong>Queue 是一种<strong>先进先出</strong>(First In First Out,FIFO)的数据结构，它有两个出口</p>\n<p>队列容器允许从一端新增元素，从另一端移除元素</p>\n<p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p>\n<p>队列中进数据称为 — <strong>入队</strong> <code>push</code></p>\n<p>队列中出数据称为 — <strong>出队</strong> <code>pop</code></p>\n<h4 id=\"6-2-queue-常用接口\"><a href=\"#6-2-queue-常用接口\" class=\"headerlink\" title=\"6.2 queue 常用接口\"></a>6.2 queue 常用接口</h4><p>功能描述：栈容器常用的对外接口</p>\n<p>构造函数：</p>\n<ul>\n<li><code>queue&lt;T&gt; que;</code> &#x2F;&#x2F;queue 采用模板类实现，queue 对象的默认构造形式</li>\n<li><code>queue(const queue &amp;que);</code> &#x2F;&#x2F;拷贝构造函数</li>\n</ul>\n<p>赋值操作：</p>\n<ul>\n<li><code>queue&amp; operator=(const queue &amp;que);</code> &#x2F;&#x2F;重载等号操作符</li>\n</ul>\n<p>数据存取：</p>\n<ul>\n<li><code>push(elem);</code> &#x2F;&#x2F;往队尾添加元素</li>\n<li><code>pop();</code> &#x2F;&#x2F;从队头移除第一个元素</li>\n<li><code>back();</code> &#x2F;&#x2F;返回最后一个元素</li>\n<li><code>front(); </code> &#x2F;&#x2F;返回第一个元素</li>\n</ul>\n<p>大小操作：</p>\n<ul>\n<li><code>empty();</code> &#x2F;&#x2F;判断堆栈是否为空</li>\n<li><code>size(); </code> &#x2F;&#x2F;返回栈的大小</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;queue&gt;\n#include &lt;string&gt;\nclass Person\n&#123;\npublic:\n    Person(string name, int age)\n    &#123;\n        this-&gt;m_Name = name;\n        this-&gt;m_Age = age;\n    &#125;\n\n    string m_Name;\n    int m_Age;\n&#125;;\n\nvoid test01() &#123;\n\n    //创建队列\n    queue&lt;Person&gt; q;\n\n    //准备数据\n    Person p1(&quot;唐僧&quot;, 30);\n    Person p2(&quot;孙悟空&quot;, 1000);\n    Person p3(&quot;猪八戒&quot;, 900);\n    Person p4(&quot;沙僧&quot;, 800);\n\n    //向队列中添加元素  入队操作\n    q.push(p1);\n    q.push(p2);\n    q.push(p3);\n    q.push(p4);\n\n    //队列不提供迭代器，更不支持随机访问\n    while (!q.empty()) &#123;\n        //输出队头元素\n        cout &lt;&lt; &quot;队头元素-- 姓名： &quot; &lt;&lt; q.front().m_Name\n              &lt;&lt; &quot; 年龄： &quot;&lt;&lt; q.front().m_Age &lt;&lt; endl;\n\n        cout &lt;&lt; &quot;队尾元素-- 姓名： &quot; &lt;&lt; q.back().m_Name\n              &lt;&lt; &quot; 年龄： &quot; &lt;&lt; q.back().m_Age &lt;&lt; endl;\n\n        cout &lt;&lt; endl;\n        //弹出队头元素\n        q.pop();\n    &#125;\n\n    cout &lt;&lt; &quot;队列大小为：&quot; &lt;&lt; q.size() &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：</p>\n<ul>\n<li>入队 — push</li>\n<li>出队 — pop</li>\n<li>返回队头元素 — front</li>\n<li>返回队尾元素 — back</li>\n<li>判断队是否为空 — empty</li>\n<li>返回队列大小 — size</li>\n</ul>\n<h3 id=\"7-list-容器\"><a href=\"#7-list-容器\" class=\"headerlink\" title=\"7 list 容器\"></a>7 list 容器</h3><h4 id=\"7-1-list-基本概念\"><a href=\"#7-1-list-基本概念\" class=\"headerlink\" title=\"7.1 list 基本概念\"></a>7.1 list 基本概念</h4><p><strong>功能</strong>：将数据进行链式存储</p>\n<p><strong>链表</strong>（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p>\n<p>链表的组成：链表由一系列<strong>结点</strong>组成</p>\n<p>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></p>\n<p>STL 中的链表是一个双向循环链表</p>\n<p>由于链表的存储方式并不是连续的内存空间，因此链表 list 中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong></p>\n<p>list 的优点：</p>\n<ul>\n<li>采用动态存储分配，不会造成内存浪费和溢出</li>\n<li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li>\n</ul>\n<p>list 的缺点：</p>\n<ul>\n<li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li>\n</ul>\n<p>List 有一个重要的性质，插入操作和删除操作都不会造成原有 list 迭代器的失效，这在 vector 是不成立的。</p>\n<p>总结：STL 中<strong>List 和 vector 是两个最常被使用的容器</strong>，各有优缺点</p>\n<h4 id=\"7-2-list-构造函数\"><a href=\"#7-2-list-构造函数\" class=\"headerlink\" title=\"7.2 list 构造函数\"></a>7.2 list 构造函数</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>创建 list 容器</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><code>list&lt;T&gt; lst;</code> &#x2F;&#x2F;list 采用采用模板类实现,对象的默认构造形式：</li>\n<li><code>list(beg,end);</code> &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。</li>\n<li><code>list(n,elem);</code> &#x2F;&#x2F;构造函数将 n 个 elem 拷贝给本身。</li>\n<li><code>list(const list &amp;lst);</code> &#x2F;&#x2F;拷贝构造函数。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;list&gt;\n\nvoid printList(const list&lt;int&gt;&amp; L) &#123;\n\n    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid test01()\n&#123;\n    list&lt;int&gt;L1;\n    L1.push_back(10);\n    L1.push_back(20);\n    L1.push_back(30);\n    L1.push_back(40);\n\n    printList(L1);\n\n    list&lt;int&gt;L2(L1.begin(),L1.end());\n    printList(L2);\n\n    list&lt;int&gt;L3(L2);\n    printList(L3);\n\n    list&lt;int&gt;L4(10, 1000);\n    printList(L4);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：list 构造方式同其他几个 STL 常用容器，熟练掌握即可</p>\n<h4 id=\"7-3-list-赋值和交换\"><a href=\"#7-3-list-赋值和交换\" class=\"headerlink\" title=\"7.3 list 赋值和交换\"></a>7.3 list 赋值和交换</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>给 list 容器进行赋值，以及交换 list 容器</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><code>assign(beg, end);</code> &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</li>\n<li><code>assign(n, elem);</code> &#x2F;&#x2F;将 n 个 elem 拷贝赋值给本身。</li>\n<li><code>list&amp; operator=(const list &amp;lst);</code> &#x2F;&#x2F;重载等号操作符</li>\n<li><code>swap(lst);</code> &#x2F;&#x2F;将 lst 与本身的元素互换。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;list&gt;\n\nvoid printList(const list&lt;int&gt;&amp; L) &#123;\n\n    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\n//赋值和交换\nvoid test01()\n&#123;\n    list&lt;int&gt;L1;\n    L1.push_back(10);\n    L1.push_back(20);\n    L1.push_back(30);\n    L1.push_back(40);\n    printList(L1);\n\n    //赋值\n    list&lt;int&gt;L2;\n    L2 = L1;\n    printList(L2);\n\n    list&lt;int&gt;L3;\n    L3.assign(L2.begin(), L2.end());\n    printList(L3);\n\n    list&lt;int&gt;L4;\n    L4.assign(10, 100);\n    printList(L4);\n\n&#125;\n\n//交换\nvoid test02()\n&#123;\n\n    list&lt;int&gt;L1;\n    L1.push_back(10);\n    L1.push_back(20);\n    L1.push_back(30);\n    L1.push_back(40);\n\n    list&lt;int&gt;L2;\n    L2.assign(10, 100);\n\n    cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl;\n    printList(L1);\n    printList(L2);\n\n    cout &lt;&lt; endl;\n\n    L1.swap(L2);\n\n    cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl;\n    printList(L1);\n    printList(L2);\n\n&#125;\n\nint main() &#123;\n\n    //test01();\n\n    test02();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：list 赋值和交换操作能够灵活运用即可</p>\n<h4 id=\"7-4-list-大小操作\"><a href=\"#7-4-list-大小操作\" class=\"headerlink\" title=\"7.4 list 大小操作\"></a>7.4 list 大小操作</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>对 list 容器的大小进行操作</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><p><code>size(); </code> &#x2F;&#x2F;返回容器中元素的个数</p>\n</li>\n<li><p><code>empty(); </code> &#x2F;&#x2F;判断容器是否为空</p>\n</li>\n<li><p><code>resize(num);</code> &#x2F;&#x2F;重新指定容器的长度为 num，若容器变长，则以默认值填充新位置。</p>\n<p>&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</p>\n</li>\n<li><p><code>resize(num, elem); </code> &#x2F;&#x2F;重新指定容器的长度为 num，若容器变长，则以 elem 值填充新位置。</p>\n<p>&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</p>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;list&gt;\n\nvoid printList(const list&lt;int&gt;&amp; L) &#123;\n\n    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\n//大小操作\nvoid test01()\n&#123;\n    list&lt;int&gt;L1;\n    L1.push_back(10);\n    L1.push_back(20);\n    L1.push_back(30);\n    L1.push_back(40);\n\n    if (L1.empty())\n    &#123;\n        cout &lt;&lt; &quot;L1为空&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;L1不为空&quot; &lt;&lt; endl;\n        cout &lt;&lt; &quot;L1的大小为： &quot; &lt;&lt; L1.size() &lt;&lt; endl;\n    &#125;\n\n    //重新指定大小\n    L1.resize(10);\n    printList(L1);\n\n    L1.resize(2);\n    printList(L1);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：</p>\n<ul>\n<li>判断是否为空 — empty</li>\n<li>返回元素个数 — size</li>\n<li>重新指定个数 — resize</li>\n</ul>\n<h4 id=\"7-5-list-插入和删除\"><a href=\"#7-5-list-插入和删除\" class=\"headerlink\" title=\"7.5 list 插入和删除\"></a>7.5 list 插入和删除</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>对 list 容器进行数据的插入和删除</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li>push_back(elem);&#x2F;&#x2F;在容器尾部加入一个元素</li>\n<li>pop_back();&#x2F;&#x2F;删除容器中最后一个元素</li>\n<li>push_front(elem);&#x2F;&#x2F;在容器开头插入一个元素</li>\n<li>pop_front();&#x2F;&#x2F;从容器开头移除第一个元素</li>\n<li>insert(pos,elem);&#x2F;&#x2F;在 pos 位置插 elem 元素的拷贝，返回新数据的位置。</li>\n<li>insert(pos,n,elem);&#x2F;&#x2F;在 pos 位置插入 n 个 elem 数据，无返回值。</li>\n<li>insert(pos,beg,end);&#x2F;&#x2F;在 pos 位置插入[beg,end)区间的数据，无返回值。</li>\n<li>clear();&#x2F;&#x2F;移除容器的所有数据</li>\n<li>erase(beg,end);&#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</li>\n<li>erase(pos);&#x2F;&#x2F;删除 pos 位置的数据，返回下一个数据的位置。</li>\n<li>remove(elem);&#x2F;&#x2F;删除容器中所有与 elem 值匹配的元素。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;list&gt;\n\nvoid printList(const list&lt;int&gt;&amp; L) &#123;\n\n    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\n//插入和删除\nvoid test01()\n&#123;\n    list&lt;int&gt; L;\n    //尾插\n    L.push_back(10);\n    L.push_back(20);\n    L.push_back(30);\n    //头插\n    L.push_front(100);\n    L.push_front(200);\n    L.push_front(300);\n\n    printList(L);\n\n    //尾删\n    L.pop_back();\n    printList(L);\n\n    //头删\n    L.pop_front();\n    printList(L);\n\n    //插入\n    list&lt;int&gt;::iterator it = L.begin();\n    L.insert(++it, 1000);\n    printList(L);\n\n    //删除\n    it = L.begin();\n    L.erase(++it);\n    printList(L);\n\n    //移除\n    L.push_back(10000);\n    L.push_back(10000);\n    L.push_back(10000);\n    printList(L);\n    L.remove(10000);\n    printList(L);\n\n    //清空\n    L.clear();\n    printList(L);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：</p>\n<ul>\n<li>尾插 — push_back</li>\n<li>尾删 — pop_back</li>\n<li>头插 — push_front</li>\n<li>头删 — pop_front</li>\n<li>插入 — insert</li>\n<li>删除 — erase</li>\n<li>移除 — remove</li>\n<li>清空 — clear</li>\n</ul>\n<h4 id=\"7-6-list-数据存取\"><a href=\"#7-6-list-数据存取\" class=\"headerlink\" title=\"7.6 list 数据存取\"></a>7.6 list 数据存取</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>对 list 容器中数据进行存取</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><code>front();</code> &#x2F;&#x2F;返回第一个元素。</li>\n<li><code>back();</code> &#x2F;&#x2F;返回最后一个元素。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;list&gt;\n\n//数据存取\nvoid test01()\n&#123;\n    list&lt;int&gt;L1;\n    L1.push_back(10);\n    L1.push_back(20);\n    L1.push_back(30);\n    L1.push_back(40);\n\n\n    //cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据\n    //cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据\n    cout &lt;&lt; &quot;第一个元素为： &quot; &lt;&lt; L1.front() &lt;&lt; endl;\n    cout &lt;&lt; &quot;最后一个元素为： &quot; &lt;&lt; L1.back() &lt;&lt; endl;\n\n    //list容器的迭代器是双向迭代器，不支持随机访问\n    list&lt;int&gt;::iterator it = L1.begin();\n    //it = it + 1;//错误，不可以跳跃访问，即使是+1\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：</p>\n<ul>\n<li>list 容器中不可以通过[]或者 at 方式访问数据</li>\n<li>返回第一个元素 — front</li>\n<li>返回最后一个元素 — back</li>\n</ul>\n<h4 id=\"7-7-list-反转和排序\"><a href=\"#7-7-list-反转和排序\" class=\"headerlink\" title=\"7.7 list 反转和排序\"></a>7.7 list 反转和排序</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>将容器中的元素反转，以及将容器中的数据进行排序</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><code>reverse();</code> &#x2F;&#x2F;反转链表</li>\n<li><code>sort();</code> &#x2F;&#x2F;链表排序</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">void printList(const list&lt;int&gt;&amp; L) &#123;\n\n    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nbool myCompare(int val1 , int val2)\n&#123;\n    return val1 &gt; val2;\n&#125;\n\n//反转和排序\nvoid test01()\n&#123;\n    list&lt;int&gt; L;\n    L.push_back(90);\n    L.push_back(30);\n    L.push_back(20);\n    L.push_back(70);\n    printList(L);\n\n    //反转容器的元素\n    L.reverse();\n    printList(L);\n\n    //排序\n    L.sort(); //默认的排序规则 从小到大\n    printList(L);\n\n    L.sort(myCompare); //指定规则，从大到小\n    printList(L);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：</p>\n<ul>\n<li>反转 — reverse</li>\n<li>排序 — sort （成员函数）</li>\n</ul>\n<h4 id=\"7-8-排序案例\"><a href=\"#7-8-排序案例\" class=\"headerlink\" title=\"7.8 排序案例\"></a>7.8 排序案例</h4><p>案例描述：将 Person 自定义数据类型进行排序，Person 中属性有姓名、年龄、身高</p>\n<p>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序</p>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;list&gt;\n#include &lt;string&gt;\nclass Person &#123;\npublic:\n    Person(string name, int age , int height) &#123;\n        m_Name = name;\n        m_Age = age;\n        m_Height = height;\n    &#125;\n\npublic:\n    string m_Name;  //姓名\n    int m_Age;      //年龄\n    int m_Height;   //身高\n&#125;;\n\n\nbool ComparePerson(Person&amp; p1, Person&amp; p2) &#123;\n\n    if (p1.m_Age == p2.m_Age) &#123;\n        return p1.m_Height  &gt; p2.m_Height;\n    &#125;\n    else\n    &#123;\n        return  p1.m_Age &lt; p2.m_Age;\n    &#125;\n\n&#125;\n\nvoid test01() &#123;\n\n    list&lt;Person&gt; L;\n\n    Person p1(&quot;刘备&quot;, 35 , 175);\n    Person p2(&quot;曹操&quot;, 45 , 180);\n    Person p3(&quot;孙权&quot;, 40 , 170);\n    Person p4(&quot;赵云&quot;, 25 , 190);\n    Person p5(&quot;张飞&quot;, 35 , 160);\n    Person p6(&quot;关羽&quot;, 35 , 200);\n\n    L.push_back(p1);\n    L.push_back(p2);\n    L.push_back(p3);\n    L.push_back(p4);\n    L.push_back(p5);\n    L.push_back(p6);\n\n    for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123;\n        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age\n              &lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl;\n    &#125;\n\n    cout &lt;&lt; &quot;---------------------------------&quot; &lt;&lt; endl;\n    L.sort(ComparePerson); //排序\n\n    for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123;\n        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age\n              &lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl;\n    &#125;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：</p>\n<ul>\n<li><p>对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序</p>\n</li>\n<li><p>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</p>\n</li>\n</ul>\n<h3 id=\"8-set-multiset-容器\"><a href=\"#8-set-multiset-容器\" class=\"headerlink\" title=\"8 set|multiset 容器\"></a>8 set|multiset 容器</h3><h4 id=\"8-1-set-基本概念\"><a href=\"#8-1-set-基本概念\" class=\"headerlink\" title=\"8.1 set 基本概念\"></a>8.1 set 基本概念</h4><p><strong>简介：</strong></p>\n<ul>\n<li>所有元素都会在插入时自动被排序</li>\n</ul>\n<p><strong>本质：</strong></p>\n<ul>\n<li>set&#x2F;multiset 属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现。</li>\n</ul>\n<p><strong>set 和 multiset 区别</strong>：</p>\n<ul>\n<li>set 不允许容器中有重复的元素</li>\n<li>multiset 允许容器中有重复的元素</li>\n</ul>\n<h4 id=\"8-2-set-构造和赋值\"><a href=\"#8-2-set-构造和赋值\" class=\"headerlink\" title=\"8.2 set 构造和赋值\"></a>8.2 set 构造和赋值</h4><p>功能描述：创建 set 容器以及赋值</p>\n<p>构造：</p>\n<ul>\n<li><code>set&lt;T&gt; st;</code> &#x2F;&#x2F;默认构造函数：</li>\n<li><code>set(const set &amp;st);</code> &#x2F;&#x2F;拷贝构造函数</li>\n</ul>\n<p>赋值：</p>\n<ul>\n<li><code>set&amp; operator=(const set &amp;st);</code> &#x2F;&#x2F;重载等号操作符</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;set&gt;\n\nvoid printSet(set&lt;int&gt; &amp; s)\n&#123;\n    for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\n//构造和赋值\nvoid test01()\n&#123;\n    set&lt;int&gt; s1;\n\n    s1.insert(10);\n    s1.insert(30);\n    s1.insert(20);\n    s1.insert(40);\n    printSet(s1);\n\n    //拷贝构造\n    set&lt;int&gt;s2(s1);\n    printSet(s2);\n\n    //赋值\n    set&lt;int&gt;s3;\n    s3 = s2;\n    printSet(s3);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：</p>\n<ul>\n<li>set 容器插入数据时用 insert</li>\n<li>set 容器插入数据的数据会自动排序</li>\n</ul>\n<h4 id=\"8-3-set-大小和交换\"><a href=\"#8-3-set-大小和交换\" class=\"headerlink\" title=\"8.3 set 大小和交换\"></a>8.3 set 大小和交换</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>统计 set 容器大小以及交换 set 容器</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><code>size();</code> &#x2F;&#x2F;返回容器中元素的数目</li>\n<li><code>empty();</code> &#x2F;&#x2F;判断容器是否为空</li>\n<li><code>swap(st);</code> &#x2F;&#x2F;交换两个集合容器</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;set&gt;\n\nvoid printSet(set&lt;int&gt; &amp; s)\n&#123;\n    for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\n//大小\nvoid test01()\n&#123;\n\n    set&lt;int&gt; s1;\n\n    s1.insert(10);\n    s1.insert(30);\n    s1.insert(20);\n    s1.insert(40);\n\n    if (s1.empty())\n    &#123;\n        cout &lt;&lt; &quot;s1为空&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;s1不为空&quot; &lt;&lt; endl;\n        cout &lt;&lt; &quot;s1的大小为： &quot; &lt;&lt; s1.size() &lt;&lt; endl;\n    &#125;\n\n&#125;\n\n//交换\nvoid test02()\n&#123;\n    set&lt;int&gt; s1;\n\n    s1.insert(10);\n    s1.insert(30);\n    s1.insert(20);\n    s1.insert(40);\n\n    set&lt;int&gt; s2;\n\n    s2.insert(100);\n    s2.insert(300);\n    s2.insert(200);\n    s2.insert(400);\n\n    cout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl;\n    printSet(s1);\n    printSet(s2);\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl;\n    s1.swap(s2);\n    printSet(s1);\n    printSet(s2);\n&#125;\n\nint main() &#123;\n\n    //test01();\n\n    test02();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：</p>\n<ul>\n<li>统计大小 — size</li>\n<li>判断是否为空 — empty</li>\n<li>交换容器 — swap</li>\n</ul>\n<h4 id=\"8-4-set-插入和删除\"><a href=\"#8-4-set-插入和删除\" class=\"headerlink\" title=\"8.4 set 插入和删除\"></a>8.4 set 插入和删除</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>set 容器进行插入数据和删除数据</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><code>insert(elem);</code> &#x2F;&#x2F;在容器中插入元素。</li>\n<li><code>clear();</code> &#x2F;&#x2F;清除所有元素</li>\n<li><code>erase(pos);</code> &#x2F;&#x2F;删除 pos 迭代器所指的元素，返回下一个元素的迭代器。</li>\n<li><code>erase(beg, end);</code> &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li>\n<li><code>erase(elem);</code> &#x2F;&#x2F;删除容器中值为 elem 的元素。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;set&gt;\n\nvoid printSet(set&lt;int&gt; &amp; s)\n&#123;\n    for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\n//插入和删除\nvoid test01()\n&#123;\n    set&lt;int&gt; s1;\n    //插入\n    s1.insert(10);\n    s1.insert(30);\n    s1.insert(20);\n    s1.insert(40);\n    printSet(s1);\n\n    //删除\n    s1.erase(s1.begin());\n    printSet(s1);\n\n    s1.erase(30);\n    printSet(s1);\n\n    //清空\n    //s1.erase(s1.begin(), s1.end());\n    s1.clear();\n    printSet(s1);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：</p>\n<ul>\n<li>插入 — insert</li>\n<li>删除 — erase</li>\n<li>清空 — clear</li>\n</ul>\n<h4 id=\"8-5-set-查找和统计\"><a href=\"#8-5-set-查找和统计\" class=\"headerlink\" title=\"8.5 set 查找和统计\"></a>8.5 set 查找和统计</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>对 set 容器进行查找数据以及统计数据</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><code>find(key);</code> &#x2F;&#x2F;查找 key 是否存在,若存在，返回该键的元素的迭代器；若不存在，返回 set.end();</li>\n<li><code>count(key);</code> &#x2F;&#x2F;统计 key 的元素个数</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;set&gt;\n\n//查找和统计\nvoid test01()\n&#123;\n    set&lt;int&gt; s1;\n    //插入\n    s1.insert(10);\n    s1.insert(30);\n    s1.insert(20);\n    s1.insert(40);\n\n    //查找\n    set&lt;int&gt;::iterator pos = s1.find(30);\n\n    if (pos != s1.end())\n    &#123;\n        cout &lt;&lt; &quot;找到了元素 ： &quot; &lt;&lt; *pos &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl;\n    &#125;\n\n    //统计\n    int num = s1.count(30);\n    cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：</p>\n<ul>\n<li>查找 — find （返回的是迭代器）</li>\n<li>统计 — count （对于 set，结果为 0 或者 1）</li>\n</ul>\n<h4 id=\"8-6-set-和-multiset-区别\"><a href=\"#8-6-set-和-multiset-区别\" class=\"headerlink\" title=\"8.6 set 和 multiset 区别\"></a>8.6 set 和 multiset 区别</h4><p><strong>学习目标：</strong></p>\n<ul>\n<li>掌握 set 和 multiset 的区别</li>\n</ul>\n<p><strong>区别：</strong></p>\n<ul>\n<li>set 不可以插入重复数据，而 multiset 可以</li>\n<li>set 插入数据的同时会返回插入结果，表示插入是否成功</li>\n<li>multiset 不会检测数据，因此可以插入重复数据</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;set&gt;\n\n//set和multiset区别\nvoid test01()\n&#123;\n    set&lt;int&gt; s;\n    pair&lt;set&lt;int&gt;::iterator, bool&gt;  ret = s.insert(10);\n    if (ret.second) &#123;\n        cout &lt;&lt; &quot;第一次插入成功!&quot; &lt;&lt; endl;\n    &#125;\n    else &#123;\n        cout &lt;&lt; &quot;第一次插入失败!&quot; &lt;&lt; endl;\n    &#125;\n\n    ret = s.insert(10);\n    if (ret.second) &#123;\n        cout &lt;&lt; &quot;第二次插入成功!&quot; &lt;&lt; endl;\n    &#125;\n    else &#123;\n        cout &lt;&lt; &quot;第二次插入失败!&quot; &lt;&lt; endl;\n    &#125;\n\n    //multiset\n    multiset&lt;int&gt; ms;\n    ms.insert(10);\n    ms.insert(10);\n\n    for (multiset&lt;int&gt;::iterator it = ms.begin(); it != ms.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：</p>\n<ul>\n<li>如果不允许插入重复数据可以利用 set</li>\n<li>如果需要插入重复数据利用 multiset</li>\n</ul>\n<h4 id=\"8-7-pair-对组创建\"><a href=\"#8-7-pair-对组创建\" class=\"headerlink\" title=\"8.7 pair 对组创建\"></a>8.7 pair 对组创建</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>成对出现的数据，利用对组可以返回两个数据</li>\n</ul>\n<p><strong>两种创建方式：</strong></p>\n<ul>\n<li><code>pair&lt;type, type&gt; p ( value1, value2 );</code></li>\n<li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code></li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;string&gt;\n\n//对组创建\nvoid test01()\n&#123;\n    pair&lt;string, int&gt; p(string(&quot;Tom&quot;), 20);\n    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt;  p.first &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.second &lt;&lt; endl;\n\n    pair&lt;string, int&gt; p2 = make_pair(&quot;Jerry&quot;, 10);\n    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p2.first &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p2.second &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：</p>\n<p>两种方式都可以创建对组，记住一种即可</p>\n<h4 id=\"8-8-set-容器排序\"><a href=\"#8-8-set-容器排序\" class=\"headerlink\" title=\"8.8 set 容器排序\"></a>8.8 set 容器排序</h4><p>学习目标：</p>\n<ul>\n<li>set 容器默认排序规则为从小到大，掌握如何改变排序规则</li>\n</ul>\n<p>主要技术点：</p>\n<ul>\n<li>利用仿函数，可以改变排序规则</li>\n</ul>\n<p><strong>示例一</strong> set 存放内置数据类型</p>\n<pre><code class=\"c\">#include &lt;set&gt;\n\nclass MyCompare\n&#123;\npublic:\n    bool operator()(int v1, int v2) &#123;\n        return v1 &gt; v2;\n    &#125;\n&#125;;\nvoid test01()\n&#123;\n    set&lt;int&gt; s1;\n    s1.insert(10);\n    s1.insert(40);\n    s1.insert(20);\n    s1.insert(30);\n    s1.insert(50);\n\n    //默认从小到大\n    for (set&lt;int&gt;::iterator it = s1.begin(); it != s1.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n\n    //指定排序规则\n    set&lt;int,MyCompare&gt; s2;\n    s2.insert(10);\n    s2.insert(40);\n    s2.insert(20);\n    s2.insert(30);\n    s2.insert(50);\n\n    for (set&lt;int, MyCompare&gt;::iterator it = s2.begin(); it != s2.end(); it++) &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：利用仿函数可以指定 set 容器的排序规则</p>\n<p><strong>示例二</strong> set 存放自定义数据类型</p>\n<pre><code class=\"c\">#include &lt;set&gt;\n#include &lt;string&gt;\n\nclass Person\n&#123;\npublic:\n    Person(string name, int age)\n    &#123;\n        this-&gt;m_Name = name;\n        this-&gt;m_Age = age;\n    &#125;\n\n    string m_Name;\n    int m_Age;\n\n&#125;;\nclass comparePerson\n&#123;\npublic:\n    bool operator()(const Person&amp; p1, const Person &amp;p2)\n    &#123;\n        //按照年龄进行排序  降序\n        return p1.m_Age &gt; p2.m_Age;\n    &#125;\n&#125;;\n\nvoid test01()\n&#123;\n    set&lt;Person, comparePerson&gt; s;\n\n    Person p1(&quot;刘备&quot;, 23);\n    Person p2(&quot;关羽&quot;, 27);\n    Person p3(&quot;张飞&quot;, 25);\n    Person p4(&quot;赵云&quot;, 21);\n\n    s.insert(p1);\n    s.insert(p2);\n    s.insert(p3);\n    s.insert(p4);\n\n    for (set&lt;Person, comparePerson&gt;::iterator it = s.begin(); it != s.end(); it++)\n    &#123;\n        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;\n    &#125;\n&#125;\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：</p>\n<p>对于自定义数据类型，set 必须指定排序规则才可以插入数据</p>\n<h3 id=\"9-map-multimap-容器\"><a href=\"#9-map-multimap-容器\" class=\"headerlink\" title=\"9 map|multimap 容器\"></a>9 map|multimap 容器</h3><h4 id=\"9-1-map-基本概念\"><a href=\"#9-1-map-基本概念\" class=\"headerlink\" title=\"9.1 map 基本概念\"></a>9.1 map 基本概念</h4><p><strong>简介：</strong></p>\n<ul>\n<li>map 中所有元素都是 pair</li>\n<li>pair 中第一个元素为 key（键值），起到索引作用，第二个元素为 value（实值）</li>\n<li>所有元素都会根据元素的键值自动排序</li>\n</ul>\n<p><strong>本质：</strong></p>\n<ul>\n<li>map&#x2F;multimap 属于<strong>关联式容器</strong>，底层结构是用二叉树实现。</li>\n</ul>\n<p><strong>优点：</strong></p>\n<ul>\n<li>可以根据 key 值快速找到 value 值</li>\n</ul>\n<p>map 和 multimap<strong>区别</strong>：</p>\n<ul>\n<li>map 不允许容器中有重复 key 值元素</li>\n<li>multimap 允许容器中有重复 key 值元素</li>\n</ul>\n<h4 id=\"9-2-map-构造和赋值\"><a href=\"#9-2-map-构造和赋值\" class=\"headerlink\" title=\"9.2 map 构造和赋值\"></a>9.2 map 构造和赋值</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>对 map 容器进行构造和赋值操作</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<p><strong>构造：</strong></p>\n<ul>\n<li><code>map&lt;T1, T2&gt; mp;</code> &#x2F;&#x2F;map 默认构造函数:</li>\n<li><code>map(const map &amp;mp);</code> &#x2F;&#x2F;拷贝构造函数</li>\n</ul>\n<p><strong>赋值：</strong></p>\n<ul>\n<li><code>map&amp; operator=(const map &amp;mp);</code> &#x2F;&#x2F;重载等号操作符</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;map&gt;\n\nvoid printMap(map&lt;int,int&gt;&amp;m)\n&#123;\n    for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)\n    &#123;\n        cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid test01()\n&#123;\n    map&lt;int,int&gt;m; //默认构造\n    m.insert(pair&lt;int, int&gt;(1, 10));\n    m.insert(pair&lt;int, int&gt;(2, 20));\n    m.insert(pair&lt;int, int&gt;(3, 30));\n    printMap(m);\n\n    map&lt;int, int&gt;m2(m); //拷贝构造\n    printMap(m2);\n\n    map&lt;int, int&gt;m3;\n    m3 = m2; //赋值\n    printMap(m3);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：map 中所有元素都是成对出现，插入数据时候要使用对组</p>\n<h4 id=\"9-3-map-大小和交换\"><a href=\"#9-3-map-大小和交换\" class=\"headerlink\" title=\"9.3 map 大小和交换\"></a>9.3 map 大小和交换</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>统计 map 容器大小以及交换 map 容器</li>\n</ul>\n<p>函数原型：</p>\n<ul>\n<li><code>size();</code> &#x2F;&#x2F;返回容器中元素的数目</li>\n<li><code>empty();</code> &#x2F;&#x2F;判断容器是否为空</li>\n<li><code>swap(st);</code> &#x2F;&#x2F;交换两个集合容器</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;map&gt;\n\nvoid printMap(map&lt;int,int&gt;&amp;m)\n&#123;\n    for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)\n    &#123;\n        cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid test01()\n&#123;\n    map&lt;int, int&gt;m;\n    m.insert(pair&lt;int, int&gt;(1, 10));\n    m.insert(pair&lt;int, int&gt;(2, 20));\n    m.insert(pair&lt;int, int&gt;(3, 30));\n\n    if (m.empty())\n    &#123;\n        cout &lt;&lt; &quot;m为空&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;m不为空&quot; &lt;&lt; endl;\n        cout &lt;&lt; &quot;m的大小为： &quot; &lt;&lt; m.size() &lt;&lt; endl;\n    &#125;\n&#125;\n\n\n//交换\nvoid test02()\n&#123;\n    map&lt;int, int&gt;m;\n    m.insert(pair&lt;int, int&gt;(1, 10));\n    m.insert(pair&lt;int, int&gt;(2, 20));\n    m.insert(pair&lt;int, int&gt;(3, 30));\n\n    map&lt;int, int&gt;m2;\n    m2.insert(pair&lt;int, int&gt;(4, 100));\n    m2.insert(pair&lt;int, int&gt;(5, 200));\n    m2.insert(pair&lt;int, int&gt;(6, 300));\n\n    cout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl;\n    printMap(m);\n    printMap(m2);\n\n    cout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl;\n    m.swap(m2);\n    printMap(m);\n    printMap(m2);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    test02();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：</p>\n<ul>\n<li>统计大小 — size</li>\n<li>判断是否为空 — empty</li>\n<li>交换容器 — swap</li>\n</ul>\n<h4 id=\"9-4-map-插入和删除\"><a href=\"#9-4-map-插入和删除\" class=\"headerlink\" title=\"9.4 map 插入和删除\"></a>9.4 map 插入和删除</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>map 容器进行插入数据和删除数据</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><code>insert(elem);</code> &#x2F;&#x2F;在容器中插入元素。</li>\n<li><code>clear();</code> &#x2F;&#x2F;清除所有元素</li>\n<li><code>erase(pos);</code> &#x2F;&#x2F;删除 pos 迭代器所指的元素，返回下一个元素的迭代器。</li>\n<li><code>erase(beg, end);</code> &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li>\n<li><code>erase(key);</code> &#x2F;&#x2F;删除容器中值为 key 的元素。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;map&gt;\n\nvoid printMap(map&lt;int,int&gt;&amp;m)\n&#123;\n    for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)\n    &#123;\n        cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nvoid test01()\n&#123;\n    //插入\n    map&lt;int, int&gt; m;\n    //第一种插入方式\n    m.insert(pair&lt;int, int&gt;(1, 10));\n    //第二种插入方式\n    m.insert(make_pair(2, 20));\n    //第三种插入方式\n    m.insert(map&lt;int, int&gt;::value_type(3, 30));\n    //第四种插入方式\n    m[4] = 40;\n    printMap(m);\n\n    //删除\n    m.erase(m.begin());\n    printMap(m);\n\n    m.erase(3);\n    printMap(m);\n\n    //清空\n    m.erase(m.begin(),m.end());\n    m.clear();\n    printMap(m);\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：</p>\n<ul>\n<li>map 插入方式很多，记住其一即可</li>\n</ul>\n<ul>\n<li>插入 — insert</li>\n<li>删除 — erase</li>\n<li>清空 — clear</li>\n</ul>\n<h4 id=\"9-5-map-查找和统计\"><a href=\"#9-5-map-查找和统计\" class=\"headerlink\" title=\"9.5 map 查找和统计\"></a>9.5 map 查找和统计</h4><p><strong>功能描述：</strong></p>\n<ul>\n<li>对 map 容器进行查找数据以及统计数据</li>\n</ul>\n<p><strong>函数原型：</strong></p>\n<ul>\n<li><code>find(key);</code> &#x2F;&#x2F;查找 key 是否存在,若存在，返回该键的元素的迭代器；若不存在，返回 set.end();</li>\n<li><code>count(key);</code> &#x2F;&#x2F;统计 key 的元素个数</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;map&gt;\n\n//查找和统计\nvoid test01()\n&#123;\n    map&lt;int, int&gt;m;\n    m.insert(pair&lt;int, int&gt;(1, 10));\n    m.insert(pair&lt;int, int&gt;(2, 20));\n    m.insert(pair&lt;int, int&gt;(3, 30));\n\n    //查找\n    map&lt;int, int&gt;::iterator pos = m.find(3);\n\n    if (pos != m.end())\n    &#123;\n        cout &lt;&lt; &quot;找到了元素 key = &quot; &lt;&lt; (*pos).first &lt;&lt; &quot; value = &quot; &lt;&lt; (*pos).second &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl;\n    &#125;\n\n    //统计\n    int num = m.count(3);\n    cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：</p>\n<ul>\n<li>查找 — find （返回的是迭代器）</li>\n<li>统计 — count （对于 map，结果为 0 或者 1）</li>\n</ul>\n<h4 id=\"9-6-map-容器排序\"><a href=\"#9-6-map-容器排序\" class=\"headerlink\" title=\"9.6 map 容器排序\"></a>9.6 map 容器排序</h4><p><strong>学习目标：</strong></p>\n<ul>\n<li>map 容器默认排序规则为 按照 key 值进行 从小到大排序，掌握如何改变排序规则</li>\n</ul>\n<p><strong>主要技术点:</strong></p>\n<ul>\n<li>利用仿函数，可以改变排序规则</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class=\"c\">#include &lt;map&gt;\n\nclass MyCompare &#123;\npublic:\n    bool operator()(int v1, int v2) &#123;\n        return v1 &gt; v2;\n    &#125;\n&#125;;\n\nvoid test01()\n&#123;\n    //默认从小到大排序\n    //利用仿函数实现从大到小排序\n    map&lt;int, int, MyCompare&gt; m;\n\n    m.insert(make_pair(1, 10));\n    m.insert(make_pair(2, 20));\n    m.insert(make_pair(3, 30));\n    m.insert(make_pair(4, 40));\n    m.insert(make_pair(5, 50));\n\n    for (map&lt;int, int, MyCompare&gt;::iterator it = m.begin(); it != m.end(); it++) &#123;\n        cout &lt;&lt; &quot;key:&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value:&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;\n    &#125;\n&#125;\nint main() &#123;\n\n    test01();\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：</p>\n<ul>\n<li>利用仿函数可以指定 map 容器的排序规则</li>\n<li>对于自定义数据类型，map 必须要指定排序规则,同 set 容器</li>\n</ul>\n<h3 id=\"10-案例-员工分组\"><a href=\"#10-案例-员工分组\" class=\"headerlink\" title=\"10 案例-员工分组\"></a>10 案例-员工分组</h3><h4 id=\"10-1-案例描述\"><a href=\"#10-1-案例描述\" class=\"headerlink\" title=\"10.1 案例描述\"></a>10.1 案例描述</h4><ul>\n<li>公司今天招聘了 10 个员工（ABCDEFGHIJ），10 名员工进入公司之后，需要指派员工在那个部门工作</li>\n<li>员工信息有: 姓名 工资组成；部门分为：策划、美术、研发</li>\n<li>随机给 10 名员工分配部门和工资</li>\n<li>通过 multimap 进行信息的插入 key(部门编号) value(员工)</li>\n<li>分部门显示员工信息</li>\n</ul>\n<h4 id=\"10-2-实现步骤\"><a href=\"#10-2-实现步骤\" class=\"headerlink\" title=\"10.2 实现步骤\"></a>10.2 实现步骤</h4><ol>\n<li>创建 10 名员工，放到 vector 中</li>\n<li>遍历 vector 容器，取出每个员工，进行随机分组</li>\n<li>分组后，将员工部门编号作为 key，具体员工作为 value，放入到 multimap 容器中</li>\n<li>分部门显示员工信息</li>\n</ol>\n<p><strong>案例代码：</strong></p>\n<pre><code class=\"c\">#include&lt;iostream&gt;\nusing namespace std;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;map&gt;\n#include &lt;ctime&gt;\n\n/*\n- 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作\n- 员工信息有: 姓名  工资组成；部门分为：策划、美术、研发\n- 随机给10名员工分配部门和工资\n- 通过multimap进行信息的插入  key(部门编号) value(员工)\n- 分部门显示员工信息\n*/\n\n#define CEHUA  0\n#define MEISHU 1\n#define YANFA  2\n\nclass Worker\n&#123;\npublic:\n    string m_Name;\n    int m_Salary;\n&#125;;\n\nvoid createWorker(vector&lt;Worker&gt;&amp;v)\n&#123;\n    string nameSeed = &quot;ABCDEFGHIJ&quot;;\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        Worker worker;\n        worker.m_Name = &quot;员工&quot;;\n        worker.m_Name += nameSeed[i];\n\n        worker.m_Salary = rand() % 10000 + 10000; // 10000 ~ 19999\n        //将员工放入到容器中\n        v.push_back(worker);\n    &#125;\n&#125;\n\n//员工分组\nvoid setGroup(vector&lt;Worker&gt;&amp;v,multimap&lt;int,Worker&gt;&amp;m)\n&#123;\n    for (vector&lt;Worker&gt;::iterator it = v.begin(); it != v.end(); it++)\n    &#123;\n        //产生随机部门编号\n        int deptId = rand() % 3; // 0 1 2\n\n        //将员工插入到分组中\n        //key部门编号，value具体员工\n        m.insert(make_pair(deptId, *it));\n    &#125;\n&#125;\n\nvoid showWorkerByGourp(multimap&lt;int,Worker&gt;&amp;m)\n&#123;\n    // 0  A  B  C   1  D  E   2  F G ...\n    cout &lt;&lt; &quot;策划部门：&quot; &lt;&lt; endl;\n\n    multimap&lt;int,Worker&gt;::iterator pos = m.find(CEHUA);\n    int count = m.count(CEHUA); // 统计具体人数\n    int index = 0;\n    for (; pos != m.end() &amp;&amp; index &lt; count; pos++ , index++)\n    &#123;\n        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;\n    &#125;\n\n    cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;美术部门： &quot; &lt;&lt; endl;\n    pos = m.find(MEISHU);\n    count = m.count(MEISHU); // 统计具体人数\n    index = 0;\n    for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)\n    &#123;\n        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;\n    &#125;\n\n    cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;研发部门： &quot; &lt;&lt; endl;\n    pos = m.find(YANFA);\n    count = m.count(YANFA); // 统计具体人数\n    index = 0;\n    for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)\n    &#123;\n        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;\n    &#125;\n\n&#125;\n\nint main() &#123;\n\n    srand((unsigned int)time(NULL));\n\n    //1、创建员工\n    vector&lt;Worker&gt;vWorker;\n    createWorker(vWorker);\n\n    //2、员工分组\n    multimap&lt;int, Worker&gt;mWorker;\n    setGroup(vWorker, mWorker);\n\n\n    //3、分组显示员工\n    showWorkerByGourp(mWorker);\n\n    ////测试\n    //for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++)\n    //&#123;\n    //\tcout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;\n    //&#125;\n\n    system(&quot;pause&quot;);\n\n    return 0;\n&#125;\n</code></pre>\n<p>总结：</p>\n<ul>\n<li>当数据以键值对形式存在，可以考虑用 map 或 multimap</li>\n</ul>\n","feature":true,"text":"C++标准模板库(STL)是C++编程中不可或缺的部分，它提供了丰富的数据结构和算法。本文我们将对每种容器和算法进行简要介绍，并给出示例代码加深理解。...","permalink":"/post/C++_STL_常用容器","photos":[],"count_time":{"symbolsCount":"56k","symbolsTime":"51 mins."},"categories":[{"name":"C++","slug":"C","count":6,"path":"api/categories/C.json"}],"tags":[{"name":"STL","slug":"STL","count":3,"path":"api/tags/STL.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#STL-%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">STL 常用容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-string-%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">1 string 容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-string-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1.1 string 基本概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-string-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">1.2 string 构造函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-string-%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">1.3 string 赋值操作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-4-string-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5\"><span class=\"toc-text\">1.4 string 字符串拼接</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-5-string-%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2\"><span class=\"toc-text\">1.5 string 查找和替换</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-6-string-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">1.6 string 字符串比较</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-7-string-%E5%AD%97%E7%AC%A6%E5%AD%98%E5%8F%96\"><span class=\"toc-text\">1.7 string 字符存取</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-8-string-%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">1.8 string 插入和删除</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-9-string-%E5%AD%90%E4%B8%B2\"><span class=\"toc-text\">1.9 string 子串</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-vector-%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">2 vector 容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-vector-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">2.1 vector 基本概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-vector-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">2.2 vector 构造函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-vector-%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">2.3 vector 赋值操作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-4-vector-%E5%AE%B9%E9%87%8F%E5%92%8C%E5%A4%A7%E5%B0%8F\"><span class=\"toc-text\">2.4 vector 容量和大小</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-5-vector-%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">2.5 vector 插入和删除</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-6-vector-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96\"><span class=\"toc-text\">2.6 vector 数据存取</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-7-vector-%E4%BA%92%E6%8D%A2%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">2.7 vector 互换容器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-8-vector-%E9%A2%84%E7%95%99%E7%A9%BA%E9%97%B4\"><span class=\"toc-text\">2.8 vector 预留空间</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-deque-%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">3 deque 容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-deque-%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">3.1 deque 容器基本概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-deque-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">3.2 deque 构造函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-3-deque-%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">3.3 deque 赋值操作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-4-deque-%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">3.4 deque 大小操作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-5-deque-%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">3.5 deque 插入和删除</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-6-deque-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96\"><span class=\"toc-text\">3.6 deque 数据存取</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-7-deque-%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">3.7 deque 排序</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E6%A1%88%E4%BE%8B-%E8%AF%84%E5%A7%94%E6%89%93%E5%88%86\"><span class=\"toc-text\">4 案例-评委打分</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-1-%E6%A1%88%E4%BE%8B%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">4.1 案例描述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-2-%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">4.2 实现步骤</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-stack-%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">5 stack 容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-1-stack-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">5.1 stack 基本概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-2-stack-%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">5.2 stack 常用接口</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-queue-%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">6 queue 容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-1-queue-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">6.1 queue 基本概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-2-queue-%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">6.2 queue 常用接口</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-list-%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">7 list 容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-1-list-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">7.1 list 基本概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-2-list-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">7.2 list 构造函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-3-list-%E8%B5%8B%E5%80%BC%E5%92%8C%E4%BA%A4%E6%8D%A2\"><span class=\"toc-text\">7.3 list 赋值和交换</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-4-list-%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">7.4 list 大小操作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-5-list-%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">7.5 list 插入和删除</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-6-list-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96\"><span class=\"toc-text\">7.6 list 数据存取</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-7-list-%E5%8F%8D%E8%BD%AC%E5%92%8C%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">7.7 list 反转和排序</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-8-%E6%8E%92%E5%BA%8F%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">7.8 排序案例</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-set-multiset-%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">8 set|multiset 容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-1-set-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">8.1 set 基本概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-2-set-%E6%9E%84%E9%80%A0%E5%92%8C%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">8.2 set 构造和赋值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-3-set-%E5%A4%A7%E5%B0%8F%E5%92%8C%E4%BA%A4%E6%8D%A2\"><span class=\"toc-text\">8.3 set 大小和交换</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-4-set-%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">8.4 set 插入和删除</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-5-set-%E6%9F%A5%E6%89%BE%E5%92%8C%E7%BB%9F%E8%AE%A1\"><span class=\"toc-text\">8.5 set 查找和统计</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-6-set-%E5%92%8C-multiset-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">8.6 set 和 multiset 区别</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-7-pair-%E5%AF%B9%E7%BB%84%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">8.7 pair 对组创建</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-8-set-%E5%AE%B9%E5%99%A8%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">8.8 set 容器排序</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-map-multimap-%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">9 map|multimap 容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-1-map-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">9.1 map 基本概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-2-map-%E6%9E%84%E9%80%A0%E5%92%8C%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">9.2 map 构造和赋值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-3-map-%E5%A4%A7%E5%B0%8F%E5%92%8C%E4%BA%A4%E6%8D%A2\"><span class=\"toc-text\">9.3 map 大小和交换</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-4-map-%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">9.4 map 插入和删除</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-5-map-%E6%9F%A5%E6%89%BE%E5%92%8C%E7%BB%9F%E8%AE%A1\"><span class=\"toc-text\">9.5 map 查找和统计</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-6-map-%E5%AE%B9%E5%99%A8%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">9.6 map 容器排序</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-%E6%A1%88%E4%BE%8B-%E5%91%98%E5%B7%A5%E5%88%86%E7%BB%84\"><span class=\"toc-text\">10 案例-员工分组</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-1-%E6%A1%88%E4%BE%8B%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">10.1 案例描述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-2-%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">10.2 实现步骤</span></a></li></ol></li></ol></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"C++_STL_常用算法","uid":"9e5f4d79310e12911a75fefd0392a14d","slug":"C++_STL_常用算法","date":"2022-01-15T08:40:57.000Z","updated":"2025-07-14T15:12:20.457Z","comments":true,"path":"api/articles/C++_STL_常用算法.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/506e6842fd8542408c76ef139e90ebd3.png","text":"C++标准模板库（STL）是C++编程中不可或缺的部分，它提供了丰富的数据结构和算法。本文我们将对每种容器和算法进行简要介绍，并给出示例代码加深理解。...","permalink":"/post/C++_STL_常用算法","photos":[],"count_time":{"symbolsCount":"25k","symbolsTime":"22 mins."},"categories":[{"name":"C++","slug":"C","count":6,"path":"api/categories/C.json"}],"tags":[{"name":"STL","slug":"STL","count":3,"path":"api/tags/STL.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true},"next_post":{"title":"C++_STL_初识","uid":"9f006e9426f7337b910be637ae59775f","slug":"C++_STL_初识","date":"2022-01-13T02:22:56.000Z","updated":"2025-07-14T15:12:20.457Z","comments":true,"path":"api/articles/C++_STL_初识.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/506e6842fd8542408c76ef139e90ebd3.png","text":"C++标准模板库（STL）是C++编程中不可或缺的部分，它提供了丰富的数据结构和算法。本文我们将对每种容器和算法进行简要介绍，并给出示例代码加深理解。...","permalink":"/post/C++_STL_初识","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"C++","slug":"C","count":6,"path":"api/categories/C.json"}],"tags":[{"name":"STL","slug":"STL","count":3,"path":"api/tags/STL.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true}}