{"title":"Java程序设计--网络编程","uid":"fcaa2443e4f23837ea39b8c51bbe3746","slug":"Java程序设计 -- 网络编程（十九）","date":"2022-04-15T02:39:59.000Z","updated":"2025-07-14T15:12:20.461Z","comments":true,"path":"api/articles/Java程序设计 -- 网络编程（十九）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","content":"<hr>\n<h1 id=\"1、网络通信三要素\"><a href=\"#1、网络通信三要素\" class=\"headerlink\" title=\"1、网络通信三要素\"></a>1、网络通信三要素</h1><ul>\n<li>&#x3D;&#x3D;IP地址:设备在网络中的地址，是唯一的标识。&#x3D;&#x3D;</li>\n<li>&#x3D;&#x3D;端口:应用程序在设备中唯一的标识。&#x3D;&#x3D;</li>\n<li>&#x3D;&#x3D;协议:数据在网络中传输的规则，常见的协议有UDP协议和TCP协议。&#x3D;&#x3D;</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/de779729c4b6482d8060f50306a65a43.png#pic_center\"></p>\n<h2 id=\"1-1-IP地址\"><a href=\"#1-1-IP地址\" class=\"headerlink\" title=\"1.1 IP地址\"></a>1.1 IP地址</h2><p> <strong>lP (Internet Protocol) ︰全称”互联网协议地址”，是分配给上网设备的唯一标志。</strong></p>\n<p>常见的IP分类为:IPv4和IPv6。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2a8e86647791491b95d19c34283fe025.png#pic_center\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/e20bcc55b81b4ecf9da9415f3d2b3365.png#pic_center\"></p>\n<p><strong>IP地址形式:</strong></p>\n<ul>\n<li>公网地址、和私有地址(局域网使用)。</li>\n<li>192.168.开头的就是常见的局域网地址，范围即为192.168.0.0 - - 192.168.255.255，专门为组织机构内部使用。</li>\n</ul>\n<p><strong>IP常用命令:</strong></p>\n<ul>\n<li>&#x3D;&#x3D;ipconfig:查看本机IP地址&#x3D;&#x3D;</li>\n<li>&#x3D;&#x3D;ping lP地址:检查网络是否连通&#x3D;&#x3D;</li>\n</ul>\n<p><strong>特殊IP地址:</strong></p>\n<ul>\n<li>本机IP:127.0.0.1或者localhost:称为回送地址也可称本地回环地址，只会寻找当前所在本机。</li>\n<li><strong>IP地址操作类- - InetAddress</strong></li>\n</ul>\n<p><strong>InetAddress的使用</strong></p>\n<ul>\n<li>此类表示Internet协议(IP）地址。</li>\n</ul>\n<p><strong>lnetAddress API如下</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public static InetAddress getLocalHost()</td>\n<td align=\"center\">返回本主机的地址对象</td>\n</tr>\n<tr>\n<td align=\"center\">public static InetAddress getByName( String host)</td>\n<td align=\"center\">得到指定主机的IP地址对象，参数是域名或者IP地址</td>\n</tr>\n<tr>\n<td align=\"center\">public String getHostName()</td>\n<td align=\"center\">获取此IP地址的主机名</td>\n</tr>\n<tr>\n<td align=\"center\">public string getHostAddress()</td>\n<td align=\"center\">返回IP地址字符串</td>\n</tr>\n<tr>\n<td align=\"center\">public boolean isReachable(int timeout)</td>\n<td align=\"center\">在指定毫秒内连通该IP地址对应的主机，连通返回true</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">public class InetAddressDemo01 &#123;\n    public static void main(String[] args) throws Exception &#123;\n        // 1.获取本机地址对象。\n        InetAddress ip1 = InetAddress.getLocalHost();\n        System.out.println(ip1.getHostName());\n        System.out.println(ip1.getHostAddress());\n\n        // 2.获取域名ip对象\n        InetAddress ip2 = InetAddress.getByName(&quot;www.baidu.com&quot;);\n        System.out.println(ip2.getHostName());\n        System.out.println(ip2.getHostAddress());\n\n        // 3.获取公网IP对象。\n        InetAddress ip3 = InetAddress.getByName(&quot;112.80.248.76&quot;);\n        System.out.println(ip3.getHostName());\n        System.out.println(ip3.getHostAddress());\n\n        // 4.判断是否能通： ping  5s之前测试是否可通\n        System.out.println(ip3.isReachable(5000));\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"1-2-端口号\"><a href=\"#1-2-端口号\" class=\"headerlink\" title=\"1.2 端口号\"></a>1.2 端口号</h2><p> <strong>端口号:标识正在计算机设备上运行的进程（程序)，被规定为一个16位的二进制，范围是0~65535</strong></p>\n<p><strong>端口类型</strong></p>\n<ul>\n<li><strong>周知端口:0~1023</strong>，被预先定义的知名应用占用(如:HTTP占用80，FTP占用21)</li>\n<li><strong>注册端口:1024~49151</strong>，分配给用户进程或某些应用程序。(如: Tomcat占用8080，MySQL占用3306)</li>\n<li><strong>动态端口:49152到65535</strong>，之所以称为动态端口，是因为它一般不固定分配某种进程，而是动态分配</li>\n</ul>\n<p><strong>注意:我们自己开发的程序选择注册端口，且一个设备中不能出现两个程序的端口号一样，否则出错。</strong></p>\n<h2 id=\"1-3-通信协议\"><a href=\"#1-3-通信协议\" class=\"headerlink\" title=\"1.3 通信协议\"></a>1.3 通信协议</h2><p><strong>连接和通信数据的规则被称为网络通信协议。</strong></p>\n<p>网络通信协议有两套参考模型</p>\n<ul>\n<li>OSI参考模型:世界互联协议标准，全球通信规范，由于此模型过于理想化，未能在因特网上进行广泛推广</li>\n<li>TCP&#x2F;IP参考模型(或TCP&#x2F;IP协议):事实上的国际标准</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">OSI参考模型</th>\n<th align=\"center\">TCP&#x2F;IP参考模型</th>\n<th align=\"center\">各层对应</th>\n<th align=\"center\">面向操作</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">应用层</td>\n<td align=\"center\">应用层</td>\n<td align=\"center\">HTTP、FTP、DNS、SMTP…</td>\n<td align=\"center\">应用程序需要关注的：浏览器，邮箱、程序员一般在这一层开发</td>\n</tr>\n<tr>\n<td align=\"center\">表示层</td>\n<td align=\"center\">应用层</td>\n<td align=\"center\">HTTP、FTP、DNS、SMTP…</td>\n<td align=\"center\">应用程序需要关注的：浏览器，邮箱、程序员一般在这一层开发</td>\n</tr>\n<tr>\n<td align=\"center\">会话层</td>\n<td align=\"center\">应用层</td>\n<td align=\"center\">HTTP、FTP、DNS、SMTP…</td>\n<td align=\"center\">应用程序需要关注的：浏览器，邮箱、程序员一般在这一层开发</td>\n</tr>\n<tr>\n<td align=\"center\">传输层</td>\n<td align=\"center\">传输层</td>\n<td align=\"center\">TCP、UDP…</td>\n<td align=\"center\">选择使用的TCP、UDP协议</td>\n</tr>\n<tr>\n<td align=\"center\">网络层</td>\n<td align=\"center\">网络层</td>\n<td align=\"center\">IP、ICMP…</td>\n<td align=\"center\">封装源和目标IP，进行路径选择</td>\n</tr>\n<tr>\n<td align=\"center\">数据链路层</td>\n<td align=\"center\">数据链路层+物理</td>\n<td align=\"center\">物理寻址</td>\n<td align=\"center\">物理设备中传输</td>\n</tr>\n<tr>\n<td align=\"center\">物理层</td>\n<td align=\"center\">数据链路层+物理</td>\n<td align=\"center\">物理寻址</td>\n<td align=\"center\">物理设备中传输</td>\n</tr>\n</tbody></table>\n<p><strong>传输层的2个常见协议</strong></p>\n<ul>\n<li><strong>TCP(Transmission Control Protocol)︰传输控制协议</strong></li>\n<li><strong>UDP(User Datagram Protocol):用户数据报协议</strong></li>\n</ul>\n<p><strong>TCP协议特点</strong></p>\n<ul>\n<li>使用TCP协议，必须双方先建立连接，它是一种面向连接的<strong>可靠通信</strong>协议。</li>\n<li>传输前，采用“三次握手”方式建立连接，所以是可靠的。</li>\n<li>在连接中可进行大数据量的传输。</li>\n<li>连接、发送数据都需要确认，且传输完毕后，还需释放已建立的连接，通信效率较低。</li>\n</ul>\n<p><strong>TCP协议通信场景</strong></p>\n<ul>\n<li>对信息安全要求较高的场景，例如:文件下载、金融等数据通信。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/ece6f1c62b194e48a495a0cae931f501.png#pic_center\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/d426463bcde047f5b86aaa545b92073e.png#pic_center\"></p>\n<p><strong>UDP协议:</strong></p>\n<ul>\n<li>UDP是一种<strong>无连接、不可靠传输</strong>的协议</li>\n<li>将数据源IP、目的地IP和端口封装成数据包，不需要建立连接</li>\n<li>每个数据包的大小限制在64KB内</li>\n<li>发送不管对方是否准备好，接收方收到也不确认，故是不可靠的</li>\n<li>可以广播发送，发送数据结束时无需释放资源，开销小，速度快</li>\n</ul>\n<p><strong>UDP协议通信场景</strong></p>\n<ul>\n<li>语音通话，视频会话等。</li>\n</ul>\n<hr>\n<h1 id=\"2、UDP通信\"><a href=\"#2、UDP通信\" class=\"headerlink\" title=\"2、UDP通信\"></a>2、UDP通信</h1><h2 id=\"2-1-UDP通信-快速入门\"><a href=\"#2-1-UDP通信-快速入门\" class=\"headerlink\" title=\"2.1 UDP通信 - - 快速入门\"></a>2.1 UDP通信 - - 快速入门</h2><p><strong>UDP协议的特点</strong></p>\n<ul>\n<li>UDP是一种无连接、不可靠传输的协议。</li>\n<li>将数据源IP、目的地IP和端口以及数据封装成数据包，大小限制在64KB内，直接发送出去即可。</li>\n</ul>\n<p><strong>DatagramPacket:数据包对象</strong>  </p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">构造器</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public DatagramPacket(byte[ ] buf, int length，InetAddress address,int port)</td>\n<td align=\"center\">创建发送端数据包对象buf:要发送的内容，字节数组length:要发送内容的字节长度address:接收端的IP地址对象port:接收端的端口号</td>\n</tr>\n<tr>\n<td align=\"center\">public DatagramPacket(byte[] buf， int length)</td>\n<td align=\"center\">创建接收端的数据包对象buf:用来存储接收的内容length:能够接收内容的长度</td>\n</tr>\n</tbody></table>\n<p><strong>DatagramPacket常用方法</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public int getLength()</td>\n<td align=\"center\">获得实际接收到的字节个数</td>\n</tr>\n</tbody></table>\n<p><strong>DatagramSocket:发送端和接收端对象</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">构造器</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public DatagramSocket()</td>\n<td align=\"center\">创建发送端的Socket对象，系统会随机分配一个端口号。</td>\n</tr>\n<tr>\n<td align=\"center\">public DatagramSocket(int port)</td>\n<td align=\"center\">创建接收端的Socket对象并指定端口号</td>\n</tr>\n</tbody></table>\n<p><strong>DatagramSocket类成员方法</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public void send(DatagramPacket dp)</td>\n<td align=\"center\">发送数据包</td>\n</tr>\n<tr>\n<td align=\"center\">public void receive(DatagramPacket p)</td>\n<td align=\"center\">接收数据包</td>\n</tr>\n<tr>\n<td align=\"center\">使用UDP通信实现：发送消息、接受消息</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\n\n/**\n  发送端  一发 一收\n */\npublic class ClientDemo1 &#123;\n    public static void main(String[] args) throws Exception &#123;\n        System.out.println(&quot;=====客户端启动======&quot;);\n\n        // 1、创建发送端对象：发送端自带默认的端口号（人）\n        DatagramSocket socket = new DatagramSocket(6666);\n        // 2、创建一个数据包对象封装数据（韭菜盘子）\n        byte[] buffer = &quot;我是一颗快乐的韭菜，你愿意吃吗？&quot;.getBytes();\n        DatagramPacket packet = new DatagramPacket( buffer, buffer.length,\n                InetAddress.getLocalHost() , 8888);\n\n        // 3、发送数据出去\n        socket.send(packet);\n\n        socket.close();\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketException;\n\n/**\n  接收端\n */\npublic class ServerDemo2 &#123;\n    public static void main(String[] args) throws Exception &#123;\n        System.out.println(&quot;=====服务端启动======&quot;);\n        // 1、创建接收端对象：注册端口（人）\n        DatagramSocket socket = new DatagramSocket(8888);\n        // 2、创建一个数据包对象接收数据（韭菜盘子）\n        byte[] buffer = new byte[1024 * 64];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        // 3、等待接收数据。\n        socket.receive(packet);\n        // 4、取出数据即可\n        // 读取多少倒出多少\n        int len = packet.getLength();\n        String rs = new String(buffer,0, len);\n        System.out.println(&quot;收到了：&quot; + rs);\n        // 获取发送端的ip和端口\n        String ip  =packet.getSocketAddress().toString();\n        System.out.println(&quot;对方地址：&quot; + ip);\n\n        int port  = packet.getPort();\n        System.out.println(&quot;对方端口：&quot; + port);\n\n        socket.close();\n    &#125;\n&#125;\n</code></pre>\n<p>使用UDP通信实现：多发多收消息</p>\n<pre><code class=\"java\">import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.MulticastSocket;\nimport java.util.Scanner;\n\n/**\n  发送端  多发 多收\n */\npublic class ClientDemo1 &#123;\n    public static void main(String[] args) throws Exception &#123;\n        System.out.println(&quot;=====客户端启动======&quot;);\n\n        // 1、创建发送端对象：发送端自带默认的端口号（人）\n        DatagramSocket socket = new DatagramSocket(7777);\n        \n\n        Scanner sc = new Scanner(System.in);\n        while (true) &#123;\n            System.out.println(&quot;请说：&quot;);\n            String msg = sc.nextLine();\n\n            if(&quot;exit&quot;.equals(msg))&#123;\n                System.out.println(&quot;离线成功！&quot;);\n                socket.close();\n                break;\n            &#125;\n\n            // 2、创建一个数据包对象封装数据（韭菜盘子）\n            byte[] buffer = msg.getBytes();\n            DatagramPacket packet = new DatagramPacket( buffer, buffer.length,\n                    InetAddress.getLocalHost() , 8888);\n\n            // 3、发送数据出去\n            socket.send(packet);\n        &#125;\n\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\n\n/**\n  接收端\n */\npublic class ServerDemo2 &#123;\n    public static void main(String[] args) throws Exception &#123;\n        System.out.println(&quot;=====服务端启动======&quot;);\n        // 1、创建接收端对象：注册端口（人）\n        DatagramSocket socket = new DatagramSocket(8888);\n\n        // 2、创建一个数据包对象接收数据（韭菜盘子）\n        byte[] buffer = new byte[1024 * 64];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n\n        while (true) &#123;\n            // 3、等待接收数据。\n            socket.receive(packet);\n            // 4、取出数据即可\n            // 读取多少倒出多少\n            int len = packet.getLength();\n            String rs = new String(buffer,0, len);\n            System.out.println(&quot;收到了来自：&quot; + packet.getAddress() +&quot;, 对方端口是&quot; + packet.getPort() +&quot;的消息：&quot; + rs);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"2-2-UDP通信-广播、组播\"><a href=\"#2-2-UDP通信-广播、组播\" class=\"headerlink\" title=\"2.2 UDP通信 - - 广播、组播\"></a>2.2 UDP通信 - - 广播、组播</h2><p><strong>UDP的三种通信方式:</strong></p>\n<ul>\n<li>单播:单台主机与单台主机之间的通信。</li>\n<li>广播:当前主机与所在网络中的所有主机通信。</li>\n<li>组播:当前主机与选定的一组主机的通信。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/1cb03cff381d46bc867abe8f7323fa17.png#pic_center\"><br><strong>UDP如何实现广播</strong></p>\n<ul>\n<li>使用广播地址:255.255.255.255</li>\n<li>具体操作:<br> - 发送端发送的数据包的目的地写的是广播地址、且指定端口。(255.255.255.255,9999)<br> - 本机所在网段的其他主机的程序只要注册对应端口就可以收到消息了。(9999)</li>\n</ul>\n<p><strong>UDP如何实现组播</strong></p>\n<ul>\n<li>使用组播地址:224.0.0.0 ~239.255.255.255</li>\n<li>具体操作:<br>  - 发送端的数据包的目的地是组播IP（例如:224.0.1.1，端口:9999)<br>  - 接收端必须绑定该组播IP(224.0.1.1)，端口还要注册发送端的目的端口9999，这样即可接收该组播消息。<br>  - DatagramSocket的子类MulticastSocket可以在接收端绑定组播IP。</li>\n</ul>\n<pre><code class=\"java\">import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.util.Scanner;\n\n/**\n  发送端  多发 多收\n */\npublic class ClientDemo1 &#123;\n    public static void main(String[] args) throws Exception &#123;\n        System.out.println(&quot;=====客户端启动======&quot;);\n\n        // 1、创建发送端对象：发送端自带默认的端口号（人）\n        DatagramSocket socket = new DatagramSocket();\n        \n\n        Scanner sc = new Scanner(System.in);\n        while (true) &#123;\n            System.out.println(&quot;请说：&quot;);\n            String msg = sc.nextLine();\n\n            if(&quot;exit&quot;.equals(msg))&#123;\n                System.out.println(&quot;离线成功！&quot;);\n                socket.close();\n                break;\n            &#125;\n\n            // 2、创建一个数据包对象封装数据（韭菜盘子）\n            byte[] buffer = msg.getBytes();\n            // 注意：只要目的地IP是 255.255.255.255 这个消息将以广播的形式对外发送\n//            DatagramPacket packet = new DatagramPacket( buffer, buffer.length,\n//                    InetAddress.getByName(&quot;255.255.255.255&quot;) , 8888);\n\n            DatagramPacket packet = new DatagramPacket( buffer, buffer.length,\n                    InetAddress.getByName(&quot;224.0.1.1&quot;) , 9898);\n\n                    // 3、发送数据出去\n            socket.send(packet);\n        &#125;\n\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">import java.net.*;\n\n/**\n  接收端\n */\npublic class ServerDemo2 &#123;\n    public static void main(String[] args) throws Exception &#123;\n        System.out.println(&quot;=====服务端启动======&quot;);\n        // 1、创建接收端对象：注册端口（人）\n        MulticastSocket socket = new MulticastSocket(9898);\n\n        // 注意：绑定组播地址（加群）\n        socket.joinGroup(new InetSocketAddress(InetAddress.getByName(&quot;224.0.1.1&quot;) , 9898),\n                NetworkInterface.getByInetAddress(InetAddress.getLocalHost()));\n\n        // 2、创建一个数据包对象接收数据（韭菜盘子）\n        byte[] buffer = new byte[1024 * 64];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n\n\n        while (true) &#123;\n            // 3、等待接收数据。\n            socket.receive(packet);\n            // 4、取出数据即可\n            // 读取多少倒出多少\n            int len = packet.getLength();\n            String rs = new String(buffer,0, len);\n            System.out.println(&quot;收到了来自：&quot; + packet.getAddress() +&quot;, 对方端口是&quot; + packet.getPort() +&quot;的消息：&quot; + rs);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h1 id=\"3、TCP通信\"><a href=\"#3、TCP通信\" class=\"headerlink\" title=\"3、TCP通信\"></a>3、TCP通信</h1><h2 id=\"3-1-TCP通信-快速入门\"><a href=\"#3-1-TCP通信-快速入门\" class=\"headerlink\" title=\"3.1 TCP通信 - - 快速入门\"></a>3.1 TCP通信 - - 快速入门</h2><p><img src=\"https://img-blog.csdnimg.cn/f51b9f1e1e3f4625a666afbe17aa835c.png#pic_center\"></p>\n<p><strong>注意:在java中只要是使用java.net.Socket类实现通信，底层即是使用了TCP协议</strong></p>\n<p><strong>编写客户端代码</strong></p>\n<p><strong>Socket</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">构造器</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public Socket(String host , int port)</td>\n<td align=\"center\">创建发送端的Socket对象与服务端连接，参数为服务端程序的ip和端口。</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>Socket类成员方法</strong></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">方法</td>\n<td align=\"center\">说明</td>\n</tr>\n<tr>\n<td align=\"center\">:-:</td>\n<td align=\"center\">:-:</td>\n</tr>\n<tr>\n<td align=\"center\">outputStream getoutputstream()</td>\n<td align=\"center\">获得字节输出流对象</td>\n</tr>\n<tr>\n<td align=\"center\">InputStream getInputstream()</td>\n<td align=\"center\">获得字节输入流对象</td>\n</tr>\n</tbody></table>\n<p><strong>客户端发送消息</strong></p>\n<p>需求:客户端实现步骤</p>\n<ol>\n<li>创建客户端的Socket对象，请求与服务端的连接。</li>\n<li>使用socket对象调用getOutputStream()方法得到字节输出流。</li>\n<li>使用字节输出流完成数据的发送。</li>\n<li>释放资源:关闭socket管道。</li>\n</ol>\n<p><strong>编写服务端代码</strong></p>\n<p><strong>ServerSocket(服务端)</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">构造器</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public ServerSocket(int port)</td>\n<td align=\"center\">注册服务端端口。</td>\n</tr>\n</tbody></table>\n<p><strong>ServerSocket类成员方法</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public Socket accept()</td>\n<td align=\"center\">等待接收客户端的socket通信连接。连接成功返回socket对象与客户端建立端到端通信。</td>\n</tr>\n</tbody></table>\n<p><strong>服务端实现接收消息</strong></p>\n<p>需求:服务端实现步骤</p>\n<ol>\n<li>创建ServerSocket对象，注册服务端端口。</li>\n<li>调用ServerSocket对象的accept()方法，等待客户端的连接，并得到Socket管道对象。</li>\n<li>通过Socket对象调用getlnputStream()方法得到字节输入流、完成数据的接收。</li>\n<li>释放资源:关闭socket管道</li>\n</ol>\n<pre><code class=\"java\">import java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.net.Socket;\n\n/**\n   目标：完成Socket网络编程入门案例的客户端开发，实现1发1收。\n */\npublic class ClientDemo1 &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            System.out.println(&quot;====客户端启动===&quot;);\n            // 1、创建Socket通信管道请求有服务端的连接\n            // public Socket(String host, int port)\n            // 参数一：服务端的IP地址\n            // 参数二：服务端的端口\n            Socket socket = new Socket(&quot;127.0.0.1&quot;, 7777);\n\n            // 2、从socket通信管道中得到一个字节输出流 负责发送数据\n            OutputStream os = socket.getOutputStream();\n\n            // 3、把低级的字节流包装成打印流\n            PrintStream ps = new PrintStream(os);\n\n            // 4、发送消息\n            ps.println(&quot;我是TCP的客户端，我已经与你对接，并发出邀请：约吗？&quot;);\n            ps.flush();\n\n            // 关闭资源。\n            // socket.close();\n\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\n/**\n   目标：开发Socket网络编程入门代码的服务端，实现接收消息\n */\npublic class ServerDemo2 &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            System.out.println(&quot;===服务端启动成功===&quot;);\n            // 1、注册端口\n            ServerSocket serverSocket = new ServerSocket(7777);\n            // 2、必须调用accept方法：等待接收客户端的Socket连接请求，建立Socket通信管道\n            Socket socket = serverSocket.accept();\n            // 3、从socket通信管道中得到一个字节输入流\n            InputStream is = socket.getInputStream();\n            // 4、把字节输入流包装成缓冲字符输入流进行消息的接收\n            BufferedReader br = new BufferedReader(new InputStreamReader(is));\n            // 5、按照行读取消息\n            String msg;\n            if ((msg = br.readLine()) != null)&#123;\n                System.out.println(socket.getRemoteSocketAddress() + &quot;说了：: &quot; + msg);\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"3-2-TCP通信-多发多收\"><a href=\"#3-2-TCP通信-多发多收\" class=\"headerlink\" title=\"3.2 TCP通信 - - 多发多收\"></a>3.2 TCP通信 - - 多发多收</h2><p>需求:使用TCP通信方式实现:多发多收消息。</p>\n<p><strong>具体要求:</strong></p>\n<ol>\n<li>可以使用死循环控制服务端收完消息继续等待接收下一个消息。</li>\n<li>客户端也可以使用死循环等待用户不断输入消息。</li>\n<li>客户端一旦输入了exit，则关闭客户端程序，并释放资源。</li>\n</ol>\n<pre><code class=\"java\">import java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.net.Socket;\nimport java.util.Scanner;\n\n/**\n   目标：实现多发和多收\n */\npublic class ClientDemo1 &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            System.out.println(&quot;====客户端启动===&quot;);\n            // 1、创建Socket通信管道请求有服务端的连接\n            // public Socket(String host, int port)\n            // 参数一：服务端的IP地址\n            // 参数二：服务端的端口\n            Socket socket = new Socket(&quot;127.0.0.1&quot;, 7777);\n\n            // 2、从socket通信管道中得到一个字节输出流 负责发送数据\n            OutputStream os = socket.getOutputStream();\n\n            // 3、把低级的字节流包装成打印流\n            PrintStream ps = new PrintStream(os);\n\n            Scanner sc =  new Scanner(System.in);\n            while (true) &#123;\n                System.out.println(&quot;请说：&quot;);\n                String msg = sc.nextLine();\n                // 4、发送消息\n                ps.println(msg);\n                ps.flush();\n            &#125;\n\n            // 关闭资源。\n            // socket.close();\n\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">import java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\n/**\n   目标：开发Socket网络编程入门代码的服务端，实现接收消息\n */\npublic class ServerDemo2 &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            System.out.println(&quot;===服务端启动成功===&quot;);\n            // 1、注册端口\n            ServerSocket serverSocket = new ServerSocket(7777);\n            while (true) &#123;\n                // 2、必须调用accept方法：等待接收客户端的Socket连接请求，建立Socket通信管道\n                Socket socket = serverSocket.accept();\n                // 3、从socket通信管道中得到一个字节输入流\n                InputStream is = socket.getInputStream();\n                // 4、把字节输入流包装成缓冲字符输入流进行消息的接收\n                BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                // 5、按照行读取消息\n                String msg;\n                while ((msg = br.readLine()) != null)&#123;\n                    System.out.println(socket.getRemoteSocketAddress() + &quot;说了：: &quot; + msg);\n                &#125;\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>本例实现了多发多收（客户端循环反复地发送消息，服务端循环反复地接收消息），但是不能同时接受多个客户端的消息，因为服务端现在只有一个线程，只能与一个客户端进行通信。</p>\n<h2 id=\"3-3-TCP通信-多接受\"><a href=\"#3-3-TCP通信-多接受\" class=\"headerlink\" title=\"3.3 TCP通信 - - 多接受\"></a>3.3 TCP通信 - - 多接受</h2><p>引入多线程可以让服务端处理多个客户端的通信需求</p>\n<p><img src=\"https://img-blog.csdnimg.cn/fa54085c8daa4b74ae844ba2010c922f.png#pic_center\"></p>\n<pre><code class=\"java\">import java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.net.Socket;\nimport java.util.Scanner;\n\n/**\n    目标：实现服务端可以同时处理多个客户端的消息。\n */\npublic class ClientDemo1 &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            System.out.println(&quot;====客户端启动===&quot;);\n            // 1、创建Socket通信管道请求有服务端的连接\n            // public Socket(String host, int port)\n            // 参数一：服务端的IP地址\n            // 参数二：服务端的端口\n            Socket socket = new Socket(&quot;127.0.0.1&quot;, 7777);\n\n            // 2、从socket通信管道中得到一个字节输出流 负责发送数据\n            OutputStream os = socket.getOutputStream();\n\n            // 3、把低级的字节流包装成打印流\n            PrintStream ps = new PrintStream(os);\n\n            Scanner sc =  new Scanner(System.in);\n            while (true) &#123;\n                System.out.println(&quot;请说：&quot;);\n                String msg = sc.nextLine();\n                // 4、发送消息\n                ps.println(msg);\n                ps.flush();\n            &#125;\n\n            // 关闭资源。\n            // socket.close();\n\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">import java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\n/**\n   目标：实现服务端可以同时处理多个客户端的消息。\n */\npublic class ServerDemo2 &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            System.out.println(&quot;===服务端启动成功===&quot;);\n            // 1、注册端口\n            ServerSocket serverSocket = new ServerSocket(7777);\n            // a.定义一个死循环由主线程负责不断的接收客户端的Socket管道连接。\n            while (true) &#123;\n                // 2、每接收到一个客户端的Socket管道，交给一个独立的子线程负责读取消息\n                Socket socket = serverSocket.accept();\n                System.out.println(socket.getRemoteSocketAddress()+ &quot;它来了，上线了！&quot;);\n                // 3、开始创建独立线程处理socket\n                new ServerReaderThread(socket).start();\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">import java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.Socket;\n\npublic class ServerReaderThread extends Thread&#123;\n    private Socket socket;\n    public ServerReaderThread(Socket socket)&#123;\n        this.socket = socket;\n    &#125;\n    @Override\n    public void run() &#123;\n        try &#123;\n            // 3、从socket通信管道中得到一个字节输入流\n            InputStream is = socket.getInputStream();\n            // 4、把字节输入流包装成缓冲字符输入流进行消息的接收\n            BufferedReader br = new BufferedReader(new InputStreamReader(is));\n            // 5、按照行读取消息\n            String msg;\n            while ((msg = br.readLine()) != null)&#123;\n                System.out.println(socket.getRemoteSocketAddress() + &quot;说了：: &quot; + msg);\n            &#125;\n        &#125; catch (Exception e) &#123;\n            System.out.println(socket.getRemoteSocketAddress() + &quot;下线了！！！&quot;);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"3-4-TCP通信-使用线程池优化\"><a href=\"#3-4-TCP通信-使用线程池优化\" class=\"headerlink\" title=\"3.4 TCP通信 - - 使用线程池优化\"></a>3.4 TCP通信 - - 使用线程池优化</h2><p>多接受客户端与服务端的线程模型是：N-N的关系，客户端并发越多，系统瘫痪的越快。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/f54258cb4c5b42078961939eaeafbc7c.png#pic_center\"></p>\n<pre><code class=\"java\">import java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.net.Socket;\nimport java.util.Scanner;\n\n/**\n    拓展：使用线程池优化：实现通信。\n */\npublic class ClientDemo1 &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            System.out.println(&quot;====客户端启动===&quot;);\n            // 1、创建Socket通信管道请求有服务端的连接\n            // public Socket(String host, int port)\n            // 参数一：服务端的IP地址\n            // 参数二：服务端的端口\n            Socket socket = new Socket(&quot;127.0.0.1&quot;, 6666);\n\n            // 2、从socket通信管道中得到一个字节输出流 负责发送数据\n            OutputStream os = socket.getOutputStream();\n\n            // 3、把低级的字节流包装成打印流\n            PrintStream ps = new PrintStream(os);\n\n            Scanner sc =  new Scanner(System.in);\n            while (true) &#123;\n                System.out.println(&quot;请说：&quot;);\n                String msg = sc.nextLine();\n                // 4、发送消息\n                ps.println(msg);\n                ps.flush();\n            &#125;\n            // 关闭资源。\n            // socket.close();\n\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">import demo.ServerReaderThread;\n\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.*;\n\n/**\n   目标：实现服务端可以同时处理多个客户端的消息。\n */\npublic class ServerDemo2 &#123;\n\n    // 使用静态变量记住一个线程池对象\n    private static ExecutorService pool = new ThreadPoolExecutor(300,\n            1500, 6, TimeUnit.SECONDS,\n            new ArrayBlockingQueue&lt;&gt;(2)\n    , Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy());\n\n    public static void main(String[] args) &#123;\n        try &#123;\n            System.out.println(&quot;===服务端启动成功===&quot;);\n            // 1、注册端口\n            ServerSocket serverSocket = new ServerSocket(6666);\n            // a.定义一个死循环由主线程负责不断的接收客户端的Socket管道连接。\n            while (true) &#123;\n                // 2、每接收到一个客户端的Socket管道，\n                Socket socket = serverSocket.accept();\n                System.out.println(socket.getRemoteSocketAddress()+ &quot;它来了，上线了！&quot;);\n\n                // 任务对象负责读取消息。\n                Runnable target = new ServerReaderRunnable(socket);\n                pool.execute(target);\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">import java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.Socket;\n\npublic class ServerReaderRunnable implements Runnable&#123;\n    private Socket socket;\n    public ServerReaderRunnable(Socket socket)&#123;\n        this.socket = socket;\n    &#125;\n    @Override\n    public void run() &#123;\n        try &#123;\n            // 3、从socket通信管道中得到一个字节输入流\n            InputStream is = socket.getInputStream();\n            // 4、把字节输入流包装成缓冲字符输入流进行消息的接收\n            BufferedReader br = new BufferedReader(new InputStreamReader(is));\n            // 5、按照行读取消息\n            String msg;\n            while ((msg = br.readLine()) != null)&#123;\n                System.out.println(socket.getRemoteSocketAddress() + &quot;说了：: &quot; + msg);\n            &#125;\n        &#125; catch (Exception e) &#123;\n            System.out.println(socket.getRemoteSocketAddress() + &quot;下线了！！！&quot;);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>服务端可以复用线程处理多个客户端，可以避免系统瘫痪。适合客户端通信时长较短的场景。</p>\n<h2 id=\"3-5-TCP通信-即时通信\"><a href=\"#3-5-TCP通信-即时通信\" class=\"headerlink\" title=\"3.5 TCP通信 - - 即时通信\"></a>3.5 TCP通信 - - 即时通信</h2><p>即时通信，是指一个客户端的消息发出去，其他客户端可以接收到。之前我们的消息都是发给服务端的。即时通信需要进行端口转发的设计思想。服务端需要把在线的Socket管道存储起来，一旦收到一个消息要推送给其他管道。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d1bee503a98548f2926ffc26ea2625d8.png#pic_center\"></p>\n<pre><code class=\"java\">import java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.net.Socket;\nimport java.util.Scanner;\n\n/**\n    拓展：即时通信\n\n    客户端：发消息的同时，随时有人发消息过来。\n    服务端：接收消息后，推送给其他所有的在线socket\n */\npublic class ClientDemo1 &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            System.out.println(&quot;====客户端启动===&quot;);\n            // 1、创建Socket通信管道请求有服务端的连接\n            // public Socket(String host, int port)\n            // 参数一：服务端的IP地址\n            // 参数二：服务端的端口\n            Socket socket = new Socket(&quot;127.0.0.1&quot;, 6868);\n\n            // 马上为客户端分配一个独立的线程负责读取它收到的消息\n            new ClientReaderThread(socket).start();\n\n            // 2、从socket通信管道中得到一个字节输出流 负责发送数据\n            OutputStream os = socket.getOutputStream();\n\n            // 3、把低级的字节流包装成打印流\n            PrintStream ps = new PrintStream(os);\n\n            Scanner sc =  new Scanner(System.in);\n            while (true) &#123;\n                System.out.println(&quot;请说：&quot;);\n                String msg = sc.nextLine();\n                // 4、发送消息\n                ps.println(msg);\n                ps.flush();\n            &#125;\n            // 关闭资源。\n            // socket.close();\n\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">import java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.net.Socket;\n\npublic class ClientReaderThread extends Thread&#123;\n    private Socket socket;\n    public ClientReaderThread(Socket socket)&#123;\n        this.socket = socket;\n    &#125;\n    @Override\n    public void run() &#123;\n        try &#123;\n            // 3、从socket通信管道中得到一个字节输入流\n            InputStream is = socket.getInputStream();\n            // 4、把字节输入流包装成缓冲字符输入流进行消息的接收\n            BufferedReader br = new BufferedReader(new InputStreamReader(is));\n            // 5、按照行读取消息\n            String msg;\n            while ((msg = br.readLine()) != null)&#123;\n                System.out.println(socket.getRemoteSocketAddress() + &quot;收到了: &quot; + msg);\n            &#125;\n        &#125; catch (Exception e) &#123;\n            System.out.println(&quot;服务端把你踢出去了~~&quot;);\n        &#125;\n    &#125;\n\n&#125;\n</code></pre>\n<pre><code class=\"java\">import java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n   目标: 即时通信\n */\npublic class ServerDemo2 &#123;\n\n    public static List&lt;Socket&gt; onLineSockets = new ArrayList&lt;&gt;();\n\n    public static void main(String[] args) &#123;\n        try &#123;\n            System.out.println(&quot;===服务端启动成功===&quot;);\n            // 1、注册端口\n            ServerSocket serverSocket = new ServerSocket(6868);\n            // a.定义一个死循环由主线程负责不断的接收客户端的Socket管道连接。\n            while (true) &#123;\n                // 2、每接收到一个客户端的Socket管道，交给一个独立的子线程负责读取消息\n                Socket socket = serverSocket.accept();\n                System.out.println(socket.getRemoteSocketAddress()+ &quot;它来了，上线了！&quot;);\n                // 把当前客户端管道Socket加入到在线集合中去\n                onLineSockets.add(socket);\n\n                // 3、开始创建独立线程处理socket\n                new ServerReaderThread(socket).start();\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">import java.io.*;\nimport java.net.Socket;\n\npublic class ServerReaderThread extends Thread&#123;\n    private Socket socket;\n    public ServerReaderThread(Socket socket)&#123;\n        this.socket = socket;\n    &#125;\n    @Override\n    public void run() &#123;\n        try &#123;\n            // 3、从socket通信管道中得到一个字节输入流\n            InputStream is = socket.getInputStream();\n            // 4、把字节输入流包装成缓冲字符输入流进行消息的接收\n            BufferedReader br = new BufferedReader(new InputStreamReader(is));\n            // 5、按照行读取消息\n            String msg;\n            while ((msg = br.readLine()) != null)&#123;\n                System.out.println(socket.getRemoteSocketAddress() + &quot;说了：: &quot; + msg);\n                // 把这个消息发给当前所有在线socket\n                sendMsgToAll(msg);\n            &#125;\n        &#125; catch (Exception e) &#123;\n            System.out.println(socket.getRemoteSocketAddress() + &quot;下线了！！！&quot;);\n            // 从在线集合中抹掉本客户端socket\n            ServerDemo2.onLineSockets.remove(socket);\n        &#125;\n    &#125;\n\n    private void sendMsgToAll(String msg) &#123;\n        try &#123;\n            // 遍历全部的在线 socket给他们发消息\n            for (Socket onLineSocket : ServerDemo2.onLineSockets) &#123;\n                // 除了自己的socket，其他socket我都发！！\n                if(onLineSocket != socket)&#123;\n                    PrintStream ps = new PrintStream(socket.getOutputStream());\n                    ps.println(msg);\n                    ps.flush();\n                &#125;\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"3-6-TCP通信-模拟BS系统\"><a href=\"#3-6-TCP通信-模拟BS系统\" class=\"headerlink\" title=\"3.6 TCP通信 - - 模拟BS系统\"></a>3.6 TCP通信 - - 模拟BS系统</h2><p>之前的客户端都是CS结构，客户端需要我们自己开发实现。BS结构是浏览器访问服务端，不需要开发客户端。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/7663d0f0ddb944ab9de54631609a1c45.png#pic_center\"></p>\n<pre><code class=\"java\">import java.io.PrintStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.*;\n\npublic class BSserverDemo &#123;\n    // 使用静态变量记住一个线程池对象\n    private static ExecutorService pool = new ThreadPoolExecutor(3,\n            5, 6, TimeUnit.SECONDS,\n            new ArrayBlockingQueue&lt;&gt;(2)\n            , Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy());\n\n    public static void main(String[] args) &#123;\n        try &#123;\n            // 1.注册端口\n            ServerSocket ss = new ServerSocket(8080);\n            // 2.创建一个循环接收多个客户端的请求。\n            while(true)&#123;\n                Socket socket = ss.accept();\n                // 3.交给一个独立的线程来处理！\n                pool.execute(new ServerReaderRunnable(socket));\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n</code></pre>\n<pre><code class=\"java\">import java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.net.Socket;\n\npublic class ServerReaderRunnable implements Runnable&#123;\n    private Socket socket;\n    public ServerReaderRunnable(Socket socket)&#123;\n        this.socket = socket;\n    &#125;\n    @Override\n    public void run() &#123;\n        try &#123;\n            // 浏览器 已经与本线程建立了Socket管道\n            // 响应消息给浏览器显示\n            PrintStream ps = new PrintStream(socket.getOutputStream());\n            // 必须响应HTTP协议格式数据，否则浏览器不认识消息\n            ps.println(&quot;HTTP/1.1 200 OK&quot;); // 协议类型和版本 响应成功的消息！\n            ps.println(&quot;Content-Type:text/html;charset=UTF-8&quot;); // 响应的数据类型：文本/网页\n\n            ps.println(); // 必须发送一个空行\n\n            // 才可以响应数据回去给浏览器\n            ps.println(&quot;&lt;span style=&#39;color:red;font-size:90px&#39;&gt;《最牛的149期》 &lt;/span&gt;&quot;);\n            ps.close();\n        &#125; catch (Exception e) &#123;\n            System.out.println(socket.getRemoteSocketAddress() + &quot;下线了！！！&quot;);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>注意:服务器必须给浏览器响应HTTP协议格式的数据，否则浏览器不识别。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/240a9252b11244c2a623541a7dd2e70b.png#pic_center\"></p>\n<hr>\n","feature":true,"text":"网络通信是计算机网络中的重要组成部分，常用的协议有UDP和TCP。UDP协议提供了快速的数据传输，但不保证数据的可靠性和顺序；而TCP协议则提供了可靠的数据传输和数据包的排序机制。合理选择UDP或TCP协议可根据具体应用场景决定。网络通信在现代互联网中扮演着重要角色，掌握网络通信技术能够提升系统的交互和数据传输效率。...","permalink":"/post/Java程序设计 -- 网络编程（十九）","photos":[],"count_time":{"symbolsCount":"29k","symbolsTime":"26 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1%E3%80%81%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%89%E8%A6%81%E7%B4%A0\"><span class=\"toc-text\">1、网络通信三要素</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-IP%E5%9C%B0%E5%9D%80\"><span class=\"toc-text\">1.1 IP地址</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E7%AB%AF%E5%8F%A3%E5%8F%B7\"><span class=\"toc-text\">1.2 端口号</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">1.3 通信协议</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2%E3%80%81UDP%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">2、UDP通信</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-UDP%E9%80%9A%E4%BF%A1-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8\"><span class=\"toc-text\">2.1 UDP通信 - - 快速入门</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-UDP%E9%80%9A%E4%BF%A1-%E5%B9%BF%E6%92%AD%E3%80%81%E7%BB%84%E6%92%AD\"><span class=\"toc-text\">2.2 UDP通信 - - 广播、组播</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3%E3%80%81TCP%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">3、TCP通信</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-TCP%E9%80%9A%E4%BF%A1-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8\"><span class=\"toc-text\">3.1 TCP通信 - - 快速入门</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-TCP%E9%80%9A%E4%BF%A1-%E5%A4%9A%E5%8F%91%E5%A4%9A%E6%94%B6\"><span class=\"toc-text\">3.2 TCP通信 - - 多发多收</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-TCP%E9%80%9A%E4%BF%A1-%E5%A4%9A%E6%8E%A5%E5%8F%97\"><span class=\"toc-text\">3.3 TCP通信 - - 多接受</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-4-TCP%E9%80%9A%E4%BF%A1-%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">3.4 TCP通信 - - 使用线程池优化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-5-TCP%E9%80%9A%E4%BF%A1-%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">3.5 TCP通信 - - 即时通信</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-6-TCP%E9%80%9A%E4%BF%A1-%E6%A8%A1%E6%8B%9FBS%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">3.6 TCP通信 - - 模拟BS系统</span></a></li></ol></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Java程序设计--Java高级技术","uid":"bec3c05a6e5145a0f9bf9077827e54de","slug":"Java程序设计 -- Java高级技术（二十）","date":"2022-04-17T08:21:11.000Z","updated":"2025-07-14T15:12:20.459Z","comments":true,"path":"api/articles/Java程序设计 -- Java高级技术（二十）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","text":"Java单元测试是一种测试方法，用于确保程序模块的正确性。反射是Java语言提供的一组API，能够在运行时动态获取类信息和操作对象。注解是一种元数据机制，可用于标记、配置和描述程序元素。动态代理则是一种设计模式，为其他对象提供一个代理，以控制对该对象的访问。合理运用Java单元测试、反射、注解和动态代理可以提升程序的可维护性和可扩展性。...","permalink":"/post/Java程序设计 -- Java高级技术（二十）","photos":[],"count_time":{"symbolsCount":"22k","symbolsTime":"20 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true},"next_post":{"title":"Java程序设计--多线程","uid":"4efd1e259b597b69971ef5e65a102b02","slug":"Java程序设计 -- 多线程基础（十八）","date":"2022-04-12T14:02:36.000Z","updated":"2025-07-14T15:12:20.459Z","comments":true,"path":"api/articles/Java程序设计 -- 多线程基础（十八）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","text":"多线程编程允许程序同时执行多个任务，提高系统利用率。线程池则管理和复用线程，降低线程创建和销毁的开销。线程通信是多线程间交换信息和协调工作的机制。合理运用多线程和线程池可以提升程序性能，而线程通信则能确保线程之间的协调和同步。这些技术在并发编程中起着重要作用，对于提升系统的效率和响应能力至关重要。...","permalink":"/post/Java程序设计 -- 多线程基础（十八）","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true}}