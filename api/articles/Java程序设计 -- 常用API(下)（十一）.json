{"title":"Java程序设计--常用API(下)","uid":"65aeac242f4186aad4881b96128bffa6","slug":"Java程序设计 -- 常用API(下)（十一）","date":"2022-03-22T11:19:57.000Z","updated":"2025-07-14T15:12:20.460Z","comments":true,"path":"api/articles/Java程序设计 -- 常用API(下)（十一）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","content":"<hr>\n<h1 id=\"1、日期与时间\"><a href=\"#1、日期与时间\" class=\"headerlink\" title=\"1、日期与时间\"></a>1、日期与时间</h1><h2 id=\"1-1-Date\"><a href=\"#1-1-Date\" class=\"headerlink\" title=\"1.1 Date\"></a>1.1 Date</h2><p><strong>Date 类代表当前所在系统的日期时间信息。</strong></p>\n<p><strong>Date 的构造器</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public Date()</td>\n<td align=\"center\">创建一个 Date 对象，代表的是系统当前此刻日期时间。</td>\n</tr>\n</tbody></table>\n<p><strong>Date 的常用方法</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public long getTime()</td>\n<td align=\"center\">返回从 1970 年 1 月 1 日 00:00:00 走到此刻的总的毫秒数</td>\n</tr>\n</tbody></table>\n<p><strong>时间毫秒值-&gt;日期对象</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">构造器</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public Date(long time)</td>\n<td align=\"center\">把时间毫秒值转换成 Date 日期对象。</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Date</th>\n<th align=\"center\">方法说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public void setTime(long time)</td>\n<td align=\"center\">设置日期对象的时间为当前时间毫秒值对应的时间</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">import java.time.Instant;\nimport java.time.ZoneId;\nimport java.util.Date;\n\n/**\n    目标：学会使用Date类处理时间，获取时间的信息\n */\npublic class DateDemo &#123;\n    public static void main(String[] args) &#123;\n        // 1、创建一个Date类的对象：代表系统此刻日期时间对象\n        Date d = new Date();\n        System.out.println(d);\n\n        // 2、获取时间毫秒值\n        long time = d.getTime();\n        System.out.println(time);\n//        long time1 = System.currentTimeMillis();\n//        System.out.println(time1);\n\n        System.out.println(&quot;----------------------------&quot;);\n        // 1、得到当前时间\n        Date d1 = new Date();\n        System.out.println(d1);\n\n        // 2、当前时间往后走 1小时  121s\n        long time2 = System.currentTimeMillis();\n        time2 += (60 * 60 + 121) * 1000;\n\n        // 3、把时间毫秒值转换成对应的日期对象。\n        // Date d2 = new Date(time2);\n        // System.out.println(d2);\n\n        Date d3 = new Date();\n        d3.setTime(time2);\n        System.out.println(d3);\n\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"1-2-SimpleDateFormat\"><a href=\"#1-2-SimpleDateFormat\" class=\"headerlink\" title=\"1.2 SimpleDateFormat\"></a>1.2 SimpleDateFormat</h2><p><strong>可以去完成日期时间的格式化操作格式化</strong></p>\n<p><strong>构造器</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">构造器</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public SimpleDateFormat(String pattern)</td>\n<td align=\"center\">构造一个 SimpleDateFormat，使用指定的格式</td>\n</tr>\n</tbody></table>\n<p><strong>格式化方法</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">格式化方法</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public final String format(Date date)</td>\n<td align=\"center\">将日期格式化成日期&#x2F;时间字符串</td>\n</tr>\n<tr>\n<td align=\"center\">public final String format(Object time)</td>\n<td align=\"center\">将时间毫秒值式化成日期&#x2F;时间字符串</td>\n</tr>\n</tbody></table>\n<p>格式化的时间形式的常用的模式对应关系：<br><img src=\"https://img-blog.csdnimg.cn/4bbe8517feda45f8af9307508fef616f.png#pic_center\"></p>\n<pre><code class=\"java\">import javax.xml.crypto.Data;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class SimpleDateFormatDemo&#123;\n    public static void main(String[] args) throws ParseException &#123;\n        // 目标: 学会使用SimpleDateFormat解析字符串时间成为日期对象。\n        // 有一个时间 2021年08月06日 11:11:11 往后 2天 14小时 49分 06秒后的时间是多少。\n        // 1、把字符串时间拿到程序中来\n        String dateStr = &quot;2021年08月06日 11:11:11&quot;;\n\n        // 2、把字符串时间解析成日期对象（本节的重点）:形式必须与被解析时间的形式完全一样，否则运行时解析报错！\n        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);\n        Date d = sdf.parse(dateStr);\n\n        // 3、往后走2天 14小时 49分 06秒\n        long time = d.getTime() + (2L*24*60*60 + 14*60*60 + 49*60 + 6) * 1000;\n\n        // 4、格式化这个时间毫秒值就是结果\n        System.out.println(sdf.format(time));\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"1-3-Calendar\"><a href=\"#1-3-Calendar\" class=\"headerlink\" title=\"1.3 Calendar\"></a>1.3 Calendar</h2><p>Calendar 代表了系统此刻日期对应的日历对象。</p>\n<p>Calendar 是一个抽象类，&#x3D;&#x3D;不能直接创建对象。&#x3D;&#x3D;</p>\n<p><strong>Calendar 日历类创建日历对象的方法</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public static calendar getInstance()</td>\n<td align=\"center\">获取当前日历对象</td>\n</tr>\n</tbody></table>\n<p><strong>Calendar 常用方法</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public int get(int field)</td>\n<td align=\"center\">取日期中的某个字段信息。</td>\n</tr>\n<tr>\n<td align=\"center\">public void set(int field,int value)</td>\n<td align=\"center\">修改日历的某个字段信息。</td>\n</tr>\n<tr>\n<td align=\"center\">public void add(int field,int amount)</td>\n<td align=\"center\">为某个字段增加&#x2F;减少指定的值</td>\n</tr>\n<tr>\n<td align=\"center\">public final Date getTime()</td>\n<td align=\"center\">拿到此刻日期对象。</td>\n</tr>\n<tr>\n<td align=\"center\">public long getTimeInMillis()</td>\n<td align=\"center\">拿到此刻时间毫秒值</td>\n</tr>\n</tbody></table>\n<p>注意:calendar 是可变日期对象，一旦修改后其对象本身表示的时间将产生变化。</p>\n<pre><code class=\"java\">import javax.xml.crypto.Data;\nimport java.util.Calendar;\nimport java.util.Date;\n\n/**\n    目标：日历类Calendar的使用,可以得到更加丰富的信息。\n */\npublic class CalendarDemo&#123;\n    public static void main(String[] args) &#123;\n        // 1、拿到系统此刻日历对象\n        Calendar cal = Calendar.getInstance();\n        System.out.println(cal);\n\n        // 2、获取日历的信息:public int get(int field)：取日期中的某个字段信息。\n        int year = cal.get(Calendar.YEAR);\n        System.out.println(year);\n\n        int mm = cal.get(Calendar.MONTH) + 1;\n        System.out.println(mm);\n\n        int days = cal.get(Calendar.DAY_OF_YEAR) ;\n        System.out.println(days);\n\n        // 3、public void set(int field,int value)：修改日历的某个字段信息。\n        // cal.set(Calendar.HOUR , 12);\n        // System.out.println(cal);\n\n        // 4.public void add(int field,int amount)：为某个字段增加/减少指定的值\n        // 请问64天后是什么时间\n        cal.add(Calendar.DAY_OF_YEAR , 64);\n        cal.add(Calendar.MINUTE , 59);\n\n        //  5.public final Date getTime(): 拿到此刻日期对象。\n        Date d = cal.getTime();\n        System.out.println(d);\n\n        //  6.public long getTimeInMillis(): 拿到此刻时间毫秒值\n        long time = cal.getTimeInMillis();\n        System.out.println(time);\n\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"1-4-LocalDate、LocalTime、LocalDateTime\"><a href=\"#1-4-LocalDate、LocalTime、LocalDateTime\" class=\"headerlink\" title=\"1.4 LocalDate、LocalTime、LocalDateTime\"></a>1.4 LocalDate、LocalTime、LocalDateTime</h2><p>从 Java 8 开始，java.time 包提供了新的日期和时间 API</p>\n<p>LocalDate、LocalTime、LocalDateTim 他们分别表示日期，时间，日期时间对象，他们的类的实例是不可变的对象。他们三者构建对象和 API 都是通用的。</p>\n<p><strong>构建对象的方式如下</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">说明</th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public static Xxxx now();</td>\n<td align=\"center\">静态方法，根据当前时间创建对象</td>\n<td align=\"center\">LocaDate localDate &#x3D; LocalDate.now();LocalTime localTime &#x3D; LocalTime.now();LocalDateTime localDateTime &#x3D; LocalDateTime.now();</td>\n</tr>\n<tr>\n<td align=\"center\">public static Xxox of(…);</td>\n<td align=\"center\">静态方法，指定日期&#x2F;时间创建对象</td>\n<td align=\"center\">LocalDate localDate1 &#x3D;LocalDate.of(2099,11,11);LocalTime localTime1 &#x3D; LocalTime.of(11,11,11);LocalDateTime localDateTime1 &#x3D; LocalDateTime.of(2020,10,6,13,23,43);</td>\n</tr>\n</tbody></table>\n<p><strong>LocalDate、LocalTime、LocalDateTime 获取信息的 API</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public int geYear()</td>\n<td align=\"center\">获取年</td>\n</tr>\n<tr>\n<td align=\"center\">public int getMonthValue()</td>\n<td align=\"center\">获取月份(1-12)</td>\n</tr>\n<tr>\n<td align=\"center\">Public int getDayOfMonth()</td>\n<td align=\"center\">获取月中第几天乘法</td>\n</tr>\n<tr>\n<td align=\"center\">Public int getDayOfYear()</td>\n<td align=\"center\">获取年中第几天</td>\n</tr>\n<tr>\n<td align=\"center\">Public DayOfWeek getDayOfWeek()</td>\n<td align=\"center\">获取星期</td>\n</tr>\n</tbody></table>\n<p><img src=\"https://img-blog.csdnimg.cn/2a01072e63724c9698f9cbe2f69a5477.png#pic_center\"><br><strong>LocalDateTime 的转换 API</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public LocalDate toLocalDate()</td>\n<td align=\"center\">转换成一个 LocalDate 对象</td>\n</tr>\n<tr>\n<td align=\"center\">public LocalTime toLocalTime()</td>\n<td align=\"center\">转换成一个 LocalTime 对象</td>\n</tr>\n</tbody></table>\n<p><strong>修改相关的 API</strong></p>\n<p>这些方法返回的是一个新的实例引用，因为 LocalDateTime 、LocaIDate 、LocalTime 都是不可变的</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">plusDays, plusWeeks, plusMonths, plusYears</td>\n<td align=\"center\">向当前 LocalDate 对象添加几天、几周、几个月、几年</td>\n</tr>\n<tr>\n<td align=\"center\">minusDays, minusWeeks, minusMonths, minusYears</td>\n<td align=\"center\">从当前 LocalDate 对象减去几天、几周、几个月、几年</td>\n</tr>\n<tr>\n<td align=\"center\">withDayOfMonth, withDayOfYear, withMonth, withYear</td>\n<td align=\"center\">将月份天数、年份天数、月份、年份修改为指定的值并返回新的 LocalDate 对象</td>\n</tr>\n<tr>\n<td align=\"center\">isBefore, isAfter</td>\n<td align=\"center\">比较两个 LocalDate</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">import java.time.LocalDate;\nimport java.time.Month;\n\npublic class Demo01LocalDate &#123;\n    public static void main(String[] args) &#123;\n        // 1、获取本地日期对象。\n        LocalDate nowDate = LocalDate.now();\n        System.out.println(&quot;今天的日期：&quot; + nowDate);//今天的日期：\n\n        int year = nowDate.getYear();\n        System.out.println(&quot;year：&quot; + year);\n\n\n        int month = nowDate.getMonthValue();\n        System.out.println(&quot;month：&quot; + month);\n\n        int day = nowDate.getDayOfMonth();\n        System.out.println(&quot;day：&quot; + day);\n\n        //当年的第几天\n        int dayOfYear = nowDate.getDayOfYear();\n        System.out.println(&quot;dayOfYear：&quot; + dayOfYear);\n\n        //星期\n        System.out.println(nowDate.getDayOfWeek());\n        System.out.println(nowDate.getDayOfWeek().getValue());\n\n        //月份\n        System.out.println(nowDate.getMonth());//AUGUST\n        System.out.println(nowDate.getMonth().getValue());//8\n\n        System.out.println(&quot;------------------------&quot;);\n        LocalDate bt = LocalDate.of(1991, 11, 11);\n        System.out.println(bt);//直接传入对应的年月日\n        System.out.println(LocalDate.of(1991, Month.NOVEMBER, 11));//相对上面只是把月换成了枚举\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">import java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.time.Month;\n\npublic class Demo02LocalTime &#123;\n    public static void main(String[] args) &#123;\n        // 1、获取本地时间对象。\n        LocalTime nowTime = LocalTime.now();\n        System.out.println(&quot;今天的时间：&quot; + nowTime);//今天的时间：\n\n        int hour = nowTime.getHour();//时\n        System.out.println(&quot;hour：&quot; + hour);//hour：\n\n        int minute = nowTime.getMinute();//分\n        System.out.println(&quot;minute：&quot; + minute);//minute：\n\n        int second = nowTime.getSecond();//秒\n        System.out.println(&quot;second：&quot; + second);//second：\n\n        int nano = nowTime.getNano();//纳秒\n        System.out.println(&quot;nano：&quot; + nano);//nano：\n\n        System.out.println(&quot;-----&quot;);\n        System.out.println(LocalTime.of(8, 20));//时分\n        System.out.println(LocalTime.of(8, 20, 30));//时分秒\n        System.out.println(LocalTime.of(8, 20, 30, 150));//时分秒纳秒\n        LocalTime mTime = LocalTime.of(8, 20, 30, 150);\n\n        System.out.println(&quot;---------------&quot;);\n        System.out.println(LocalDateTime.of(1991, 11, 11, 8, 20));\n        System.out.println(LocalDateTime.of(1991, Month.NOVEMBER, 11, 8, 20));\n        System.out.println(LocalDateTime.of(1991, 11, 11, 8, 20, 30));\n        System.out.println(LocalDateTime.of(1991, Month.NOVEMBER, 11, 8, 20, 30));\n        System.out.println(LocalDateTime.of(1991, 11, 11, 8, 20, 30, 150));\n        System.out.println(LocalDateTime.of(1991, Month.NOVEMBER, 11, 8, 20, 30, 150));\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">import java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\n\npublic class Demo03LocalDateTime &#123;\n    public static void main(String[] args) &#123;\n        // 日期 时间\n        LocalDateTime nowDateTime = LocalDateTime.now();\n        System.out.println(&quot;今天是：&quot; + nowDateTime);//今天是：\n        System.out.println(nowDateTime.getYear());//年\n        System.out.println(nowDateTime.getMonthValue());//月\n        System.out.println(nowDateTime.getDayOfMonth());//日\n        System.out.println(nowDateTime.getHour());//时\n        System.out.println(nowDateTime.getMinute());//分\n        System.out.println(nowDateTime.getSecond());//秒\n        System.out.println(nowDateTime.getNano());//纳秒\n        //日：当年的第几天\n        System.out.println(&quot;dayOfYear：&quot; + nowDateTime.getDayOfYear());//dayOfYear：249\n        //星期\n        System.out.println(nowDateTime.getDayOfWeek());//THURSDAY\n        System.out.println(nowDateTime.getDayOfWeek().getValue());//4\n        //月份\n        System.out.println(nowDateTime.getMonth());//SEPTEMBER\n        System.out.println(nowDateTime.getMonth().getValue());//9\n\n\n        LocalDate ld = nowDateTime.toLocalDate();\n        System.out.println(ld);\n\n        LocalTime lt = nowDateTime.toLocalTime();\n        System.out.println(lt.getHour());\n        System.out.println(lt.getMinute());\n        System.out.println(lt.getSecond());\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"1-5-Instant\"><a href=\"#1-5-Instant\" class=\"headerlink\" title=\"1.5 Instant\"></a>1.5 Instant</h2><p>JDK8 获取时间戳特别简单，且功能更丰富。Instant 类由一个静态的工厂方法 now()可以返回当前时间戳。</p>\n<pre><code class=\"java\">import java.time.Instant;\nimport java.time.LocalDate;\nimport java.time.ZoneId;\nimport java.util.Date;\n\npublic class InstantDemo &#123;\n    public static void main(String[] args) &#123;\n        // 1、得到一个Instant时间戳对象\n        Instant instant = Instant.now();\n        System.out.println(instant);\n\n        // 2、系统此刻的时间戳怎么办？\n        Instant instant1 = Instant.now();\n        System.out.println(instant1.atZone(ZoneId.systemDefault()));\n\n        // 3、如何去返回Date对象\n        Date date = Date.from(instant);\n        System.out.println(date);\n\n        Instant i2 = date.toInstant();\n        System.out.println(i2);\n    &#125;\n&#125;\n</code></pre>\n<p>时间戳是包含日期和时间的，与 java.util.Date 很类似，事实上 Instant 就是类似 JDK8 以前的 Date.lnstant 和 Date 这两个类可以进行转换。</p>\n<h2 id=\"1-6-DateTimeFormatter\"><a href=\"#1-6-DateTimeFormatter\" class=\"headerlink\" title=\"1.6 DateTimeFormatter\"></a>1.6 DateTimeFormatter</h2><p>在 JDK8 中，引入了一个全新的日期与时间格式器 DateTimeFormatter。<br>正反都能调用 format 方法。</p>\n<pre><code class=\"java\">import java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\n\npublic class DateTimeFormatDemo &#123;\n    public static void main(String[] args) &#123;\n        // 本地此刻  日期时间 对象\n        LocalDateTime ldt = LocalDateTime.now();\n        System.out.println(ldt);\n\n        // 解析/格式化器\n        DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss EEE a&quot;);\n        // 正向格式化\n        System.out.println(dtf.format(ldt));\n        // 逆向格式化\n        System.out.println(ldt.format(dtf));\n\n        // 解析字符串时间\n        DateTimeFormatter dtf1 = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);\n        // 解析当前字符串时间成为本地日期时间对象\n        LocalDateTime ldt1 = LocalDateTime.parse(&quot;2019-11-11 11:11:11&quot; ,  dtf1);\n        System.out.println(ldt1);\n        System.out.println(ldt1.getDayOfYear());\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"1-7-Period-Duration\"><a href=\"#1-7-Period-Duration\" class=\"headerlink\" title=\"1.7 Period&#x2F;Duration\"></a>1.7 Period&#x2F;Duration</h2><p><strong>Period</strong></p>\n<p>在 Java8 中，我们可以使用以下类来计算曰期间隔差异: java.time.Period</p>\n<p>主要是 Period 类方法 getYears()， getMonths()和 getDays()来计算,只能精确到年月日。用于计算两个“时间”间隔。用于 LocalDate 之间的比较。</p>\n<pre><code class=\"java\">import java.time.LocalDate;\nimport java.time.Period;\n\npublic class PeriodDemo &#123;\n    public static void main(String[] args) &#123;\n        // 当前本地 年月日\n        LocalDate today = LocalDate.now();\n        System.out.println(today);//\n\n        // 生日的 年月日\n        LocalDate birthDate = LocalDate.of(1998, 10, 13);\n        System.out.println(birthDate);\n\n        Period period = Period.between(birthDate, today);//第二个参数减第一个参数\n\n        System.out.println(period.getYears());\n        System.out.println(period.getMonths());\n        System.out.println(period.getDays());\n    &#125;\n&#125;\n</code></pre>\n<p><strong>Duration</strong></p>\n<p>在 Java8 中，我们可以使用以下类来计算时间间隔差异: java.time.Duration 提供了使用基于时间的值测量时间量的方法。用于计算两个“日期”间隔。</p>\n<p>用于 LocalDateTime 之间的比较。也可用于 Instant 之间的比较。</p>\n<pre><code class=\"java\">import java.time.Duration;\nimport java.time.LocalDateTime;\n\npublic class DurationDemo &#123;\n    public static void main(String[] args) &#123;\n        // 本地日期时间对象。\n        LocalDateTime today = LocalDateTime.now();\n        System.out.println(today);\n\n        // 出生的日期时间对象\n        LocalDateTime birthDate = LocalDateTime.of(2021,8\n                ,06,01,00,00);\n\n        System.out.println(birthDate);\n\n        Duration duration = Duration.between(  today , birthDate);//第二个参数减第一个参数\n\n        System.out.println(duration.toDays());//两个时间差的天数\n        System.out.println(duration.toHours());//两个时间差的小时数\n        System.out.println(duration.toMinutes());//两个时间差的分钟数\n        System.out.println(duration.toMillis());//两个时间差的毫秒数\n        System.out.println(duration.toNanos());//两个时间差的纳秒数\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"1-8-ChronoUnit\"><a href=\"#1-8-ChronoUnit\" class=\"headerlink\" title=\"1.8 ChronoUnit\"></a>1.8 ChronoUnit</h2><p>java.time.temporal.ChronoUnit</p>\n<p>ChronoUnit 类可用于在单个时间单位内测量一段时间，这个工具类是最全的了，可以用于比较所有的时间单位</p>\n<pre><code class=\"java\">import java.time.LocalDateTime;\nimport java.time.temporal.ChronoUnit;\n\npublic class ChronoUnitDemo &#123;\n    public static void main(String[] args) &#123;\n        // 本地日期时间对象：此刻的\n        LocalDateTime today = LocalDateTime.now();\n        System.out.println(today);\n\n        // 生日时间\n        LocalDateTime birthDate = LocalDateTime.of(1990,10,1,\n                10,50,59);\n        System.out.println(birthDate);\n\n        System.out.println(&quot;相差的年数：&quot; + ChronoUnit.YEARS.between(birthDate, today));\n        System.out.println(&quot;相差的月数：&quot; + ChronoUnit.MONTHS.between(birthDate, today));\n        System.out.println(&quot;相差的周数：&quot; + ChronoUnit.WEEKS.between(birthDate, today));\n        System.out.println(&quot;相差的天数：&quot; + ChronoUnit.DAYS.between(birthDate, today));\n        System.out.println(&quot;相差的时数：&quot; + ChronoUnit.HOURS.between(birthDate, today));\n        System.out.println(&quot;相差的分数：&quot; + ChronoUnit.MINUTES.between(birthDate, today));\n        System.out.println(&quot;相差的秒数：&quot; + ChronoUnit.SECONDS.between(birthDate, today));\n        System.out.println(&quot;相差的毫秒数：&quot; + ChronoUnit.MILLIS.between(birthDate, today));\n        System.out.println(&quot;相差的微秒数：&quot; + ChronoUnit.MICROS.between(birthDate, today));\n        System.out.println(&quot;相差的纳秒数：&quot; + ChronoUnit.NANOS.between(birthDate, today));\n        System.out.println(&quot;相差的半天数：&quot; + ChronoUnit.HALF_DAYS.between(birthDate, today));\n        System.out.println(&quot;相差的十年数：&quot; + ChronoUnit.DECADES.between(birthDate, today));\n        System.out.println(&quot;相差的世纪（百年）数：&quot; + ChronoUnit.CENTURIES.between(birthDate, today));\n        System.out.println(&quot;相差的千年数：&quot; + ChronoUnit.MILLENNIA.between(birthDate, today));\n        System.out.println(&quot;相差的纪元数：&quot; + ChronoUnit.ERAS.between(birthDate, today));\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h1 id=\"2、包装类\"><a href=\"#2、包装类\" class=\"headerlink\" title=\"2、包装类\"></a>2、包装类</h1><p>包装类就是 8 种基本数据类型对应的引用类型。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">基本数据类型</th>\n<th align=\"center\">引用数据类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">byte</td>\n<td align=\"center\">Byte</td>\n</tr>\n<tr>\n<td align=\"center\">short</td>\n<td align=\"center\">Short</td>\n</tr>\n<tr>\n<td align=\"center\">int</td>\n<td align=\"center\">Integer</td>\n</tr>\n<tr>\n<td align=\"center\">long</td>\n<td align=\"center\">Long</td>\n</tr>\n<tr>\n<td align=\"center\">char</td>\n<td align=\"center\">Character</td>\n</tr>\n<tr>\n<td align=\"center\">float</td>\n<td align=\"center\">Float</td>\n</tr>\n<tr>\n<td align=\"center\">double</td>\n<td align=\"center\">Double</td>\n</tr>\n<tr>\n<td align=\"center\">boolean</td>\n<td align=\"center\">Boolean</td>\n</tr>\n</tbody></table>\n<p>Java 为了实现一切皆对象，为 8 种基本类型提供了对应的引用类型。集合和泛型其实也只能支持包装类型，不支持基本数据类型。</p>\n<p>自动装箱:基本类型的数据和变量可以直接赋值给包装类型的变量。</p>\n<p>自动拆箱:包装类型的变量可以直接赋值给基本数据类型的变量。</p>\n<p><strong>包装类的特有功能</strong></p>\n<p>包装类的变量的默认值可以是 null，容错率更高。</p>\n<p>&#x3D;&#x3D;可以把基本类型的数据转换成字符串类型&#x3D;&#x3D;</p>\n<pre><code class=\"Markdown\">调用toString()方法得到字符串结果。\n调用lnteger.toString(基本类型的数据)。\n</code></pre>\n<p>&#x3D;&#x3D;可以把字符串类型的数值转换成真实的数据类型&#x3D;&#x3D;</p>\n<pre><code class=\"Markdown\">Integer.parselnt(“字符串类型的整数”)\nDouble.parseDouble(“字符串类型的小数”)。\n</code></pre>\n<pre><code class=\"java\">/**\n    明白包装类的概念，并使用。\n */\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        int a = 10;\n        Integer a1 = 11;\n        Integer a2 = a; // 自动装箱\n        System.out.println(a);\n        System.out.println(a1);\n\n        Integer it = 100;\n        int it1 = it; // 自动拆箱\n        System.out.println(it1);\n\n        double db = 99.5;\n        Double db2 = db; // 自动装箱了\n        double db3 = db2; // 自动拆箱\n        System.out.println(db3);\n\n        // int age = null; // 报错了！\n        Integer age1 = null;\n        Integer age2 = 0;\n\n        System.out.println(&quot;-----------------&quot;);\n        // 1、包装类可以把基本类型的数据转换成字符串形式。\n        Integer i3 = 23;\n        String rs = i3.toString();\n        System.out.println(rs + 1);\n\n        String rs1 = Integer.toString(i3);\n        System.out.println(rs1 + 1);\n\n        // 可以直接+字符串得到字符串类型\n        String rs2 = i3 + &quot;&quot;;\n        System.out.println(rs2 + 1);\n\n        System.out.println(&quot;-----------------&quot;);\n\n        String number = &quot;23&quot;;\n        //转换成整数\n        // int age = Integer.parseInt(number);\n        int age = Integer.valueOf(number);\n        System.out.println(age + 1);\n\n        String number1 = &quot;99.9&quot;;\n        //转换成小数\n//        double score = Double.parseDouble(number1);\n        double score = Double.valueOf(number1);\n        System.out.println(score + 0.1);\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h1 id=\"3、正则表达式\"><a href=\"#3、正则表达式\" class=\"headerlink\" title=\"3、正则表达式\"></a>3、正则表达式</h1><h2 id=\"3-1-正则表达式概述、初体验\"><a href=\"#3-1-正则表达式概述、初体验\" class=\"headerlink\" title=\"3.1 正则表达式概述、初体验\"></a>3.1 正则表达式概述、初体验</h2><p>正则表示：正则表达式可以用一些规定的字符来制定规则，并用来校验数据格式的合法性。</p>\n<p>正则表达式初体验</p>\n<p>需求:假如现在要求校验一个 qq 号码是否正确，6 位及 20 位之内，必须全部是数字。<br>先使用目前所学知识完成校验需求;然后体验—下正则表达式检验。</p>\n<pre><code class=\"java\">public class RegexDemo1 &#123;\n    public static void main(String[] args) &#123;\n        // 需求：校验qq号码，必须全部数字 6 - 20位\n        System.out.println(checkQQ(&quot;251425998&quot;));\n        System.out.println(checkQQ(&quot;2514259a98&quot;));\n        System.out.println(checkQQ(null));\n        System.out.println(checkQQ(&quot;2344&quot;));\n\n        System.out.println(&quot;-------------------------&quot;);\n        // 正则表达式的初体验：\n        System.out.println(checkQQ2(&quot;251425998&quot;));\n        System.out.println(checkQQ2(&quot;2514259a98&quot;));\n        System.out.println(checkQQ2(null));\n        System.out.println(checkQQ2(&quot;2344&quot;));\n\n    &#125;\n\n    public static boolean checkQQ2(String qq)&#123;\n        return qq != null &amp;&amp; qq.matches(&quot;\\\\d&#123;6,20&#125;&quot;);\n    &#125;\n\n\n    public static boolean checkQQ(String qq)&#123;\n        // 1、判断qq号码的长度是否满足要求\n        if(qq == null || qq.length() &lt; 6 || qq.length() &gt; 20 ) &#123;\n            return false;\n        &#125;\n\n        // 2、判断qq中是否全部是数字，不是返回false\n        //  251425a87\n        for (int i = 0; i &lt; qq.length(); i++) &#123;\n            // 获取每位字符\n            char ch = qq.charAt(i);\n            // 判断这个字符是否不是数字，不是数字直接返回false\n            if(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n                return false;\n            &#125;\n        &#125;\n\n        return true; // 肯定合法了！\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"3-2-正则表达式的匹配规则\"><a href=\"#3-2-正则表达式的匹配规则\" class=\"headerlink\" title=\"3.2 正则表达式的匹配规则\"></a>3.2 正则表达式的匹配规则</h2><p>字符串对象提供了匹配正则表达式的方法</p>\n<p><img src=\"https://img-blog.csdnimg.cn/dd17748741be440b95a38e8a9599f465.png#pic_center\"></p>\n<p>字符类(默认匹配一个字符)</p>\n<p><img src=\"https://img-blog.csdnimg.cn/7e4ac38882ac4a4b88c28c9d80f85685.png#pic_center\"></p>\n<p>预定义的字符类(默认匹配一个字符)</p>\n<p><img src=\"https://img-blog.csdnimg.cn/f2b066fef57245a89c27e202c563f415.png#pic_center\"></p>\n<p>贪婪的量词(配合匹配多个字符)<br><img src=\"https://img-blog.csdnimg.cn/67d8bb5994ae40d5a40f8ea289d08432.png#pic_center\"></p>\n<p>需求</p>\n<ol>\n<li>请编写程序模拟用户输入手机号码、验证格式正确，并给出提示，直到格式输入正确为止。</li>\n<li>请编写程序模拟用户输入邮箱号码、验证格式正确，并给出提示，直到格式输入正确为止。</li>\n<li>请编写程序模拟用户输入电话号码、验证格式正确，并给出提示，直到格式输入正确为止。</li>\n</ol>\n<pre><code class=\"java\">import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class RegexTest3 &#123;\n    public static void main(String[] args) &#123;\n        // 目标：校验 手机号码 邮箱  电话号码\n         checkPhone();\n         checkEmail();\n         checkTel();\n    &#125;\n\n    public static void checkTel()&#123;\n        Scanner sc = new Scanner(System.in);\n        while (true) &#123;\n            System.out.println(&quot;请您输入您的电话号码：&quot;);\n            String tel = sc.next();\n            // 判断邮箱格式是否正确   027-3572457  0273572457\n            if(tel.matches(&quot;0\\\\d&#123;2,6&#125;-?\\\\d&#123;5,20&#125;&quot;))&#123;\n                System.out.println(&quot;格式正确，注册完成！&quot;);\n                break;\n            &#125;else &#123;\n                System.out.println(&quot;格式有误！&quot;);\n            &#125;\n        &#125;\n    &#125;\n\n    public static void checkEmail()&#123;\n        Scanner sc = new Scanner(System.in);\n        while (true) &#123;\n            System.out.println(&quot;请您输入您的注册邮箱：&quot;);\n            String email = sc.next();\n            // 判断邮箱格式是否正确   3268847878@qq.com\n            // 判断邮箱格式是否正确   3268847dsda878@163.com\n            // 判断邮箱格式是否正确   3268847dsda878@pci.com.cn\n            if(email.matches(&quot;\\\\w&#123;1,30&#125;@[a-zA-Z0-9]&#123;2,20&#125;(\\\\.[a-zA-Z0-9]&#123;2,20&#125;)&#123;1,2&#125;&quot;))&#123;\n                System.out.println(&quot;邮箱格式正确，注册完成！&quot;);\n                break;\n            &#125;else &#123;\n                System.out.println(&quot;格式有误！&quot;);\n            &#125;\n        &#125;\n    &#125;\n\n    public static void checkPhone()&#123;\n        Scanner sc = new Scanner(System.in);\n        while (true) &#123;\n            System.out.println(&quot;请您输入您的注册手机号码：&quot;);\n            String phone = sc.next();\n            // 判断手机号码的格式是否正确\n            if(phone.matches(&quot;1[3-9]\\\\d&#123;9&#125;&quot;))&#123;\n                System.out.println(&quot;手机号码格式正确，注册完成！&quot;);\n                break;\n            &#125;else &#123;\n                System.out.println(&quot;格式有误！&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"3-3-正则表达式的应用\"><a href=\"#3-3-正则表达式的应用\" class=\"headerlink\" title=\"3.3 正则表达式的应用\"></a>3.3 正则表达式的应用</h2><table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public String replaceAll(String regex,String newStr)</td>\n<td align=\"center\">按照正则表达式匹配的内容进行替换</td>\n</tr>\n<tr>\n<td align=\"center\">public String] split(String regex):</td>\n<td align=\"center\">按照正则表达式匹配的内容进行分割字符串，反回一个字符串数组。</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">public class RegexDemo04 &#123;\n    public static void main(String[] args) &#123;\n        String names = &quot;小路dhdfhdf342蓉儿43fdffdfbjdfaf小何&quot;;\n\n        String[] arrs = names.split(&quot;\\\\w+&quot;);\n        for (int i = 0; i &lt; arrs.length; i++) &#123;\n            System.out.println(arrs[i]);\n        &#125;\n\n        String names2 = names.replaceAll(&quot;\\\\w+&quot;, &quot;  &quot;);\n        System.out.println(names2);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"3-4-正则表达式爬取信息\"><a href=\"#3-4-正则表达式爬取信息\" class=\"headerlink\" title=\"3.4 正则表达式爬取信息\"></a>3.4 正则表达式爬取信息</h2><pre><code class=\"java\">/**\n    拓展：正则表达式爬取信息中的内容。(了解)\n */\npublic class RegexDemo05 &#123;\n    public static void main(String[] args) &#123;\n        String rs = &quot;学习Java,电话020-43422424，或者联系邮箱&quot; +\n                &quot;itcast@itcast.cn,电话18762832633，0203232323&quot; +\n                &quot;邮箱bozai@itcast.cn，400-100-3233 ，4001003232&quot;;\n\n        // 需求：从上面的内容中爬取出 电话号码和邮箱。\n        // 1、定义爬取规则，字符串形式\n        String regex = &quot;(\\\\w&#123;1,30&#125;@[a-zA-Z0-9]&#123;2,20&#125;(\\\\.[a-zA-Z0-9]&#123;2,20&#125;)&#123;1,2&#125;)|(1[3-9]\\\\d&#123;9&#125;)&quot; +\n                &quot;|(0\\\\d&#123;2,6&#125;-?\\\\d&#123;5,20&#125;)|(400-?\\\\d&#123;3,9&#125;-?\\\\d&#123;3,9&#125;)&quot;;\n\n        // 2、把这个爬取规则编译成匹配对象。\n        Pattern pattern = Pattern.compile(regex);\n\n        // 3、得到一个内容匹配器对象\n        Matcher matcher = pattern.matcher(rs);\n\n        // 4、开始找了\n        while (matcher.find()) &#123;\n            String rs1 = matcher.group();\n            System.out.println(rs1);\n        &#125;\n\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h1 id=\"4、Arrays-类\"><a href=\"#4、Arrays-类\" class=\"headerlink\" title=\"4、Arrays 类\"></a>4、Arrays 类</h1><h2 id=\"4-1-Arrays-类概述，常用功能演示\"><a href=\"#4-1-Arrays-类概述，常用功能演示\" class=\"headerlink\" title=\"4.1 Arrays 类概述，常用功能演示\"></a>4.1 Arrays 类概述，常用功能演示</h2><p>数组操作工具类,专门用于操作数组元素的。</p>\n<p><strong>Arrays 类的常用 API</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public static String tostring(类型[] a)</td>\n<td align=\"center\">返回数组的内容（字符串形式)</td>\n</tr>\n<tr>\n<td align=\"center\">public static void sort(类型[] a)</td>\n<td align=\"center\">对数组进行默认升序排序</td>\n</tr>\n<tr>\n<td align=\"center\">public static <T> void sort(类型[] a, Comparator&lt;? superT&gt; c)</td>\n<td align=\"center\">使用比较器对象自定义排序</td>\n</tr>\n<tr>\n<td align=\"center\">public static int binarySearch(int[] a, int key)</td>\n<td align=\"center\">二分搜索数组中的数据,存在返回索引,不存在返回-1</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">\nimport java.util.Arrays;\n\npublic class ArraysDemo1 &#123;\n    public static void main(String[] args) &#123;\n        // 目标：学会使用Arrays类的常用API ,并理解其原理\n        int[] arr = &#123;10, 2, 55, 23, 24, 100&#125;;\n        System.out.println(arr);\n\n        // 1、返回数组内容的 toString(数组)\n//        String rs = Arrays.toString(arr);\n//        System.out.println(rs);\n\n        System.out.println(Arrays.toString(arr));\n\n        // 2、排序的API(默认自动对数组元素进行升序排序)\n        Arrays.sort(arr);\n        System.out.println(Arrays.toString(arr));\n\n        // 3、二分搜索技术（前提数组必须排好序才支持，否则出bug）\n        int index = Arrays.binarySearch(arr, 55);\n        System.out.println(index);\n\n        // 返回不存在元素的规律： - （应该插入的位置索引 + 1）\n        int index2 = Arrays.binarySearch(arr, 22);\n        System.out.println(index2);\n\n\n        // 注意：数组如果没有排好序，可能会找不到存在的元素，从而出现bug!!\n        int[] arr2 = &#123;12, 36, 34, 25 , 13,  24,  234, 100&#125;;\n        System.out.println(Arrays.binarySearch(arr2 , 36));\n    &#125;\n\n&#125;\n</code></pre>\n<h2 id=\"4-2-Arrays-类对于-Comparator-比较器的支持\"><a href=\"#4-2-Arrays-类对于-Comparator-比较器的支持\" class=\"headerlink\" title=\"4.2 Arrays 类对于 Comparator 比较器的支持\"></a>4.2 Arrays 类对于 Comparator 比较器的支持</h2><p><strong>Arrays 类的排序方法</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public static void sort(类型 a)</td>\n<td align=\"center\">对数组进行默认升序排序</td>\n</tr>\n<tr>\n<td align=\"center\">public static <T> void sort(类型 a, Comparator&lt; ? super T&gt; c)</td>\n<td align=\"center\">使用比较器对象自定义排序</td>\n</tr>\n</tbody></table>\n<p>自定义排序规则</p>\n<p>设置 Comparator 接口对应的比较器对象，来定制比较规则。</p>\n<ul>\n<li>如果认为左边数据大于右边数据返回正整数</li>\n<li>如果认为左边数据小于右边数据返回负整数</li>\n<li>如果认为左边数据等于右边数据返回 0</li>\n</ul>\n<pre><code class=\"java\">import java.util.Arrays;\nimport java.util.Comparator;\n\npublic class ArraysDemo2 &#123;\n    public static void main(String[] args) &#123;\n        // 目标：自定义数组的排序规则：Comparator比较器对象。\n        // 1、Arrays的sort方法对于有值特性的数组是默认升序排序\n        int[] ages = &#123;34, 12, 42, 23&#125;;\n        Arrays.sort(ages);\n        System.out.println(Arrays.toString(ages));\n\n        // 2、需求：降序排序！(自定义比较器对象，只能支持引用类型的排序！！)\n        Integer[] ages1 = &#123;34, 12, 42, 23&#125;;\n        /**\n           参数一：被排序的数组 必须是引用类型的元素\n           参数二：匿名内部类对象，代表了一个比较器对象。\n         */\n        Arrays.sort(ages1, new Comparator&lt;Integer&gt;() &#123;\n            @Override\n            public int compare(Integer o1, Integer o2) &#123;\n                // 指定比较规则。\n//                if(o1 &gt; o2)&#123;\n//                    return 1;\n//                &#125;else if(o1 &lt; o2)&#123;\n//                    return -1;\n//                &#125;\n//                return 0;\n                // return o1 - o2; // 默认升序\n                return o2 - o1; //  降序\n            &#125;\n        &#125;);\n        System.out.println(Arrays.toString(ages1));\n\n        System.out.println(&quot;-------------------------&quot;);\n        Student[] students = new Student[3];\n        students[0] = new Student(&quot;吴磊&quot;,23 , 175.5);\n        students[1] = new Student(&quot;谢鑫&quot;,18 , 185.5);\n        students[2] = new Student(&quot;王亮&quot;,20 , 195.5);\n        System.out.println(Arrays.toString(students));\n\n        // Arrays.sort(students);  // 直接运行奔溃\n        Arrays.sort(students, new Comparator&lt;Student&gt;() &#123;\n            @Override\n            public int compare(Student o1, Student o2) &#123;\n                // 自己指定比较规则\n                // return o1.getAge() - o2.getAge(); // 按照年龄升序排序！\n                // return o2.getAge() - o1.getAge(); // 按照年龄降序排序！！\n                // return Double.compare(o1.getHeight(), o2.getHeight()); // 比较浮点型可以这样写 升序\n                return Double.compare(o2.getHeight(), o1.getHeight()); // 比较浮点型可以这样写  降序\n            &#125;\n        &#125;);\n        System.out.println(Arrays.toString(students));\n\n\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h1 id=\"5、常见算法\"><a href=\"#5、常见算法\" class=\"headerlink\" title=\"5、常见算法\"></a>5、常见算法</h1><p>参见数据结构系列博客 <a href=\"https://blog.csdn.net/ASHIYI66/article/details/123036987\">数据结构笔记</a>。</p>\n<hr>\n<h1 id=\"6、Lambda-表达式\"><a href=\"#6、Lambda-表达式\" class=\"headerlink\" title=\"6、Lambda 表达式\"></a>6、Lambda 表达式</h1><h2 id=\"6-1-Lambda-概述\"><a href=\"#6-1-Lambda-概述\" class=\"headerlink\" title=\"6.1 Lambda 概述\"></a>6.1 Lambda 概述</h2><p>Lambda 表达式是 JDK 8 开始后的一种新语法形式。</p>\n<p>作用:简化匿名内部类的代码写法。</p>\n<p>Lambda 表达式的简化格式</p>\n<pre><code class=\"Markdown\">(匿名内部类被重写方法的形参列表)-&gt;&#123;\n    被重写方法的方法体代码。\n&#125;\n注:-&gt;是语法形式。无实际含义\n</code></pre>\n<pre><code class=\"java\">public class LambdaDemo1 &#123;\n    public static void main(String[] args) &#123;\n        // 目标：学会使用Lambda的标准格式简化匿名内部类的代码形式\n        Animal a = new Animal() &#123;\n            @Override\n            public void run() &#123;\n                System.out.println(&quot;乌龟跑的很慢~~~~~&quot;);\n            &#125;\n        &#125;;\n        a.run();\n\n        // 注意：lambda并不是可以简化所有匿名匿名内部类形式！！\n//        Animal a1 = () -&gt; &#123;\n//            System.out.println(&quot;乌龟跑的很慢~~~~~&quot;);\n//        &#125;;\n//        a1.run();\n    &#125;\n&#125;\n\n\n\nabstract class Animal&#123;\n    public abstract void run();\n&#125;\n\n</code></pre>\n<p><strong>注意:Lambda 表达式只能简化 &#x3D;&#x3D;函数式接口（首先必须是接口、其次接口中有且仅有一个抽象方法的形式）&#x3D;&#x3D; 的匿名内部类的写法形式</strong></p>\n<h2 id=\"6-2-Lambda-应用\"><a href=\"#6-2-Lambda-应用\" class=\"headerlink\" title=\"6.2 Lambda 应用\"></a>6.2 Lambda 应用</h2><pre><code class=\"java\">public class LambdaDemo2 &#123;\n    public static void main(String[] args) &#123;\n        // 目标：学会使用Lambda的标准格式简化匿名内部类的代码形式\n        // 注意：Lambda只能简化接口中只有一个抽象方法的匿名内部类形式（函数式接口）\n//        Swimming s1 = new Swimming() &#123;\n//            @Override\n//            public void swim() &#123;\n//                System.out.println(&quot;老师游泳贼溜~~~~~&quot;);\n//            &#125;\n//        &#125;;\n\n//        Swimming s1 = () -&gt; &#123;\n//            System.out.println(&quot;老师游泳贼溜~~~~~&quot;);\n//        &#125;;\n\n        Swimming s1 = () -&gt; System.out.println(&quot;老师游泳贼溜~~~~~&quot;);\n        go(s1);\n\n        System.out.println(&quot;---------------------&quot;);\n//        go(new Swimming() &#123;\n//            @Override\n//            public void swim() &#123;\n//                System.out.println(&quot;学生游泳很开心~~~&quot;);\n//            &#125;\n//        &#125;);\n\n//        go(() -&gt;&#123;\n//                System.out.println(&quot;学生游泳很开心~~~&quot;);\n//        &#125;);\n\n        go(() -&gt; System.out.println(&quot;学生游泳很开心~~~&quot;));\n\n\n    &#125;\n\n    public static void go(Swimming s)&#123;\n        System.out.println(&quot;开始。。。&quot;);\n        s.swim();\n        System.out.println(&quot;结束。。。&quot;);\n    &#125;\n&#125;\n\n@FunctionalInterface // 一旦加上这个注解必须是函数式接口，里面只能有一个抽象方法\ninterface Swimming&#123;\n    void swim();\n&#125;\n</code></pre>\n<h2 id=\"6-3-Lambda-表达式的省略规则\"><a href=\"#6-3-Lambda-表达式的省略规则\" class=\"headerlink\" title=\"6.3 Lambda 表达式的省略规则\"></a>6.3 Lambda 表达式的省略规则</h2><p>Lambda 表达式的省略写法(进—步在 Lambda 表达式的基础上继续简化)</p>\n<ul>\n<li><strong>参数类型可以省略不写。</strong></li>\n<li><strong>如果只有一个参数，参数类型可以省略，同时()也可以省略。</strong></li>\n<li><strong>如果 Lambda 表达式的方法体代码只有一行代码。可以省略大括号不写,同时要省略分号!</strong></li>\n<li><strong>如果 Lambda 表达式的方法体代码只有一行代码。可以省略大括号不写。此时，如果这行代码是 return 语句，必须省略 return 不写，同时也必须省略”;”不写</strong></li>\n</ul>\n<hr>\n","feature":true,"text":"日期类是Java中用于处理日期和时间的类，提供了日期和时间的操作、格式化和解析等功能。正则表达式是一种用于匹配和操作字符串的强大工具，Java通过Pattern和Matcher类提供了对正则表达式的支持。Lambda表达式是Java 8引入的一种新特性，用于简化函数式编程的表达方式，可以更简洁地表示匿名函数，提高代码的可读性和简洁性。...","permalink":"/post/Java程序设计 -- 常用API(下)（十一）","photos":[],"count_time":{"symbolsCount":"29k","symbolsTime":"26 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">1、日期与时间</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-Date\"><span class=\"toc-text\">1.1 Date</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-SimpleDateFormat\"><span class=\"toc-text\">1.2 SimpleDateFormat</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-Calendar\"><span class=\"toc-text\">1.3 Calendar</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4-LocalDate%E3%80%81LocalTime%E3%80%81LocalDateTime\"><span class=\"toc-text\">1.4 LocalDate、LocalTime、LocalDateTime</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-5-Instant\"><span class=\"toc-text\">1.5 Instant</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-6-DateTimeFormatter\"><span class=\"toc-text\">1.6 DateTimeFormatter</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-7-Period-Duration\"><span class=\"toc-text\">1.7 Period&#x2F;Duration</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-8-ChronoUnit\"><span class=\"toc-text\">1.8 ChronoUnit</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB\"><span class=\"toc-text\">2、包装类</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">3、正则表达式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A6%82%E8%BF%B0%E3%80%81%E5%88%9D%E4%BD%93%E9%AA%8C\"><span class=\"toc-text\">3.1 正则表达式概述、初体验</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99\"><span class=\"toc-text\">3.2 正则表达式的匹配规则</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">3.3 正则表达式的应用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-4-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%88%AC%E5%8F%96%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">3.4 正则表达式爬取信息</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4%E3%80%81Arrays-%E7%B1%BB\"><span class=\"toc-text\">4、Arrays 类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-Arrays-%E7%B1%BB%E6%A6%82%E8%BF%B0%EF%BC%8C%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%E6%BC%94%E7%A4%BA\"><span class=\"toc-text\">4.1 Arrays 类概述，常用功能演示</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2-Arrays-%E7%B1%BB%E5%AF%B9%E4%BA%8E-Comparator-%E6%AF%94%E8%BE%83%E5%99%A8%E7%9A%84%E6%94%AF%E6%8C%81\"><span class=\"toc-text\">4.2 Arrays 类对于 Comparator 比较器的支持</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5%E3%80%81%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">5、常见算法</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#6%E3%80%81Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">6、Lambda 表达式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-1-Lambda-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">6.1 Lambda 概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-2-Lambda-%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">6.2 Lambda 应用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-3-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%9C%81%E7%95%A5%E8%A7%84%E5%88%99\"><span class=\"toc-text\">6.3 Lambda 表达式的省略规则</span></a></li></ol></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Java程序设计--集合(上)","uid":"84c5c7d3318822a7a4ef1ba96214ecd0","slug":"Java程序设计 -- 集合(上)（十二）","date":"2022-03-22T13:26:15.000Z","updated":"2025-07-14T15:12:20.461Z","comments":true,"path":"api/articles/Java程序设计 -- 集合(上)（十二）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","text":"Java集合是编程中重要的概念，提供有序对象操作。Collection是基本接口，List是其子接口，实现有序可重复元素序列。使用List简化开发和维护工作，处理数据如员工名单、商品列表更高效方便。提供排序、查找、过滤等算法和工具类，支持泛型确保类型安全。掌握Java集合是必备技能。...","permalink":"/post/Java程序设计 -- 集合(上)（十二）","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true},"next_post":{"title":"Java程序设计--常用API(中)","uid":"14d6bcd214a7a0ca6551995e61aaab69","slug":"Java程序设计 -- 常用API(中)（十）","date":"2022-03-21T14:44:56.000Z","updated":"2025-07-14T15:12:20.460Z","comments":true,"path":"api/articles/Java程序设计 -- 常用API(中)（十）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","text":"Object是Java中所有类的根类，它定义了一些通用的方法，如equals()和toString()。Math是Java提供的数学工具类，包含了一系列数学相关的静态方法，如求绝对值、平方根、三角函数等。BigDecimal是Java中用于精确计算的高精度数字类，它可以处理任意位数的小数，避免了浮点数计算中的精度丢失问题。...","permalink":"/post/Java程序设计 -- 常用API(中)（十）","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"10 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true}}