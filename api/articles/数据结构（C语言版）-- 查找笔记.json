{"title":"查找","uid":"c6ad7ccbed505349c9093570c864bff1","slug":"数据结构（C语言版）-- 查找笔记","date":"2022-02-20T13:03:12.000Z","updated":"2025-07-14T15:12:20.469Z","comments":true,"path":"api/articles/数据结构（C语言版）-- 查找笔记.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/db70ceb9e22c4eebb7eb82117f4787b5.png","content":"<hr>\n<h1 id=\"1、查找的基本概念\"><a href=\"#1、查找的基本概念\" class=\"headerlink\" title=\"1、查找的基本概念\"></a>1、查找的基本概念</h1><p><strong>查找表</strong></p>\n<p>&#x3D;&#x3D;查找表是由同―类型的数据元素（或记录）构成的集合。&#x3D;&#x3D;</p>\n<p><strong>关键字</strong></p>\n<p>&#x3D;&#x3D;关键字是数据元素(或记录）中某个数据项的值，用它可以标识一个数据元素（或记录)。若此关键字可以唯一地标识一个记录，则称此关键字为主关键字（对不同的记录，其主关键字均不同)。反之，称用以识别若干记录的关键字为次关键字。当数据元素只有一个数据项时，其关键字即为该数据元素的值。&#x3D;&#x3D;</p>\n<p><strong>查找</strong></p>\n<p>&#x3D;&#x3D;查找是指根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或数据元素。若表中存在这样的一个记录，则称查找成功，此时查找的结果可给出整个记录的信息，或指示该记录在查找表中的位置;若表中不存在关键字等于给定值的记录，则称查找不成功，此时查找的结果可给出一个“空”记录或“空”指针。&#x3D;&#x3D;</p>\n<p><strong>动态查找表和静态查找表</strong></p>\n<p>&#x3D;&#x3D;若在查找的同时对表做修改操作(如插入和删除)，则相应的表称之为动态查找表，否则称之为静态查找表。换句话说，动态查找表的表结构本身是在查找过程中动态生成的，即在创建表时，对于给定值，若表中存在其关键字等于给定值的记录，则查找成功返回;否则插入关键字等于给定值的记录。&#x3D;&#x3D;</p>\n<p><strong>平均查找长度</strong></p>\n<p>&#x3D;&#x3D;为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值，称为查找算法，在查找成功时的平均查找长度。( Average Search Length，ASL )。&#x3D;&#x3D;</p>\n<p><img src=\"https://img-blog.csdnimg.cn/ecf29fde1406491280329ac8438d6727.png#pic_center\"></p>\n<hr>\n<h1 id=\"2、线性表的查找\"><a href=\"#2、线性表的查找\" class=\"headerlink\" title=\"2、线性表的查找\"></a>2、线性表的查找</h1><h2 id=\"①-顺序查找\"><a href=\"#①-顺序查找\" class=\"headerlink\" title=\"①.顺序查找\"></a>①.顺序查找</h2><p><strong>顺序查找( Sequential Search )的查找过程为:从表的一端开始，依次将记录的关键字和给定值进行比较，若某个记录的关键字和给定值相等，则查找成功;反之，若扫描整个表后，仍未找到关键字和给定值相等的记录，则查找失败。</strong></p>\n<p>顺序查找方法既适用于线性表的顺序存储结构，又适用于线性表的链式存储结构。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/fe57a0307a7c42388ca5875ff5662467.png#pic_center\"></p>\n<pre><code class=\"cpp\">//顺序查找\n#include&lt;iostream&gt;\nusing namespace std;\n#define MAXSIZE 100\n#define OK 1;\n\ntypedef struct&#123;\n    int key;//关键字域\n&#125;ElemType;\n\ntypedef struct&#123;\n    ElemType *R;\n    int length;\n&#125;SSTable;\n\nint InitList_SSTable(SSTable &amp;L)\n&#123;\n    L.R=new ElemType[MAXSIZE];\n    if (!L.R)\n    &#123;\n        cout&lt;&lt;&quot;初始化错误&quot;;\n        return 0;\n    &#125;\n    L.length=0;\n    return OK;\n&#125;\n\nint Insert_SSTable(SSTable &amp;L) \n&#123;\n    int j=0;\n    for(int i=0;i&lt;MAXSIZE;i++)\n    &#123;\n        L.R[i].key=j;\n        L.length++;\n        j++;\n    &#125;\n    return 1;\n&#125;\n\nint Search_Seq(SSTable ST, int key)&#123;\n    //在顺序表ST中顺序查找其关键字等于key的数据元素。若找到，则函数值为\n    //该元素在表中的位置，否则为0\n     for (int i=ST.length; i&gt;=1; --i)  \n             if (ST.R[i].key==key) return i;\t\t//从后往前找        \n     return 0;\n   &#125;// Search_Seq\n\nvoid Show_End(int result,int testkey)\n&#123;\n    if(result==0)\n        cout&lt;&lt;&quot;未找到&quot;&lt;&lt;testkey&lt;&lt;endl;\n    else\n        cout&lt;&lt;&quot;找到&quot;&lt;&lt;testkey&lt;&lt;&quot;位置为&quot;&lt;&lt;result&lt;&lt;endl;\n    return;\n&#125;\nvoid main()\n&#123;\n    SSTable ST;\n    InitList_SSTable(ST);\n    Insert_SSTable(ST);\n    int testkey1=7,testkey2=200;\n    int result;\n    result=Search_Seq(ST, testkey1);\n    Show_End(result,testkey1);\n    result=Search_Seq(ST, testkey2);\n    Show_End(result,testkey2);\n&#125;\n</code></pre>\n<p><strong>改进:把待查关键字key存入表头（“哨兵”），从后向前逐个比较，可免去查找过程中每一步都要检测是否查找完毕，加快速度。</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/d21b3aae468f486e8cbe5663e737af17.png#pic_center\"></p>\n<pre><code class=\"cpp\">//设置监视哨的顺序查找\n#include&lt;iostream&gt;\nusing namespace std;\n#define MAXSIZE 100\n#define OK 1;\n\ntypedef struct&#123;\n    int key;//关键字域\n&#125;ElemType;\n\ntypedef struct&#123;\n    ElemType *R;\n    int length;\n&#125;SSTable;\n\nint InitList_SSTable(SSTable &amp;L)\n&#123;\n    L.R=new ElemType[MAXSIZE];\n    if (!L.R)\n    &#123;\n        cout&lt;&lt;&quot;初始化错误&quot;;\n        return 0;\n    &#125;\n    L.length=0;\n    return OK;\n&#125;\n\nint Insert_SSTable(SSTable &amp;L) \n&#123;\n    int j=1;//空出ST.R[0]的位置\n    for(int i=1;i&lt;MAXSIZE;i++)\n    &#123;\n        L.R[i].key=j;\n        L.length++;\n        j++;\n    &#125;\n    return 1;\n&#125;\n\nint Search_Seq(SSTable ST, int key)&#123;\n      //在顺序表ST中顺序查找其关键字等于key的数据元素。若找到，则函数值为\n      //该元素在表中的位置，否则为0\n     ST.R[0].key = key;                          \t\t\t//“哨兵”\n     for(int i = ST.length; ST.R[i].key!=key; --i)  ;\t\t//从后往前找\n     return i;                                         \n&#125;// Search_Seq\nvoid Show_End(int result,int testkey)\n&#123;\n    if(result==0)\n        cout&lt;&lt;&quot;未找到&quot;&lt;&lt;testkey&lt;&lt;endl;\n    else\n        cout&lt;&lt;&quot;找到&quot;&lt;&lt;testkey&lt;&lt;&quot;位置为&quot;&lt;&lt;result&lt;&lt;endl;\n    return;\n&#125;\nvoid main()\n&#123;\n    SSTable ST;\n    InitList_SSTable(ST);\n    Insert_SSTable(ST);\n    int testkey1=7,testkey2=200;\n    int result;\n    result=Search_Seq(ST, testkey1);\n    Show_End(result,testkey1);\n    result=Search_Seq(ST, testkey2);\n    Show_End(result,testkey2);\n&#125;\n</code></pre>\n<p>顺序查找的时间复杂度为O（n）。</p>\n<p>顺序查找的<strong>优点</strong>是:算法简单，对表结构无任何要求，既适用于顺序结构，也适用于链式结构，无论记录是否按关键字有序均可应用。</p>\n<p>其<strong>缺点</strong>是:平均查找长度较大，查找效率较低，所以当n很大时，不官采用顺序查找。</p>\n<h2 id=\"②-折半查找\"><a href=\"#②-折半查找\" class=\"headerlink\" title=\"②.折半查找\"></a>②.折半查找</h2><p>&#x3D;&#x3D;折半查找(Binary Search )也称二分查找，它是一种效率较高的查找方法。<strong>但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列（顺序有序）。</strong>&#x3D;&#x3D;</p>\n<p>折半查找的查找过程为:从表的中间记录开始，如果给定值和中间记录的关键字相等，则查找成功;如果给定值大于或者小于中间记录的关键字，则在表中大于或小于中间记录的那一半中查找，这样重复操作，直到查找成功，或者在某一步中查找区间为空，则代表查找失败。</p>\n<p>设表长为n, low、high和mid分别指向待查元素所在区间的上界、下界和中点，key为要查找的值</p>\n<ol>\n<li>初始时，令low&#x3D;1 , high&#x3D;n, mid&#x3D;⌊(1ow+high)&#x2F;2⌋</li>\n<li>让key与mid指向的记录比较<br>- 若key&#x3D;&#x3D;R[ mid].key，查找成功<br>- 若key&lt;R[mid].key，则high&#x3D;mid-1<br>- 若key&gt;R[mid].key，则low&#x3D;mid+1</li>\n<li>重复上述操作，直至low&gt;high时，查找失败</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/0b7202ed537f434e8db1bef46f9bd1f8.png#pic_center\"></p>\n<pre><code class=\"cpp\">//折半查找\n#include&lt;iostream&gt;\nusing namespace std;\n#define MAXSIZE 100\n#define OK 1;\n\ntypedef struct&#123;\n    int key;//关键字域\n&#125;ElemType;\n\ntypedef struct&#123;\n    ElemType *R;\n    int length;\n&#125;SSTable;\n\nint InitList_SSTable(SSTable &amp;L)\n&#123;\n    L.R=new ElemType[MAXSIZE];\n    if (!L.R)\n    &#123;\n        cout&lt;&lt;&quot;初始化错误&quot;;\n        return 0;\n    &#125;\n    L.length=0;\n    return OK;\n&#125;\n\nint Insert_SSTable(SSTable &amp;L) \n&#123;\n    int j=1;\n    for(int i=1;i&lt;MAXSIZE;i++)\n    &#123;\n        L.R[i].key=j;\n        L.length++;\n        j++;\n    &#125;\n    return 1;\n&#125;\n\nint Search_Bin(SSTable ST,int key) &#123;\n   // 在有序表ST中折半查找其关键字等于key的数据元素。若找到，则函数值为\n   // 该元素在表中的位置，否则为0\n   int low=1,high=ST.length;\t\t\t\t\t\t\t//置查找区间初值\n   int  mid;\n   while(low&lt;=high) &#123;\n       mid=(low+high) / 2;\n      if (key==ST.R[mid].key)  return mid;      \t\t//找到待查元素\n      else if (key&lt;ST.R[mid].key)  high = mid -1;\t\t//继续在前一子表进行查找\n      else  low =mid +1;                       \t\t\t//继续在后一子表进行查找\n   &#125;//while\n   return 0;\t\t\t\t\t\t\t\t\t\t//表中不存在待查元素\n&#125;// Search_Bin\n\nvoid Show_End(int result,int testkey)\n&#123;\n    if(result==0)\n        cout&lt;&lt;&quot;未找到&quot;&lt;&lt;testkey&lt;&lt;endl;\n    else\n        cout&lt;&lt;&quot;找到&quot;&lt;&lt;testkey&lt;&lt;&quot;位置为&quot;&lt;&lt;result&lt;&lt;endl;\n    return;\n&#125;\n\nvoid main()\n&#123;\n    SSTable ST;\n    InitList_SSTable(ST);\n    Insert_SSTable(ST);\n    int testkey1=7,testkey2=200;\n    int result;\n    result=Search_Bin(ST, testkey1);\n    Show_End(result,testkey1);\n    result=Search_Bin(ST, testkey2);\n    Show_End(result,testkey2);\n&#125;\n</code></pre>\n<p>折半查找的时间复杂度为O(log<del>2</del>n )。可见，折半查找的效率比顺序查找高，但折半查找只适用于有序表，且限于顺序存储结构。</p>\n<p>折半查找的<strong>优点</strong>是：比较次数少，查找效率高。</p>\n<p>其<strong>缺点</strong>是:对表结构要求高，只能用于顺序存储的有序表。查找前需要排序，而排序本身是一种费时的运算。同时为了保持顺序表的有序性，对有序表进行插人和删除时，平均比较和移动表中一半元素，这也是一种费时的运算。因此，折半查找不适用于数据元素经常变动的线性表。</p>\n<h2 id=\"③-分块查找\"><a href=\"#③-分块查找\" class=\"headerlink\" title=\"③.分块查找\"></a>③.分块查找</h2><ol>\n<li>分块有序，即分成若干子表，要求每个子表中的数值都比后一块中数值小(但子表内部未必有序)。</li>\n<li>建立“索引表”，索引表包括:<br>- 关键字项:各子表中的最大关键字。<br>- 指针项:指示该子表的起始地址。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/069e58c10bdf414c80c92b1649d49dba.png#pic_center\"></p>\n<ol>\n<li>先确定待查记录所在块<br>- 对索引表使用折半查找法(因为索引表是有序表);</li>\n<li>确定了待查关键字所在的子表后，在子表内采用顺序查找法（因为各子表内部是无序表);</li>\n</ol>\n<p>分块查找的<strong>优点</strong>是:在表中插人和删除数据元素时，只要找到该元素对应的块，就可以在该块内进行插人和删除运算。由于块内是无序的，故插人和删除比较容易，无需进行大量移动。如果线性表既要快速查找又经常动态变化，则可采用分块查找。</p>\n<p>其<strong>缺点</strong>是:要增加一个索引表的存储空间并对初始索引表进行排序运算。</p>\n<hr>\n<h1 id=\"3、树表的查找\"><a href=\"#3、树表的查找\" class=\"headerlink\" title=\"3、树表的查找\"></a>3、树表的查找</h1><h2 id=\"①-二叉排序树\"><a href=\"#①-二叉排序树\" class=\"headerlink\" title=\"①.二叉排序树\"></a>①.二叉排序树</h2><p><strong>二叉排序树（Binary Sort Tree）又称二叉查找树，它是一种对排序和查找都很有用的特殊二叉树。</strong></p>\n<p><strong>二叉排序树的定义</strong></p>\n<p>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树:</p>\n<ol>\n<li>&#x3D;&#x3D;若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值;&#x3D;&#x3D;</li>\n<li>&#x3D;&#x3D;若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值;&#x3D;&#x3D;</li>\n<li>&#x3D;&#x3D;它的左、右子树也分别为二叉排序树。&#x3D;&#x3D;</li>\n</ol>\n<p>二叉排序树是递归定义的。由定义可以得出二叉排序树的一个重要性质:<strong>中序遍历一棵二叉树时可以得到一个结点值递增的有序序列。</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/8139039abc614b6cb2e9119be77f9ae9.png#pic_center\"></p>\n<p><strong>二叉树排序树的操作-查找</strong></p>\n<ol>\n<li>若二叉排序树为空，则查找失败，返回空指针。</li>\n<li>若二叉排序树非空，将给定值key与根结点的关键字T-&gt;data.key进行比较:<br>- 若key&#x3D;&#x3D;T-&gt;data.key，则查找成功，返回根结点地址;<br>- 若key<T->data.key，则进一步查找左子树;<br>- 若key&gt;T-&gt;data.key，则进一步查找右子树。</li>\n</ol>\n<p><strong>二叉树排序树的操作-插入</strong></p>\n<ol>\n<li>若二叉排序树为空，则待插入结点*S作为根结点插入到空树中。</li>\n<li>若二叉排序树非空，则将key与根结点的关键字T&gt;data.key进行比较:<br>- 若key小于T-&gt;data.key，则将<em>S插入左子树;<br>- 若key大于T&gt;data,key，则将</em>S插入右子树。</li>\n</ol>\n<p><strong>二叉树排序树的操作-创建</strong></p>\n<ol>\n<li>将二叉排序树T初始化为空树。</li>\n<li>读入一个关键字为key的结点。</li>\n<li>如果读入的关键字key不是输入结束标志，则循环执行以下操作:<br>- 将此结点插入二叉排序树T中;<br>- 读人一个关键字为key的结点。</li>\n</ol>\n<p>例：设关键字的输入次序为：45,24,53,45,12,24,90，写出二叉排序树的创建过程。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/30aacfd77e7d43e4b8eeed34d28af667.png#pic_center\"></p>\n<p><strong>二叉树排序树的操作-删除</strong></p>\n<p>原则:删除后保持所有节点的中序遍历顺序不变<br>删除一个结点，不能把以该结点为根的子树都删掉，将因删除结点而断开的二叉链表重新链接起来<br>假设被删结点为<em>p(即p指针指向的结点)，其双亲为</em>f，<em>p是</em>f的左孩子(或右孩子)，分三种情况︰</p>\n<ol>\n<li>被删结点*p为叶子结点</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/f19199050a0649bd836e31696fb981a7.png#pic_center\"><br>2. 被删结点*p只有左子树或右子树</p>\n<p><img src=\"https://img-blog.csdnimg.cn/e29df1ea254c4f59ab486b83a58c428f.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/691b1c1343ed47a58463dfb906add01d.png#pic_center\"><br>3. 被删结点*p既有左子树又有右子树</p>\n<p><img src=\"https://img-blog.csdnimg.cn/1aef4035837b4817b12e4b0adb70d42f.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/fa3a9cf7de694f85841cf122361f22ac.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/5c18f1e5df5c4c329c2057b4771b46d9.png#pic_center\"></p>\n<pre><code class=\"cpp\">//二叉排序树的综合操作\n#include&lt;iostream&gt;\nusing namespace std;\n#define ENDFLAG &#39;#&#39;\n//char a[10]=&#123;&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;2&#39;,&#39;1&#39;,&#39;9&#39;,&#39;8&#39;,&#39;10&#39;,&#39;3&#39;,&#39;4&#39;,&#39;#&#39;&#125;;//全局变量\ntypedef struct ElemType&#123;\t\n    char key;\n&#125;ElemType;\n\ntypedef struct BSTNode&#123;\n    ElemType data;\t//结点数据域\n    BSTNode *lchild,*rchild;\t//左右孩子指针\n&#125;BSTNode,*BSTree;\n\n\n//二叉排序树的递归查找\nBSTree SearchBST(BSTree T,char key) &#123;\n  //在根指针T所指二叉排序树中递归地查找某关键字等于key的数据元素\n  //若查找成功，则返回指向该数据元素结点的指针，否则返回空指针\n  if((!T)|| key==T-&gt;data.key) return T;       \t            \t//查找结束\n  else if (key&lt;T-&gt;data.key)  return SearchBST(T-&gt;lchild,key);\t//在左子树中继续查找\n  else return SearchBST(T-&gt;rchild,key);    \t\t   \t\t\t//在右子树中继续查找\n&#125; // SearchBST\n\n\n\n//二叉排序树的插入\nvoid InsertBST(BSTree &amp;T,ElemType e ) &#123;\n  //当二叉排序树T中不存在关键字等于e.key的数据元素时，则插入该元素\n  if(!T) &#123;                \t\t\t\t//找到插入位置，递归结束\n         BSTree S = new BSTNode;            \t\t//生成新结点*S\n         S-&gt;data = e;                  \t\t//新结点*S的数据域置为e   \n         S-&gt;lchild = S-&gt;rchild = NULL;\t//新结点*S作为叶子结点\n         T =S;            \t\t\t\t//把新结点*S链接到已找到的插入位置\n  &#125;\n  else if (e.key&lt; T-&gt;data.key) \n      InsertBST(T-&gt;lchild, e );\t\t\t//将*S插入左子树\n  else if (e.key&gt; T-&gt;data.key) \n      InsertBST(T-&gt;rchild, e);\t\t\t//将*S插入右子树\n&#125;// InsertBST\n\n\n\n//二叉排序树的创建\nvoid CreateBST(BSTree &amp;T ) &#123;\n  //依次读入一个关键字为key的结点，将此结点插入二叉排序树T中\n  T=NULL;\n  ElemType e;\n  cin&gt;&gt;e.key;        //???\n  while(e.key!=ENDFLAG)&#123;   \t//ENDFLAG为自定义常量，作为输入结束标志\n    InsertBST(T, e);          \t//将此结点插入二叉排序树T中\n    cin&gt;&gt;e.key;\t\t\t//???\n  &#125;//while            \n&#125;//CreatBST\n\nvoid DeleteBST(BSTree &amp;T,char key) &#123;\n  //从二叉排序树T中删除关键字等于key的结点\n  BSTree p=T;BSTree f=NULL;                     \t\t\t//初始化\n  BSTree q;\n  BSTree s;\n  /*------------下面的while循环从根开始查找关键字等于key的结点*p-------------*/\n  while(p)&#123;                  \n   if (p-&gt;data.key == key) break;  \t      \t//找到关键字等于key的结点*p，结束循环\n   f=p;                                \t\t\t//*f为*p的双亲结点\n   if (p-&gt;data.key&gt; key)  p=p-&gt;lchild;     \t//在*p的左子树中继续查找\n   else p=p-&gt;rchild;  \t                  \t\t//在*p的右子树中继续查找\n  &#125;//while\nif(!p) return;                         \t\t//找不到被删结点则返回\n/*―考虑三种情况实现p所指子树内部的处理：*p左右子树均不空、无右子树、无左子树―*/\nif ((p-&gt;lchild)&amp;&amp; (p-&gt;rchild)) &#123;     \t\t//被删结点*p左右子树均不空\n     q = p;\n     s = p-&gt;lchild;\n     while (s-&gt;rchild)                \t\t\t//在*p的左子树中继续查找其前驱结点，即最右下结点\n       &#123;q = s; s = s-&gt;rchild;&#125;\t         \t\t//向右到尽头\n     p-&gt;data = s-&gt;data;               \t\t\t//s指向被删结点的“前驱”\n     if(q!=p)&#123;\n         q-&gt;rchild = s-&gt;lchild;     \t//重接*q的右子树\n     &#125;\n     else q-&gt;lchild = s-&gt;lchild;        \t\t//重接*q的左子树\n     delete s;\n  &#125;//if\nelse&#123;\n    if(!p-&gt;rchild) &#123;               \t\t//被删结点*p无右子树，只需重接其左子树\n          q = p; p = p-&gt;lchild; \n      &#125;//else if\n    else if(!p-&gt;lchild) &#123;               \t\t//被删结点*p无左子树，只需重接其右子树\n         q = p; p = p-&gt;rchild;\n      &#125;//else if\n    /*――――――――――将p所指的子树挂接到其双亲结点*f相应的位置――――――――*/\n      if(!f) T=p;                       \t\t\t//被删结点为根结点\n      else if (q==f-&gt;lchild) f-&gt;lchild = p;   \t//挂接到*f的左子树位置\n      else f-&gt;rchild = p;                 \t\t//挂接到*f的右子树位置\n      delete q;\n    &#125;\n&#125;//DeleteBST\n\n//二叉排序树的删除\n\n//中序遍历\nvoid InOrderTraverse(BSTree &amp;T)\n&#123;\n    if(T)\n    &#123;\n    InOrderTraverse(T-&gt;lchild);\n    cout&lt;&lt;T-&gt;data.key;\n    InOrderTraverse(T-&gt;rchild);\n    &#125;\n&#125;\n\nvoid main()\n&#123;\n    BSTree T;\n    cout&lt;&lt;&quot;请输入若干字符，用回车区分，以#结束输入&quot;&lt;&lt;endl;\n    CreateBST(T);\n    cout&lt;&lt;&quot;当前有序二叉树中序遍历结果为&quot;&lt;&lt;endl;\n    InOrderTraverse(T);\n    char key;//待查找或待删除内容\n    cout&lt;&lt;&quot;请输入待查找字符&quot;&lt;&lt;endl;\n    cin&gt;&gt;key;\n    BSTree result=SearchBST(T,key);\n    if(result)\n    &#123;cout&lt;&lt;&quot;找到字符&quot;&lt;&lt;key&lt;&lt;endl;&#125;\n    else\n    &#123;cout&lt;&lt;&quot;未找到&quot;&lt;&lt;key&lt;&lt;endl;&#125;\n    cout&lt;&lt;&quot;请输入待删除的字符&quot;&lt;&lt;endl;\n    cin&gt;&gt;key;\n    DeleteBST(T,key);\n    cout&lt;&lt;&quot;当前有序二叉树中序遍历结果为&quot;&lt;&lt;endl;\n    InOrderTraverse(T);\n&#125;\n</code></pre>\n<h2 id=\"②-平衡二叉树\"><a href=\"#②-平衡二叉树\" class=\"headerlink\" title=\"②.平衡二叉树\"></a>②.平衡二叉树</h2><p><strong>平衡二叉树又称AVL树</strong></p>\n<ul>\n<li>一棵AVL树或者是空树，或者是具有下列性质的二叉排序树:<br>  - &#x3D;&#x3D;它的左子树和右子树都是AVL树，且左子树和右子树的深度之差的绝对值不超过1。&#x3D;&#x3D;<br>  - &#x3D;&#x3D;左子树和右子树也是AVL树。&#x3D;&#x3D;</li>\n</ul>\n<p>每个结点附加一个数字，给出该结点平衡因子BF。</p>\n<p>&#x3D;&#x3D;BF:该结点的左子树深度和右子树深度之差。&#x3D;&#x3D;</p>\n<p>&#x3D;&#x3D;<strong>AVL树任一结点平衡因子只能取-1，0，1。</strong>&#x3D;&#x3D;</p>\n<p><img src=\"https://img-blog.csdnimg.cn/9a3fc2275cc54378a7a1c12615c29d02.png#pic_center\"></p>\n<p><strong>平衡二叉树的平衡调整方法</strong></p>\n<p>如果在一棵AVL树中插入一个新结点，就有可能造成失衡，此时必须重新调整树的结构，使之恢复平衡。</p>\n<p><strong>调整方法:找到离插入点最近且平衡因子绝对值超过1的祖先结点，以该结点为根的子树称为最小不平衡子树，可将重新平衡的范围局限于这颗子树。</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/6ecece911d0949b081b811f26d535357.png#pic_center\"><br><strong>平衡二叉树的插入</strong></p>\n<p>在向一棵本来是AVL树中插入一个新结点时，如果树中某个结点的平衡因子的绝对值|balance| &gt; 1，则出现了不平衡，需要做平衡化处理。<br>算法︰从一棵空树开始，通过输入一系列关键字，逐步建立AVL树。在插入新结点时使用平衡旋转方法进行平衡化处理。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/9c622bcb17cc4f6ba2feec04d64ebe39.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/39146e44e0934e14a96e11b257a4f377.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/69647983f4c34dfbb003897dcec2e790.png#pic_center\"><br>例：<br><img src=\"https://img-blog.csdnimg.cn/17dbba5a77fe4e79ac3dfc6d0514aaf6.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/b583a4e759c94d8b80e7befddcf35e97.png#pic_center\"></p>\n<h2 id=\"③-B-树\"><a href=\"#③-B-树\" class=\"headerlink\" title=\"③.B-树\"></a>③.B-树</h2><p><strong>B-树的概念</strong></p>\n<p>B-树是由R.Bayer和E.Maccreight于1970年提出的，是一种特殊的多叉树，是一种在外存文件系统中常用的动态索引技术，是大型数据库文件的一种组织结构。B-树中的每个结点大小都相同。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/4925451f4ee748c9b1c688bca1c7cde4.png#pic_center\"><br><strong>B-树的结点结构</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/80d66e7345b4461d8324a1f7ff62e821.png#pic_center\"></p>\n<ul>\n<li>m称为B-树的阶,m≥3</li>\n<li>par为指向父亲结点的指针域</li>\n<li>K<del>1</del>、K<del>2</del>、…K<del>n</del>为n个按从小到大顺序排列的关键字</li>\n<li>对非根结点⌈m&#x2F;2⌉-1≤n≤m-1</li>\n<li>P<del>0</del>、P<del>1</del>、P<del>2</del>,、…P<del>n</del>为n+1个指针，分别指向该结点的n+1棵子树</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/4cf36c79654644bdb027058d4e10b867.png#pic_center\"></p>\n<p>每个结点关键字最少&#x3D;⌈m&#x2F;2⌉-1&#x3D;2-1&#x3D;1;最多&#x3D;m-1&#x3D;3，每个结点的子树数目最少为⌈m&#x2F;2⌉&#x3D;2，最多为m&#x3D;4。不管每个结点实际使用了多少个关键字域和指针域，它都包含4个关键字域、4个指向记录存储位置的指针域、5个指向孩子结点的指针域、一个指向父亲结点的指针域和一个保存关键字个数的n域。</p>\n<p><strong>B-树的特点</strong></p>\n<ul>\n<li>一棵m阶B-树(m叉树)是一棵平衡的m路搜索树,它或者是空树,或者是满足下列性质的树:<br>  - 根结点至少有2个子树。<br>  - 除根结点以外的所有结点(不包括失败结点)至少有⌈m&#x2F;2⌉个子树。<br>  - 所有的失败结点（叶子结点)都位于同一层。<br>  - 每个结点最多有m棵子树。</li>\n<li>在B-树中的“失败”结点是当搜索值x不在树中时才能到达的结点。</li>\n<li>关键字的插入次序不同，将生成不同结构的B-树。</li>\n<li>一棵B-树是平衡的m路搜索树，但一棵平衡的m路搜索树不一定是B-树。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/f1cb03e34d84496cb746823db490cf75.png#pic_center\"><br><strong>B-树的搜索算法</strong></p>\n<ul>\n<li>B-树的搜索过程是一个在结点内搜索和循某一条路径向下一层搜索交替进行的过程。</li>\n<li>B-树的搜索时间与B-树的阶数m和B-树的高度h直接有关,必须加以权衡。</li>\n<li>在B-树上进行搜索，搜索成功所需的时间取决于关键码所在的层次;搜索不成功所需的时间取决于树的高度。</li>\n</ul>\n<p><strong>高度h与关键码个数N之间的关系</strong></p>\n<p>设在m阶B-树中每层结点个数达到最少,则B-树的高度可能达到最大。设树中关键码个数为N，从B-树的定义知:h-1层至少有2⌈m&#x2F;2⌉^h-2^个结点。</p>\n<p><strong>m值的选择</strong></p>\n<p>如果提高B-树的阶数m,可以减少树的高度,从而减少读入结点的次数,因而可减少读磁盘的次数。<br>事实上,m受到内存可使用空间的限制。当m很大超出内存工作区容量时,结点不能一次读入到内存，增加了读盘次数，也增加了结点内搜索的难度。<br>&#x3D;&#x3D;m值的选择:应使得在B-树中找到关键码×的时间总量达到最小。&#x3D;&#x3D;<br>这个时间由两部分组成:从磁盘中读入结点所用时间+在结点中搜索x所用时间。</p>\n<p><strong>B-树的插入</strong></p>\n<ol>\n<li>在B-树中查找给定关键字的记录，若查找成功，则插入操作失败;否则将新记录作为空指针p插入到查找失败的叶子结点的上一层结点（由q指向）中。</li>\n<li>若插人新记录和空指针后，q指向的结点的关键字个数未超过m-l，则插人操作成功，否则转入步骤③。</li>\n<li>以该结点的第⌈m&#x2F;2⌉个关键字K<del>⌈m&#x2F;2⌉</del>为拆分点，将该结点分成3个部分:K<del>⌈m&#x2F;2⌉</del>左边部分、K<del>⌈m&#x2F;2⌉</del>、K<del>⌈m&#x2F;2⌉</del>右边部分。K<del>⌈m&#x2F;2⌉</del>左边部分仍然保留在原结点中;K<del>⌈m&#x2F;2⌉</del>右边部分存放在一个新创建的结点(由p指向）中;关键字值为K<del>⌈m&#x2F;2⌉</del>的记录和指针p插人到q的双亲结点中。因q的双亲结点增加一个新的记录，所以必须对q的双亲结点重复②和③的操作，依次类推，直至由q指向的结点是根结点，转入步骤④。</li>\n<li>④由于根结点无双亲，则由其分裂产生的两个结点的指针p和q，以及关键字为K⌈m&#x2F;2⌉的记录构成一个新的根结点。此时，B-的高度增加1。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/5ec688bae1c64b0e95dcd6864ed82d18.png#pic_center\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/17d7e81570fb4415a3ec8601646f0a71.png#pic_center\"></p>\n<p><strong>B- 树的删除</strong></p>\n<p>在B-树上删除一个关键码时，首先需要找到这个关键码所在的结点,从中删去这个关键码。<br>若该结点不是叶结点,且被删关键码为K<del>i</del>;,1 ≤i≤n,则在删去该关键码之后,应以该结点P<del>i</del>;所指示子树中的最小关键码×来代替被删关键码K<del>i</del>;所在的位置,然后在×所在的叶结点中删除x。</p>\n<pre><code class=\"cpp\">//B-树的查找\n//B-树的插入\n\n\n#include&lt;iostream&gt;\nusing namespace std;\n#define FALSE 0\n#define TRUE 1\n#define OK 1\n#define m 3\t\t\t\t\t\t//B-树的阶，暂设为3\ntypedef struct BTNode&#123;\n    int keynum;\t\t\t\t\t//结点中关键字的个数，即结点的大小\n    BTNode *parent;\t\t\t\t//指向双亲结点\n    int key[m+1];\t\t\t\t//关键字矢量，0号单元未用\n    BTNode *ptr[m+1];\t\t\t//子树指针矢量\n&#125;BTNode,*BTree;\n\n//- - - - - B-树的查找结果类型定义- - - - -\nstruct Result&#123;\n  BTNode *pt;     \t\t\t\t\t\t\t//指向找到的结点\n  int i;           \t\t\t\t\t\t\t//1..m，在结点中的关键字序号\n  int tag;         \t\t\t\t\t\t\t//1：查找成功，0：查找失败\n&#125;; \t                           \n\n\nint Search(BTree T,int key)\n&#123;\n    BTree p=T;\t\n    int endnum;\n    if(p)\t\t\t\t\t\t//树不为空时\n    &#123;\n        endnum=p-&gt;keynum;\t\t//获得首节点包含的记录个数\n    &#125;\n    else\n    &#123;\n        return 0;\t\t\t\t//返回没找到\n    &#125;\n    int i=0;\n    if(endnum==0)\n    &#123;\n        return i;\t\t\t\t//树存在，但仅有一个为空根节点\n    &#125;\n    else if(key&gt;=p-&gt;key[endnum])//节点不为空，但当前值比最大的key还大\n    &#123;\n        i=endnum;\n        return i;\n    &#125;\n    else if(key&lt;=p-&gt;key[1])\t\t//节点不为空，但当前值比最小的key还小\n    &#123;\n        return i;&#125;\n    else\n    &#123;\n        for(i=1;i&lt;endnum;i++)\t//有合适的位置，即处于当前结点的最大和最小值之间，或找到了\n        &#123;\n            if(p-&gt;key[i]&lt;=key &amp;&amp; key&lt;p-&gt;key[i+1])\n                return i;\n        &#125;\n    &#125;\n&#125;\n\nvoid Insert(BTree &amp;q,int i,int x,BTree &amp;ap)\n&#123;//将x插入q结点的i+1位置中\n    int j;\n    for(j=m-1;j&gt;i;j--)\t\t\t\n    &#123;\n        //将插入位置之后的key全部后移一位\n        q-&gt;key[j+1]=q-&gt;key[j];\n    &#125;\n    for(j=m;j&gt;i;j--)\n    &#123;\n        //相应地也移动其后ptr的位置\n        q-&gt;ptr[j]=q-&gt;ptr[j-1];\n    &#125;\n    q-&gt;key[i+1]=x;//插入x到该位置\n    q-&gt;ptr[i+1]=ap;\n    q-&gt;keynum++;\n&#125;\n\nvoid split(BTree &amp;q,int s,BTree &amp;ap)\n&#123;\t//将q-&gt;key[s+1,..,m], q-&gt;ptr[s+1,..,m]移入新结点*ap作为右结点\n    //原结点作为新的左侧结点\n    //中间值被保存在ap[0]-&gt;key中，等待找到跳转回InsertBTree（）寻找到到合适的插入位置插入\n    int i;\n    ap=new BTNode;\n    for(i=s+1;i&lt;=m;i++)\n    &#123;\t//将q-&gt;key[s+1,..,m]保存到ap-&gt;key[0,..,m-s+1]中\n        //将q-&gt;ptr[s+1,..,m]保存到ap-&gt;ptr[0,..,m-s+1]中\n        ap-&gt;key[i-s-1]=q-&gt;key[i];\t\n        ap-&gt;ptr[i-s-1]=q-&gt;ptr[i];\n    &#125;\n    if(ap-&gt;ptr[0])\n    &#123;\n        //当ap有子树的时候\n        for(i=0;i&lt;=1;i++)\n        &#123;\n            //将ap的子树的父亲改为ap自己\n            ap-&gt;ptr[i]-&gt;parent=ap;\n        &#125;\n    &#125;\n    ap-&gt;keynum=(m-s)-1;\n    ap-&gt;parent=q-&gt;parent;//将ap的父亲改为q的父亲\n\n    q-&gt;keynum=q-&gt;keynum-(m-s);//修改q的记录个数\n&#125;\n\nvoid NewRoot(BTree &amp;T,BTree q,int x,BTree &amp;ap)//生成含信息（T, x, ap）的新的根结点*T，原T和ap为子树指针\n&#123;\n    BTree newT=new BTNode;//新建一个结点作为新的根\n    \n    newT-&gt;key[1]=x;//写入新根的key[1]\n    newT-&gt;ptr[0]=T;//将原来的树根作为新根的左子树\n    newT-&gt;ptr[1]=ap;//ap作为新根的右子树\n    newT-&gt;keynum=1;\n    newT-&gt;parent=NULL;//新根的父亲为空\n\n    ap-&gt;parent=newT;//ap的父亲为新根\n    T-&gt;parent=newT;//T的父亲为新根\n\n    T=newT;//树改成新根引导的\n&#125;\n\n//B-树的插入\nint InsertBTree(BTree &amp;T,int K,BTree q,int i)&#123;\n  int x=K;\n  BTree ap=NULL;\n  int finished=FALSE;//x表示新插入的关键字，ap为一个空指针\n  while(q&amp;&amp;!finished)&#123;\n    Insert(q,i,x,ap);      \t\t//将x和ap分别插入到q-&gt;key[i+1]和q-&gt;ptr[i+1]\n    if (q-&gt;keynum&lt;m)\n        finished=TRUE;   \t//插入完成\n    else&#123;                      \t//分裂结点*q\n     int s= m/2;\n     split(q,s,ap);\n    x=ap-&gt;key[0];//\t x=q-&gt;key[s];\n      //将q-&gt;key[s+1..m], q-&gt;ptr[s..m]和q-&gt;recptr[s+1..m] 移入新结点*ap\n      q=q-&gt;parent;\n      if(q)\n      &#123;\n          i=Search(q,x);\n      &#125;\t\t//在双亲结点*q中查找x的插入位置\n    &#125;\t\t\t\t\t\t//else\n  &#125;\t\t\t\t\t\t\t//while\n  if(!finished)    \t\t\t//T是空树（参数q初值为NULL）或者根结点已分裂为结点*q和*ap\n      NewRoot(T,q,x,ap);\t\t//生成含信息（T, x, ap）的新的根结点*T，原T和ap为子树指针\n  return  OK;\n&#125;\t\t\t\t\t\t\t//InsertBTree\t\t\t\t\t\t//InsertBTree\n\n//B-树的查找\nResult SearchBTree(BTree &amp;T, int key)&#123;\n    /*在m阶B-树T上查找关键字key，返回结果(pt,i,tag)。若查找成功，则特征值tag=1，指针pt所指结点中第i个关键字等于key；否则特征值tag=0，等于key的关键字应插入在指针pt所指结点中第i和第i+1个关键字之间*/\n    BTree p=T;\n    BTree q=NULL;\n    int found=FALSE;\n    int i=0;\t\t\t//初始化，p指向待查结点，q指向p的双亲\nwhile(p&amp;&amp;!found)&#123;\n    i=Search(p,key);               \t\n    //在p-＞key[1..keynum]中查找i，使得：p-＞key[i]＜=key＜p-＞key[i+1]\n    if(i&gt;0&amp;&amp;p-&gt;key[i]==key)\n        found=TRUE;\t\t//找到待查关键字\n    else\n    &#123;\n        q=p;\n        p=p-&gt;ptr[i];\n    &#125;\n  &#125;\n    Result result;\nif(found)\n&#123;\n    result.pt=p;\n    result.i=i;\n    result.tag=1;\n    return result;\n&#125;              \t\t//查找成功\nelse\n&#123;\n    result.pt=q;\n    result.i=i;\n    result.tag=0;\n    return result;\n&#125;              \t\t\t//查找不成功，返回K的插入位置信息\n&#125;//SearchBTree\n\nvoid InitialBTree(BTree &amp;T)\n&#123;\n    //初始化一个空的根\n    T-&gt;keynum=0;\t\t\n    T-&gt;parent=NULL;\t\n    for(int i=0;i&lt;m+1;i++)\n    &#123;\n        T-&gt;ptr[i]=NULL;\n    &#125;\n&#125;\n\n\n\nvoid main()\n&#123;\n    BTree T=new BTNode;\n    InitialBTree(T);\n    //先用SearchBTree()找到要插入的位置，得到一个Result结构体\n    //再用InsertBTree()插入数据\n    Result result;\n    int a[11]=&#123;45,24,53,90,3,12,50,61,70,100&#125;;\n    for(int i=0;i&lt;10;i++)\n    &#123;\n        result=SearchBTree(T,a[i]);\n        if(result.tag==0)\n        &#123;\n            InsertBTree(T,a[i],result.pt,result.i);\n        &#125;\n    &#125;\n    cout&lt;&lt;&quot;OK&quot;;\n&#125;\n</code></pre>\n<h2 id=\"④-B-树\"><a href=\"#④-B-树\" class=\"headerlink\" title=\"④.B+树\"></a>④.B+树</h2><p><strong>m阶B+树的定义</strong></p>\n<ul>\n<li>树中每个非叶结点最多有m棵子树;</li>\n<li>根结点(非叶结点)至少有2棵子树。除根结点外，其它的非叶结点至少有⌈m&#x2F;2⌉棵子树;</li>\n<li>所有叶结点都处于同一层次上，包含了全部关键码及指向相应数据对象存放地址的指针，且叶结点本身按关键码从小到大顺序链接。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/ae8a3ca41fc842c5b8eb555864cb8e50.png#pic_center\"></p>\n<ul>\n<li>在B+树中有两个头指针:一个指向B+树的根结点，一个指向关键码最小的叶结点。</li>\n</ul>\n<p>可对B+树进行两种搜索运算:</p>\n<p>循叶结点链顺序搜索<br>另一种是从根结点开始,进行自顶向下,直至叶结点的随机搜索。<br>在B+树上进行随机搜索、插入和删除的过程基本上与B-树类似。只是在搜索过程中，如果非叶结点上的关键码等于给定值，搜索并不停止，而是继续沿右指针向下，一直查到叶结点上的这个关键码。</p>\n<p><strong>B+树的搜索分析</strong></p>\n<p>B+树的插入仅在叶结点上进行。每插入一个(关键码-指针)索引项后都要判断结点中的子树棵数是否超出范围。<br>当插入后结点中的子树棵数n &gt; m1 时，需要将叶结点分裂为两个结点，它们的关键码分别为⌈(m1+1)&#x2F;2⌉和⌊(m1+1)&#x2F;2⌋.<br>它们的双亲结点中应同时包含这两个结点的最大关键码和结点地址。此后，问题归于在非叶结点中的插入了。</p>\n<p><strong>B+树的删除</strong></p>\n<p>仅在叶结点上进行。当在叶结点上删除一个(关键码-指针)索引项后,结点中的子树棵数仍然不少于⌈m1&#x2F;2⌉，这属于简单删除，其上层索引可以不改变。<br>如果删除的关键码是该结点的最小关键码,但因在其上层的副本只是起了一个引导搜索的“分界关键码”的作用,所以上层的副本仍然可以保留。<br>如果在叶结点中删除一个(关键码-指针)索引项后，该结点中的子树棵数n小于结点子树棵数的下限⌈m1&#x2F;2⌉，必须做结点的调整或合并工作。</p>\n<p>如果右兄弟结点的子树棵数已达到下限⌈m1&#x2F;2⌉ ，没有多余的关键码可以移入被删关键码所在的结点，必须进行两个结点的合并。将右兄弟结点中的所有(关键码-指针)索引项移入被删关键码所在结点，再将右兄弟结点删去。<br>结点的合并将导致双亲结点中“分界关键码”的减少，有可能减到叶结点中子树棵数的下限⌈m&#x2F;2⌉以下。这样将引起非叶结点的调整或合并。如果根结点的最后两个子女结点合并，树的层数就会减少一层。</p>\n<p><strong>B-树与B+树的差异</strong></p>\n<p>B树分为B-树和B＋树，它们的树结构大致相同。一个m阶的B+树与B-树的差异是:</p>\n<ol>\n<li>在B-树中，每个结点含有n个关键字和n+1棵子树，而在B+树中，每个结点含有n个关键字和n棵子树;</li>\n<li>在B-树中，每个结点(除根结点外）中的关键字个数n的取值范围是:⌈m&#x2F;2⌉-1≤n≤m-1<br>;在B+树中，每个结点（除根结点外）中的关键字个数n的取值范围是:⌈m&#x2F;2⌉ ≤n≤m，树根结点的取值范围是:1≤n≤m。</li>\n<li>B＋树中的所有叶子结点包含了全部关键字及指向对应记录的指针，且所有叶子结点按关键字从小到大的顺序依次链接;</li>\n<li>B＋树中所有非叶子结点仅起到索引的作用，即结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。</li>\n</ol>\n<hr>\n<h1 id=\"4、散列表的查找\"><a href=\"#4、散列表的查找\" class=\"headerlink\" title=\"4、散列表的查找\"></a>4、散列表的查找</h1><h2 id=\"①-散列表的基本概念\"><a href=\"#①-散列表的基本概念\" class=\"headerlink\" title=\"①.散列表的基本概念\"></a>①.散列表的基本概念</h2><p>&#x3D;&#x3D;<strong>散列表</strong>：是一个有限连续的地址空间，是一种存储结构。&#x3D;&#x3D;</p>\n<p>&#x3D;&#x3D;<strong>散列地址</strong>:数据元素（记录)的存储位置。&#x3D;&#x3D;</p>\n<p>通常情况下︰散列表是一维数组，散列地址是数组的下标。</p>\n<p>&#x3D;&#x3D;<strong>散列函数</strong>:在数据元素（记录)的存储位置p和关键字key之间建立一个确定的对应关系H，使p&#x3D;H(key)，称这个对应关系H为散列函数，p为散列地址。&#x3D;&#x3D;</p>\n<p>&#x3D;&#x3D;<strong>散列方法</strong>：选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放。查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键字进行比较，确定查找是否成功。&#x3D;&#x3D;</p>\n<p>&#x3D;&#x3D;<strong>冲突</strong>：不同的关键字映射到同一个散列地址，即key 1≠key2，而H(key1)&#x3D;H(key2)，这种现象称为冲突，key1和key2互称为同义词。&#x3D;&#x3D;</p>\n<h2 id=\"②-散列函数的构造方法\"><a href=\"#②-散列函数的构造方法\" class=\"headerlink\" title=\"②.散列函数的构造方法\"></a>②.散列函数的构造方法</h2><p><strong>直接定址法</strong></p>\n<p>即H(key)&#x3D;a·key + b (a、b为常数)。</p>\n<ul>\n<li>优点:这种散列函数计算简单，并且不可能有冲突发生。</li>\n<li>缺点:当关键字的分布基本连续时，可用直接定址法的散列函数;否则，若关键字分布不连续将造成内存单元的大量浪费。</li>\n<li>如:H(学号)&#x3D;学号-201816010101<br><img src=\"https://img-blog.csdnimg.cn/89610a6727ee402499eeb3325b4d91bb.png#pic_center\"></li>\n</ul>\n<p><strong>除留余数法</strong></p>\n<p>设散列表长度为m，用关键字key除以一个不大于m的数p，所得的余数作为散列地址的方法。<br>除留余数法的散列函数H(key)为:H(key)&#x3D;key mod p (mod为求余运算，p≤m)<br>这个方法的关键是选取适当的p，一般情况下，可以选p为小于表长的最大质数。例如，表长m &#x3D; 100，可取p &#x3D;97。</p>\n<h2 id=\"③-处理冲突的方法\"><a href=\"#③-处理冲突的方法\" class=\"headerlink\" title=\"③.处理冲突的方法\"></a>③.处理冲突的方法</h2><p>“处理冲突”的实际含义是:为产生冲突的地址寻找下一个散列地址。</p>\n<p><strong>开放地址法</strong></p>\n<p><strong>基本方法:当冲突发生时，形成某个探测序列;按此序列逐个探测散列表中的其他地址，直到找到给定的关键字或一个空地址(开放的地址)为止，将发生冲突的记录放到该地址中。</strong></p>\n<p>新的散列地址的计算公式是:<br>H<del>i</del>(key)&#x3D;(H(key)+d<del>i</del>)MOD m, i&#x3D;1，2，…， k(k≤m-1)</p>\n<p>其中:</p>\n<ul>\n<li>H(key):散列函数;</li>\n<li>m:散列表长度;</li>\n<li>d<del>i</del>:第i次探测时的增量序列;</li>\n<li>H<del>i</del>(key) :经第i次探测后得到的散列地址。</li>\n</ul>\n<p><strong>探测:是指寻找“下一个”空位的过程。</strong></p>\n<p>对增量d<del>i</del>有三种取法:</p>\n<ol>\n<li><strong>线性探测法</strong>:依次循环探测d的下一个地址，即一旦冲突，就找附近（下一个）空地址存入。d<del>i</del> &#x3D; 1,2,3,… . ..m-1</li>\n<li><strong>二次探测法</strong>:发生冲突时前后查找空位置 d<del>i</del>&#x3D;1^2^,-1^2^,2^2^,-2^3^,3^2^,……±k^2^ (k ≤ m&#x2F;2)</li>\n<li><strong>随机探测法</strong>：d<del>i</del>是一组伪随机数列或者 d<del>i</del> &#x3D; i×H<del>2</del>(key)(又称双散列函数探测)</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/e42268c18d3d41a5abf4c4a82629e780.png#pic_center\"></p>\n<p><strong>链地址法</strong></p>\n<p><strong>基本思想:将具有相同散列地址的记录链成一个单链表，m个散列地址就设m个单链表，然后用一个数组将m个单链表的表头指针存储起来，形成一个动态的结构</strong></p>\n<p>单链表中存放的是同义词，称为同义词链表。在这种方法中，散列表每个单元中存放的不再是记录本身，而是相应同义词单链表的头指针</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d4596ff7aa704ed7980e7e105bd50f53.png#pic_center\"></p>\n<h2 id=\"④-散列表的查找\"><a href=\"#④-散列表的查找\" class=\"headerlink\" title=\"④.散列表的查找\"></a>④.散列表的查找</h2><p>哈希表的查找过程和建表过程一致，以开放定址法为例:</p>\n<ol>\n<li>求出k的哈希地址</li>\n<li>若表中此位置上为空记录,则查找失败，返回;也可将关键字等于k的记录填入</li>\n<li>如果该分量不空且关键字&#x3D;k,则成功返回;否则按设定的处理冲突的方法找下一地址</li>\n<li>重复前两步</li>\n</ol>\n<pre><code class=\"cpp\">#include&lt;stdio.h&gt;\n#include&lt;malloc.h&gt;\n#include&lt;string.h&gt;\n#define MaxSize 1000\ntypedef struct node\n&#123;\n    int key;\n    struct node *next;\n&#125;NodeType;\ntypedef struct\n&#123;\n    NodeType*first;\n&#125;HashTable;\nHashTable ha[MaxSize];//哈希表\nint keys[MaxSize];//存键值\nvoid Insert(HashTable ha[],int m,int key)\n&#123;\n    int adr;\n    adr=key%m;//关键字%哈希表长度\n    NodeType *q;\n    q=(NodeType*)malloc(sizeof(NodeType));\n    q-&gt;key=key;\n    q-&gt;next=NULL;\n    //通过链接形成某地址的哈希表\n    if(ha[adr].first==NULL)\n    &#123;\n        ha[adr].first=q;\n    &#125;else//头插法\n    &#123;\n        q-&gt;next=ha[adr].first;\n        ha[adr].first=q;\n    &#125;\n&#125;\nvoid Seek(HashTable ha[],int m,int k)\n&#123;\n    int i=0,adr;\n    adr=k%m;\n    //判断是哪一个地址的哈希表\n    NodeType *q;\n    q=ha[adr].first;\n    //q为当前地址的哈希表的头指针\n    while(q!=NULL)\n    &#123;\n        i++;\n        if(q-&gt;key==k) break;\n        q=q-&gt;next;\n    &#125;\n    if(q!=NULL)\n    printf(&quot;%d,%d&quot;,adr,i);\n    else\n    printf(&quot;-1&quot;);\n&#125;\nint main()\n&#123;\n    int m,n,k;\n    scanf(&quot;%d&quot;,&amp;m);//哈希表长度\n    scanf(&quot;%d&quot;,&amp;n);//关键字个数\n    for(int i=0;i&lt;n;i++)\n    &#123;\n        scanf(&quot;%d&quot;,&amp;keys[i]);//关键字集合\n    &#125;\n    for(int i=0;i&lt;m;i++)\n    &#123;\n        ha[i].first=NULL;\n    &#125;\n    for(int i=0;i&lt;n;i++)\n    &#123;\n        Insert(ha,m,keys[i]);///插入哈希表\n    &#125;\n    scanf(&quot;%d&quot;,&amp;k);\n    Seek(ha,m,k);\n&#125;\n\n</code></pre>\n<p>例：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/e7fa0925f32b43728434c3c18b80427e.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/72ee8aa52f954231a9736593270c1647.png#pic_center\"></p>\n<hr>\n<h1 id=\"5、总结\"><a href=\"#5、总结\" class=\"headerlink\" title=\"5、总结\"></a>5、总结</h1><p>查找是数据处理中经常使用的一种操作。本章主要介绍了对查找表的查找，查找表实际上仅仅是一个集合，为了提高查找效率，将查找表组织成不同的数据结构，主要包括3种不同结构的查找表:线性表、树表和散列表。</p>\n<p>( 1 ）<strong>线性表的查找</strong>。主要包括顺序查找、折半查找和分块查找。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/1848afbe5bd64d61a1ffb8d7de83dd61.png#pic_center\"></p>\n<p>(2)<strong>树表的查找</strong>。树表的结构主要包括二叉排序树、平衡二叉树、B-树和B＋树。</p>\n<p>①二叉排序树的查找过程与折半查找过程类似。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/24f1eda45b674ac798493aeb480c2cc0.png#pic_center\"></p>\n<p>②二叉排序树在形态均匀时性能最好，而形态为单支树时其查找性能则退化为与顺序查找相同，因此，二叉排序树最好是一棵平衡二叉树。平衡二叉树的平衡调整方法就是确保二叉排序树在任何情况下的深度均为O(logzn )，平衡调整方法分为4种:LL型、RR型、LR型和RL型。</p>\n<p>③B-树是一种平衡的多叉查找树，是一种在外存文件系统中常用的动态索引技术。在B-树上进行查找的过程和二叉排序树类似，是一个顺指针查找结点和在结点内的关键字中查找交叉进行的过程。为了确保B-树的定义，在B-树中插人一个关键字，可能产生结点的“分裂”，而删除一个关键字，可能产生结点的“合并”。</p>\n<p>④B+树是一种B-树的变型树，更适合做文件系统的索引。在B+树上进行随机查找、插人和删除的过程基本上与B-树类似,但具体实现细节又有所区别。</p>\n<p>(3）<strong>散列表的查找</strong>。散列表也属线性结构，但它和线性表的查找有着本质的区别。它不是以关键字比较为基础进行查找的，而是通过一种散列函数把记录的关键字和它在表中的位置建立起对应关系，并在存储记录发生冲突时采用专门的处理冲突的方法。这种方式构造的散列表，不仅平均查找长度和记录总数无关，而且可以通过调节装填因子，把平均查找长度控制在所需的范围内。</p>\n<p>散列查找法主要研究两方面的问题:如何构造散列函数，以及如何处理冲突。</p>\n<p>①构造散列函数的方法很多,除留余数法是最常用的构造散列函数的方法。它不仅可以对关键字直接取模,也可在折叠、平方取中等运算之后取模。</p>\n<p>②处理冲突的方法通常分为两大类:开放地址法和链地址法，二者之间的差别类似于顺序表和单链表的差别。<br><img src=\"https://img-blog.csdnimg.cn/29d137146df4435485b65a5af69b0e86.png#pic_center\"></p>\n<hr>\n<h1 id=\"6、例题与应用\"><a href=\"#6、例题与应用\" class=\"headerlink\" title=\"6、例题与应用\"></a>6、例题与应用</h1><p><img src=\"https://img-blog.csdnimg.cn/dba4e69e86a4489380b4dfaf27396bd4.png#pic_center\"><br>采用除留余数法实现哈希表的创建，任意采用一种处理冲突的方法解决冲突，计算哈希表的平均查找长度。编程实现以下功能：<br>已知一组关键字(19,14,23,1,68,20,84,27,55,11,10,79)，哈希函数定义为：H(key)&#x3D;key MOD 13, 哈希表长为m&#x3D;16。实现该哈希表的散列，并计算平均查找长度（设每个记录的查找概率相等）。<br>（1）哈希表定义为定长的数组结构；<br>（2）使用线性探测再散列或链地址法解决冲突；<br>（3）散列完成后在屏幕上输出数组内容或链表；<br>（4）输出等概率查找下的平均查找长度；<br>（5）完成散列后，输入关键字完成查找操作，要分别测试查找成功与查找不成功两种情况。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/4f3d13af2c4144f7a0990d1ebb0bbe50.png#pic_center\"></p>\n<pre><code class=\"cpp\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#define N 13\n#define Hashsize 16\n\nint sign = 2;\n\ntypedef struct Hash\n&#123;\n    int date;\n    int sign;\n&#125; HashNode;\n//线性冲突处理\nvoid compare(HashNode H[], int p, int i, int key[])\n&#123;\n    p++;\n    if (H[p].sign != 0)\n    &#123;\n        sign++;\n        compare(H, p, i, key);\n    &#125;\n    else\n    &#123;\n        H[p].date = key[i];\n        H[p].sign = sign;\n        sign = 2;\n    &#125;\n&#125;\n\nvoid Hashlist(HashNode H[], int key[])\n&#123;\n    int p;\n    for (int i = 0; i &lt; 12; i++)\n    &#123;\n        p = key[i] % N;\n\n        if (H[p].sign == 0)\n        &#123;\n            H[p].date = key[i];\n            H[p].sign = 1;\n        &#125;\n        else\n            compare(H, p, i, key);\n    &#125;\n&#125;\n//查找冲突处理\nint judge(HashNode H[], int num, int n)\n&#123;\n    n++;\n\n    if (n &gt;= Hashsize)\n        return 0;\n\n    if (H[n].date == num)\n    &#123;\n        printf(&quot;位置\\t数据\\n&quot;);\n        printf(&quot;%d\\t %d\\n\\n&quot;, n, H[n].date);\n        return 1;\n    &#125;\n    else\n    &#123;\n        judge(H, num, n);\n    &#125;\n&#125;\n//查找\nint search(char num, HashNode H[])\n&#123;\n    int n;\n    n = num % N;\n    if (H[n].sign == 0)\n    &#123;\n        printf(&quot;查找失败！&quot;);\n        return 0;\n    &#125;\n    if (H[n].sign != 0 &amp;&amp; H[n].date == num)\n    &#123;\n        printf(&quot;位置\\t数据\\n&quot;);\n        printf(&quot;%d\\t %d\\n&quot;, n, H[n].date);\n    &#125;\n    else if (H[n].sign != 0 &amp;&amp; H[n].date != num)\n    &#123;\n        if (judge(H, num, n) == 0)\n            return 0;\n    &#125;\n    return 1;\n&#125;\n\nint main(void)\n&#123;\n    int key[N] = &#123;19, 14, 23, 1, 68, 20, 84, 27, 55, 11, 10, 79&#125;;\n    float a = 0;\n    HashNode H[Hashsize];\n    for (int i = 0; i &lt; Hashsize; i++)\n        H[i].sign = 0;\n    Hashlist(H, key);\n    printf(&quot;建立好的哈希表如下所示:\\n位置\\t\\t数据\\n&quot;);\n    for (int i = 0; i &lt; Hashsize; i++)\n    &#123;\n        if (H[i].sign != 0)\n        &#123;\n            printf(&quot;%d\\t--&gt;\\t%d\\n&quot;, i, H[i].date);\n        &#125;\n        else\n        &#123;\n            H[i].date = 0;\n            printf(&quot;%d\\t--&gt;\\t%d\\n&quot;, i, H[i].date);\n        &#125;\n    &#125;\n    int num;\n    printf(&quot;输入查找数值(输入-1退出):\\n&quot;);\n    for (int i = 0;; i++)\n    &#123;\n        scanf(&quot;%d&quot;, &amp;num);\n        if (num == -1)\n            break;\n        if (search(num, H) == 0)\n            printf(&quot;该数值不存在！\\n&quot;);\n    &#125;\n    for (int i = 0; i &lt; Hashsize; i++)\n    &#123;\n        a = a + H[i].sign;\n    &#125;\n    printf(&quot;平均查找长度:%0.2f\\n&quot;, a / 12);\n    return 0;\n&#125;\n</code></pre>\n","feature":true,"text":"查找是数据处理中经常使用的一种操作。本章主要介绍了对查找表的查找，查找表实际上仅仅是一个集合，为了提高查找效率，将查找表组织成不同的数据结构，主要包括3种不同结构的查找表:线性表、树表和散列表。...","permalink":"/post/数据结构（C语言版）-- 查找笔记","photos":[],"count_time":{"symbolsCount":"27k","symbolsTime":"25 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"字节跳动青训营","slug":"字节跳动青训营","count":21,"path":"api/tags/字节跳动青训营.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1、查找的基本概念</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">2、线性表的查找</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">①.顺序查找</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">②.折半查找</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A2-%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">③.分块查找</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">3、树表的查找</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91\"><span class=\"toc-text\">①.二叉排序树</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">②.平衡二叉树</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A2-B-%E6%A0%91\"><span class=\"toc-text\">③.B-树</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A3-B-%E6%A0%91\"><span class=\"toc-text\">④.B+树</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4%E3%80%81%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">4、散列表的查找</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">①.散列表的基本概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">②.散列函数的构造方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A2-%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">③.处理冲突的方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A3-%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">④.散列表的查找</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5%E3%80%81%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">5、总结</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#6%E3%80%81%E4%BE%8B%E9%A2%98%E4%B8%8E%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">6、例题与应用</span></a></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"排序","uid":"2a1893ca085cc0c5b7d1cdcd8c0b1c91","slug":"数据结构（C语言版）-- 排序笔记","date":"2022-02-20T13:06:27.000Z","updated":"2025-07-14T15:12:20.469Z","comments":true,"path":"api/articles/数据结构（C语言版）-- 排序笔记.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/615f198050724f5e8140b446a34d7f7c.png","text":"排序是计算机内经常进行的一种操作，其目的是将一组“无序”的记录序列调整为“有序”的记录序列。排序的目的是为了便于查找。...","permalink":"/post/数据结构（C语言版）-- 排序笔记","photos":[],"count_time":{"symbolsCount":"33k","symbolsTime":"30 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"字节跳动青训营","slug":"字节跳动青训营","count":21,"path":"api/tags/字节跳动青训营.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true},"next_post":{"title":"图","uid":"0b9c5318228023fdd1e179358a45ba07","slug":"数据结构（C语言版）-- 图笔记","date":"2022-02-20T12:59:01.000Z","updated":"2025-07-14T15:12:20.468Z","comments":true,"path":"api/articles/数据结构（C语言版）-- 图笔记.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/56d020cfc5f84516b5980d6710ece105.png","text":"图(Graph )G由两个集合V和E组成，记为G=(V,E)，其中V是顶点的有穷非空集合，E是V中顶点偶对的有穷集合，这些顶点偶对称为边。V(G)和E(G)通常分别表示图G的顶点集合和边集合，E(G)可以为空集。若E(G)为空，则图G只有顶点而没有边。...","permalink":"/post/数据结构（C语言版）-- 图笔记","photos":[],"count_time":{"symbolsCount":"62k","symbolsTime":"56 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"字节跳动青训营","slug":"字节跳动青训营","count":21,"path":"api/tags/字节跳动青训营.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true}}