{"title":"数据库原理及应用概述","uid":"ddc9a9789fb65bc02a967a2d0baf7db8","slug":"计算机数据库原理及应用概述","date":"2023-02-10T04:36:13.000Z","updated":"2025-07-14T15:12:20.470Z","comments":true,"path":"api/articles/计算机数据库原理及应用概述.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/direct/ee77d7ad8e324cd4aa3a7c8b88696a75.png","content":"<h1 id=\"数据库原理及应用\"><a href=\"#数据库原理及应用\" class=\"headerlink\" title=\"数据库原理及应用\"></a>数据库原理及应用</h1><h1 id=\"1、数据库系统概述\"><a href=\"#1、数据库系统概述\" class=\"headerlink\" title=\"1、数据库系统概述\"></a>1、数据库系统概述</h1><h2 id=\"1-1-基本概念\"><a href=\"#1-1-基本概念\" class=\"headerlink\" title=\"1.1 基本概念\"></a>1.1 基本概念</h2><p><strong>数据data</strong></p>\n<ul>\n<li>数据库中存储的基本对象，描述事物的符号记录</li>\n</ul>\n<p><strong>数据库DB</strong></p>\n<ol>\n<li><strong>长期存储在计算机内</strong></li>\n<li><strong>有组织的</strong></li>\n<li><strong>可共享的大量数据的集合</strong></li>\n</ol>\n<ul>\n<li>数据管理：数据查询、(数据更新)数据插入、数据删除、数据修改</li>\n</ul>\n<p><strong>数据库管理系统</strong></p>\n<ul>\n<li>位于用户和计算机操作系统之间的一层数据管理软件</li>\n<li>主要功能：<ul>\n<li>数据定义</li>\n<li>数据操作</li>\n<li>事务管理和运行管理</li>\n<li>数据存储和查询处理</li>\n<li>建立和维护功能</li>\n</ul>\n</li>\n</ul>\n<p><strong>数据库系统DBS</strong></p>\n<ul>\n<li>采用数据库技术的计算机系统称为DBS</li>\n<li>组成：数据库DB、数据库管理系统DBMS、数据库管理员DBA、应用程序</li>\n<li>优点：<ul>\n<li>数据整体结构化 – 数据库系统与文件系统的本质区别</li>\n<li><strong>数据的共享性高、冗余度低、易扩充</strong></li>\n<li>数据独立性高<ul>\n<li>物理独立性：数据库数据的存储结构与存取方法与外部应用程序独立</li>\n<li>逻辑独立性：局部逻辑数据结构与全局逻辑数据结构之间的独立性</li>\n</ul>\n</li>\n<li>数据统一由DBMS控制</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"1-2-数据模型\"><a href=\"#1-2-数据模型\" class=\"headerlink\" title=\"1.2 数据模型\"></a>1.2 数据模型</h2><ul>\n<li><p>数据模型是一种形式机制，用于数据建模，描述数据、数据之间的联系、数据的语义、数据上的操作和数据的完整性约束条件</p>\n</li>\n<li><p><strong>概念模型(信息模型)<strong>：</strong>实体-联系</strong>(E-R)模型是一种广泛使用的概念模型</p>\n</li>\n<li><p>数据模型的三要素</p>\n<ul>\n<li><strong>数据结构</strong>：数据结构描述数据库中的对象和对象之间的联系，是对系统静态特性的描述</li>\n<li><strong>数据操作</strong>：数据操作定义数据库中各种数据对象的实例上允许执行的操作和操作规则(查询和更新)，是对系统动态特性的描述</li>\n<li><strong>数据完整性约束</strong>：数据的完整性约束条件是一组规则，用以限定符合数据模型的数据库状态和状态的变化，保证数据的正确、有效和相容</li>\n</ul>\n</li>\n<li><p>目前最流行的数据模型是<strong>关系模型</strong></p>\n</li>\n<li><p>关系的每个属性必须取原子值</p>\n</li>\n</ul>\n<h2 id=\"1-3-数据库系统的结构\"><a href=\"#1-3-数据库系统的结构\" class=\"headerlink\" title=\"1.3 数据库系统的结构\"></a>1.3 数据库系统的结构</h2><ul>\n<li>模式：对全体数据逻辑结构和特征的描述，对型的描述，不涉及具体值</li>\n<li>实例：模式的一个具体值</li>\n</ul>\n<p><strong>三级模式</strong></p>\n<ul>\n<li><strong>外模式：</strong>外模式也称子模式或用户模式。外模式介于模式与应用之间，是特定数据库用户的数据视图，是与某一具体应用相关的数据局部逻辑结构的描述，<strong>一个数据库有多个外模式</strong></li>\n<li><strong>模式：</strong>模式也称逻辑模式。模式是数据库中<strong>全体数据的总体逻辑结构描述</strong>，是所有用户的公共数据视图，<strong>一个数据库只有一个模式</strong></li>\n<li><strong>内模式：</strong>内模式也称存储模式或物理模式。内模式是数据物理结构和存储方式的描述，定义数据在数据库内部的表示方式，<strong>一个数据库只有一个内模式</strong></li>\n</ul>\n<p><strong>二级映像</strong></p>\n<ul>\n<li><p><strong>外模式–模式映像</strong></p>\n<ul>\n<li>保证数据的逻辑独立性</li>\n</ul>\n</li>\n<li><p><strong>模式–内模式映像</strong></p>\n<ul>\n<li>保证数据的物理独立性</li>\n<li>唯一的</li>\n</ul>\n</li>\n</ul>\n<p><strong>扩展</strong></p>\n<ul>\n<li>数据库系统提供三种语言:DDL用于定义数据库模式，DML用于表达数据库的查询和更新，而 DCL用于定义用户对数据对象的访问权限。这三种语言不是独立的，而是集成在一起，形成完整的数据库语言。</li>\n<li>数据管理员负责管理数据库，实施数据的集中控制。</li>\n</ul>\n<h1 id=\"2、实体-–-联系模型\"><a href=\"#2、实体-–-联系模型\" class=\"headerlink\" title=\"2、实体 – 联系模型\"></a>2、实体 – 联系模型</h1><h2 id=\"2-1-基本概念\"><a href=\"#2-1-基本概念\" class=\"headerlink\" title=\"2.1  基本概念\"></a>2.1  基本概念</h2><ul>\n<li><p>实体：客观存在并且可以相互区分的任何事物，可以是实际对象，也可以是抽象模型</p>\n</li>\n<li><p>实体集：具有相同属性的实体的集合</p>\n</li>\n<li><p>码：</p>\n<ul>\n<li>超码：能够<strong>唯一确定</strong>实体集中每个实体的属性集，(<strong>包含无关紧要属性的码</strong>)</li>\n<li>候选码：真子集都不是超码的极小超码**(”最小“超码)**</li>\n<li>主码：用来区分同一实体集中不同实体的候选码**(从候选码中选即可)**，(<strong>最多只能有一个的码</strong>)</li>\n<li>码：表示主码或候选码<ul>\n<li>对于学生实体集中，{学号}和{学号，姓名}都是超码，{学号}是极小超码，因为它的真子集是空集，不是超码，如果不允许重名的话，{姓名}也是极小超码，{学号}，{姓名}都是候选码，可以选择{学号}作为主码</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>属性：</p>\n<ul>\n<li>简单属性：<strong>不能划分成更小</strong>部分的属性</li>\n<li>复合属性：<strong>可以划分成更小</strong>部分的属性(具有层次关系)</li>\n<li>单值属性：是特定的实体在该属性上只能取<strong>单个值</strong>的属性</li>\n<li>多值属性：是特定的实体在该属性上只能取<strong>多个值</strong>的属性(具有对等关系)</li>\n<li>基本属性：不能通过其他属性的值来推导出来（即它的值必须存储在系统中）的属性</li>\n<li>派生属性：派生属性的值可以从其他相关属性或实体计算得到，因此派生属性又称计算属性</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/39a98d41ed22453ba3d64569f69d1f20.png\"></p>\n<ul>\n<li>E-R图：</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/90ed73eef1a8415bb01506fcacab3e05.png\"></p>\n<h2 id=\"2-2-实体-联系图\"><a href=\"#2-2-实体-联系图\" class=\"headerlink\" title=\"2.2 实体-联系图\"></a>2.2 实体-联系图</h2><ul>\n<li><p>联系是多个实体之间的相互联系</p>\n</li>\n<li><p>联系集是相同类型联系的集合</p>\n</li>\n<li><p><strong>联系的类型</strong></p>\n<ul>\n<li>一对一联系</li>\n<li>一对多(多对一)联系</li>\n<li>多对多联系</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/e8a4c62a4a59422693572ef1a166658e.png\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/7793bf1f6f934c108306b0bef3a0f191.png\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/500e1402a03846e98c36453bb2ff6c55.png\"></p>\n<h2 id=\"2-3-弱实体集\"><a href=\"#2-3-弱实体集\" class=\"headerlink\" title=\"2.3 弱实体集\"></a>2.3 弱实体集</h2><ul>\n<li>如果一个实体集的任何属性集都不足以形成该实体集的码，则称该实体集为<strong>弱实体集</strong></li>\n<li>存在码的实体集称为<strong>强实体集</strong></li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/2a61b385b7c14ffeadfc3049cb0a9ba4.png\"></p>\n<ul>\n<li>标识实体集： 弱实体集必须与另一个<strong>称作标识实体集</strong>或<strong>属主实体集</strong>的强实体集相关联才有意义</li>\n<li>标识性联系： 标识实体集与弱实体集相关联的联系称为标识性联系，表示法：<strong>双线菱形</strong></li>\n<li>分辨符： 如果一个属性可以惟一确定存在依赖于同一个强实体的弱实体，则称该属性集为弱实体集的分辨符，表示法：<strong>虚下划线</strong></li>\n<li>弱实体的码： 弱实体集的<strong>标识实体集的码</strong>和该<strong>弱实体集的分辨符</strong>共同形成弱实体集的码</li>\n<li>部分码： 弱实体集的分辨符又称弱实体集的部分码</li>\n<li>可以与多个标识实体集关联：有的弱实体集还可以与多个标识实体集关联，该弱实体集的码由诸标识实体集的码和弱实体集的分辨符的组合</li>\n<li>另一种处理弱实体集的方法：把它作为其标识实体集的一个多值复合属性，例如可以把家属作为职工的一个多值属性</li>\n<li><strong>不好的设计:</strong> 方法将强实体集的码添加到弱实体集的属性集中，将弱实体集转化成强实体集</li>\n</ul>\n<h1 id=\"3、关系数据模型\"><a href=\"#3、关系数据模型\" class=\"headerlink\" title=\"3、关系数据模型\"></a>3、关系数据模型</h1><h2 id=\"3-1-关系数据库的结构\"><a href=\"#3-1-关系数据库的结构\" class=\"headerlink\" title=\"3.1 关系数据库的结构\"></a>3.1 关系数据库的结构</h2><ul>\n<li><p>关系模型只包含单一的数据结构 – <strong>关系</strong></p>\n</li>\n<li><p>域：一个具有相同数据类型的值的集合 – 顺序的取值范围</p>\n</li>\n<li><p>基数：一个域允许的不同取值个数</p>\n</li>\n<li><p>笛卡尔积：域上面的一种集合运算 – 得到每个域中元素的所有可能的组合 – 基数相乘</p>\n</li>\n<li><p>关系：笛卡尔积的子集叫做其在域上的集合(<strong>可以用二维表和集合来表示关系</strong>)</p>\n</li>\n<li><p>除了语义约束外，对关系的限制主要有两点：</p>\n<ul>\n<li>第一，在关系数据库中，<strong>只考虑有限关系</strong></li>\n<li>第二，<strong>关系的每个属性都必须是原子的</strong></li>\n</ul>\n</li>\n<li><p>关系模式概念对应于程序设计语言中的类型概念，是对关系型的描述，可以表示为<strong>R(U, D, DOM, F) – 关系模式名(关系模式的诸属性，属性对应的域，U到D的映射，属性间的数据依赖集定义)</strong></p>\n</li>\n<li><p><strong>二维表表示关系时列的次序不重要</strong></p>\n</li>\n<li><p>外码是另外一个表的主码</p>\n</li>\n</ul>\n<h2 id=\"3-2-从ER模型到关系模型\"><a href=\"#3-2-从ER模型到关系模型\" class=\"headerlink\" title=\"3.2 从ER模型到关系模型\"></a>3.2 从ER模型到关系模型</h2><ul>\n<li><p>属性处理</p>\n<ul>\n<li>派生属性的处理:转换时我们<strong>忽略</strong>派生属性</li>\n<li>复合属性的处理:忽略复合属性本身，而<strong>直接考虑</strong>它的成分属性</li>\n<li>多值属性的处理:为每个多值属性M创建一个关系Rm</li>\n</ul>\n</li>\n<li><p>实体集处理</p>\n<ul>\n<li>强实体集处理：实体集名可以作为关系名,实体集的全部属性构成关系的属性</li>\n<li>弱实体集处理：弱实体集名可以作为关系名,弱实体集存在依赖的标识实体集的主码和弱实体集的全部属性构成关系的属性</li>\n</ul>\n</li>\n<li><p>联系集处理</p>\n</li>\n<li><p>方法一：<strong>联系转换成关系模式</strong></p>\n<ul>\n<li>联系是<strong>一对一</strong>的，则<strong>每个实体集的码都是关系的码</strong></li>\n<li>联系是<strong>一对多(多对一)<strong>的，则</strong>“多端”</strong>实体集的码组合成关系的码</li>\n<li>联系是<strong>多对多</strong>的，则<strong>参与联系的所有实体集的码组合</strong>成关系的码</li>\n</ul>\n</li>\n<li><p>方法二：<strong>合并</strong></p>\n<ul>\n<li>联系是一对一的，则可以和任意一端实体集转换得到的关系模式合并</li>\n<li>联系是一对多的，则和多端实体集转换得到的关系模式合并</li>\n<li>联系是多对多的，则该联系集转换成独立的关系模式</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-3-关系操作、完整性约束、关系代数\"><a href=\"#3-3-关系操作、完整性约束、关系代数\" class=\"headerlink\" title=\"3.3 关系操作、完整性约束、关系代数\"></a>3.3 关系操作、完整性约束、关系代数</h2><ul>\n<li><p>关系语言的分类 ：关系代数、关系演算、SQL语言</p>\n</li>\n<li><p>完整性分类：</p>\n<ul>\n<li><strong>实体完整性</strong>：关系R的所有元组在主码上的值<strong>必须惟一</strong>，并且在主码的任何属性上都<strong>不能取空值</strong></li>\n<li><strong>参照完整性</strong>：如果属性集FK是关系R的外码(一个关系中的一个属性是另外一个关系中的主码则这个属性为外码)，它参照关系S的主码Ks ,则R的任何元组在FK上的值等于S的某个元组在主码Ks上的值，或者为空值，<strong>对外码取值限制</strong></li>\n<li><strong>用户自定义完整性</strong>：反映特定的数据库所涉及的数据必须满足的语义约束条件。由于不存在一般性规则，这些约束条件必须由用户根据实际问题的语义指定，<strong>对候选码取值限制</strong></li>\n</ul>\n</li>\n<li><p>基本运算：选择(一元运算符)、投影(一元运算符)、并、差、笛卡尔积</p>\n</li>\n<li><p>附加运算：交、除、连接、自然连接（必须有同名属性才能进行）</p>\n</li>\n</ul>\n<h1 id=\"4、关系数据库的设计理论\"><a href=\"#4、关系数据库的设计理论\" class=\"headerlink\" title=\"4、关系数据库的设计理论\"></a>4、关系数据库的设计理论</h1><ul>\n<li>不好的关系模式：冗余、插入异常、更新异常、删除异常</li>\n</ul>\n<h2 id=\"4-1-函数依赖\"><a href=\"#4-1-函数依赖\" class=\"headerlink\" title=\"4.1 函数依赖\"></a>4.1 函数依赖</h2><ul>\n<li>数据依赖是语义概念,是关于关系诸属性值之间内在相关性的陈述,它规定了关系模式的合法关系实例所必须满足的条件</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/6818e80d950244bfab006a0bb0af7d12.png\"></p>\n<ul>\n<li>平凡的函数依赖(X包含Y)、非平凡的函数依赖</li>\n</ul>\n<h2 id=\"4-2-关系模式\"><a href=\"#4-2-关系模式\" class=\"headerlink\" title=\"4.2 关系模式\"></a>4.2 关系模式</h2><ul>\n<li><p><strong>1NF</strong>要求关系的所有属性值都是原子的，是对关系模式的基本要求，不满足1NF的数据模式不能称为关系模式，即所有关系模式都是1NF</p>\n</li>\n<li><p><strong>2NF</strong>对于任意的非平凡函数依赖X→A∈F^+^ :<strong>A是主属性，X不是R的任意码的真子集</strong></p>\n</li>\n<li><p><strong>3NF</strong>对于任意的非平凡函数依赖X→A∈F^+^：<strong>A是主属性，X是R的码</strong></p>\n</li>\n<li><p><strong>BCNF</strong> 限制R中成立的所有函数依赖要么是平凡的，要么是对码的依赖。对于任何关系模式R，以下两种两数依赖必定成立:平凡的函数依赖；任意属性对超码的依赖</p>\n</li>\n<li><p>主属性：一个属性只要在任何一个<strong>候选码</strong>中出现过，这个属性就是主属性。</p>\n</li>\n<li><p>非主属性：一个属性没有在任何候选码中出现过，这个属性就是非主属性。</p>\n</li>\n<li><p>部分函数依赖：设有关系R(A,B,C)，若AB→C，A→C，则C部分函数依赖于AB。</p>\n</li>\n<li><p>完全函数依赖：设有关系R(A,B,C)，若AB→C，A!→C，B!→C，则C完全函数依赖于AB。</p>\n</li>\n<li><p>传递函数依赖：设有关系R(A,B,C)，若A→B，B→C，则C传递函数依赖于A。</p>\n</li>\n<li><p><strong>1NF：关系中的每个属性都不可再分。</strong></p>\n</li>\n<li><p><strong>2NF：</strong>在1NF的基础之上，消除了非主属性对于候选码的<strong>部分函数依赖。</strong></p>\n</li>\n<li><p><strong>3NF：</strong>在2NF的基础之上，消除了非主属性对于候选码的<strong>传递函数依赖。</strong></p>\n</li>\n<li><p><strong>BCNF：</strong>在3NF的基础之上，消除主属性对于候选码的部分函数依赖与传递函数依赖。</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/d9284103ee8841e89f73862d6dd23fd9.png\"></p>\n<h2 id=\"4-3-在设计中使用规范化理论\"><a href=\"#4-3-在设计中使用规范化理论\" class=\"headerlink\" title=\"4.3 在设计中使用规范化理论\"></a>4.3 在设计中使用规范化理论</h2><ul>\n<li>规范化的总体目标是:<strong>消除某些冗余，避免存储异常，产生一种直观、易于扩充、可以很好描述现实世界，并且可以简单地验证某些语义约束的设计</strong></li>\n<li>ER模型与规范化</li>\n<li>完全规范化导致许多逻辑上相互分离的关系;涉及多个关系的查询需要求多个关系的自然连接，而自然连接是一种非常耗时的运算，从而会影响查询性能。解决方案:引入“冗余”的关系模式，即<strong>逆规范</strong>(denormalization) </li>\n<li>(操作时间冲突):逆规范化只对某些查询有利，而对另一些查询不利或对更新不利。解决方案:<strong>物化视图</strong>( materialized view ，对应SQL SERVER索引视图)</li>\n</ul>\n<h1 id=\"5、数据库设计\"><a href=\"#5、数据库设计\" class=\"headerlink\" title=\"5、数据库设计\"></a>5、数据库设计</h1><ul>\n<li>数据库设计步骤：需求分析 → 概念设计 → 逻辑结构设计 → 物理结构设计 → 数据库试运行和维护阶段</li>\n</ul>\n<h2 id=\"5-1-数据库设计概述\"><a href=\"#5-1-数据库设计概述\" class=\"headerlink\" title=\"5.1 数据库设计概述\"></a>5.1 数据库设计概述</h2><ul>\n<li>数据库设计就是根据用户应用需求和数据库的支撑环境（包括DBMS、操作系统和硬件)，设计出<strong>数据模式</strong>（包括外模式、模式和内模式)、<strong>建立数据库</strong>和<strong>典型的应用程序</strong>﹐使之能够有效地<strong>存储数据</strong>，满足各种用户的<strong>信息要求</strong>和<strong>处理要求</strong>。</li>\n<li>数据库设计的成果有：<strong>数据模式</strong>，<strong>以数据库为基础的典型应用程序</strong></li>\n<li>数据库设计的目标是为用户和各种应用系统提供一个信息基础设施和高效的运行环境，即存取效率高、存储空间的利用率高，数据库系统运行管理效率高</li>\n<li>数据库设计的特点：反复性、试探性、多阶段性、多技术性</li>\n<li>设计之前的工作 – <strong>可行性分析</strong></li>\n</ul>\n<h2 id=\"5-2-需求分析\"><a href=\"#5-2-需求分析\" class=\"headerlink\" title=\"5.2 需求分析\"></a>5.2 需求分析</h2><ul>\n<li>调查应用领域，对应用领域中各种应用的<strong>信息要求、处理要求、安全性</strong>和<strong>完整性</strong>要求进行详细分析，形成<strong>需求分析说明书</strong></li>\n<li><strong>数据字典</strong>是需求分析阶段所取得的主要成果之一 – 为设计人员提供了关于数据详细描述的信息</li>\n<li><strong>数据项</strong>是数据的基本单元或最小单位</li>\n<li><strong>数据结构</strong>是若干数据项组成的有意义的集合，它反映了数据之间组合关系</li>\n<li>数据流是数据在系统中的传输路径,它由一个处理传到另一个处理</li>\n<li>处理过程也称加工过程，这里指数据库应用程序模块</li>\n</ul>\n<h2 id=\"5-3-概念结构设计\"><a href=\"#5-3-概念结构设计\" class=\"headerlink\" title=\"5.3 概念结构设计\"></a>5.3 概念结构设计</h2><ul>\n<li><strong>逐步扩张</strong>(滚雪球)和<strong>混合策略</strong>(自顶向下和自底向上混合)</li>\n<li>数据抽象 – 将具有某些共同特性和行为的对象抽象为一个概念</li>\n<li>分E-R图集成：<strong>合并</strong>(消除冲突 [<strong>属性冲突、命名冲突、结构冲突</strong>])和<strong>优化</strong>(消除冗余)</li>\n<li>概念结构设计阶段的成果是<strong>全局ER图</strong></li>\n</ul>\n<h2 id=\"5-4-逻辑结构设计\"><a href=\"#5-4-逻辑结构设计\" class=\"headerlink\" title=\"5.4 逻辑结构设计\"></a>5.4 逻辑结构设计</h2><ul>\n<li>关系的分解：<ul>\n<li>水平分解：把关系的元组分为若干子集，对每个子集定义一个子关系，以提高系统的效率</li>\n<li>垂直分解：把关系模式R的属性分解为若干子集合，形成多个子关系模式，从而将对应的关系也分解成多个子关系，优点是可以提高某些查询的效率</li>\n</ul>\n</li>\n<li>逻辑结构设计阶段的成果是<strong>关系模式</strong>，对关系模式进行优化，外模式设计在此阶段设计</li>\n</ul>\n<h2 id=\"5-5-物理结构设计\"><a href=\"#5-5-物理结构设计\" class=\"headerlink\" title=\"5.5 物理结构设计\"></a>5.5 物理结构设计</h2><ul>\n<li><p>数据库在物理设备上的<strong>存储结构</strong>和<strong>存取方法</strong>就称为数据库的物理结构</p>\n</li>\n<li><p>数据库的物理结构设计∶就是为一个给定数据库的逻辑结构选取一个最适合应用环境的物理结构和存取方法的过程，目的是为了提高数据库的访问速度并有效地利用存储空间</p>\n</li>\n<li><p>常用索引方法 – 聚簇：为了提高某个属性(或属性组)的查询速度，把这个或这些属性(称为取簇码）上具有相同值的元组集中存放在同一个物理块或若干个相邻的物理块或柱面内</p>\n</li>\n<li><p>对<strong>已有关系建立聚簇</strong>，将导致关系中<strong>元组物理存储位置的变化</strong>，并使此关系上原有的索引无效，必须重建</p>\n</li>\n<li><p>确定数据库的物理结构主要指：</p>\n<ul>\n<li>确定数据的存放位置和存储结构，包括确定<strong>关系、索引、聚簇、日志、备份</strong>等存储安排和存储结构</li>\n<li>确定系统配置</li>\n</ul>\n</li>\n<li><p>确定数据的存放位置和存储结构要综合考虑</p>\n<ul>\n<li><p>存取时间</p>\n</li>\n<li><p>存储空间利用率</p>\n</li>\n<li><p>维护代价</p>\n</li>\n</ul>\n</li>\n<li><p>为了提高系统性能，应该根据应用情况将数据的<strong>易变部分</strong>与<strong>稳定部分</strong>，<strong>经常存取部分</strong>和<strong>存取频率较低部分</strong>分开存放</p>\n</li>\n<li><p>DBMS产品一般都提供了一些<strong>系统配置变量</strong>、<strong>存储分配参数</strong>、供设计人员和DBA对数据库进行物理优化</p>\n</li>\n</ul>\n<h2 id=\"5-6-数据库的实施和维护\"><a href=\"#5-6-数据库的实施和维护\" class=\"headerlink\" title=\"5.6 数据库的实施和维护\"></a>5.6 数据库的实施和维护</h2><ul>\n<li>建立数据库模式</li>\n<li>加载数据</li>\n<li>试运行将检验数据库系统的设计是否达到设计目标、能否满足实际需要</li>\n<li>确认系统能够满足实际需要之后﹐系统才能正式投入使用，进入漫长的运行维护阶段</li>\n</ul>\n<h1 id=\"6、-关系数据库标准语言\"><a href=\"#6、-关系数据库标准语言\" class=\"headerlink\" title=\"6、 关系数据库标准语言\"></a>6、 关系数据库标准语言</h1><h2 id=\"6-1-SQL概述\"><a href=\"#6-1-SQL概述\" class=\"headerlink\" title=\"6.1 SQL概述\"></a>6.1 SQL概述</h2><ul>\n<li>SQL的数据定义语言(DDL)、SQL的数据操纵语言(DML)、SQL的数据控制语言(DCL)</li>\n<li>SQL的特点集多种数据库语言于一体、<strong>高度非过程化</strong>(大大减轻了用户负担&#x2F;有利于提高数据的独立性)、面向集合的操作方式、一种语法两种使用方式、功能强大，语言简洁</li>\n</ul>\n<h2 id=\"6-2-SQL的数据类型\"><a href=\"#6-2-SQL的数据类型\" class=\"headerlink\" title=\"6.2 SQL的数据类型\"></a>6.2 SQL的数据类型</h2><ul>\n<li><strong>CHAR</strong>(n):定长字符串，长度n由用户指定·省略n时，长度为1,CHAR的全称是CHARACTER</li>\n<li><strong>VARCHAR</strong>(n):变长字符串，最大长度n由用户指定, VARCHAR的全称是CHARACTER VARYING</li>\n<li><strong>BIT</strong>(n):定长二进位串，长度n由用户指定。省略n时，长度为1</li>\n<li><strong>BIT VARYING</strong>(n):变长二进位串，最大长度n由用户指定</li>\n<li><strong>INT</strong>:整数，其值域依赖于具体实现。INT的全称是INTEGER</li>\n<li><strong>SMALLINT</strong> :小整数，其值域依赖于具体实现，但小于INT的值域</li>\n<li><strong>DEC</strong>(p, d): p位有效数字的定点数，其中小数点右边占d位。DEC的全称是DECIMAL</li>\n<li><strong>FLOAT</strong>(n):精度至少为n位数字的浮点数，其值域依赖于实现REAL:实数，精度依赖于实现</li>\n<li><strong>DOUBLE PRECISION</strong>:双精度实数，精度依赖于实现，但精度比REAL高</li>\n<li><strong>DATE</strong>:日期，包括年﹑月﹑日，格式为YYYY-MM-DD</li>\n<li><strong>TIME</strong>:时间，包括时﹑分﹑秒,格式为HH:MM:SS ° TIME(n)可以表示比秒更小的单位，秒后取n位</li>\n<li><strong>TIMESTAMP</strong>:时间戳，是DATE 和 TIME的结合</li>\n<li><strong>INTERVAL</strong>:时间间隔·SQL允许对DATE 、TIME和INTERVAL类型的值进行计算</li>\n<li>SQL提供<strong>ETRACT</strong>(field FROM Var) , Var可以是DATE ·TIME 或TIMESTAMP数据类型的变<br>量,ETRACT函数的功能是从 Var 中提取字段field</li>\n</ul>\n<h2 id=\"6-3-模式、表、索引的定义和删除\"><a href=\"#6-3-模式、表、索引的定义和删除\" class=\"headerlink\" title=\"6.3 模式、表、索引的定义和删除\"></a>6.3 模式、表、索引的定义和删除</h2><p><strong>模式</strong></p>\n<ul>\n<li><p>目录(catlog) – 模式(schema) – 对象</p>\n</li>\n<li><p>符号说明：</p>\n<ul>\n<li>&lt; X &gt;表示X是需要进一步定义或说明语言成分</li>\n<li>[X]表示X可以缺省或出现一次</li>\n<li>{}表示X可以出现一次</li>\n<li>X |Y表示或者X出现，或者Y出现，但二者不能同时出现</li>\n</ul>\n</li>\n<li><p>模式的定义：</p>\n<ul>\n<li><strong>CREATE SCHEMA&lt;模式名&gt;[&lt;模式元素&gt;….]</strong></li>\n<li><strong>CREATE SCHEMA[&lt;模式名&gt;]AUTHORIZATION&lt;用户名&gt;</strong> – <strong>授权</strong></li>\n</ul>\n</li>\n<li><p>模式删除：<strong>DROP SCHEMA&lt;模式名&gt; CASCADE|RESTRICT</strong></p>\n<ul>\n<li><strong>CASCADE</strong>，则删除&lt;模式名&gt;指定模式得同时并删除该模式中的所有数据库对象(基本表﹑视图﹑断言等)</li>\n<li><strong>RESTRICT</strong>，则仅当&lt;模式名&gt;指定的模式不包含任何数据库对象时才删除指定的模式，否则拒绝删除</li>\n</ul>\n</li>\n</ul>\n<p><strong>表</strong></p>\n<ul>\n<li><p>表的定义：<strong>CREATE TABLE&lt;表名&gt;</strong></p>\n</li>\n<li><p>列级约束的定义：**[CONSTRAINT&lt;约束名&gt;]&lt;列约束&gt;**</p>\n<ul>\n<li>NOT NULL</li>\n<li>PRIMARY KEY</li>\n<li>UNIQUE</li>\n<li>CHECK&lt;条件&gt;</li>\n</ul>\n</li>\n<li><p>表级约束的定义：**[CONSTRAINT&lt;约束名&gt;]&lt;表约束&gt;**</p>\n<ul>\n<li>PRIMARY</li>\n<li>UNIQUE</li>\n<li>CHECK</li>\n<li>FOREIGN KEY</li>\n</ul>\n</li>\n<li><p>修改基本表：<strong>ALTER TABLE&lt;表名&gt;</strong></p>\n<ul>\n<li>[ADD[COLUMN]&lt;列名&gt;&lt;数据类型[列级约束定义]]</li>\n<li>[[ALTER[COLUMN]&lt;列名&gt;{SET DEFAULT&lt;缺省值&gt;| DROP DEFAULT}]</li>\n<li>[DROP [ COLUMN ]&lt;列名&gt;{CASCADE|RESTRICT}]</li>\n<li>[[ADD&lt;表约束定义&gt;]</li>\n<li>[DROP CONSTRAINT&lt;约束名&gt;{CASCADE|RESTRICTH]</li>\n</ul>\n</li>\n<li><p>删除基本表：<strong>DROP TABLE&lt;表名&gt;{CASCADE|RESTRICT}</strong></p>\n</li>\n</ul>\n<p><strong>索引</strong></p>\n<ul>\n<li><strong>CREATE [UNIQUE] [CLUSTER] INDEX&lt;索引名&gt;ON&lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;]{,&lt;列名&gt;[&lt;次序&gt;]})</strong><ul>\n<li>&lt;索引名&gt;为建立的索引命名</li>\n<li>&lt;表名&gt;是要建立索引的基本表的名字</li>\n<li>次序可以是 ASC (升序)和 DESC (降序)，缺省值为ASC</li>\n</ul>\n</li>\n<li>UNIQUE表示该索引为惟一性索引UNIQUE缺省时，创建的索引为非唯一性索引；CLUSTER表示建立的索引是聚簇索引，缺省时为非聚簇索引；创建索引不仅创建索引结构，而且将索引的定义存储在数据字典中</li>\n<li>索引删除：<strong>DROP INDEX&lt;索引名&gt;</strong></li>\n</ul>\n<h2 id=\"6-4-数据操作\"><a href=\"#6-4-数据操作\" class=\"headerlink\" title=\"6.4 数据操作\"></a>6.4 数据操作</h2><ul>\n<li><p>SELECT</p>\n<ul>\n<li>SELECT[ALL | DISTINCT]&lt;选择序列&gt;</li>\n<li>FROM&lt;表引用&gt;,…,&lt;表引用&gt;</li>\n<li>[WHERE&lt;查询条件&gt;]</li>\n<li>[GROUP BY&lt;分组列&gt;{&lt;分组列&gt;}[HAVING&lt;分组选择条件&gt;]</li>\n<li>[ORDER BY&lt;排序列&gt;[ASC | DESC]{,&lt;排序列&gt;[ASC lDESC}</li>\n</ul>\n</li>\n<li><p>SELECT后可以使用集合量词ALL或DISTINCT，缺省时为ALL;ALL不删除结果的重复行，而DISTINCT将删除结果中的重复行</p>\n</li>\n<li><p>BETWEEN表达式：**&lt;值表达式&gt;[NOT] BETWEEN&lt;下界&gt;AND&lt;上界&gt;**</p>\n</li>\n<li><p>IN表达式：</p>\n<ul>\n<li><strong>&lt;值表达式&gt;[NOT]IN(&lt;值表达式列表&gt;)</strong></li>\n<li><strong>&lt;元组&gt; |[NOT] IN&lt;子查询&gt;</strong></li>\n</ul>\n</li>\n<li><p>LIKE表达式：**[NOT] LIKE&lt;匹配串&gt;[ESCAPE‘&lt;换码字符&gt;’]**</p>\n</li>\n<li><p>NULL表达式：**&lt;值表达式&gt;&lt;子查询&gt;IS [ NOT ] NULL**</p>\n</li>\n<li><p>排序：<strong>ORDER BY&lt;排序列&gt;[ASC | DESC] {,&lt;排序列&gt;[ASCDESC]}</strong></p>\n</li>\n<li><p>聚集函数</p>\n</li>\n<li><p>分组语句group by：<strong>GROUP BY&lt;分组列&gt;{，&lt;分组列&gt;}[HAVING&lt;分组选择条件&gt;]</strong></p>\n</li>\n<li><p>对于带GROUP BY子句的SELECT语句,<strong>SELECT子句中的结果列必须是GROUPBY子句中的&lt;分组列&gt;或聚集函数</strong>；分组语句细化了聚集函数作用的作用对象</p>\n</li>\n<li><p>连接查询、嵌套查询、子查询、集合查询</p>\n</li>\n</ul>\n<p><strong>数据更新</strong></p>\n<ul>\n<li>插入：INSERRT INTO T[] VALUES()                  &#x2F;            INSERT INTO T[]</li>\n<li>删除：DELETE FROM T [ WHERE&lt;删除条件&gt;]</li>\n<li>修改：UPDATE T SET A1 &#x3D; e1, …,Ak &#x3D; ek[WHERE&lt;修改条件&gt;]</li>\n</ul>\n<p><strong>例：</strong></p>\n<p>1.在产品表(Products)中找出库存<strong>大于</strong>50的产品的所有信息，按产品编号<strong>升序排序</strong>。</p>\n<p><code>SELECT * FROM Products WHERE UnitsInStock&gt;=50 ORDER BY ProductID</code></p>\n<p>2.查询顾客表(Customers)中所有<strong>不重复</strong>的所在城市，并<strong>升序排序</strong>。</p>\n<p><code>SELECT DISTINCT City FROM Customers ORDER BY City</code></p>\n<p>3.在顾客表(Customers)中<strong>找出所在城市为</strong>London、Madrid、Torino和Paris的顾客编号及电话。</p>\n<p><code>SELECT CustomerID,Phone FROM Customers WHERE City IN (&#39;London&#39;,&#39;Madrid&#39;,&#39;Torino&#39;,&#39;Paris&#39;)</code></p>\n<p>4.在产品表(Products)中找出单位数量中<strong>有box</strong>的产品名和产品编号。</p>\n<p><code>SELECT ProductName,ProductID FROM Products WHERE QuantityPerUnit LIKE &#39;%box%&#39;</code></p>\n<p>5.在顾客表(Customers)中找出公司名的<strong>首字母为F，第5位为k</strong>的顾客编号和联系人名。</p>\n<p><code>SELECT CustomerID,ContactName FROM Customers WHERE CompanyName LIKE &#39;F___k%&#39;</code></p>\n<p>6.统计<strong>在’1997-10-1’ 到’1997-10-7’期间</strong>，订单中每个员工的订单数，并按订单数<strong>降序</strong>排序。</p>\n<p><code>SELECT EmployeeID&quot;员工编号&quot;,COUNT(ORDERID)&quot;订单数&quot; FROM Orders WHERE OrderDate BETWEEN &#39;1997-10-1&#39;ANd&#39;1997-10-7&#39; GROUP　BY EmployeeID ORDER BY COUNT(OrderID) DESC</code></p>\n<p>7.请查询平均价格在30元及以上的产品类型。</p>\n<p><code>SELECT CategoryID,AVG(UnitPrice)&#39;平均价格&#39; FROM Products GROUP　BY CategoryID Having AVG(UnitPrice)&gt;=30</code></p>\n<p>8.查询’1997-10-7’当天所售商品的库存情况，包括商品编号、名称、库存。</p>\n<p><code>SELECT Products.ProductID,ProductName,UnitsInStock FROM Products,Orders,[Order Details] WHERE Products.ProductID=[Order Details].ProductID AND [Order Details].OrderID=Orders.OrderID AND OrderDate=&#39;1997-10-7&#39;</code></p>\n<h2 id=\"6-5-视图\"><a href=\"#6-5-视图\" class=\"headerlink\" title=\"6.5 视图\"></a>6.5 视图</h2><ul>\n<li><p>定义：<strong>CREATE VIEW&lt;视图名&gt;[(&lt;列名&gt;，…,&lt;列名&gt;)]AS&lt;查询表达式&gt;[WITH CHECK OPTION]</strong></p>\n</li>\n<li><p>删除：<strong>DROP VIEW&lt;视图名&gt;[ CASCADE |RESTRICT ]</strong></p>\n</li>\n<li><p>视图的优点：</p>\n</li>\n</ul>\n<ol>\n<li><p>视图能够简化用户的操作</p>\n</li>\n<li><p>视图使用户能以多种角度看待同一数据</p>\n</li>\n<li><p>视图重构数据库提供了一定程度的逻辑独立性</p>\n</li>\n<li><p>视图能够对机密数据提供安全保护</p>\n</li>\n<li><p>视图能够更清晰的表达</p>\n</li>\n</ol>\n<h1 id=\"7、数据库的完整性\"><a href=\"#7、数据库的完整性\" class=\"headerlink\" title=\"7、数据库的完整性\"></a>7、数据库的完整性</h1><h2 id=\"7-1-完整性概述\"><a href=\"#7-1-完整性概述\" class=\"headerlink\" title=\"7.1  完整性概述\"></a>7.1  完整性概述</h2><ul>\n<li><p>数据库的完整性是指数据库中数据是<strong>正确的</strong>(数据库的数据是符合语义约束的数据)、<strong>一致的</strong>(数据之间的逻辑关系是正确的)和<strong>相容的</strong>(同一个事实的两个数据应当是一致的)</p>\n</li>\n<li><p>约束的分类：(就被约束的数据对象而言)</p>\n<ul>\n<li>类型&#x2F;域约束</li>\n<li>属性约束</li>\n<li>关系约束</li>\n<li>数据库约束</li>\n</ul>\n</li>\n<li><p>约束的分类：(从约束的状态的角度)</p>\n<ul>\n<li>静态约束（数据库正确状态）</li>\n<li>动态约束（数据库状态转移）</li>\n</ul>\n</li>\n<li><p>DBMS必须提供完整性控制的机制有：定义完整性约束条件的方法、完整性检查机制、违约处理</p>\n</li>\n<li><p>可以实现级联操作的短语是：<code>CASCADE</code></p>\n</li>\n</ul>\n<h2 id=\"7-2-实体完整性\"><a href=\"#7-2-实体完整性\" class=\"headerlink\" title=\"7.2 实体完整性\"></a>7.2 实体完整性</h2><ul>\n<li><p>实体完整性要求:</p>\n<ul>\n<li>每个关系应该有一个<strong>主码</strong>，每个元组的主码值惟一确定该元组</li>\n<li>主码的任何属性都<strong>不能取空值</strong></li>\n</ul>\n</li>\n<li><p>违反的操作： 插入新元祖、修改元祖的主码、DBMS自动检查、SQL支持实体完整性</p>\n</li>\n</ul>\n<h2 id=\"7-3-参照完整性\"><a href=\"#7-3-参照完整性\" class=\"headerlink\" title=\"7.3 参照完整性\"></a>7.3 参照完整性</h2><ul>\n<li><p>参照完整性要求:</p>\n<ul>\n<li>参照关系R的任何元组在其外码FKR上的值或者等于被参照关系S的某个元组在主码K上的值，或者为空值</li>\n</ul>\n</li>\n<li><p>违法的操作：向参照关系R插入、修改参照关系R外码上的值、删除(修改)被参照关系S的元组</p>\n</li>\n<li><p>向数据库表中插入数据违法参照完整性规则时，系统所做的操作是：<strong>拒绝</strong></p>\n</li>\n</ul>\n<h2 id=\"7-4-用户自定义完整性\"><a href=\"#7-4-用户自定义完整性\" class=\"headerlink\" title=\"7.4 用户自定义完整性\"></a>7.4 用户自定义完整性</h2><ul>\n<li><p>用户自定义的完整性约束：用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求，用户定义的完整性可以是：</p>\n<ul>\n<li>属性级</li>\n<li>关系级</li>\n<li>数据库级</li>\n</ul>\n</li>\n<li><p>域约束：每个属性都必须在一个值域上取值</p>\n</li>\n<li><p>属性约束：属性的取值必须来自其定义的值域</p>\n</li>\n<li><p>关系约束：说明关系的合法取值，常常涉及同一关系的多个属性和或多个元祖</p>\n</li>\n<li><p>断言与数据库约束：断言是一种命名约束，表达了数据库状态必须满足的逻辑条件</p>\n</li>\n</ul>\n<h2 id=\"7-5-触发器\"><a href=\"#7-5-触发器\" class=\"headerlink\" title=\"7.5 触发器\"></a>7.5 触发器</h2><ul>\n<li>触发器( trigger）是特殊类型的存储过程，当某个事件发生时它自动执行</li>\n<li>按触发事件分：DELETE触发器、INSERT触发器、UPDATE触发器</li>\n<li>定义触发器操作的SQL语句：<code>CREATE TRIGGER</code></li>\n</ul>\n<div class=\"language-sql\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">sql</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1d1d1d\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #F78C6C\">CREATE</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">TRIGGER</span><span style=\"color: #BABED8\"> `</span><span style=\"color: #82AAFF\">register</span><span style=\"color: #BABED8\">` </span><span style=\"color: #F78C6C\">AFTER</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">UPDATE</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">ON</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">`</span><span style=\"color: #C3E88D\">student</span><span style=\"color: #89DDFF\">`</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">FOR</span><span style=\"color: #BABED8\"> EACH </span><span style=\"color: #F78C6C\">ROW</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">BEGIN</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">UPDATE</span><span style=\"color: #BABED8\"> driver_school </span><span style=\"color: #F78C6C\">SET</span><span style=\"color: #BABED8\"> total_number </span><span style=\"color: #89DDFF\">=</span><span style=\"color: #BABED8\"> (total_number </span><span style=\"color: #89DDFF\">+</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">1</span><span style=\"color: #BABED8\">) </span><span style=\"color: #F78C6C\">WHERE</span><span style=\"color: #BABED8\"> driver_school.id </span><span style=\"color: #89DDFF\">=</span><span style=\"color: #BABED8\"> student.school_id;</span></span>\n<span class=\"line\"><span style=\"color: #F78C6C\">END</span></span></code></pre></div><h1 id=\"8、数据库编程与访问技术\"><a href=\"#8、数据库编程与访问技术\" class=\"headerlink\" title=\"8、数据库编程与访问技术\"></a>8、数据库编程与访问技术</h1><h2 id=\"8-1-T-SQL\"><a href=\"#8-1-T-SQL\" class=\"headerlink\" title=\"8.1 T-SQL\"></a>8.1 T-SQL</h2><ul>\n<li>变量：局部变量–变量名前加一个@，全局变量–变量名前加两个@@</li>\n<li>变量的声明与赋值：&lt;@var&gt;</li>\n<li>运算符：算术运算符、比较运算符、逻辑运算符、位运算符、字符串连接运算符–‘+’</li>\n<li>函数</li>\n<li>流程控制语句</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/875d6c78c1e44decaa263a5c3de8a7e2.png\"></p>\n<h2 id=\"8-2-存储过程\"><a href=\"#8-2-存储过程\" class=\"headerlink\" title=\"8.2 存储过程\"></a>8.2 存储过程</h2><ul>\n<li>存储过程是为了完成特定功能汇集而成的命名了的一组SQL语句集合<ul>\n<li>编译、优化后存储，可多次执行</li>\n</ul>\n</li>\n<li>优点：将业务操作封装、实现一定程度的安全性保护、适合复杂的统计和查询操作</li>\n</ul>\n<div class=\"language-sql\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">sql</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1d1d1d\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #F78C6C\">CREATE</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">PROCEDURE</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">&lt;</span><span style=\"color: #BABED8\">procedureName</span><span style=\"color: #89DDFF\">&gt;</span><span style=\"color: #BABED8\"> </span><span style=\"color: #676E95; font-style: italic\">--&lt;procedureName&gt;存储过程名称</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    [(&lt;@parameterName&gt;&lt;datatype&gt;[=&lt;defaultValue&gt;][OUTPUT]</span><span style=\"color: #676E95; font-style: italic\">--&lt;@parameterName&gt; 参数名</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">       [,&lt;@parameterName&gt;&lt;datatype&gt;[=&lt;defaultValue&gt;][OUTPUT]])]</span><span style=\"color: #676E95; font-style: italic\">--OUTPUT输出参数</span></span>\n<span class=\"line\"><span style=\"color: #F78C6C\">As</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    </span><span style=\"color: #89DDFF\">&lt;</span><span style=\"color: #F78C6C\">SQL</span><span style=\"color: #89DDFF\">-</span><span style=\"color: #BABED8\">Statements</span><span style=\"color: #89DDFF\">&gt;</span></span></code></pre></div><h2 id=\"8-3-数据库访问技术\"><a href=\"#8-3-数据库访问技术\" class=\"headerlink\" title=\"8.3  数据库访问技术\"></a>8.3  数据库访问技术</h2><ul>\n<li>ODBC：一组对数据库访问的标准API</li>\n<li>DAO与RDO</li>\n<li>JDBC访问步骤：<ul>\n<li>导入包</li>\n<li>加载JDBC驱动程序</li>\n<li>打开一个数据库连接</li>\n<li>执行一个查询</li>\n<li>从结果集中提取数据</li>\n<li>清理环境</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"9、数据库的安全性\"><a href=\"#9、数据库的安全性\" class=\"headerlink\" title=\"9、数据库的安全性\"></a>9、数据库的安全性</h1><h2 id=\"9-1-概述\"><a href=\"#9-1-概述\" class=\"headerlink\" title=\"9.1 概述\"></a>9.1 概述</h2><ul>\n<li><strong>数据库的安全性是指保护数据库，防止因用户非法使用数据库造成数据泄露、更改或破坏</strong></li>\n<li>恶意访问的形式：未经授权读取、修改、删除数据</li>\n<li>安全性保护手段：<strong>用户标识与鉴别、强制存取控制、审计和加密、自主存取和控制、视图</strong></li>\n</ul>\n<h2 id=\"9-2-用户识别与标识\"><a href=\"#9-2-用户识别与标识\" class=\"headerlink\" title=\"9.2 用户识别与标识\"></a>9.2 用户识别与标识</h2><ul>\n<li><p>用户标识与鉴别是系统提供的<strong>最外层安全保护措施</strong></p>\n</li>\n<li><p>其基本方法是:系统提供一定的方式让用户标识自己的名字或身份;系统内部记录着所有合法用户的标识;每次用户要求进入系统(与数据库连接)时，由系统核对用户提供的身份标识;通过鉴别的合法用户才能进入系统，建立数据库连接</p>\n</li>\n</ul>\n<h2 id=\"9-3-存取控制\"><a href=\"#9-3-存取控制\" class=\"headerlink\" title=\"9.3 存取控制\"></a>9.3 存取控制</h2><ul>\n<li>存取控制是数据库系统的主要安全措施：<strong>自主存取控制，强制存取控制</strong></li>\n</ul>\n<h2 id=\"9-4-自主存取控制\"><a href=\"#9-4-自主存取控制\" class=\"headerlink\" title=\"9.4 自主存取控制\"></a>9.4 自主存取控制</h2><ul>\n<li>存取控制的任务：<ul>\n<li>授权（DCL中提供了相应的授权语句，允许用户自主地定义存取权限，并将用户的授权登记在数据字典中）</li>\n<li>合法权限检查（当用户发出存取数据库的操作请求后，DBMS将查找数据字典，根据用户权限进行合法权限的检查;如果用户的操作请求超出了自身的权限，系统将拒绝执行此操作2）</li>\n</ul>\n</li>\n<li>权限的授予与回收：<ul>\n<li><strong>GRANT&lt;权限列表&gt;ON&lt;对象名&gt;TO&lt;用户&#x2F;角色列表&gt;[WITH GTANT OPTION]</strong></li>\n<li><strong>REVOKE&lt;权限列表&gt;ON&lt;对象名&gt;FROM&lt;用户&#x2F;角色列表&gt;{CASCADE|RESTRICT}</strong></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"9-5-强制存取控制\"><a href=\"#9-5-强制存取控制\" class=\"headerlink\" title=\"9.5 强制存取控制\"></a>9.5 强制存取控制</h2><ul>\n<li><p>自主存取控制不能阻止副本的非授权传播</p>\n</li>\n<li><p>强制存取控制( Mandatory Access Control ，简称MAC）是系统为保证更高程度的安全性所采取的强制存取检查手段</p>\n</li>\n<li><p>在MAC中,DBMS所管理的全部实体被分为<strong>主体</strong>和<strong>客体</strong>两大类：</p>\n<ul>\n<li>主体是系统中的活动实体，可以是DBMS管理的实际用户或代表用户的各个进程</li>\n<li>客体是系统中的被动实体，是受主体操纵的对象·如文件、基本表、索引、视图等</li>\n</ul>\n</li>\n<li><p>敏感度标记：绝密、机密、秘密、公开</p>\n<ul>\n<li>主体的敏感度标记称为许可证级别（ Clearance Level)</li>\n<li>客体的敏感度标记称为密级（ Classification Level )</li>\n</ul>\n</li>\n<li><p>仅当主体的许可证级别<strong>大于或等于</strong>客体的密级时，该主体才能<strong>读取</strong>相应的客体；仅当主体的许可证级别<strong>小于或等于</strong>客体的密级时，该主体才能<strong>写</strong>相应的客体</p>\n</li>\n</ul>\n<h2 id=\"9-6-视图机制\"><a href=\"#9-6-视图机制\" class=\"headerlink\" title=\"9.6 视图机制\"></a>9.6 视图机制</h2><ul>\n<li>视图是定义外模式,为用户提供个性化数据库模型的一种手段</li>\n<li>利用视图实现安全保护的基本思想是:<ul>\n<li>首先通过定义视图，屏蔽掉一部分需要对某些用户保密的数据</li>\n<li>然后，在视图上定义存取权限，将对视图的访问权授予这些用户，而不允许他们直接访问定义视图的关系(基本表)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"9-7-其它措施\"><a href=\"#9-7-其它措施\" class=\"headerlink\" title=\"9.7 其它措施\"></a>9.7 其它措施</h2><ul>\n<li>审计启用一个专门的审计日志（ Audit Log），自动记录所有用户对数据库的更新操作(插入、删除和修改)</li>\n<li>数据加密的基本思想:按照一定的加密算法，将原始数据(明文)变换成不可直接识别的格式(密文)，使得不知道解密方法的人即使获得数据，也不知道数据的真实内容，从而达到保护数据的目的</li>\n</ul>\n<h1 id=\"10、事务于并发控制\"><a href=\"#10、事务于并发控制\" class=\"headerlink\" title=\"10、事务于并发控制\"></a>10、事务于并发控制</h1><h2 id=\"10-1-事务与并发控制\"><a href=\"#10-1-事务与并发控制\" class=\"headerlink\" title=\"10.1 事务与并发控制\"></a>10.1 事务与并发控制</h2><p><strong>事务</strong></p>\n<ul>\n<li><strong>事务是用户定义的一个数据库的操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单元</strong></li>\n<li>事务是<strong>并发控制与调度</strong>的<strong>基本单位</strong>，也是<strong>数据库恢复</strong>的<strong>基本单位</strong></li>\n<li>事务的特点：(ACID)原子性、一致性、隔离性、持久性</li>\n<li><strong>事务状态</strong><ul>\n<li><strong>活动状态</strong>：初始状态，事务执行时处于该状态</li>\n<li><strong>部分提交状态</strong>：最后一条语句被执行后的状态</li>\n<li><strong>失败状态</strong>：正常的执行不能持续后的状态</li>\n<li><strong>中止状态</strong>：事务回滚并且数据库已被恢复到事务开始执行前的状态<ul>\n<li>重启事务</li>\n<li>废除事务</li>\n</ul>\n</li>\n<li><strong>提交状态</strong>：成功完成后的状态</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/40cfc8d687c7459bb6550348c150acab.png\"></p>\n<ul>\n<li>SQL对事务的支持：COMMIT WORK–提交当前事务；ROLLBACK WORD–中止当前事务；SET TRANSACTION–设置事务的特性</li>\n<li>这里&lt;级别&gt;从低到高依次为<ul>\n<li>READ UNCOMMITED读未提交的修改，只能在只读状态下使用</li>\n<li>READ COMMITED读提交的修改</li>\n<li>REPEATABLE READ可重复读</li>\n<li>SERIALIZABLE可串行化</li>\n</ul>\n</li>\n<li>隔离级别越高(低)，可能出现的问题越少(多)，系统并发度越低（高)</li>\n</ul>\n<p><strong>并发控制</strong></p>\n<ul>\n<li><strong>为了防止数据库的不一致性，对多个运行的事务需要并发控制</strong></li>\n<li>保证事务的<strong>一致性、隔离性</strong></li>\n<li>相对于串行执行，并发执行<strong>优点</strong>有：提高吞吐量和资源利用率、减少等待时间；<strong>缺点</strong>有：<strong>丢失修改、读脏数据、不可重复读</strong></li>\n</ul>\n<h2 id=\"10-2-封锁\"><a href=\"#10-2-封锁\" class=\"headerlink\" title=\"10.2 封锁\"></a>10.2 封锁</h2><ul>\n<li>并发控制的主要技术有：<strong>封锁、时间戳、乐观控制法、多版本并发控制</strong></li>\n<li>所谓封锁就是事务T在对某个数据对象操作之前，先向系统发出加锁请求，加锁后事务T就对该数据对象有了一定的控制权，在事务T释放它的锁之前，其它事务不能更新该数据对象</li>\n<li>基本锁类型：<strong>共享锁S</strong>(读锁，可读不可写)和<strong>排他锁X</strong>(写锁，可读可写)</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/9a7a5fd4252e4aee8dfa08f390d23567.png\"></p>\n<ul>\n<li><p>封锁协议：</p>\n<ul>\n<li>一级封锁协议 <strong>防止丢失修改</strong></li>\n<li>二级封锁协议 <strong>防止读“脏”数据</strong></li>\n<li>三级封锁协议 <strong>进一步保证可重复读</strong></li>\n</ul>\n</li>\n<li><p><strong>活锁与死锁</strong>：活锁又称饥饿，是某个事务因等待锁而处于无限期等待状态(<strong>解决–先来先服务</strong>)；死锁是两个或两个以上的事务之间的循环等待现象(<strong>解决–一次封锁法、顺序封锁法</strong>)</p>\n</li>\n<li><p><strong>死锁的检测与解除：超时法和等待图法</strong></p>\n</li>\n<li><p>解除死锁：选择一个或多个处于死锁状态的事务，将其撤销并释放这些事务持有的所有的锁，从而打破了循环等待条件，解除死锁，使得其他事务能够继续运行。当然,被撤消的事务对数据库的更新必须恢复(回滚)，并且要在稍后需要重新运行</p>\n</li>\n</ul>\n<h2 id=\"10-3-并发调度的可串行化\"><a href=\"#10-3-并发调度的可串行化\" class=\"headerlink\" title=\"10.3 并发调度的可串行化\"></a>10.3 并发调度的可串行化</h2><ul>\n<li><strong>并发调度正确性准则</strong>：一组事务的一个并发调度S是正确的，当且仅当调度S的执行结果与某一个串行调度的执行结果相同。此时，我们称并发调度S是可串行化的</li>\n</ul>\n<h2 id=\"10-4-两阶段协议\"><a href=\"#10-4-两阶段协议\" class=\"headerlink\" title=\"10.4 两阶段协议\"></a>10.4 两阶段协议</h2><ul>\n<li>两段锁协议：是最常用的一种封锁协议、理论上已经证明使用该协议可保证并发调度串行化</li>\n<li>为了避免级联回滚，产生了两种改进的两阶段封锁协议：严格两阶段封锁协议、强两阶段封锁协议</li>\n</ul>\n<h2 id=\"10-5-多粒度封锁\"><a href=\"#10-5-多粒度封锁\" class=\"headerlink\" title=\"10.5 多粒度封锁\"></a>10.5 多粒度封锁</h2><ul>\n<li><strong>系统能够同时支持多种封锁粒度供不同的事务选择的封锁方法称之为多粒度封锁</strong></li>\n<li>选择封锁粒度时应该同时考虑<strong>封锁开销</strong>和<strong>并发度</strong>两个因素：<ul>\n<li>封锁的粒度越大，数据库所能封锁的数据单元就越少，并发度就越小，系统开销就越小</li>\n<li>封锁的粒度越小，并发度就高，系统开销就越大</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"11、数据库的恢复技术\"><a href=\"#11、数据库的恢复技术\" class=\"headerlink\" title=\"11、数据库的恢复技术\"></a>11、数据库的恢复技术</h1><h2 id=\"1-1-概述\"><a href=\"#1-1-概述\" class=\"headerlink\" title=\"1.1 概述\"></a>1.1 概述</h2><ul>\n<li>数据库的恢复机制就是负责将数据库恢复到故障发生前的某一个一致状态，并将崩溃后的数据库不能使用的时间减少到最小</li>\n<li>故障的类型：<ul>\n<li><strong>事务故障</strong>：事务程序的逻辑错误，系统错误</li>\n<li><strong>系统故障</strong>：</li>\n<li><strong>介质故障</strong>：磁盘损坏导致的故障</li>\n</ul>\n</li>\n<li>故障恢复技术的基本思想：在系统正常时建立冗余数据（<strong>通过登记日志、数据转储</strong>），保证有足够的信息可用于故障恢复；故障发生后采取措施将数据库内容恢复到某个一致性状态，保证事务原子性和持久性</li>\n</ul>\n<h2 id=\"1-2-存储器结构\"><a href=\"#1-2-存储器结构\" class=\"headerlink\" title=\"1.2 存储器结构\"></a>1.2 存储器结构</h2><ul>\n<li><p>存储器类型：</p>\n<ul>\n<li>易失性存储器：内存、高速缓存</li>\n<li>非易失性存储器：磁盘、磁带</li>\n<li>稳定存储器：理想的存储器</li>\n</ul>\n</li>\n<li><p>采用<strong>冗余独立磁盘阵列</strong>可以保证单个磁盘的故障不会导致数据丢失</p>\n</li>\n<li><p>数据访问通过<strong>input</strong>和<strong>output</strong>将块在主存和磁盘之间移动</p>\n</li>\n</ul>\n<h2 id=\"1-3-恢复技术\"><a href=\"#1-3-恢复技术\" class=\"headerlink\" title=\"1.3 恢复技术\"></a>1.3 恢复技术</h2><p><strong>基于日志的恢复技术</strong></p>\n<ul>\n<li>日志是日志记录的序列，记录了数据库中所有的更新活动</li>\n<li>日志记录的格式：事务标识符、操作类型、操作对象、旧值、新值</li>\n<li>日志登记的原则：日志记录必须严格按并发事务执行的时间次序登记；<strong>必须先记日志，后写数据库</strong></li>\n<li><strong>redo</strong>(正序)和<strong>undo</strong>(逆序)操作</li>\n<li><strong>延迟更新</strong>指的是将事务对数据库的更新推迟到事务提交之后</li>\n<li><strong>即时更新</strong>技术允许事务在活跃状态时就将更新输出到数据库中</li>\n<li><strong>系统故障发生，哪些事务需要重做，事务需要回滚</strong><ul>\n<li><strong>什么时候重做——系统故障发生之前，事务A已经提交，事务A需要重做</strong></li>\n<li><strong>什么时候回滚——系统故障发生时，事务B已经开始，但未提交，而且没有回滚</strong></li>\n<li><strong>什么时候不做处理——系统发生故障前，已经回滚</strong></li>\n<li>（PS:注意检查点隔断问题！！！)</li>\n</ul>\n</li>\n</ul>\n<p><strong>基于检查点的恢复技术</strong></p>\n<ul>\n<li><p>提高系统故障恢复效率的基本方法是使用<strong>检查点技术</strong></p>\n</li>\n<li><p>在建立检查点时，不允许事务执行任何更新动作，如写缓冲块或写日志记录；建立检查点之后，所有在检查点前发生的更新都已经输出到数据库中，尚未完成的事务都登记在检查点记录中；这样，发生系统故障时，只需要从最近的检查点记录开始扫描日志</p>\n</li>\n<li><p><strong>对于事务故障用处不大，对于系统故障能提高效率</strong></p>\n</li>\n</ul>\n<p><strong>缓冲技术</strong></p>\n<ul>\n<li><strong>日志缓冲</strong>：一个日志记录通常远小于稳定存储器的块。为了提高I&#x2F;O效率，日志记录在主存中被缓冲，而不是直接输出到稳定存储器；当缓冲区被日志记录装满，或者执行日志强制输出时，日志记录才被输出到稳定存储器；日志缓冲减少了将日志输出到稳定存储器的开销，但是也带来了风险:一旦发生系统发生故障，缓冲区中的日志记录将丢失</li>\n<li><strong>数据库缓冲</strong>：数据库存储在非易失性存储器中，在需要时再将相应的数据块调入主存，存在闩锁</li>\n</ul>\n<p><strong>转储</strong></p>\n<ul>\n<li>转储是指将整个或部分数据库复制到磁带或另一个磁盘上，产生数据库后备副本的过程；后备副本可以脱机保存，供介质故障恢复时使用（因此，转储又称归档)；一旦数据库遭到破坏，就可以将后备副本重新装入，将数据库恢复到转储时的状态，分为<strong>静态转储&#x2F;动态转储</strong>或者<strong>海量转储&#x2F;增量转储</strong></li>\n</ul>\n<p><strong>其他恢复技术</strong></p>\n<ul>\n<li>影子分页技术</li>\n<li>数据库镜像</li>\n</ul>\n","feature":true,"text":"数据库原理是指数据库系统的基本概念和工作原理。它包括数据模型、数据结构、数据操作和数据管理等方面。常见的数据库模型包括层次模型、网络模型和关系模型，其中关系模型是最常用和广泛应用的。数据库原理还涉及索引技术、事务管理、并发控制和数据备份等内容。...","permalink":"/post/计算机数据库原理及应用概述","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[{"name":"计算机科学与技术","slug":"计算机科学与技术","count":6,"path":"api/categories/计算机科学与技术.json"}],"tags":[{"name":"数据库原理及应用","slug":"数据库原理及应用","count":1,"path":"api/tags/数据库原理及应用.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">数据库原理及应用</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1、数据库系统概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1.1 基本概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">1.2 数据模型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">1.3 数据库系统的结构</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%AE%9E%E4%BD%93-%E2%80%93-%E8%81%94%E7%B3%BB%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">2、实体 – 联系模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">2.1  基本概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E5%AE%9E%E4%BD%93-%E8%81%94%E7%B3%BB%E5%9B%BE\"><span class=\"toc-text\">2.2 实体-联系图</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-%E5%BC%B1%E5%AE%9E%E4%BD%93%E9%9B%86\"><span class=\"toc-text\">2.3 弱实体集</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">3、关系数据模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">3.1 关系数据库的结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-%E4%BB%8EER%E6%A8%A1%E5%9E%8B%E5%88%B0%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">3.2 从ER模型到关系模型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E3%80%81%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F%E3%80%81%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0\"><span class=\"toc-text\">3.3 关系操作、完整性约束、关系代数</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4%E3%80%81%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA\"><span class=\"toc-text\">4、关系数据库的设计理论</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">4.1 函数依赖</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">4.2 关系模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-3-%E5%9C%A8%E8%AE%BE%E8%AE%A1%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA\"><span class=\"toc-text\">4.3 在设计中使用规范化理论</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">5、数据库设计</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">5.1 数据库设计概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-2-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90\"><span class=\"toc-text\">5.2 需求分析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-3-%E6%A6%82%E5%BF%B5%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">5.3 概念结构设计</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-4-%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">5.4 逻辑结构设计</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-5-%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">5.5 物理结构设计</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-6-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E6%96%BD%E5%92%8C%E7%BB%B4%E6%8A%A4\"><span class=\"toc-text\">5.6 数据库的实施和维护</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#6%E3%80%81-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%87%E5%87%86%E8%AF%AD%E8%A8%80\"><span class=\"toc-text\">6、 关系数据库标准语言</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-1-SQL%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">6.1 SQL概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-2-SQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">6.2 SQL的数据类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-3-%E6%A8%A1%E5%BC%8F%E3%80%81%E8%A1%A8%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">6.3 模式、表、索引的定义和删除</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-4-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">6.4 数据操作</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-5-%E8%A7%86%E5%9B%BE\"><span class=\"toc-text\">6.5 视图</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#7%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7\"><span class=\"toc-text\">7、数据库的完整性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-1-%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">7.1  完整性概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-2-%E5%AE%9E%E4%BD%93%E5%AE%8C%E6%95%B4%E6%80%A7\"><span class=\"toc-text\">7.2 实体完整性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-3-%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7\"><span class=\"toc-text\">7.3 参照完整性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-4-%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%8C%E6%95%B4%E6%80%A7\"><span class=\"toc-text\">7.4 用户自定义完整性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-5-%E8%A7%A6%E5%8F%91%E5%99%A8\"><span class=\"toc-text\">7.5 触发器</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#8%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">8、数据库编程与访问技术</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-1-T-SQL\"><span class=\"toc-text\">8.1 T-SQL</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-2-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">8.2 存储过程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-3-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">8.3  数据库访问技术</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#9%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7\"><span class=\"toc-text\">9、数据库的安全性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">9.1 概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-2-%E7%94%A8%E6%88%B7%E8%AF%86%E5%88%AB%E4%B8%8E%E6%A0%87%E8%AF%86\"><span class=\"toc-text\">9.2 用户识别与标识</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-3-%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">9.3 存取控制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-4-%E8%87%AA%E4%B8%BB%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">9.4 自主存取控制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-5-%E5%BC%BA%E5%88%B6%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">9.5 强制存取控制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-6-%E8%A7%86%E5%9B%BE%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">9.6 视图机制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-7-%E5%85%B6%E5%AE%83%E6%8E%AA%E6%96%BD\"><span class=\"toc-text\">9.7 其它措施</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#10%E3%80%81%E4%BA%8B%E5%8A%A1%E4%BA%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">10、事务于并发控制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-1-%E4%BA%8B%E5%8A%A1%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">10.1 事务与并发控制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-2-%E5%B0%81%E9%94%81\"><span class=\"toc-text\">10.2 封锁</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-3-%E5%B9%B6%E5%8F%91%E8%B0%83%E5%BA%A6%E7%9A%84%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96\"><span class=\"toc-text\">10.3 并发调度的可串行化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-4-%E4%B8%A4%E9%98%B6%E6%AE%B5%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">10.4 两阶段协议</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-5-%E5%A4%9A%E7%B2%92%E5%BA%A6%E5%B0%81%E9%94%81\"><span class=\"toc-text\">10.5 多粒度封锁</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#11%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">11、数据库的恢复技术</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1.1 概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">1.2 存储器结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">1.3 恢复技术</span></a></li></ol></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"前端初学者必读：TypeScript入门指南","uid":"054121162cf16271d339158fbc3ed82e","slug":"前端--前端初学者必读：TypeScript入门指南","date":"2023-02-13T01:45:38.000Z","updated":"2025-07-14T15:12:20.465Z","comments":true,"path":"api/articles/前端--前端初学者必读：TypeScript入门指南.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/direct/6653363c76e6423191bb64af30fd1345.png","text":"TypeScript是一种由微软开发的JavaScript超集，可用于构建大规模和复杂的应用程序。使用TypeScript能够提高代码的可读性和可维护性，减少出错率。它支持静态类型检查、面向对象编程、接口定义等功能。...","permalink":"/post/前端--前端初学者必读：TypeScript入门指南","photos":[],"count_time":{"symbolsCount":"19k","symbolsTime":"17 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"TypeScript","slug":"TypeScript","count":2,"path":"api/tags/TypeScript.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true},"next_post":{"title":"计算机网络概述","uid":"42ad5343960ce09baf2db672de3117be","slug":"计算机网络基础知识点","date":"2023-02-02T02:13:39.000Z","updated":"2025-07-14T15:12:20.470Z","comments":true,"path":"api/articles/计算机网络基础知识点.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/direct/4ec43504e6e445a5b4d30bd12fb42fa7.jpeg","text":"计算机网络基础知识包括IP地址、子网掩码、网关、DNS、HTTP等关键概念。IP地址是计算机在网络中的唯一标识，子网掩码用于划分网络和主机部分，网关连接不同网络，实现数据转发。DNS解析域名为IP地址，HTTP是应用层协议，用于传输和接收网页等资源。...","permalink":"/post/计算机网络基础知识点","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"计算机科学与技术","slug":"计算机科学与技术","count":6,"path":"api/categories/计算机科学与技术.json"}],"tags":[{"name":"计算机网络","slug":"计算机网络","count":1,"path":"api/tags/计算机网络.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true}}