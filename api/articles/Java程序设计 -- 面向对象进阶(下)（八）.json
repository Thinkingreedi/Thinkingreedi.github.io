{"title":"Java程序设计--面向对象进阶(下)","uid":"d1d7e86490a5e69b9e63a3257b8f9b8b","slug":"Java程序设计 -- 面向对象进阶(下)（八）","date":"2022-03-21T03:01:58.000Z","updated":"2025-07-14T15:12:20.462Z","comments":true,"path":"api/articles/Java程序设计 -- 面向对象进阶(下)（八）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","content":"<hr>\n<h1 id=\"1、包\"><a href=\"#1、包\" class=\"headerlink\" title=\"1、包\"></a>1、包</h1><p>包是用来分门别类的管理各种不同类的，类似于文件夹、建包利于程序的管理和维护。<br>建包的语法格式: <strong>package公司域名倒写.技术名称</strong>。包名建议全部英文小写，且具备意义<br>建包语句必须在第一行，一般IDEA工具会帮助创建。</p>\n<p><strong>导包</strong></p>\n<p>相同包下的类可以直接访问，不同包下的类必须导包,才可以使用!<br>导包格式: <strong>import包名.类名;</strong><br>&#x3D;&#x3D;假如一个类中需要用到不同类，而这个两个类的名称是一样的，那么默认只能导入一个类，另一个类要带包名访问&#x3D;&#x3D;。</p>\n<hr>\n<h1 id=\"2、权限修饰符\"><a href=\"#2、权限修饰符\" class=\"headerlink\" title=\"2、权限修饰符\"></a>2、权限修饰符</h1><p><strong>权限修饰符:是用来控制一个成员能够被访问的范围的。</strong></p>\n<p>可以修饰成员变量，方法，构造器，内部类，不同权限修饰符修饰的成员能够被访问的范围将受到限制。</p>\n<p>权限修饰符的分类和具体作用范围:</p>\n<p>&#x3D;&#x3D;权限修饰符:有四种作用范围由小到大(private -&gt;缺省-&gt; protected - &gt; public )&#x3D;&#x3D;</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">修饰符</th>\n<th align=\"center\">同一个类中</th>\n<th align=\"center\">同一个包中其它类</th>\n<th align=\"center\">不同包下的子类</th>\n<th align=\"center\">不同包下的无关类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">private</td>\n<td align=\"center\">√</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">缺省</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">protected</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">public</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">public class Fu &#123;\n    // 1.private 只能本类中访问\n    private void show1() &#123;\n        System.out.println(&quot;private&quot;);\n    &#125;\n\n    // 2.缺省：本类，同一个包下的类中。\n    void show2() &#123;\n        System.out.println(&quot;缺省&quot;);\n    &#125;\n\n    // 3.protected：本类，同一个包下的类中，其他包下的子类\n    protected void show3() &#123;\n        System.out.println(&quot;protected&quot;);\n    &#125;\n\n    // 4.任何地方都可以\n    public void show4() &#123;\n        System.out.println(&quot;public&quot;);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        //创建Fu的对象，测试看有哪些方法可以使用\n        Fu f = new Fu();\n        f.show1();\n        f.show2();\n        f.show3();\n        f.show4();\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Demo &#123;\n    public static void main(String[] args) &#123;\n        //创建Fu的对象，测试看有哪些方法可以使用\n        Fu f = new Fu();\n//        f.show1(); // 私有的\n        f.show2();\n        f.show3();\n        f.show4();\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h1 id=\"3、final\"><a href=\"#3、final\" class=\"headerlink\" title=\"3、final\"></a>3、final</h1><p>&#x3D;&#x3D;final关键字是最终的意思，可以修饰(方法，变量，类)&#x3D;&#x3D;</p>\n<ul>\n<li>&#x3D;&#x3D;修饰方法:表明该方法是最终方法，不能被重写。&#x3D;&#x3D;</li>\n<li>&#x3D;&#x3D;修饰变量:表示该变量第一次赋值后，不能再次被赋值(有且仅能被赋值一次)。&#x3D;&#x3D;</li>\n<li>&#x3D;&#x3D;修饰类:表明该类是最终类，不能被继承。&#x3D;&#x3D;</li>\n</ul>\n<pre><code class=\"java\">public class Test &#123;\n    // 属于类，只加载一次，可以共享 (常量)\n    public static final String schoolName = &quot;河工大&quot;;\n    public static final String schoolName2;\n    static&#123;\n        schoolName2 = &quot;中粮大&quot;;\n        // schoolName2 = &quot;中粮大&quot;; // 第二次赋值，报错了！\n    &#125;\n\n    // 属于对象的！ (final基本上不会用来修饰实例成员变量，没有意义！)\n    private final String name = &quot;王麻子&quot;;\n\n    public static void main(String[] args) &#123;\n       // final修饰变量，变量有且仅能被赋值一次。\n        /* 变量有几种：\n           局部变量。\n           成员变量。\n                -- 1、静态成员变量。\n                -- 2、实例成员变量。\n       */\n        final int age;\n        age = 12;\n        // age = 20; // 第二次赋值，报错了！\n        System.out.println(age);\n\n        final double rate = 3.14;\n\n        buy(0.8);\n\n        // schoolName = &quot;传智&quot;; // 第二次赋值，报错了！\n        Test t = new Test();\n        // t.name = &quot;麻子&quot;; // 第二次赋值，报错了！\n        System.out.println(t.name);\n    &#125;\n\n    public static void buy(final double z)&#123;\n        // z = 0.1; // 第二次赋值，报错了！\n    &#125;\n&#125;\n\n/**\n   final修饰方法，方法不能被重写\n */\nclass Animal&#123;\n    public final void run()&#123;\n        System.out.println(&quot;动物可以跑~~&quot;);\n    &#125;\n&#125;\n\nclass Tiger extends Animal&#123;\n//    @Override\n//    public void run() &#123;\n//        System.out.println(&quot;老虎跑的贼快~~~&quot;);\n//    &#125;\n&#125;\n</code></pre>\n<p>final修饰变量的注意</p>\n<ul>\n<li><strong>final修饰的变量是基本类型:那么变量存储的数据值不能发生改变。</strong></li>\n<li><strong>final修饰的变量是引用类型:那么变量存储的地址值不能发生改变，但是地址指向的对象内容是可以发生变化的。</strong></li>\n</ul>\n<pre><code class=\"java\">public class Test2 &#123;\n    public static void main(String[] args) &#123;\n        // final修饰变量的注意事项：\n        // 1、final修饰基本类型变量，其数据不能再改变\n        final double rate = 3.14;\n        // rate = 3.15; // 第二次赋值，报错\n\n        // 2、final修饰引用数据类型的变量，变量中存储的地址不能被改变，但是地址指向的对象内容可以改变。\n        final int[] arr = &#123;10, 20, 30&#125;;\n        System.out.println(arr);\n        // arr = null; // 属于第二次赋值，arr中的地址不能被改变\n        arr[1] = 200;\n        System.out.println(arr);\n        System.out.println(arr[1]);\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h1 id=\"4、常量\"><a href=\"#4、常量\" class=\"headerlink\" title=\"4、常量\"></a>4、常量</h1><p><strong>常量是使用了public static final修饰的成员变量，必须有初始化值，而且执行的过程中其值不能被改变。</strong></p>\n<p>常量的作用和好处:可以用于做系统的配置信息，方便程序的维护，同时也能提高可读性。</p>\n<p>常量命名规范：<strong>英文单词全部大写，多个单词下划线连接起来。</strong></p>\n<pre><code class=\"java\">public class ConstantDemo &#123;\n    public static final String SCHOOL_NAME = &quot;河工大&quot;;\n    public static final String USER_NAME = &quot;hauter&quot;;\n    public static final String PASS_WORD = &quot;123456&quot;;\n\n    public static void main(String[] args) &#123;\n        System.out.println(SCHOOL_NAME);\n        System.out.println(SCHOOL_NAME);\n        System.out.println(SCHOOL_NAME);\n        System.out.println(SCHOOL_NAME);\n        System.out.println(SCHOOL_NAME);\n        System.out.println(SCHOOL_NAME);\n\n        if(USER_NAME.equals(&quot;&quot;))&#123;\n\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>常量的执行原理</p>\n<p>在编译阶段会进行“宏替换”，把使用常量的地方全部替换成真实的字面量。</p>\n<p>这样做的好处是让使用常量的程序的执行性能与直接使用字面量是一样的。</p>\n<hr>\n<h1 id=\"5、枚举\"><a href=\"#5、枚举\" class=\"headerlink\" title=\"5、枚举\"></a>5、枚举</h1><p>枚举是Java中的一种特殊类型</p>\n<p><strong>枚举的作用:”是为了做信息的标志和信息的分类”。</strong></p>\n<pre><code class=\"java\">修饰符 enum 枚举名称&#123;\n    第一行都是罗列枚举类实例的名称\n&#125;\n\npublic enum Season&#123;\n    SPRING,SUMMER.AUTUMN,WINTER;\n&#125;\n</code></pre>\n<p>枚举的特征:</p>\n<ul>\n<li>枚举类都是继承了枚举类型: java.lang.Enum</li>\n<li>&#x3D;&#x3D;枚举都是最终类，不可以被继承。&#x3D;&#x3D;</li>\n<li>&#x3D;&#x3D;构造器都是私有的，枚举对外不能创建对象。&#x3D;&#x3D;</li>\n<li>枚举类的第一行默认都是罗列枚举对象的名称的。</li>\n<li>枚举类相当于是多例模式。</li>\n</ul>\n<hr>\n<h1 id=\"6、抽象类\"><a href=\"#6、抽象类\" class=\"headerlink\" title=\"6、抽象类\"></a>6、抽象类</h1><h2 id=\"6-1-抽象类、抽象方法\"><a href=\"#6-1-抽象类、抽象方法\" class=\"headerlink\" title=\"6.1 抽象类、抽象方法\"></a>6.1 抽象类、抽象方法</h2><p>&#x3D;&#x3D;在Java中abstract是抽象的意思，<strong>如果一个类中的某个方法的具体实现不能确定</strong>，就可以申明成abstract修饰的抽象方法（不能写方法体了)，这个类必须用abstract修饰，被称为抽象类。&#x3D;&#x3D;</p>\n<pre><code class=\"java\">修饰符 abstract 返回值类型 方法名称(形参列表);\n\n修饰符 abstract class 类名&#123;&#125;\n</code></pre>\n<pre><code class=\"java\">public abstract class Animal &#123;\n    private String name;\n\n    public abstract void run();\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Dog extends Animal&#123;\n    @Override\n    public void run() &#123;\n        System.out.println(&quot;狗跑的也很快~~~&quot;);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Tiger extends Animal&#123;\n    @Override\n    public void run() &#123;\n        System.out.println(&quot;老虎跑的贼溜~~~~&quot;);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Test &#123;\n    public static void main(String[] args) &#123;\n        Tiger t = new Tiger();\n        t.run();\n\n        Dog t1 = new Dog();\n        t1.run();\n    &#125;\n&#125;\n</code></pre>\n<p>抽象的使用总结与注意事项</p>\n<ul>\n<li>&#x3D;&#x3D;抽象类可以理解成类的不完整设计图，是用来被子类继承的。&#x3D;&#x3D;</li>\n<li>&#x3D;&#x3D;一个类如果继承了抽象类，那么这个类必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类。&#x3D;&#x3D;</li>\n</ul>\n<h2 id=\"6-2-抽象的特征和注意事项\"><a href=\"#6-2-抽象的特征和注意事项\" class=\"headerlink\" title=\"6.2 抽象的特征和注意事项\"></a>6.2 抽象的特征和注意事项</h2><ul>\n<li>有得有失:得到了抽象方法，失去了创建对象的能力。</li>\n<li>类有的成员（成员变量、方法、构造器）抽象类都具备</li>\n<li>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类</li>\n<li>一个类继承了抽象类必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类</li>\n<li>不能用abstract修饰变量、代码块、构造器。</li>\n</ul>\n<p><strong>final和abstract是互斥关系</strong></p>\n<ul>\n<li>abstract定义的抽象类作为模板让子类继承，final定义的类不能被继承。</li>\n<li>抽象方法定义通用功能让子类重写，final定义的方法子类不能重写。</li>\n</ul>\n<h2 id=\"6-3-模板方法模式\"><a href=\"#6-3-模板方法模式\" class=\"headerlink\" title=\"6.3 模板方法模式\"></a>6.3 模板方法模式</h2><p>模板方法模式实现步骤</p>\n<ul>\n<li>把功能定义成一个所谓的模板方法，放在抽象类中，模板方法中只定义通用且能确定的代码。</li>\n<li>模板方法中不能决定的功能定义成抽象方法让具体子类去实现。</li>\n</ul>\n<pre><code class=\"java\">public abstract class Account &#123;\n    private String cardId;\n    private double money;\n\n    public Account() &#123;\n    &#125;\n\n    public Account(String cardId, double money) &#123;\n        this.cardId = cardId;\n        this.money = money;\n    &#125;\n\n    /**\n      模板方法\n     */\n    public final void handle(String loginName , String passWord )&#123;\n        // a.判断登录是否成功\n        if(&quot;huater&quot;.equals(loginName) &amp;&amp; &quot;123456&quot;.equals(passWord))&#123;\n            System.out.println(&quot;登录成功。。&quot;);\n            // b.正式结算利息\n            // 当前模板方法知道所有子类账户都要结算利息，但是具体怎么结算，模板不清楚，交给具体的子类来计算\n            double result = calc();\n            // c.输出利息详情\n            System.out.println(&quot;本账户利息是：&quot;+ result);\n        &#125;else&#123;\n            System.out.println(&quot;用户名或者密码错误了&quot;);\n        &#125;\n    &#125;\n\n    public abstract double calc();\n\n\n    public String getCardId() &#123;\n        return cardId;\n    &#125;\n\n    public void setCardId(String cardId) &#123;\n        this.cardId = cardId;\n    &#125;\n\n    public double getMoney() &#123;\n        return money;\n    &#125;\n\n    public void setMoney(double money) &#123;\n        this.money = money;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">/**\n  活期账户\n */\npublic class CurrentAccount extends Account &#123;\n\n    public CurrentAccount(String cardId,  double money) &#123;\n        super(cardId, money);\n    &#125;\n\n    @Override\n    public double calc() &#123;\n        // b.正式结算利息\n        double result =  getMoney() * 0.0175; // 结算利息了\n        return result;\n    &#125;\n\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Test &#123;\n    public static void main(String[] args) &#123;\n        CurrentAccount acc = new CurrentAccount(&quot;ICBC-111&quot;, 100000);\n        acc.handle(&quot;hauter&quot;, &quot;123456&quot;);\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h1 id=\"7、接口\"><a href=\"#7、接口\" class=\"headerlink\" title=\"7、接口\"></a>7、接口</h1><h2 id=\"7-1-接口概述\"><a href=\"#7-1-接口概述\" class=\"headerlink\" title=\"7.1 接口概述\"></a>7.1 接口概述</h2><p>接口是一种规范，是接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。<br><img src=\"https://img-blog.csdnimg.cn/9e83de58699642afa8aaa30d203e1512.png#pic_center\"><br>接口的定义如下</p>\n<pre><code class=\"java\">public interface 接口名&#123;\n    //常量\n    //抽象方法\n&#125;\n</code></pre>\n<p><strong>接口不能实例化。</strong></p>\n<p>接口中的成员都是public修饰的，写不写都是，因为规范的目的是为了公开化。</p>\n<pre><code class=\"java\">public class Test &#123;\n    public static void main(String[] args) &#123;\n        // 接口不能创建对象！\n        // SportManInterface s = new SportManInterface();\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public interface SportManInterface &#123;\n    // 接口中的成员：JDK 1.8之前只有常量 和 抽象方法\n    // public static final 可以省略不写，接口默认会为你加上！\n    // public static final String SCHOOL_NAME = &quot;河工大&quot;;\n    String SCHOOL_NAME = &quot;河工大&quot;;\n\n    // 2、抽象方法\n    //  public abstract 可以省略不写，接口默认会为你加上！\n    // public abstract void run();\n    void run();\n\n    // public abstract void eat();\n    void eat();\n&#125;\n</code></pre>\n<h2 id=\"7-2-接口的使用–被实现\"><a href=\"#7-2-接口的使用–被实现\" class=\"headerlink\" title=\"7.2 接口的使用–被实现\"></a>7.2 接口的使用–被实现</h2><p>接口的用法:</p>\n<p><strong>接口是用来被类实现(implements)的，实现接口的类称为实现类。实现类可以理解成所谓的子类。</strong></p>\n<pre><code class=\"java\">修饰符  class 实现类 implements 接口1，接口2，接口3，...&#123;\n&#125;\n</code></pre>\n<p><strong>接口可以被类单实现，也可以被类多实现</strong></p>\n<p>接口实现的注意事项:</p>\n<p>一个类实现接口，必须重写完全部接口的全部抽象方法，否则这个类需要定义成抽象类。</p>\n<pre><code class=\"java\">public interface Law &#123;\n    void rule(); // 遵章守法\n&#125;\n</code></pre>\n<pre><code class=\"java\">public interface SportMan &#123;\n    void run();\n    void competition();\n&#125;\n</code></pre>\n<pre><code class=\"java\">/**\n   实现类（子类）\n */\npublic class PingPongMan implements SportMan , Law&#123;\n    private String name;\n    public PingPongMan(String name) &#123;\n        this.name = name;\n    &#125;\n\n    @Override\n    public void rule() &#123;\n        System.out.println(name + &quot;要遵章守法，不能随意外出，酗酒，约会~~~&quot;);\n    &#125;\n\n    @Override\n    public void run() &#123;\n        System.out.println(name + &quot;必须要跑步训练~~&quot;);\n    &#125;\n\n    @Override\n    public void competition() &#123;\n        System.out.println(name + &quot;需要参加国际比赛~~&quot;);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Test &#123;\n    public static void main(String[] args) &#123;\n        PingPongMan p = new PingPongMan(&quot;张松松&quot;);\n        p.rule();\n        p.run();\n        p.competition();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"7-3-接口与接口的关系–多继承\"><a href=\"#7-3-接口与接口的关系–多继承\" class=\"headerlink\" title=\"7.3 接口与接口的关系–多继承\"></a>7.3 接口与接口的关系–多继承</h2><p>类和类的关系:单继承。</p>\n<p>类和接口的关系:多实现。</p>\n<p>接口和接口的关系:多继承，一个接口可以同时继承多个接口。</p>\n<pre><code class=\"java\">public interface Law &#123;\n    void rule(); // 遵章守法\n    void eat();\n&#125;\n</code></pre>\n<pre><code class=\"java\">public interface People &#123;\n    void eat();\n&#125;\n</code></pre>\n<pre><code class=\"java\">public interface SportMan extends Law, People &#123;\n    void run();\n    void competition();\n&#125;\n</code></pre>\n<pre><code class=\"java\">/**\n   实现类\n */\n// public class BasketballMan implements Law, SportMan, People &#123;\npublic class BasketballMan implements SportMan&#123;\n\n    @Override\n    public void rule() &#123;\n\n    &#125;\n\n    @Override\n    public void eat() &#123;\n\n    &#125;\n\n\n    @Override\n    public void run() &#123;\n\n    &#125;\n\n    @Override\n    public void competition() &#123;\n\n    &#125;\n&#125;\n</code></pre>\n<p>接口多继承的作用</p>\n<p>规范合并，整合多个接口为同一个接口，便于子类实现。</p>\n<h2 id=\"7-4-接口的注意事项\"><a href=\"#7-4-接口的注意事项\" class=\"headerlink\" title=\"7.4 接口的注意事项\"></a>7.4 接口的注意事项</h2><ol>\n<li>接口不能创建对象</li>\n<li>一个类实现多个接口，多个接口中有同样的静态方法不冲突。</li>\n<li>一个类继承了父类，同时又实现了接口，父类中和接口中有同名方法，默认用父类的。</li>\n<li>一个类实现了多个接口，多个接口中存在同名的默认方法，不冲突，这个类重写该方法即可</li>\n<li>一个接口继承多个接口，是没有问题的，如果多个接口中存在规范冲突则不能多继承。</li>\n</ol>\n<hr>\n<h1 id=\"8、面向对象特征–多态\"><a href=\"#8、面向对象特征–多态\" class=\"headerlink\" title=\"8、面向对象特征–多态\"></a>8、面向对象特征–多态</h1><p><strong>同类型的对象，执行同一个行为，会表现出不同的行为特征。</strong></p>\n<pre><code class=\"java\">父类类型对象名称=new子类构造器;\n接口对象名称=new 实现类构造器;\n</code></pre>\n<pre><code class=\"java\">/**\n    父类\n */\npublic class Animal &#123;\n    public String name = &quot;动物名称&quot;;\n    public void run()&#123;\n        System.out.println(&quot;动物可以跑~~&quot;);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Dog extends Animal&#123;\n    public String name = &quot;狗名称&quot;;\n    @Override\n    public void run() &#123;\n        System.out.println(&quot;🐕跑的贼溜~~~~~&quot;);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Tortoise extends Animal&#123;\n    public String name = &quot;乌龟名称&quot;;\n\n    @Override\n    public void run() &#123;\n        System.out.println(&quot;🐢跑的非常慢~~~&quot;);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Test &#123;\n    public static void main(String[] args) &#123;\n        // 目标：先认识多态的形式\n        // 父类  对象名称 = new 子类构造器();\n        Animal a = new Dog();\n        a.run(); // 方法调用：编译看左，运行看右\n        System.out.println(a.name); // 方法调用：编译看左，运行也看左，动物名称\n\n        Animal a1 = new Dog();\n        a1.run();\n        System.out.println(a1.name); // 动物名称\n    &#125;\n&#125;\n</code></pre>\n<p>多态中成员访问特点</p>\n<ul>\n<li><strong>方法调用:编译看左边，运行看右边。</strong></li>\n<li><strong>变量调用:编译看左边，运行也看左边。</strong></li>\n</ul>\n<p>(多态侧重行为多态)多态的前提</p>\n<ol>\n<li>有继承&#x2F;实现关系;</li>\n<li>有父类引用指向子类对象;</li>\n<li>有方法重写。</li>\n</ol>\n<p>在多态形式下，右边对象可以实现解耦合，便于扩展和维护。</p>\n<pre><code class=\"java\">Animal a =new Dog0;\na.run();//后续业务行为随对象而变,后续代码无需修改\n</code></pre>\n<p>定义方法的时候，使用父类型作为参数，该方法就可以接收这父类的一切子类对象，体现出多态的扩展性与便利。</p>\n<p><strong>多态下会产生的一个问题:多态下不能使用子类的独有功能</strong></p>\n<ol>\n<li>自动类型转换（从子到父):子类对象赋值给父类类型的变量指向。</li>\n<li>强制类型转换（从父到子) 此时必须进行强制类型转换:&#x3D;&#x3D;子类对象变量&#x3D;(子类)父类类型的变量&#x3D;&#x3D;</li>\n</ol>\n<p>&#x3D;&#x3D;作用:可以解决多态下的劣势，可以实现调用子类独有的功能。&#x3D;&#x3D;</p>\n<p>&#x3D;&#x3D;注意:如果转型后的类型和对象真实类型不是同一种类型，那么在转换的时候就会出现ClassCastException&#x3D;&#x3D;</p>\n<pre><code class=\"java\">Animal t = new Tortoise();\nDog d = (Dog)t; //出现异常ClassCastException\n</code></pre>\n<pre><code class=\"java\">/**\n    父类\n */\npublic class Animal &#123;\n    public String name = &quot;动物名称&quot;;\n    public void run()&#123;\n        System.out.println(&quot;动物可以跑~~&quot;);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Dog extends Animal &#123;\n    public String name = &quot;狗名称&quot;;\n    @Override\n    public void run() &#123;\n        System.out.println(&quot;🐕跑的贼溜~~~~~&quot;);\n    &#125;\n\n    /**\n      独有功能\n     */\n    public void lookDoor()&#123;\n        System.out.println(&quot;🐕在看🚪！！！&quot;);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Tortoise extends Animal &#123;\n    public String name = &quot;乌龟名称&quot;;\n\n    @Override\n    public void run() &#123;\n        System.out.println(&quot;🐢跑的非常慢~~~&quot;);\n    &#125;\n\n    /**\n     独有功能\n     */\n    public void layEggs()&#123;\n        System.out.println(&quot;🐢在下蛋~~~&quot;);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">/**\n     多态形式下的类中转换机制。\n */\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        // 自动类型转换\n        Animal a = new Dog();\n        a.run();\n//        a.lookDoor(); // 多态下无法调用子类独有功能\n\n        // 强制类型转换:可以实现调用子类独有功能的\n        Dog d = (Dog) a;\n        d.lookDoor();\n\n        // 注意：多态下直接强制类型转换，可能出现类型转换异常\n        // 规定：有继承或者实现关系的2个类型就可以强制类型转换，运行时可能出现问题。\n        // Tortoise t1 = (Tortoise) a;\n        // 建议强制转换前，先判断变量指向对象的真实类型，再强制类型转换。\n        if(a instanceof Tortoise)&#123;\n            Tortoise t = (Tortoise) a;\n            t.layEggs();\n        &#125;else if(a instanceof Dog)&#123;\n            Dog d1 = (Dog) a;\n            d1.lookDoor();\n        &#125;\n\n        System.out.println(&quot;---------------------&quot;);\n        Animal a1 = new Dog();\n        go(a1);\n    &#125;\n\n    public static void go(Animal a)&#123;\n        System.out.println(&quot;预备~~~&quot;);\n        a.run();\n        // 独有功能\n        if(a instanceof Tortoise)&#123;\n            Tortoise t = (Tortoise) a;\n            t.layEggs();\n        &#125;else if(a instanceof Dog)&#123;\n            Dog d1 = (Dog) a;\n            d1.lookDoor();\n        &#125;\n        System.out.println(&quot;结束~~~~&quot;);\n    &#125;\n&#125;\n</code></pre>\n<p><strong>Java建议强转转换前使用instanceof判断当前对象的真实类型，再进行强制转换</strong></p>\n<pre><code class=\"java\">变量名instanceof真实类型\n</code></pre>\n<p>判断关键字左边的变量指向的对象的真实类型，是否是右边的类型或者是其子类类型，是则源回true,反之。</p>\n<hr>\n<h1 id=\"9、内部类\"><a href=\"#9、内部类\" class=\"headerlink\" title=\"9、内部类\"></a>9、内部类</h1><h2 id=\"9-1-内部类概述\"><a href=\"#9-1-内部类概述\" class=\"headerlink\" title=\"9.1 内部类概述\"></a>9.1 内部类概述</h2><p>内部类就是定义在一个类里面的类，里面的类可以理解成(寄生)，外部类可以理解成（宿主)。</p>\n<pre><code class=\"java\">public class People&#123;\n    public class Heart&#123;\n    &#125;\n&#125;\n</code></pre>\n<p>内部类的使用场景、作用</p>\n<ul>\n<li>当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构可以选择使用内部类来设计。</li>\n<li>内部类通常可以方便访问外部类的成员，包括私有的成员。</li>\n<li>内部类提供了更好的封装性，内部类本身就可以用private protectecd等修饰，封装性可以做更多控制</li>\n</ul>\n<h2 id=\"9-2-静态内部类（了解）\"><a href=\"#9-2-静态内部类（了解）\" class=\"headerlink\" title=\"9.2 静态内部类（了解）\"></a>9.2 静态内部类（了解）</h2><p>有static修饰，属于外部类本身。</p>\n<p>它的特点和使用与普通类是完全一样的，类有的成分它都有，只是位置在别人里面而已。</p>\n<pre><code class=\"java\">public class Outer&#123;\n    //静态成员内部类\n    public static class Inner&#123;\n    &#125;\n&#125;\n</code></pre>\n<p>静态内部类创建对象的格式</p>\n<pre><code class=\"java\">外部类名.内部类名 对象名 = new 外部类名.内部类构造器;\n\nOuter.Inner in = new Outer.Inner();\n</code></pre>\n<p>&#x3D;&#x3D;静态内部类中<strong>可以</strong>直接访问<strong>外部类的静态成员</strong>，外部类的静态成员只有一份可以被共享访问。&#x3D;&#x3D;</p>\n<p>&#x3D;&#x3D;静态内部类中<strong>不可以</strong>直接访问<strong>外部类的实例成员</strong>，外部类的实例成员必须用外部类对象访问。&#x3D;&#x3D;</p>\n<h2 id=\"9-3-成员内部类（了解）\"><a href=\"#9-3-成员内部类（了解）\" class=\"headerlink\" title=\"9.3 成员内部类（了解）\"></a>9.3 成员内部类（了解）</h2><p>无static修饰，属于外部类的对象。</p>\n<p>JDK16之前，成员内部类中不能定义静态成员，JDK16开始也可以定义静态成员了。</p>\n<pre><code class=\"java\">public class Outer&#123;\n    //成员内部类\n    public class Inner&#123;\n    &#125;\n&#125;\n</code></pre>\n<p>成员内部类创建对象的格式：</p>\n<pre><code class=\"java\">外部类名.内部类名 对象名 = new 外部类构造器.new 内部类构造器();\n\nOuter.Inner in = new Outer().new Inner();\n</code></pre>\n<p>&#x3D;&#x3D;成员内部类中<strong>可以</strong>直接访问<strong>外部类的静态成员</strong>，外部类的静态成员只有一份可以被共享访问。&#x3D;&#x3D;</p>\n<p>&#x3D;&#x3D;成员内部类的实例方法中<strong>可以</strong>直接访问<strong>外部类的实例成员</strong>，因为必须先有外部类对象，才能有成员内部类对象，所以可以直接访问外部类对象的实例成员&#x3D;&#x3D;</p>\n<h2 id=\"9-4-局部内部类（了解）\"><a href=\"#9-4-局部内部类（了解）\" class=\"headerlink\" title=\"9.4 局部内部类（了解）\"></a>9.4 局部内部类（了解）</h2><p>局部内部类放在方法、代码块、构造器等执行体中。</p>\n<p>局部内部类的类文件名为:外部类$N内部类.class。</p>\n<h2 id=\"9-5-匿名内部类（重点）\"><a href=\"#9-5-匿名内部类（重点）\" class=\"headerlink\" title=\"9.5 匿名内部类（重点）\"></a>9.5 匿名内部类（重点）</h2><p>本质上是一个没有名字的局部内部类，定义在方法中、代码块中、等。</p>\n<p><strong>作用:方便创建子类对象，最终目的为了简化代码编写。</strong></p>\n<pre><code class=\"java\">new 类|抽象名|接口名()&#123;\n    重写方法；\n&#125;；\n</code></pre>\n<pre><code class=\"java\">/**\n      匿名内部类的形式和特点。\n */\npublic class Test1 &#123;\n    public static void main(String[] args) &#123;\n        Animal a = new Animal()&#123;\n            @Override\n            public void run() &#123;\n                System.out.println(&quot;老虎跑的块~~~&quot;);\n            &#125;\n        &#125;;\n        a.run();\n    &#125;\n&#125;\n\n//class Tiger extends Animal&#123;\n//    @Override\n//    public void run() &#123;\n//        System.out.println(&quot;老虎跑的块~~~&quot;);\n//    &#125;\n//&#125;\n\nabstract class Animal&#123;\n    public abstract void run();\n&#125;\n</code></pre>\n<pre><code class=\"java\">/**\n    匿名内部类的使用形式（语法）\n */\npublic class Test2 &#123;\n    public static void main(String[] args) &#123;\n        Swimming s = new Swimming() &#123;\n            @Override\n            public void swim() &#123;\n                System.out.println(&quot;学生快乐的自由泳🏊‍&quot;);\n            &#125;\n        &#125;;\n        go(s);\n\n        System.out.println(&quot;--------------&quot;);\n\n        Swimming s1 = new Swimming() &#123;\n            @Override\n            public void swim() &#123;\n                System.out.println(&quot;老师泳🏊的贼快~~~~~&quot;);\n            &#125;\n        &#125;;\n        go(s1);\n\n        System.out.println(&quot;--------------&quot;);\n\n        go(new Swimming() &#123;\n            @Override\n            public void swim() &#123;\n                System.out.println(&quot;运动员🏊的贼快啊~~~~~&quot;);\n            &#125;\n        &#125;);\n\n\n    &#125;\n\n    /**\n       学生 老师 运动员可以一起参加游泳比赛\n     */\n    public static void go(Swimming s)&#123;\n        System.out.println(&quot;开始。。。&quot;);\n        s.swim();\n        System.out.println(&quot;结束。。。&quot;);\n    &#125;\n&#125;\n\n\ninterface Swimming&#123;\n    void swim();\n&#125;\n</code></pre>\n<p>特点总结:</p>\n<ol>\n<li>匿名内部类是一个没有名字的内部类。</li>\n<li>匿名内部类写出来就会产生一个匿名内部类的对象。</li>\n<li>匿名内部类的对象类型相当于是当前new的那个的类型的子类类型。</li>\n<li>匿名内部类可以作为方法的实际参数进行传输。</li>\n</ol>\n<hr>\n<h1 id=\"10、泛型\"><a href=\"#10、泛型\" class=\"headerlink\" title=\"10、泛型\"></a>10、泛型</h1><ul>\n<li>定义类、接口、方法时，**同时声明了一个或者多个类型变量(如: &lt; E &gt;)**，称为泛型类、泛型接口，泛型方法、它们统称为泛型。</li>\n</ul>\n<pre><code class=\"java\">public class ArrayList&lt;E&gt;&#123;\n    ...\n&#125;\n</code></pre>\n<ul>\n<li>作用：泛型提供了在编译阶段约束所能操作的数据类型，并自动进行检查的能力!<strong>这样可以避免强制类型转换，及其可能出现的异常。</strong></li>\n<li><strong>泛型的本质：把具体的数据类型作为参数传给类型变量。</strong></li>\n</ul>\n<pre><code class=\"java\">// 泛型类\n修饰符 class 类名&lt;类型变量,类型变量,...&gt;&#123;\n    \n&#125;\npublic class ArrayList&lt;E&gt;&#123;\n    ...\n&#125;\n\n// 泛型接口\n修饰符 interface 接口名&lt;类型变量,类型变量,...&gt;&#123;\n    \n&#125;\npublic interface A&lt;E&gt;&#123;\n    ...\n&#125;\n\n// 泛型方法\n修饰符 &lt;类型变量,类型变量,...&gt; 返回值类型 方法名(形参列表)&#123;\n    \n&#125;\n</code></pre>\n<ul>\n<li>类型变量建议用大写的英文字母，常用的有：E、T、K、V等</li>\n<li>通配符：就是“?”，可以在“使用泛型”的时候代表一切类型；E、T、K、V是在定义泛型的时候使用。</li>\n<li>泛型上下限：<ul>\n<li>泛型上限: ? extends car:?能接收的必须是Car或者其子类。</li>\n<li>泛型下限:? super Car : ?能接收的必须是Car或者其父类。</li>\n</ul>\n</li>\n<li>注意：<ul>\n<li>泛型是工作在编译阶段的，一旦程序编译成class文件，class文件中就不存在泛型了，这就是泛型擦除。</li>\n<li>泛型不支持基本数据类型，只能支持对象类型(引用数据类型)。</li>\n</ul>\n</li>\n</ul>\n","feature":true,"text":"final用于修饰不可改变的类、方法或变量；抽象类不能实例化，只能作为父类，可以包含抽象方法和具体方法；接口定义方法签名但不提供实现，类可以实现多个接口。它们能够提供代码的安全性、可维护性和灵活性。...","permalink":"/post/Java程序设计 -- 面向对象进阶(下)（八）","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"17 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%8C%85\"><span class=\"toc-text\">1、包</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2%E3%80%81%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6\"><span class=\"toc-text\">2、权限修饰符</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3%E3%80%81final\"><span class=\"toc-text\">3、final</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4%E3%80%81%E5%B8%B8%E9%87%8F\"><span class=\"toc-text\">4、常量</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5%E3%80%81%E6%9E%9A%E4%B8%BE\"><span class=\"toc-text\">5、枚举</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#6%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB\"><span class=\"toc-text\">6、抽象类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-1-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">6.1 抽象类、抽象方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-2-%E6%8A%BD%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">6.2 抽象的特征和注意事项</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-3-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">6.3 模板方法模式</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#7%E3%80%81%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">7、接口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-1-%E6%8E%A5%E5%8F%A3%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">7.1 接口概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-2-%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8%E2%80%93%E8%A2%AB%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">7.2 接口的使用–被实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-3-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB%E2%80%93%E5%A4%9A%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">7.3 接口与接口的关系–多继承</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-4-%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">7.4 接口的注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#8%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81%E2%80%93%E5%A4%9A%E6%80%81\"><span class=\"toc-text\">8、面向对象特征–多态</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#9%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB\"><span class=\"toc-text\">9、内部类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-1-%E5%86%85%E9%83%A8%E7%B1%BB%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">9.1 内部类概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-2-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89\"><span class=\"toc-text\">9.2 静态内部类（了解）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-3-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89\"><span class=\"toc-text\">9.3 成员内部类（了解）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-4-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89\"><span class=\"toc-text\">9.4 局部内部类（了解）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-5-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\"><span class=\"toc-text\">9.5 匿名内部类（重点）</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#10%E3%80%81%E6%B3%9B%E5%9E%8B\"><span class=\"toc-text\">10、泛型</span></a></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Java程序设计--常用API(上)","uid":"b96805334df48e1df4b0636b2d6744aa","slug":"Java程序设计 -- 常用API(上)（九）","date":"2022-03-21T14:27:13.000Z","updated":"2025-07-14T15:12:20.460Z","comments":true,"path":"api/articles/Java程序设计 -- 常用API(上)（九）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","text":"String是Java中表示字符串的类，提供了丰富的字符串操作方法。ArrayList是Java中的动态数组实现，可以动态增加或减少元素。这两个类在Java编程中经常被用到，提供了便利的字符串处理和动态数组功能。...","permalink":"/post/Java程序设计 -- 常用API(上)（九）","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true},"next_post":{"title":"Java程序设计--面向对象进阶(上)","uid":"85159c9648aa55d2d25caaf72205c399","slug":"Java程序设计 -- 面向对象进阶(上)（七）","date":"2022-03-20T01:40:03.000Z","updated":"2025-07-14T15:12:20.462Z","comments":true,"path":"api/articles/Java程序设计 -- 面向对象进阶(上)（七）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","text":"在Java中，关键字static用于声明静态成员，这些成员属于类本身而不是对象。静态成员在类加载时被初始化，可以通过类名直接访问，无需创建对象。继承和静态成员的结合使用可以实现代码的重用和扩展。通过继承，子类可以继承父类的属性和方法。而通过静态成员，可以在不创建对象的情况下直接访问类的成员。...","permalink":"/post/Java程序设计 -- 面向对象进阶(上)（七）","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true}}