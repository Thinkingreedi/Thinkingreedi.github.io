{"title":"提高开发效率：ES6技巧大全","uid":"26420f1034bff9b91a54684d743949a2","slug":"前端--一文轻松搞懂ES6-ES11(ES6详解)","date":"2023-01-12T00:36:22.000Z","updated":"2025-07-14T15:12:20.465Z","comments":true,"path":"api/articles/前端--一文轻松搞懂ES6-ES11(ES6详解).json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/693b39076a084dd39ab56802ff1834b9.jpeg","content":"<h1 id=\"ECMAScript-6-11\"><a href=\"#ECMAScript-6-11\" class=\"headerlink\" title=\"ECMAScript 6-11\"></a>ECMAScript 6-11</h1><h2 id=\"1、ECMAScript-相关介绍\"><a href=\"#1、ECMAScript-相关介绍\" class=\"headerlink\" title=\"1、ECMAScript 相关介绍\"></a>1、ECMAScript 相关介绍</h2><h3 id=\"1-1-ECMAScript简介\"><a href=\"#1-1-ECMAScript简介\" class=\"headerlink\" title=\"1.1 ECMAScript简介\"></a>1.1 ECMAScript简介</h3><p><img src=\"https://img-blog.csdnimg.cn/5d40cbca8087406a839d8748616b799c.png#pic_center\"></p>\n<ul>\n<li>ECMA（European Computer Manufacturers Association）中文名称为欧洲计算机制造商协会，这个组织的目标是评估、开发和认可电信和计算机标准。1994 年后该组织改名为 ECMA 国际</li>\n<li>ECMAScript 是由 Ecma 国际通过 ECMA-262 标<a href=\"https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80\">准化的脚本程序设计语言</a></li>\n<li>Ecma 国际制定了许多标准，而 ECMA-262 只是其中的一个，所有标准列表查看：<a href=\"http://www.ecma-international.org/publications/standards/Standard.html\">http://www.ecma-international.org/publications/standards/Standard.html</a></li>\n<li>ECMA-262（ECMAScript）历史版本查看网址：<a href=\"http://www.ecma-international.org/publications/standards/Ecma-262-arch.htm\"> http://www.ecma-international.org/publications/standards/Ecma-262-arch.htm</a></li>\n</ul>\n<h3 id=\"1-2-ES6的重要性\"><a href=\"#1-2-ES6的重要性\" class=\"headerlink\" title=\"1.2 ES6的重要性\"></a>1.2 ES6的重要性</h3><ul>\n<li><p>ES6 的版本变动内容最多，具有里程碑意义</p>\n</li>\n<li><p>ES6 加入许多新的语法特性，编程实现更简单、高效</p>\n</li>\n<li><p>ES6 是前端发展趋势，就业必备技能</p>\n</li>\n<li><p><a href=\"http://kangax.github.io/compat-table/es6/\"> http://kangax.github.io/compat-table/es6/</a> 可查看兼容性</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/cf54f136d06a410b99b8d97357f21c54.png#pic_center\"></p>\n<h2 id=\"2、ECMAScript-6新特性\"><a href=\"#2、ECMAScript-6新特性\" class=\"headerlink\" title=\"2、ECMAScript 6新特性\"></a>2、ECMAScript 6新特性</h2><h3 id=\"2-1-let关键字\"><a href=\"#2-1-let关键字\" class=\"headerlink\" title=\"2.1 let关键字\"></a>2.1 let关键字</h3><ul>\n<li><p>let关键字用来声明变量，使用let声明的变量有几个特点:</p>\n<ol>\n<li><p>不允许重复声明</p>\n</li>\n<li><p>块级作用域</p>\n</li>\n<li><p>不存在变量提升</p>\n</li>\n<li><p>不影响作用域链</p>\n</li>\n</ol>\n</li>\n<li><p>代码：</p>\n</li>\n</ul>\n<pre><code class=\"JavaScript\">//声明变量\nlet a;\nlet b, c, d;\nlet e = 100;\nlet f = 521, g = &#39;iloveyou&#39;, h = [];\n\n//1. 变量不能重复声明\n// let star = &#39;罗志祥&#39;;\n// let star = &#39;小猪&#39;;报错\n\n//2. 块儿级作用域  全局, 函数, eval\n// if else while for \n// &#123;\n//     let girl = &#39;周扬青&#39;;\n// &#125;\n// console.log(girl);//报错\n\n//3. 不存在变量提升\n// console.log(song);\n// let song = &#39;恋爱达人&#39;;//报错\n\n//4. 不影响作用域链\nlet school = &#39;河工大&#39;;\n     function fn() &#123;\n          console.log(school);\n     &#125;\n     fn();\n&#125;\n</code></pre>\n<ul>\n<li><strong>应用场景:以后声明变量直接使用let</strong></li>\n</ul>\n<h3 id=\"2-2-const关键字\"><a href=\"#2-2-const关键字\" class=\"headerlink\" title=\"2.2 const关键字\"></a>2.2 const关键字</h3><ul>\n<li><p>const关键字用来声明常量，const声明有以下特点：</p>\n<ol>\n<li><p>声明必须赋初始值</p>\n</li>\n<li><p>标识符一般为大写</p>\n</li>\n<li><p>不允许重复声明</p>\n</li>\n<li><p>值不允许修改</p>\n</li>\n<li><p>块级作用域</p>\n</li>\n</ol>\n</li>\n<li><p>代码：</p>\n</li>\n</ul>\n<pre><code class=\"JavaScript\">//声明常量\nconst SCHOOL = &#39;河工大&#39;;\n\n//1. 一定要赋初始值\n// const A;//报错\n\n//2. 一般常量使用大写(潜规则)\n// const a = 100;\n\n//3. 常量的值不能修改\n// SCHOOL = &#39;HAUT&#39;;//报错\n\n//4. 块儿级作用域\n// &#123;\n// \t\tconst PLAYER = &#39;UZI&#39;;\n// &#125;\n// console.log(PLAYER);\n\n//5. 对于数组和对象的元素修改, 不算做对常量的修改, 不会报错\n//const TEAM = [&#39;UZI&#39;,&#39;MXLG&#39;,&#39;Ming&#39;,&#39;Letme&#39;];\n// TEAM.push(&#39;Meiko&#39;);\n</code></pre>\n<ul>\n<li><strong>注意:对象属性修改和数组元素变化不会出现const错误</strong></li>\n<li><strong>应用场景:声明对象类型使用const，非对象类型声明选择let</strong></li>\n</ul>\n<h3 id=\"2-3-变量的解构赋值\"><a href=\"#2-3-变量的解构赋值\" class=\"headerlink\" title=\"2.3 变量的解构赋值\"></a>2.3 变量的解构赋值</h3><ul>\n<li>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构赋值</li>\n<li>代码：</li>\n</ul>\n<pre><code class=\"JavaScript\">//1. 数组的结构\n// const F4 = [&#39;小沈阳&#39;, &#39;刘能&#39;, &#39;赵四&#39;, &#39;宋小宝&#39;];\n// let [xiao, liu, zhao, song] = F4;//解构赋值\n// console.log(xiao);\n// console.log(liu);\n// console.log(zhao);\n// console.log(song);\n\n//2. 对象的解构\nconst zhao = &#123;\n    name: &#39;赵本山&#39;,\n    age: &#39;不详&#39;,\n    xiaopin: function()&#123;\n             console.log(&quot;我可以演小品&quot;);\n         &#125;\n    &#125;;\n\nlet &#123;name, age, xiaopin&#125; = zhao;//解构赋值\nconsole.log(name);\nconsole.log(age);\nconsole.log(xiaopin);\nxiaopin();\n\nlet &#123; xiaopin &#125; = zhao;\nxiaopin();\n</code></pre>\n<ul>\n<li><strong>注意:频繁使用对象方法、数组元素，就可以使用解构赋值形式</strong></li>\n</ul>\n<h3 id=\"2-4-模板字符串\"><a href=\"#2-4-模板字符串\" class=\"headerlink\" title=\"2.4 模板字符串\"></a>2.4 模板字符串</h3><ul>\n<li><p>模板字符串(template string）是增强版的字符串，用反引号（&#96;&#96;）标识，</p>\n</li>\n<li><p>特点:</p>\n<ol>\n<li>字符串中可以出现换行符</li>\n<li>可以使用${xxx}形式输出变量</li>\n</ol>\n</li>\n<li><p>代码：</p>\n</li>\n</ul>\n<pre><code class=\"JavaScript\">//1. 声明\nlet str = `我也是一个字符串哦!`;\nconsole.log(str, typeof str);\n\n//2. 内容中可以直接出现换行符\nlet str = `&lt;ul&gt;\n            &lt;li&gt;沈腾&lt;/li&gt;\n            &lt;li&gt;玛丽&lt;/li&gt;\n            &lt;li&gt;魏翔&lt;/li&gt;\n               &lt;li&gt;艾伦&lt;/li&gt;\n           &lt;/ul&gt;`;\n//3. 变量拼接\nlet lovest = &#39;魏翔&#39;;\nlet out = `$&#123;lovest&#125;是我心目中最搞笑的演员!!`;\nconsole.log(out);\n</code></pre>\n<ul>\n<li><strong>注意:当遇到字符串与变量拼接的情况使用模板字符串</strong></li>\n</ul>\n<h3 id=\"2-5-简化对象写法\"><a href=\"#2-5-简化对象写法\" class=\"headerlink\" title=\"2.5 简化对象写法\"></a>2.5 简化对象写法</h3><ul>\n<li>ES6允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁</li>\n<li>代码：</li>\n</ul>\n<pre><code class=\"JavaScript\">let name = &#39;尚硅谷&#39;;\nlet change = function()&#123;\n    console.log(&#39;我们可以改变你!!&#39;);\n&#125;\n\nconst school = &#123;\n    name,\n    change,\n    improve()&#123;\n        console.log(&quot;我们可以提高你的技能&quot;);\n    &#125;\n&#125;\n\nconsole.log(school);\n</code></pre>\n<ul>\n<li><strong>注意:对象简写形式简化了代码，所以以后用简写就对了</strong></li>\n</ul>\n<h3 id=\"2-6-箭头函数\"><a href=\"#2-6-箭头函数\" class=\"headerlink\" title=\"2.6 箭头函数\"></a>2.6 箭头函数</h3><ul>\n<li><p>ES6允许使用「箭头」（&#x3D;&gt;)定义函数</p>\n</li>\n<li><p>箭头函数的注意点:</p>\n<ol>\n<li>如果形参只有一个，则小括号可以省略</li>\n<li>函数体如果只有一条语句，则花括号可以省略，函数的返回值为该条语句的执行结果</li>\n<li>箭头函数this 指向声明时所在作用域下this 的值</li>\n<li>箭头函数不能作为构造函数实例化</li>\n<li>不能使用arguments</li>\n</ol>\n</li>\n<li><p>代码：</p>\n</li>\n</ul>\n<pre><code class=\"JavaScript\">//普通函数\nlet fn = function()&#123;\n\n&#125;\n//箭头函数\nlet fn = (a,b) =&gt; &#123;\n     return a + b;\n&#125;\n\n//1. this 是静态的. this 始终指向函数声明时所在作用域下的 this 的值\nfunction getName() &#123;\n    console.log(this.name);\n&#125;\nlet getName2 = () =&gt; &#123;\n    console.log(this.name);\n&#125;\n\n//设置 window 对象的 name 属性\nwindow.name = &#39;河工大&#39;;\n    const school = &#123;\n        name: &quot;haut&quot;\n&#125;\n\n//直接调用\ngetName();//河工大\ngetName2();//河工大\n\n//call 方法调用\ngetName.call(school);//haut\ngetName2.call(school);//河工大\n\n//2. 不能作为构造实例化对象\n// let Person = (name, age) =&gt; &#123;\n// \t\tthis.name = name;\n// \t\tthis.age = age;\n// &#125;\n// let me = new Person(&#39;xiao&#39;,30);\n// console.log(me);\n\n//3. 不能使用 arguments 变量\n// let fn = () =&gt; &#123;\n// \t\tconsole.log(arguments);\n// &#125;\n// fn(1,2,3);\n\n//4. 箭头函数的简写\n//1) 省略小括号, 当形参有且只有一个的时候\nlet add = n =&gt; &#123;\n    return n + n;\n&#125;\nconsole.log(add(9));\n//2) 省略花括号, 当代码体只有一条语句的时候, 此时 return 必须省略\n// 而且语句的执行结果就是函数的返回值\nlet pow = n =&gt; n * n;\nconsole.log(pow(8));\n</code></pre>\n<ul>\n<li><strong>注意:箭头函数不会更改this指向，用来指定回调函数会非常合适</strong></li>\n</ul>\n<h3 id=\"2-7-rest参数\"><a href=\"#2-7-rest参数\" class=\"headerlink\" title=\"2.7 rest参数\"></a>2.7 rest参数</h3><ul>\n<li>ES6引入rest参数，用于获取函数的实参，用来代替arguments</li>\n<li>代码：</li>\n</ul>\n<pre><code class=\"JavaScript\">// ES5 获取实参的方式\nfunction date() &#123;\n    console.log(arguments);\n&#125;\ndate(&#39;白芷&#39;, &#39;阿娇&#39;, &#39;思慧&#39;);//Array(3)\n\n// rest 参数\nfunction date(...args) &#123;\n    console.log(args);// filter some every map\n&#125;\ndate(&#39;阿娇&#39;, &#39;柏芝&#39;, &#39;思慧&#39;);//Array(3)\n\n// rest 参数必须要放到参数最后\nfunction fn(a, b, ...args) &#123;\n    console.log(a);\n    console.log(b);\n    console.log(args);\n&#125;\nfn(1, 2, 3, 4, 5, 6);//1,2,Array(4)\n</code></pre>\n<ul>\n<li><strong>注意: rest参数非常适合不定个数参数函数的场景</strong></li>\n</ul>\n<p><strong>补充：参数默认值</strong></p>\n<ul>\n<li>代码：</li>\n</ul>\n<pre><code class=\"javascript\">//1. 形参初始值 具有默认值的参数, 一般位置要靠后(潜规则)\nfunction add(a, b, c = 10) &#123;\n    return a + b + c;\n&#125;\nlet result = add(1, 2);\nconsole.log(result);\n\n//2. 与解构赋值结合\nfunction connect(&#123; host = &quot;127.0.0.1&quot;, username, password, port &#125;) &#123;\n    console.log(host)\n    console.log(username)\n    console.log(password)\n    console.log(port)\n&#125;\nconnect(&#123;\n    host: &#39;ASHIYI.com&#39;,\n    username: &#39;root&#39;,\n    password: &#39;root&#39;,\n    port: 3306\n&#125;)\n</code></pre>\n<h3 id=\"2-8-spread扩展运算符\"><a href=\"#2-8-spread扩展运算符\" class=\"headerlink\" title=\"2.8 spread扩展运算符\"></a>2.8 spread扩展运算符</h3><ul>\n<li>扩展运算符(spread）也是三个点(…）。它好比 rest参数的逆运算，将一个数组转为用逗号分隔的参数序列，对数组进行解包</li>\n<li>代码：</li>\n</ul>\n<pre><code class=\"JavaScript\">const tfboys = [&#39;易烊千玺&#39;,&#39;王源&#39;,&#39;王俊凯&#39;];\n\nfunction chunwan()&#123;\n    console.log(arguments);\n&#125;\n\nchunwan(...tfboys);// chunwan(&#39;易烊千玺&#39;,&#39;王源&#39;,&#39;王俊凯&#39;)\n\n//扩展运算符的应用\n//1. 数组的合并\nconst kuaizi = [&#39;王太利&#39;, &#39;肖央&#39;];\nconst fenghuang = [&#39;曾毅&#39;, &#39;玲花&#39;];\n// const zuixuanxiaopingguo = kuaizi.concat(fenghuang);\nconst zuixuanxiaopingguo = [...kuaizi, ...fenghuang];\nconsole.log(zuixuanxiaopingguo);\n\n//2. 数组的克隆\nconst sanzhihua = [&#39;E&#39;, &#39;G&#39;, &#39;M&#39;];\nconst sanyecao = [...sanzhihua];// [&#39;E&#39;,&#39;G&#39;,&#39;M&#39;]\nconsole.log(sanyecao);\n\n//3. 将伪数组转为真正的数组\nconst divs = document.querySelectorAll(&#39;div&#39;);\nconst divArr = [...divs];\nconsole.log(divArr);// arguments\n</code></pre>\n<h3 id=\"2-9-Symbol\"><a href=\"#2-9-Symbol\" class=\"headerlink\" title=\"2.9 Symbol\"></a>2.9 Symbol</h3><p><strong>Symbol基本使用</strong></p>\n<ul>\n<li><p>ES6引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是JavaScript语言的第七种数据类型，是一种类似于字符串的数据类型</p>\n</li>\n<li><p>Symbol特点</p>\n<ol>\n<li>Symbol的值是唯一的，用来解决命名冲突的问题</li>\n<li>Symbol值不能与其他数据进行运算</li>\n<li>Symbol定义的对象属性不能使用for …in循环遍历，但是可以使用Reflect.ownKeys来获取对象的所有键名</li>\n</ol>\n</li>\n<li><p>代码：</p>\n</li>\n</ul>\n<pre><code class=\"JavaScript\">//创建Symbol\nlet s = Symbol();\n// console.log(s, typeof s);\nlet s2 = Symbol(&#39;尚硅谷&#39;);\nlet s3 = Symbol(&#39;尚硅谷&#39;);\nconsole.log(s2 === s3)//false\n\n//Symbol.for 创建\nlet s4 = Symbol.for(&#39;尚硅谷&#39;);\nlet s5 = Symbol.for(&#39;尚硅谷&#39;);\nconsole.log(s4 === s5)//true\n//Symbol.for()不会每次调用就返回一个新的Symbol类型的值，而是先检查给定的参数字符串是否已存在，如果不存在才会新建一个并返回一个该字符串为名称的Symbol值\n</code></pre>\n<ul>\n<li><strong>注:遇到唯一性的场景时要想到symbol</strong></li>\n</ul>\n<p><strong>Symbol内置值</strong></p>\n<ul>\n<li>除了定义自己使用的Symbol值以外,ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。可以称这些方法为魔术方法，因为它们会在特定的场景下自动执行</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Symbol.hasInstance</td>\n<td align=\"center\">当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol.isConcatSpreadable</td>\n<td align=\"center\">对象的Symbol.isConcatSpreadable属性等于的是一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol.species</td>\n<td align=\"center\">创建衍生对象时，会使用该属性</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol.match</td>\n<td align=\"center\">当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值</td>\n</tr>\n<tr>\n<td align=\"center\">symbol.replace</td>\n<td align=\"center\">当该对象被str.replace(myObject)方法调用时，会返回该方法的返回值</td>\n</tr>\n<tr>\n<td align=\"center\">symbol.search</td>\n<td align=\"center\">当该对象被str.search (myObject)方法调用时，会返回该方法的返回值</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol.split</td>\n<td align=\"center\">当该对象被str.split (myObject)方法调用时，会返回该方法的返回值</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol.iterator</td>\n<td align=\"center\">对象进行for..of 循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器</td>\n</tr>\n<tr>\n<td align=\"center\">symbol.toPrimitive</td>\n<td align=\"center\">该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol.toStringTag</td>\n<td align=\"center\">在该对象上面调用toString方法时，返回该方法的返回值</td>\n</tr>\n<tr>\n<td align=\"center\">symbol. unscopables</td>\n<td align=\"center\">该对象指定了使用with关键字时,哪些属性会被with环境排除</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-10-迭代器\"><a href=\"#2-10-迭代器\" class=\"headerlink\" title=\"2.10 迭代器\"></a>2.10 迭代器</h3><ul>\n<li><p>遍历器（lterator）就是一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署lterator接口,就可以完成遍历操作</p>\n<ol>\n<li><p>ES6创造了一种新的遍历命令for…of循环，lterator接口主要供 for…of消费</p>\n</li>\n<li><p>原生具备iterator接口的数据(可用for of 遍历)<br>a)Array</p>\n<p>b)Arguments</p>\n<p>c)Set</p>\n<p>d)Map</p>\n<p>e)string</p>\n<p>f)TypedArray</p>\n<p>g)NodeList</p>\n</li>\n<li><p>工作原理<br> a)创建一个指针对象，指向当前数据结构的起始位置</p>\n<p> b)第一次调用对象的next方法，指针自动指向数据结构的第一个成员</p>\n<p> c)接下来不断调用next方法，指针一直往后移动，直到指向最后一个成员</p>\n<p> d)每调用next方法返回一个包含value(值)和 done(判断循环是否完成)属性的对象</p>\n</li>\n</ol>\n</li>\n<li><p>代码：</p>\n</li>\n</ul>\n<pre><code class=\"JavaScript\">//声明一个数组\nconst xiyou = [&#39;唐僧&#39;, &#39;孙悟空&#39;, &#39;猪八戒&#39;, &#39;沙僧&#39;];\n\n//使用 for...of 遍历数组\nfor (let v of xiyou) &#123;\n    console.log(v);\n&#125;\n</code></pre>\n<ul>\n<li><strong>注:需要自定义遍历数据的时候，要想到迭代器</strong></li>\n</ul>\n<h3 id=\"2-11-生成器\"><a href=\"#2-11-生成器\" class=\"headerlink\" title=\"2.11 生成器\"></a>2.11 生成器</h3><ul>\n<li>生成器函数是ES6提供的一种异步编程解决方案,语法行为与传统函数完全不同</li>\n<li>代码：</li>\n</ul>\n<pre><code class=\"JavaScript\">function * gen()&#123;\n\n    yield &#39;一只没有耳朵&#39;;\n\n    yield &#39;一只没有尾部&#39;;\n    \n    yield &#39;真奇怪&#39;;\n&#125;\n\nlet iterator = gen();\nconsole.log(iterator.next());\nconsole.log(iterator.next());\nconsole.log(iterator.next());\nconsole.log(iterator.next());\n</code></pre>\n<ul>\n<li>代码说明:<ol>\n<li>*的位置没有限制</li>\n<li>生成器函数返回的结果是迭代器对象,调用迭代器对象的next方法可以得到yield 语句后的值</li>\n<li>yield相当于函数的暂停标记，也可以认为是函数的分隔符，每调用一次next方法，执行一段代码</li>\n<li>next方法可以传递实参，作为yield语句的返回值</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"2-12-Promise\"><a href=\"#2-12-Promise\" class=\"headerlink\" title=\"2.12 Promise\"></a>2.12 Promise</h3><ul>\n<li><p>Promise是ES6引入的异步编程的新解决方案。语法上 Promise是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果</p>\n<ol>\n<li>Promise构造函数: Promise (excutor){}</li>\n<li>Promise.prototype.then方法；<strong>then方法的返回结果是 Promise 对象, 对象状态由回调函数的执行结果决定；如果回调函数中返回的结果是 非 promise 类型的属性, 状态为成功, 返回值为对象的成功的值；如果返回是 promise类型 对象，内部返回promise状态决定than方法返回promise状态；抛出错误，状态是失败，值为抛出的值</strong></li>\n<li>Promise.prototype.catch方法；</li>\n</ol>\n</li>\n<li><p>代码：</p>\n</li>\n</ul>\n<pre><code class=\"JavaScript\">//Promise基本语法\n//实例化 Promise 对象\nconst p = new Promise(function(resolve, reject)&#123;\n    setTimeout(function()&#123;\n\n        // let data = &#39;数据库中的用户数据&#39;;\n        // resolve\n        // resolve(data);\n\n        let err = &#39;数据读取失败&#39;;\n        reject(err);\n    &#125;, 1000);\n&#125;);\n\n//调用 promise 对象的 then 方法\np.then(function(value)&#123;//成功执行\n    console.log(value);\n&#125;, function(reason)&#123;//失败执行\n    console.error(reason);\n&#125;)\n</code></pre>\n<h3 id=\"2-13-set\"><a href=\"#2-13-set\" class=\"headerlink\" title=\"2.13 set\"></a>2.13 set</h3><ul>\n<li><p>ES6提供了新的数据结构Set(集合)。它<strong>类似于数组，但成员的值都是唯一的</strong>，集合实现了iterator接口，所以可以使用『扩展运算符』和『for…of…』扩展运算符进行遍历，集合的属性和方法:</p>\n<ol>\n<li>size返回集合的元素个数</li>\n<li>add增加一个新元素，返回当前集合</li>\n<li>delete删除元素，返回boolean值</li>\n<li>has检测集合中是否包含某个元素，返回boolean值</li>\n<li>clear清空集合，返回undefined</li>\n</ol>\n</li>\n<li><p>代码:</p>\n</li>\n</ul>\n<pre><code class=\"JavaScript\">//声明一个 set\nlet s = new Set();\nlet s2 = new Set([&#39;大事儿&#39;, &#39;小事儿&#39;, &#39;好事儿&#39;, &#39;坏事儿&#39;, &#39;小事儿&#39;]);\n\nfor (let v of s2) &#123;\n    console.log(v);\n&#125;\n\n//元素个数\nconsole.log(s2.size);\n//添加新的元素\ns2.add(&#39;喜事儿&#39;);\n//删除元素\ns2.delete(&#39;坏事儿&#39;);\n//检测\nconsole.log(s2.has(&#39;糟心事&#39;));\n//清空\ns2.clear();\nconsole.log(s2);\n\nfor (let v of s2) &#123;\n    console.log(v);\n&#125;\n</code></pre>\n<pre><code class=\"JavaScript\">//集合应用\nlet arr = [1, 2, 3, 4, 5, 4, 3, 2, 1];\n//1. 数组去重\nlet result1 = [...new Set(arr)];\nconsole.log(result1);\n\n//2. 交集\nlet arr2 = [4, 5, 6, 5, 6];\nlet result2 = [...new Set(arr)].filter(item =&gt; new Set(arr2).has(item));\nconsole.log(result2);\n\n//3. 并集\nlet union = [...new Set([...arr, ...arr2])];\nconsole.log(union);\n\n//4. 差集\nlet diff = [...new Set(arr)].filter(item =&gt; !(new Set(arr2).has(item)));\nconsole.log(diff);\n</code></pre>\n<h3 id=\"2-14-map\"><a href=\"#2-14-map\" class=\"headerlink\" title=\"2.14 map\"></a>2.14 map</h3><ul>\n<li>ES6提供了Map数据结构。它<strong>类似于对象，也是键值对的集合</strong>。但是“键”的范围不限于字符串，各种类型的值(包括对象）都可以当作键。Map也实现了iterator接口，所以可以使用『扩展运算符』和『for ….of…』。进行遍历。Map的属性和方法:<ol>\n<li>size返回Map 的元素个数</li>\n<li>set 增加一个新元素，返回当前Map</li>\n<li>get返回键名对象的键值</li>\n<li>has检测Map中是否包含某个元素，返回boolean值</li>\n<li>clear清空集合，返回undefined</li>\n</ol>\n</li>\n</ul>\n<pre><code class=\"JavaScript\">//声明 Map\nlet m = new Map();\n\n//添加元素\nm.set(&#39;name&#39;, &#39;河工大&#39;);\nm.set(&#39;change&#39;, function () &#123;\n    console.log(&quot;我们可以改变你!!&quot;);\n&#125;);\nlet key = &#123;\n    school: &#39;大学&#39;\n&#125;;\nm.set(key, [&#39;北京&#39;, &#39;上海&#39;, &#39;深圳&#39;]);\n</code></pre>\n<h3 id=\"2-15-class类\"><a href=\"#2-15-class类\" class=\"headerlink\" title=\"2.15 class类\"></a>2.15 class类</h3><ul>\n<li>ES6提供了更接近传统语言的写法，引入了Class(类)这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已；知识点:<ol>\n<li>class声明类</li>\n<li>constructor定义构造函数初始化</li>\n<li>extends继承父类</li>\n<li>super调用父级构造方法</li>\n<li>static定义静态方法和属性</li>\n<li>父类方法可以重写（子类不能调用父类的重名方法）</li>\n</ol>\n</li>\n</ul>\n<pre><code class=\"javascript\">//class\nclass Shouji &#123;\n//构造方法 名字不能修改\n    constructor(brand, price) &#123;\n        this.brand = brand;\n        this.price = price;\n    &#125;\n\n//方法必须使用该语法, 不能使用 ES5 的对象完整形式\n    call() &#123;\n        console.log(&quot;我可以打电话!!&quot;);\n    &#125;\n&#125;\n\nlet onePlus = new Shouji(&quot;1+&quot;, 1999);\n\nconsole.log(onePlus);\n</code></pre>\n<pre><code class=\"JavaScript\">class Phone&#123;\n    //静态属性 属于类，不属于实例对象\n    static name = &#39;手机&#39;;\n    static change()&#123;\n        console.log(&quot;我可以改变世界&quot;);\n    &#125;\n&#125;\n\nlet nokia = new Phone();\nconsole.log(nokia.name);//undefined\nconsole.log(Phone.name);//手机\n</code></pre>\n<pre><code class=\"JavaScript\">class Phone&#123;\n    //构造方法\n    constructor(brand, price)&#123;\n        this.brand = brand;\n        this.price = price;\n    &#125;\n    //父类的成员属性\n    call()&#123;\n        console.log(&quot;我可以打电话!!&quot;);\n    &#125;\n&#125;\n\nclass SmartPhone extends Phone &#123;\n    //构造方法\n    constructor(brand, price, color, size)&#123;\n        super(brand, price);// Phone.call(this, brand, price)\n        this.color = color;\n        this.size = size;\n    &#125;\n\n    photo()&#123;\n        console.log(&quot;拍照&quot;);\n    &#125;\n\n    playGame()&#123;\n        console.log(&quot;玩游戏&quot;);\n    &#125;\n\n    call()&#123;\n        console.log(&#39;我可以进行视频通话&#39;);\n    &#125;\n&#125;\n\n    const xiaomi = new SmartPhone(&#39;小米&#39;,799,&#39;黑色&#39;,&#39;4.7inch&#39;);\n    // console.log(xiaomi);\n    xiaomi.call();\n    xiaomi.photo();\n    xiaomi.playGame();\n</code></pre>\n<pre><code class=\"JavaScript\">// get 和 set\nclass Phone &#123;\n    get price() &#123;//无需参数，有返回值(没写默认undefined)\n        console.log(&quot;价格属性被读取了&quot;);\n        return &#39;iloveyou&#39;;\n    &#125;\n\n    set price(newVal) &#123;//需要参数(否则报错)，无返回值\n        console.log(&#39;价格属性被修改了&#39;);\n    &#125;\n&#125;\n\n//实例化对象\nlet s = new Phone();\n\n// console.log(s.price);\ns.price = &#39;free&#39;;\n</code></pre>\n<h3 id=\"2-16-数值扩展\"><a href=\"#2-16-数值扩展\" class=\"headerlink\" title=\"2.16 数值扩展\"></a>2.16 数值扩展</h3><p><strong>Number.EPSILON</strong> </p>\n<ul>\n<li><p>JavaScript 表示的最小精度</p>\n</li>\n<li><p>EPSILON 属性的值接近于 2.2204460492503130808472633361816E-16（小于这个数认为相等）</p>\n</li>\n</ul>\n<pre><code class=\"JavaScript\">function equal(a, b) &#123;\n    if (Math.abs(a - b) &lt; Number.EPSILON) &#123;\n        return true;\n    &#125; else &#123;\n        return false;\n    &#125;\n&#125;\nconsole.log(0.1 + 0.2 === 0.3);//false\nconsole.log(equal(0.1 + 0.2, 0.3)//true\n</code></pre>\n<p><strong>二进制和八进制</strong></p>\n<ul>\n<li>ES6提供了二进制和八进制数值的新的写法，分别用前缀<strong>0b</strong>和<strong>0o</strong>表示。</li>\n</ul>\n<p><strong>Number.isFinite()与Number.isNaN()</strong></p>\n<ul>\n<li>Number.isFinite()用来检查一个数值是否为有限的</li>\n<li>Number.isNaN()用来检查一个值是否为NaN</li>\n</ul>\n<p><strong>Number.parselnt()与Number.parseFloat()</strong></p>\n<ul>\n<li>ES6将全局方法parseInt和 parseFloat，移植到Number对象上面，使用不变。</li>\n</ul>\n<p><strong>Math.trunc</strong></p>\n<ul>\n<li>用于去除一个数的小数部分，返回整数部分</li>\n</ul>\n<p><strong>Number.islnteger</strong></p>\n<ul>\n<li>Number.islnteger()用来判断一个数值是否为整数<ul>\n<li>值为正，返回1</li>\n<li>值为0，返回0</li>\n<li>值为负，返回-1</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-17-对象扩展\"><a href=\"#2-17-对象扩展\" class=\"headerlink\" title=\"2.17 对象扩展\"></a>2.17 对象扩展</h3><ul>\n<li>ES6新增了一些object对象的方法<ol>\n<li>object.is比较两个值是否严格相等，与「&#x3D;&#x3D;&#x3D;』行为基本一致（ NaN)</li>\n<li>Object.assign对象的合并，将源对象的所有可枚举属性，复制到目标对象(覆盖)</li>\n<li>Object.setPrototypeOf可以直接给实例对象的构造函数设置对象的原型</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"2-18-模块化\"><a href=\"#2-18-模块化\" class=\"headerlink\" title=\"2.18 模块化\"></a>2.18 模块化</h3><p><strong>模块化的好处</strong></p>\n<ul>\n<li>模块化的优势有以下几点:</li>\n</ul>\n<ol>\n<li>防止命名冲突</li>\n<li>代码复用</li>\n<li>高维护性</li>\n</ol>\n<p><strong>模块化规范产品</strong></p>\n<ul>\n<li>ES6之前的模块化规范有:</li>\n</ul>\n<ol>\n<li>CommonJS  &#x3D;&gt; NodeJS、Browserify</li>\n<li>AMD &#x3D;&gt; requireJS</li>\n<li>CMD &#x3D;&gt; seaJS</li>\n</ol>\n<p><strong>ES6模块化语法</strong></p>\n<ul>\n<li>模块功能主要由两个命令构成: export和import<ul>\n<li>export命令用于规定模块的对外接口(分别暴露、统一暴露、默认暴露)</li>\n<li>import命令用于输入其他模块提供的功能</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3、ECMAScript-7新特性\"><a href=\"#3、ECMAScript-7新特性\" class=\"headerlink\" title=\"3、ECMAScript 7新特性\"></a>3、ECMAScript 7新特性</h2><h3 id=\"3-1-Array-prototype-includes\"><a href=\"#3-1-Array-prototype-includes\" class=\"headerlink\" title=\"3.1 Array.prototype.includes\"></a>3.1 Array.prototype.includes</h3><ul>\n<li>Includes方法用来检测数组中是否包含某个元素，返回布尔类型值</li>\n</ul>\n<h3 id=\"3-2-指数操作符\"><a href=\"#3-2-指数操作符\" class=\"headerlink\" title=\"3.2 指数操作符\"></a>3.2 指数操作符</h3><ul>\n<li>在ES7中引入指数运算符「**」，用来实现幂运算，功能与Math.pow结果相同</li>\n</ul>\n<h2 id=\"4、ECMAScript-8新特性\"><a href=\"#4、ECMAScript-8新特性\" class=\"headerlink\" title=\"4、ECMAScript 8新特性\"></a>4、ECMAScript 8新特性</h2><h3 id=\"4-1-async和await\"><a href=\"#4-1-async和await\" class=\"headerlink\" title=\"4.1 async和await\"></a>4.1 async和await</h3><p>async和 await 两种语法结合可以让异步代码像同步代码一样</p>\n<p><strong>async函数</strong></p>\n<ol>\n<li><p><strong>async函数的返回值为promise对象</strong></p>\n</li>\n<li><p>promise对象的结果由async函数执行的返回值决定</p>\n</li>\n</ol>\n<ul>\n<li>代码：</li>\n</ul>\n<pre><code class=\"JavaScript\">//async 函数\nasync function fn()&#123;\n    // 返回一个字符串\n    // return &#39;尚硅谷&#39;;\n    \n    // 返回的结果不是一个 Promise 类型的对象, 返回的结果就是成功 Promise 对象\n    // return;//(resolved undefined)\n    \n    //抛出错误, 返回的结果是一个失败的 Promise\n    // throw new Error(&#39;出错啦!&#39;);//(rejected 对象)\n    \n    //返回的结果如果是一个 Promise 对象\n    return new Promise((resolve, reject)=&gt;&#123;\n        resolve(&#39;成功的数据&#39;);//(resolved 对象)\n        // reject(&quot;失败的错误&quot;);//(rejected 对象)\n    &#125;);\n&#125;\n</code></pre>\n<p><strong>await表达式</strong></p>\n<ol>\n<li>await必须写在 async函数中</li>\n<li>await右侧的表达式一般为promise对象</li>\n<li>await返回的是promise成功的值</li>\n<li>await 的promise失败了，就会抛出异常，需要通过try…catch 捕获处理</li>\n</ol>\n<ul>\n<li>代码：</li>\n</ul>\n<pre><code class=\"javascript\">//创建 promise 对象\nconst p = new Promise((resolve, reject) =&gt; &#123;\n    // resolve(&quot;用户数据&quot;);\n    reject(&quot;失败啦!&quot;);\n&#125;)\n\n// await 要放在 async 函数中.\nasync function main() &#123;\n    try &#123;\n        let result = await p;\n        console.log(result);\n    &#125; catch (e) &#123;\n        console.log(e);\n    &#125;\n&#125;\n//调用函数\nmain();\n</code></pre>\n<h3 id=\"4-2-对象方法的扩展\"><a href=\"#4-2-对象方法的扩展\" class=\"headerlink\" title=\"4.2 对象方法的扩展\"></a>4.2 对象方法的扩展</h3><p><strong>Object.values和Object.entries</strong></p>\n<ol>\n<li><p>Object.values()方法返回一个给定对象的所有可枚举<strong>属性值</strong>的数组</p>\n</li>\n<li><p>Object.entries()方法返回一个给定对象自身可遍历属性**[key,value]**的数(创建map)</p>\n</li>\n</ol>\n<p><strong>Object.getOwnPropertyDescriptors</strong></p>\n<ul>\n<li>该方法返回指定对象所有自身属性的描述对象</li>\n</ul>\n<h2 id=\"5、ECMAScript-9新特性\"><a href=\"#5、ECMAScript-9新特性\" class=\"headerlink\" title=\"5、ECMAScript 9新特性\"></a>5、ECMAScript 9新特性</h2><h3 id=\"5-1-Rest-Spread属性\"><a href=\"#5-1-Rest-Spread属性\" class=\"headerlink\" title=\"5.1 Rest&#x2F;Spread属性\"></a>5.1 Rest&#x2F;Spread属性</h3><ul>\n<li>Rest参数(省略)与spread扩展运算符(对象合并)在ES6中已经引入，不过ES6中只针对于数组，在ES9中为对象提供了像数组一样的rest参数和扩展运算符</li>\n</ul>\n<h3 id=\"5-2-正则表达式命名捕获组\"><a href=\"#5-2-正则表达式命名捕获组\" class=\"headerlink\" title=\"5.2.正则表达式命名捕获组\"></a>5.2.正则表达式命名捕获组</h3><ul>\n<li>ES9允许命名捕获组使用符号<strong>『?&lt; name&gt;』</strong> ,这样获取捕获结果可读性更强</li>\n<li>代码：</li>\n</ul>\n<pre><code class=\"JavaScript\">let str = &#39;&lt;a href=&quot;http://www.atguigu.com&quot;&gt;尚硅谷&lt;/a&gt;&#39;;\n//分组命名\nconst reg = /&lt;a href=&quot;(?&lt;url&gt;.*)&quot;&gt;(?&lt;text&gt;.*)&lt;\\ /a&gt;/;\n\nconst result = reg.exec(str);\n\nconsole.log(result.groups.url);//http://www.atguigu.com\n\nconsole.log(result.groups.text);//尚硅谷\n</code></pre>\n<h3 id=\"5-3-正则表达式反向断言\"><a href=\"#5-3-正则表达式反向断言\" class=\"headerlink\" title=\"5.3.正则表达式反向断言\"></a>5.3.正则表达式反向断言</h3><ul>\n<li>ES9支持反向断言，通过对匹配结果前面的内容进行判断，对匹配进行筛选</li>\n<li>代码：</li>\n</ul>\n<pre><code class=\"JavaScript\">//声明字符串\nlet str = &#39;JS5211314你知道么555啦啦啦&#39;;\n//正向断言\n// const reg = /\\d+(?=啦)/;\n// const result = reg.exec(str);\n\n//反向断言\nconst reg = /(?&lt;=么)\\d+ /; \nconst result=reg.exec(str); \nconsole.log(result);\n</code></pre>\n<h3 id=\"5-4-正则表达式dotAll模式\"><a href=\"#5-4-正则表达式dotAll模式\" class=\"headerlink\" title=\"5.4.正则表达式dotAll模式\"></a>5.4.正则表达式dotAll模式</h3><ul>\n<li>正则表达式中点 . 匹配除回车外的任何单字符，标记『s』改变这种行为，允许行终止符出现</li>\n<li>代码：</li>\n</ul>\n<pre><code class=\"JavaScript\">//dot . 元字符 除换行符以外的任意单个字符\nlet str = `\n&lt;ul&gt;\n    &lt;li&gt;\n        &lt;a&gt;肖生克的救赎&lt;/a&gt;\n        &lt;p&gt;上映日期: 1994-09-10&lt;/p&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n        &lt;a&gt;阿甘正传&lt;/a&gt;\n        &lt;p&gt;上映日期: 1994-07-06&lt;/p&gt;\n    &lt;/li&gt;\n&lt;/ul&gt;`;\n//声明正则\n// const reg = /&lt;li&gt;\\s+&lt;a&gt;(.*?)&lt;\\ /a&gt;\\s+&lt;p&gt;(.*?)&lt;\\ /p&gt;/;\nconst reg = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\\ /a&gt;.*?&lt;p&gt;(.*?)&lt;\\ /p&gt;/gs;\n//执行匹配\n// const result = reg.exec(str);\nlet result;\nlet data = [];\nwhile(result = reg.exec(str))&#123;\n    data.push(&#123;title: result[1], time: result[2]&#125;);\n&#125;\n//输出结果\nconsole.log(data);\n</code></pre>\n<h2 id=\"6、ECMAScript-10新特性\"><a href=\"#6、ECMAScript-10新特性\" class=\"headerlink\" title=\"6、ECMAScript 10新特性\"></a>6、ECMAScript 10新特性</h2><h3 id=\"6-1-Object-fromEntries\"><a href=\"#6-1-Object-fromEntries\" class=\"headerlink\" title=\"6.1 Object.fromEntries\"></a>6.1 Object.fromEntries</h3><ul>\n<li>代码：</li>\n</ul>\n<pre><code class=\"JavaScript\">//二维数组\nconst result1 = Object.fromEntries([\n    [&#39;name&#39;, &#39;IT&#39;],\n    [&#39;xueke&#39;, &#39;Java,大数据,前端,云计算&#39;]\n]);\nconsole.log(result1);\n\n//Map\nconst m = new Map();\nm.set(&#39;name&#39;, &#39;ATGUIGU&#39;);\nconst result2 = Object.fromEntries(m);\nconsole.log(result2);\n\n//Object.entries ES8\nconst arr = Object.entries(&#123;\n    name: &quot;IT&quot;\n&#125;)\nconsole.log(arr);\n</code></pre>\n<h3 id=\"6-2-trimStart-和-trimEnd\"><a href=\"#6-2-trimStart-和-trimEnd\" class=\"headerlink\" title=\"6.2 trimStart 和 trimEnd\"></a>6.2 trimStart 和 trimEnd</h3><ul>\n<li>代码：</li>\n</ul>\n<pre><code class=\"JavaScript\">// trim\nlet str = &#39; iloveyou &#39;;\n\nconsole.log(str);\nconsole.log(str.trimStart());//清除左侧空白\nconsole.log(str.trimEnd());//清除右侧空白\n</code></pre>\n<h3 id=\"6-3-Array-prototype-flat-与flatMap\"><a href=\"#6-3-Array-prototype-flat-与flatMap\" class=\"headerlink\" title=\"6.3 Array.prototype.flat 与flatMap\"></a>6.3 Array.prototype.flat 与flatMap</h3><ul>\n<li>代码：</li>\n</ul>\n<pre><code class=\"JavaScript\">//flat 平\n//将多维数组转化为低位数组\n// const arr = [1, 2, 3, 4, [5, 6]];\n// console.log(arr.flat());\n// const arr = [1, 2, 3, 4, [5, 6, [7, 8, 9]]];\n//参数为深度 是一个数字\n// console.log(arr.flat(2));//三维变一维，深度为2\n\n//flatMap\nconst arr = [1, 2, 3, 4];\nconst result = arr.flatMap(item =&gt; [item * 10]);//flat+map\nconsole.log(result);\n</code></pre>\n<h3 id=\"6-4-Symbol-prototype-description\"><a href=\"#6-4-Symbol-prototype-description\" class=\"headerlink\" title=\"6.4 Symbol.prototype.description\"></a>6.4 Symbol.prototype.description</h3><ul>\n<li>代码：</li>\n</ul>\n<pre><code class=\"javascript\">//创建 Symbol\nlet s = Symbol(&#39;河工大&#39;);\n//获取属性\nconsole.log(s.description);\n</code></pre>\n<h2 id=\"7、ECMAScript-11新特性\"><a href=\"#7、ECMAScript-11新特性\" class=\"headerlink\" title=\"7、ECMAScript 11新特性\"></a>7、ECMAScript 11新特性</h2><h3 id=\"7-1-类的私有属性\"><a href=\"#7-1-类的私有属性\" class=\"headerlink\" title=\"7.1 类的私有属性\"></a>7.1 类的私有属性</h3><ul>\n<li>代码:</li>\n</ul>\n<pre><code class=\"javascript\">class Person &#123;\n    //公有属性\n    name;\n    //私有属性\n    #age;\n    #weight;\n    //构造方法\n    constructor(name, age, weight) &#123;\n        this.name = name;\n        this.#age = age;\n        this.#weight = weight;\n    &#125;\n\n    intro() &#123;\n        console.log(this.name);\n        console.log(this.#age);\n        console.log(this.#weight);\n    &#125;\n&#125;\n\n//实例化\nconst girl = new Person(&#39;晓红&#39;, 18, &#39;45kg&#39;);\n\n// console.log(girl.name);\n// console.log(girl.#age);//报错\n// console.log(girl.#weight);\n\ngirl.intro();\n</code></pre>\n<h3 id=\"7-2-Promise-allSettled\"><a href=\"#7-2-Promise-allSettled\" class=\"headerlink\" title=\"7.2 Promise.allSettled\"></a>7.2 Promise.allSettled</h3><ul>\n<li>代码：</li>\n</ul>\n<pre><code class=\"JavaScript\">//声明两个promise对象\nconst p1 = new Promise((resolve, reject) =&gt; &#123;\n    setTimeout(() =&gt; &#123;\n        resolve(&#39;商品数据 - 1&#39;);\n    &#125;, 1000)\n&#125;);\n\nconst p2 = new Promise((resolve, reject) =&gt; &#123;\n    setTimeout(() =&gt; &#123;\n        resolve(&#39;商品数据 - 2&#39;);\n        // reject(&#39;出错啦!&#39;);\n    &#125;, 1000)\n&#125;);\n\n//调用 allsettled 方法\nconst result = Promise.allSettled([p1, p2]);//一个成功就成功\n\n// const res = Promise.all([p1, p2]);//都成功才成功，一个失败就失败\n\nconsole.log(res);\n</code></pre>\n<h3 id=\"7-3-String-prototype-matchAll\"><a href=\"#7-3-String-prototype-matchAll\" class=\"headerlink\" title=\"7.3 String.prototype.matchAll\"></a>7.3 String.prototype.matchAll</h3><ul>\n<li>代码：</li>\n</ul>\n<pre><code class=\"JavaScript\">let str = `&lt;ul&gt;\n    &lt;li&gt;\n        &lt;a&gt;肖生克的救赎&lt;/a&gt;\n        &lt;p&gt;上映日期: 1994-09-10&lt;/p&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n        &lt;a&gt;阿甘正传&lt;/a&gt;\n        &lt;p&gt;上映日期: 1994-07-06&lt;/p&gt;\n    &lt;/li&gt;\n&lt;/ul&gt;`;\n\n//声明正则\nconst reg = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\\ /a&gt;.*?&lt;p&gt;(.*?)&lt;\\ /p&gt;/sg\n\n//调用方法\nconst result = str.matchAll(reg);\n\n// for(let v of result)&#123;\n// \t\tconsole.log(v);\n// &#125;\n\nconst arr = [...result];\n\nconsole.log(arr);\n</code></pre>\n<h3 id=\"7-4-可选链操作符\"><a href=\"#7-4-可选链操作符\" class=\"headerlink\" title=\"7.4 可选链操作符\"></a>7.4 可选链操作符</h3><ul>\n<li>代码：</li>\n</ul>\n<pre><code class=\"javascript\">// 可选链操作符 ?. 判断前面的值是否传入，已传入则读取后面的属性\nfunction main(config) &#123;\n    // const dbHost = config &amp;&amp; config.db &amp;&amp; config.db.host;\n    const dbHost = config?.db?.host;\n\n    console.log(dbHost);\n&#125;\n\nmain(&#123;\n    db: &#123;\n        host: &#39;192.168.1.100&#39;,\n        username: &#39;root&#39;\n    &#125;,\n    cache: &#123;\n        host: &#39;192.168.1.200&#39;,\n        username: &#39;admin&#39;\n    &#125;\n&#125;)\n</code></pre>\n<h3 id=\"7-5-动态import-导入\"><a href=\"#7-5-动态import-导入\" class=\"headerlink\" title=\"7.5 动态import 导入\"></a>7.5 动态import 导入</h3><ul>\n<li>代码：</li>\n</ul>\n<pre><code>//test.html\n&lt;button id=&quot;btn&quot;&gt;点击&lt;/button&gt;\n&lt;script src=&quot;./js/app.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt;\n\n//app.js 获取元素\nconst btn = document.getElementById(&#39;btn&#39;);\n\nbtn.onclick = function()&#123;\n    import(&#39;./hello.js&#39;).then(module =&gt; &#123;\n        module.hello();\n    &#125;);\n&#125;\n\n//hello.js\nexport function hello()&#123;\n    alert(&#39;Hello&#39;);\n&#125;\n</code></pre>\n<h3 id=\"7-6-BigInt\"><a href=\"#7-6-BigInt\" class=\"headerlink\" title=\"7.6 BigInt\"></a>7.6 BigInt</h3><ul>\n<li>代码：</li>\n</ul>\n<pre><code class=\"javascript\">//大整形\n// let n = 521n;\n// console.log(n, typeof(n));//521n &#39;bigint&#39;\n\n//函数\n// let n = 123;\n// console.log(BigInt(n));//123n\n// console.log(BigInt(1.2));//报错\n\n//大数值运算\nlet max = Number.MAX_SAFE_INTEGER;\nconsole.log(max);//9007199254740991\nconsole.log(max + 1);//9007199254740992\nconsole.log(max + 2);//9007199254740993\n\nconsole.log(BigInt(max))//9007199254740991n\nconsole.log(BigInt(max) + BigInt(1))//9007199254740992n\nconsole.log(BigInt(max) + BigInt(2))//9007199254740993n\n</code></pre>\n<h3 id=\"7-7-globalThis对象\"><a href=\"#7-7-globalThis对象\" class=\"headerlink\" title=\"7.7 globalThis对象\"></a>7.7 globalThis对象</h3><ul>\n<li>代码：</li>\n</ul>\n<pre><code class=\"JavaScript\">console.log(globalThis);//输出当前全局对象\n</code></pre>\n","feature":true,"text":"ES6引入了箭头函数、模板字符串等特性，ES7加入了Array.prototype.includes()方法，ES8推出了async/await语法，ES9引入了Asynchronous Iteration，ES10增加了Array.flat()和Array.flatMap()方法，ES11则新增了可选链操作符和空值合并操作符。掌握这些语法能够提升前端开发效率和代码质量。...","permalink":"/post/前端--一文轻松搞懂ES6-ES11(ES6详解)","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"19 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":4,"path":"api/tags/JavaScript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ECMAScript-6-11\"><span class=\"toc-text\">ECMAScript 6-11</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1%E3%80%81ECMAScript-%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">1、ECMAScript 相关介绍</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-ECMAScript%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">1.1 ECMAScript简介</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-ES6%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7\"><span class=\"toc-text\">1.2 ES6的重要性</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2%E3%80%81ECMAScript-6%E6%96%B0%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">2、ECMAScript 6新特性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-let%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">2.1 let关键字</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-const%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">2.2 const关键字</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">2.3 变量的解构赋值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">2.4 模板字符串</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-5-%E7%AE%80%E5%8C%96%E5%AF%B9%E8%B1%A1%E5%86%99%E6%B3%95\"><span class=\"toc-text\">2.5 简化对象写法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-6-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">2.6 箭头函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-7-rest%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">2.7 rest参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-8-spread%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">2.8 spread扩展运算符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-9-Symbol\"><span class=\"toc-text\">2.9 Symbol</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-10-%E8%BF%AD%E4%BB%A3%E5%99%A8\"><span class=\"toc-text\">2.10 迭代器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-11-%E7%94%9F%E6%88%90%E5%99%A8\"><span class=\"toc-text\">2.11 生成器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-12-Promise\"><span class=\"toc-text\">2.12 Promise</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-13-set\"><span class=\"toc-text\">2.13 set</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-14-map\"><span class=\"toc-text\">2.14 map</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-15-class%E7%B1%BB\"><span class=\"toc-text\">2.15 class类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-16-%E6%95%B0%E5%80%BC%E6%89%A9%E5%B1%95\"><span class=\"toc-text\">2.16 数值扩展</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-17-%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95\"><span class=\"toc-text\">2.17 对象扩展</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-18-%E6%A8%A1%E5%9D%97%E5%8C%96\"><span class=\"toc-text\">2.18 模块化</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3%E3%80%81ECMAScript-7%E6%96%B0%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">3、ECMAScript 7新特性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-Array-prototype-includes\"><span class=\"toc-text\">3.1 Array.prototype.includes</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-%E6%8C%87%E6%95%B0%E6%93%8D%E4%BD%9C%E7%AC%A6\"><span class=\"toc-text\">3.2 指数操作符</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4%E3%80%81ECMAScript-8%E6%96%B0%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">4、ECMAScript 8新特性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-async%E5%92%8Cawait\"><span class=\"toc-text\">4.1 async和await</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A9%E5%B1%95\"><span class=\"toc-text\">4.2 对象方法的扩展</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5%E3%80%81ECMAScript-9%E6%96%B0%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">5、ECMAScript 9新特性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-Rest-Spread%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">5.1 Rest&#x2F;Spread属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-2-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%91%BD%E5%90%8D%E6%8D%95%E8%8E%B7%E7%BB%84\"><span class=\"toc-text\">5.2.正则表达式命名捕获组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-3-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8D%E5%90%91%E6%96%AD%E8%A8%80\"><span class=\"toc-text\">5.3.正则表达式反向断言</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-4-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8FdotAll%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">5.4.正则表达式dotAll模式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6%E3%80%81ECMAScript-10%E6%96%B0%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">6、ECMAScript 10新特性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-1-Object-fromEntries\"><span class=\"toc-text\">6.1 Object.fromEntries</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-2-trimStart-%E5%92%8C-trimEnd\"><span class=\"toc-text\">6.2 trimStart 和 trimEnd</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-3-Array-prototype-flat-%E4%B8%8EflatMap\"><span class=\"toc-text\">6.3 Array.prototype.flat 与flatMap</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-4-Symbol-prototype-description\"><span class=\"toc-text\">6.4 Symbol.prototype.description</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7%E3%80%81ECMAScript-11%E6%96%B0%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">7、ECMAScript 11新特性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-1-%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">7.1 类的私有属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-2-Promise-allSettled\"><span class=\"toc-text\">7.2 Promise.allSettled</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-3-String-prototype-matchAll\"><span class=\"toc-text\">7.3 String.prototype.matchAll</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-4-%E5%8F%AF%E9%80%89%E9%93%BE%E6%93%8D%E4%BD%9C%E7%AC%A6\"><span class=\"toc-text\">7.4 可选链操作符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-5-%E5%8A%A8%E6%80%81import-%E5%AF%BC%E5%85%A5\"><span class=\"toc-text\">7.5 动态import 导入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-6-BigInt\"><span class=\"toc-text\">7.6 BigInt</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-7-globalThis%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">7.7 globalThis对象</span></a></li></ol></li></ol></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Ajax实战指南：快速入门","uid":"269efa4fe53bba32d25aec66c5987385","slug":"前端--详解AJAX(快速入门)","date":"2023-01-15T01:38:59.000Z","updated":"2025-07-14T15:12:20.466Z","comments":true,"path":"api/articles/前端--详解AJAX(快速入门).json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/7f6c7c162dd6446782022ec8ae527017.jpeg","text":"前端开发中，Ajax是一种用于异步请求和更新网页内容的技术。通过Ajax，可以在不刷新整个页面的情况下，与服务器进行数据交互。这种技术使得用户能够更加流畅地浏览网页，并实现实时更新数据的功能。...","permalink":"/post/前端--详解AJAX(快速入门)","photos":[],"count_time":{"symbolsCount":"33k","symbolsTime":"30 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"Ajax","slug":"Ajax","count":1,"path":"api/tags/Ajax.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true},"next_post":{"title":"前端进阶：探索JavaScript高级语法","uid":"da652f0027f23ff5ab9b268e0c44336d","slug":"前端--JavaScript高级","date":"2023-01-07T05:22:11.000Z","updated":"2025-07-14T15:12:20.463Z","comments":true,"path":"api/articles/前端--JavaScript高级.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/de6c1a55cf774f9fa1e2cff7c25e5fc9.png","text":"JavaScript高级语法包括闭包、原型链、对象高级、线程与执行机制等。掌握这些高级语法可以提升代码的可维护性和性能，实现更复杂的功能和逻辑。在前端开发中，熟练应用JavaScript高级语法能够编写出结构清晰、功能强大的代码，为用户提供更流畅的交互体验。...","permalink":"/post/前端--JavaScript高级","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":4,"path":"api/tags/JavaScript.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true}}