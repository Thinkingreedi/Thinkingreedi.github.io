{"title":"前端设计模式应用","uid":"4fde660230560945997cb0c9305b7a1e","slug":"青训营--前端设计模式应用","date":"2022-02-07T02:42:27.000Z","updated":"2025-07-14T15:12:20.472Z","comments":true,"path":"api/articles/青训营--前端设计模式应用.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/3112c385d3c845d4b0305beebbc3ffdf.jpeg","content":"<hr>\n<h2 id=\"什么是设计模式\"><a href=\"#什么是设计模式\" class=\"headerlink\" title=\"什么是设计模式\"></a>什么是设计模式</h2><p>软件设计中常见问题的解决方案模型:</p>\n<ul>\n<li>历史经验的总结</li>\n<li>与特定语言无关</li>\n</ul>\n<p><strong>设计模式背景</strong></p>\n<ol>\n<li>模式语言:城镇、建筑、建造 (A Pattern Language:Towns, Buildings,Construction)1977</li>\n<li>设计模式:可复用面向对象软件的基础 (Design Patterns: Elements of<br>ReusableObject-Oriented Software)1994</li>\n</ol>\n<p><strong>设计模式趋势</strong><br><img src=\"https://img-blog.csdnimg.cn/ab69b37abc444e0cbf50703a4da5647e.png#pic_center\"><br><strong>设计模式分类</strong></p>\n<p>23种设计模式</p>\n<ul>\n<li>创建型-如何创建一个对象 </li>\n<li>结构型-如何灵活的将对象组装成较大的结构 </li>\n<li>行为型-负责对象间的高效通信和职责划分</li>\n</ul>\n<hr>\n<h2 id=\"浏览器中的设计模式\"><a href=\"#浏览器中的设计模式\" class=\"headerlink\" title=\"浏览器中的设计模式\"></a>浏览器中的设计模式</h2><p><strong>单例模式</strong></p>\n<p>定义:<br>全局唯一访问对象 </p>\n<p>应用场景:<br> 缓存， 全局状态管理等。</p>\n<p><strong>单例模式请求缓存</strong></p>\n<pre><code class=\"javascript\">//定义api，500m后返回\nimport &#123; api &#125; from”./utils&quot; ;\n\nexport cLass Requset &#123;//定义请求实例\n    static instance: Requset;//定义缓存\n    private cache: Recordestring, string&gt;;\n\n    constructor() &#123;//初始化缓存内容\n        this.cache = &#123;&#125;;\n    &#125;\n    \n    static getInstance() &#123;\n        if ( this. instance) &#123;\n            return this. instance;\n        &#125;\n        \n        this. instance = new Requset();\n        return this. instance;\n    &#125;\n    \n    pubLic async request(url: string) &#123; \n        if (this . cache[urU])&#123; \n            return this . cache[urL];\n        &#125;\n        const response = await api(urL); \n        this . cache[urL] = response;\n        \n        return response;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"javascript\">test(&quot;should response more than 500ms with class&quot;, async () = &#123;\n    const request = Requset. getInstance();\n\n    const startTime = Date . now();\n    await request . request(&quot; /user/1&quot;);\n    const endTime = Date. now();\n\n    const costTime = endTime - startTime;\n    expect ( costTime) . toBeGreaterThanOrEquaL(500);\n&#125;);\n\n\ntest(&quot;should response quickly second time with class&quot;, async () = &#123;\n    const request1 = Requset . getInstance();\n    await request1 . request(&quot; /user/1&quot;);\n\n    const startTime = Date now();\n    const request2 = Requset . getInstance();\n    await request2 . request(&quot; /user/1&quot;);\n    const endTime = Date . now();\n\n    const costTime = endTime - startTime;\n    expect ( costTime) . toBeLessThan(50);\n&#125;);\n</code></pre>\n<pre><code class=\"javascript\">    import &#123; api &#125; from &quot;./utils&quot;;\n\n    const cache: Record&lt;string, string&gt; = &#123;&#125;;\n    \n    export const request = async (urT: string) →&#123;\n        if (cache[urL]) &#123;\n            return cache[urL];\n        &#125;\n    \n    const response = await api(urL);\n    \n    cache[urL] = response;\n    return response;\n&#125;;\n</code></pre>\n<pre><code class=\"javascript\">    test(&quot; should response quickly second time&quot;, async 0) = &#123; \n        await request(&quot; /user/1&quot;);\n        const startTime = Date. now() ;\n        await request(&quot; /user/1&quot;);\n        const endTime = Date. now() ;\n        \n        const costTime = endTime - startTime;\n\n        expect (costTime) . toBeLessThan(50) ;\n&#125;);\n</code></pre>\n<p><strong>发布订阅模式</strong></p>\n<p>定义:<br> 一种订阅机制， 可在被订阅对象发生变化 时通知订阅者。</p>\n<p>应用场景:<br> 从系统架构之间的解耦，到业务中一-些实 现模式，像邮件订阅，上线订阅等等，应用广泛。</p>\n<pre><code class=\"javascript\">type Notify = (user: User) =&gt; void;\n\nexport class User &#123;\n  name: string;\n  status: &quot;offline&quot; | &quot;online&quot;;\n  // user 订阅自己的人，notify 上线时的通知函数\n  followers: &#123; user: User; notify: Notify &#125;[];\n\n  constructor(name: string) &#123;\n    this.name = name;\n    this.status = &quot;offline&quot;;\n    this.followers = [];\n  &#125;\n\n  // 订阅参数中的 user\n  subscribe(user: User, notify: Notify) &#123;\n    user.followers.push(&#123; user, notify &#125;);\n  &#125;\n\n  // 上线\n  online() &#123;\n    // 状态改为 online\n    this.status = &quot;online&quot;;\n    // 通知所有订阅自己的人\n    this.followers.forEach((&#123; notify &#125;) =&gt; &#123;\n      notify(this);\n    &#125;);\n  &#125;\n&#125;\n</code></pre>\n<pre><code class=\"javascript\">test(&quot;should notify followers when user is online for multiple users&quot;, () =&gt; &#123;\n  // 创建三个用户\n  const user1 = new User(&quot;user1&quot;);\n  const user2 = new User(&quot;user2&quot;);\n  const user3 = new User(&quot;user3&quot;);\n\n  // 通知 user1 和 user2 的函数\n  const mockNotifyUser1 = jest.fn();\n  const mockNotifyUser2 = jest.fn();\n\n  // user1 订阅了 user3 的上线，传入通知 user1 的函数\n  user1.subscribe(user3, mockNotifyUser1);\n  user2.subscribe(user3, mockNotifyUser2);\n\n  // user3 上线\n  user3.online();\n\n  // user3 会调用通知 user1 的函数\n  expect(mockNotifyUser1).toBeCalledWith(user3);\n  expect(mockNotifyUser2).toBeCalledWith(user3);\n&#125;);\n</code></pre>\n<hr>\n<h2 id=\"Javascript中的设计模式\"><a href=\"#Javascript中的设计模式\" class=\"headerlink\" title=\"Javascript中的设计模式\"></a>Javascript中的设计模式</h2><p><strong>原型模式</strong></p>\n<p>定义 :<br>复制已有对象来创建新的对象</p>\n<p>应用场景 :<br>JS中对象创建的基本模式</p>\n<p><strong>用原型模式创建上线订阅中的用户</strong></p>\n<pre><code class=\"javascript\">const baseUser: User = &#123;\n  name: &quot;&quot;,\n  status: &quot;offline&quot;,\n  followers: [],\n\n  subscribe(user, notify) &#123;\n    user.followers.push(&#123; user, notify &#125;);\n  &#125;,\n\n  online() &#123;\n    this.status = &quot;online&quot;;\n    this.followers.forEach((&#123; notify &#125;) =&gt; &#123;\n      notify(this);\n    &#125;);\n  &#125;,\n&#125;;\n\nexport const createUser = (name: string) =&gt; &#123;\n  // Object.create(obj) 会根据已有的对象返回一个新的对象\n  // baseUser 是原型，与新创建的对象是继承关系\n  const user: User = Object.create(baseUser);\n\n  user.name = name;\n  user.followers = [];\n\n  return user;\n&#125;;\n</code></pre>\n<pre><code class=\"javascript\">test(&quot;should notify followers when user is online for multiple users&quot;, () =&gt; &#123;\n  const user1 = createUser(&quot;user1&quot;);\n  const user2 = createUser(&quot;user2&quot;);\n  const user3 = createUser(&quot;user3&quot;);\n\n  const mockNotifyUser1 = jest.fn();\n  const mockNotifyUser2 = jest.fn();\n\n  user1.subscribe(user3, mockNotifyUser1);\n  user2.subscribe(user3, mockNotifyUser2);\n\n  user3.online();\n\n  expect(mockNotifyUser1).toBeCalledWith(user3);\n  expect(mockNotifyUser2).toBeCalledWith(user3);\n&#125;);\n</code></pre>\n<p><strong>代理模式</strong></p>\n<p>定义：<br>可以自定义控制对原对象的访问方式，并且允许在更新后做一些额外处理</p>\n<p>应用场景：<br>监控，代理工具，前端框架实现</p>\n<p><strong>用代理模式实现用户状态订阅</strong></p>\n<pre><code class=\"javascript\">type Notify = (user: User) =&gt; void;\n\nexport class User &#123;\n  name: string;\n  status: &quot;offline&quot; | &quot;online&quot;;\n  followers: &#123; user: User; notify: Notify &#125;[];\n\n  constructor(name: string) &#123;\n    this.name = name;\n    this.status = &quot;offline&quot;; this.followers = [];\n  &#125;\n\n  subscribe(user: User, notify: Notify) &#123;\n    user.followers.push(&#123; user, notify &#125;);\n  &#125;\n\n  // 添加新功能时，代码不好维护\n  // online() &#123;\n  //   this.status = &quot;online&quot;;\n  //   this.followers.forEach((&#123; notify &#125;) =&gt; &#123;\n  //     notify(this);\n  //   &#125;);\n  // &#125;\n\n  // online 只做上线一件事情，单一职责原则\n  online() &#123;\n    this.status = &#39;online&#39;\n  &#125;\n&#125;\n\n// 实现通知\nexport const createProxyUser = (name: string) =&gt; &#123;\n  const user = new User(name);\n\n  // 使用 new Proxy() 实现代理\n  const proxyUser = new Proxy(user, &#123;\n    set: (target, prop: keyof User, value) =&gt; &#123;\n      target[prop] = value;\n      if (prop === &quot;status&quot;) &#123;\n        notifyStatusHandlers(target, value);\n      &#125;\n      return true;\n    &#125;,\n  &#125;);\n\n  const notifyStatusHandlers = (user: User, status: &quot;online&quot; | &quot;offline&quot;) =&gt; &#123;\n    if (status === &quot;online&quot;) &#123;\n      user.followers.forEach((&#123; notify &#125;) =&gt; &#123;\n        notify(user);\n      &#125;);\n    &#125;\n  &#125;;\n\n  return proxyUser;\n&#125;;\n</code></pre>\n<p><strong>迭代器模式</strong></p>\n<p>定义：<br>在不暴露数据类型的情况下访问集合的数据</p>\n<p>应用场景：<br>数据结构中有多种数据类型，列表，树等，提供通用的操作接口</p>\n<p><strong>用 for of 迭代所有组件</strong></p>\n<pre><code class=\"javascript\">// 浏览器中的 DOM 结构\nclass MyDomElement &#123;\n  tag: string;\n  children: MyDomElement[];\n\n  constructor(tag: string) &#123;\n    this.tag = tag;\n    this.children = [];\n  &#125;\n\n  addChildren(component: MyDomElement) &#123;\n    this.children.push(component);\n  &#125;\n\n  // 使组件可迭代\n  [Symbol.iterator]() &#123;\n    const list = [...this.children];\n    let node;\n\n    return &#123;\n      // for...of 迭代时调用的函数\n      next: () =&gt; &#123;\n        while ((node = list.shift())) &#123;\n          // 层序遍历\n          node.children.length &gt; 0 &amp;&amp; list.push(...node.children);\n          // value 是迭代出的值，done 是指迭代是否完成\n          return &#123; value: node, done: false &#125;;\n        &#125;\n        return &#123; value: null, done: true &#125;;\n      &#125;,\n    &#125;;\n  &#125;\n&#125;\n</code></pre>\n<pre><code class=\"javascript\">test(&quot;can iterate root element&quot;, () =&gt; &#123;\n  const body = new MyDomElement(&quot;body&quot;);\n  const header = new MyDomElement(&quot;header&quot;);\n  const main = new MyDomElement(&quot;main&quot;);\n  const banner = new MyDomElement(&quot;banner&quot;);\n  const content = new MyDomElement(&quot;content&quot;);\n  const footer = new MyDomElement(&quot;footer&quot;);\n\n  body.addChildren(header);\n  body.addChildren(main);\n  body.addChildren(footer);\n\n  main.addChildren(banner);\n  main.addChildren(content);\n\n  const expectTags: string[] = [];\n  for (const element of body) &#123;\n    if (element) &#123;\n      expectTags.push(element.tag);\n    &#125;\n  &#125;\n\n  expect(expectTags.length).toBe(5);\n&#125;);\n</code></pre>\n<h2 id=\"前端框架中的设计模式\"><a href=\"#前端框架中的设计模式\" class=\"headerlink\" title=\"前端框架中的设计模式\"></a>前端框架中的设计模式</h2><p><strong>Vue 组件实现计数器</strong></p>\n<pre><code class=\"javascript\">&lt;template&gt;\n  &lt;button @click=&quot;count++&quot;&gt;count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=&quot;ts&quot;&gt;\nimport &#123; ref &#125; from &quot;vue &quot;;\nconst count = ref(0);\n&lt;/script&gt;\n</code></pre>\n<p>没有框架之前，我们通过监听 click 事件，通过 innerText 手动改变 DOM 的属性。前端框架对 DOM 操作进行代理，模板中的 DOM 都是 Proxy 代理后的虚拟 DOM，我们的操作的 DOM 是虚拟 DOM，之后通过 Diff 对视图更新。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/c58b5fa99efd43c595148f4521d0e900.png#pic_center\"><br><strong>组合模式</strong></p>\n<p>定义：<br>可多个对象组合使用成为一个单独的对象，也可以单个对象独立使用</p>\n<p>应用场景：<br>DOM，前端组件，文件目录</p>\n<p>React 的组件结构</p>\n<pre><code class=\"javascript\">export const Count = () =&gt; &#123;\n  const [count, setCount] = useState(0);\n  return (\n    &lt;button onClick=&#123;() =&gt; setCount((count) =&gt; count + 1)&#125; &gt;\n      count is: &#123;count&#125;\n    &lt;/button &gt;\n  );\n&#125;;\n</code></pre>\n<pre><code class=\"javascript\">function App() &#123;\n  return (\n    &lt;div className=&quot;App&quot;&gt;\n      &lt;Header /&gt;\n      &lt;Count /&gt;\n      &lt;Footer /&gt;\n    &lt;/div&gt;\n  );\n&#125;\n</code></pre>\n<hr>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>设计模式不是银弹。</p>\n<ul>\n<li>总结出抽象的设计模式比较简单，但是套用到场景中却非常困难。</li>\n<li>现代编程语言的多编程范式能带来更多的可能性。</li>\n<li>要从真正优秀的开源项目中学习设计模式并不断实现。</li>\n</ul>\n","feature":false,"text":"前端设计模式是在前端开发中常用的一种解决问题的方法论，它可以帮助开发者更好地组织和管理代码。本文将介绍前端设计模式的应用，包括常见的设计模式如单例模式、观察者模式、工厂模式等，并深入探讨它们的原理和适用场景。...","permalink":"/post/青训营--前端设计模式应用","photos":[],"count_time":{"symbolsCount":"9.3k","symbolsTime":"8 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"字节跳动青训营","slug":"字节跳动青训营","count":21,"path":"api/tags/字节跳动青训营.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">什么是设计模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">浏览器中的设计模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Javascript%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">Javascript中的设计模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">前端框架中的设计模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"小游戏开发","uid":"aaa9ceedcc6e20da90d5782857e132e7","slug":"青训营--小游戏开发","date":"2022-02-08T02:41:06.000Z","updated":"2025-07-14T15:12:20.472Z","comments":true,"path":"api/articles/青训营--小游戏开发.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/3112c385d3c845d4b0305beebbc3ffdf.jpeg","text":"小游戏开发是当前热门的领域之一，它结合了游戏设计和软件开发技术。本文将介绍常见的小游戏开发平台和工具，如Unity、Cocos Creator等，并深入讨论游戏场景设计、角色控制、碰撞检测、音效处理等关键技术。...","permalink":"/post/青训营--小游戏开发","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"字节跳动青训营","slug":"字节跳动青训营","count":21,"path":"api/tags/字节跳动青训营.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":false},"next_post":{"title":"Typescript快速入门","uid":"fc3331da72f382869606f6a944c6cf7d","slug":"青训营--Typescript快速入门","date":"2022-02-05T10:40:59.000Z","updated":"2025-07-14T15:12:20.471Z","comments":true,"path":"api/articles/青训营--Typescript快速入门.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/3112c385d3c845d4b0305beebbc3ffdf.jpeg","text":"TypeScript是一种由Microsoft开发的语言，它是JavaScript的一个超集，增加了静态类型和面向对象编程等特性。本文将引导读者快速入门TypeScript，包括环境搭建、基本语法、类型系统、面向对象编程、模块化等方面的内容。...","permalink":"/post/青训营--Typescript快速入门","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"17 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"字节跳动青训营","slug":"字节跳动青训营","count":21,"path":"api/tags/字节跳动青训营.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":false}}