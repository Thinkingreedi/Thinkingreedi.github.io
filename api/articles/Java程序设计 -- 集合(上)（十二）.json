{"title":"Java程序设计--集合(上)","uid":"84c5c7d3318822a7a4ef1ba96214ecd0","slug":"Java程序设计 -- 集合(上)（十二）","date":"2022-03-22T13:26:15.000Z","updated":"2025-07-14T15:12:20.461Z","comments":true,"path":"api/articles/Java程序设计 -- 集合(上)（十二）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","content":"<hr>\n<h1 id=\"1、集合的概述\"><a href=\"#1、集合的概述\" class=\"headerlink\" title=\"1、集合的概述\"></a>1、集合的概述</h1><p>集合和数组都是容器</p>\n<ul>\n<li><p>数组定义完成并<strong>启动后，类型确定、长度固定</strong>。</p>\n</li>\n<li><p>数组可以&#x3D;&#x3D;存储基本类型和引用类型的数据。&#x3D;&#x3D;</p>\n</li>\n<li><p>适合元素的个数和类型确定的业务场景，不适合做需要增删数据操作。</p>\n</li>\n<li><p>集合的大小不固定，<strong>启动后可以动态变化，类型也可以选择不固定。</strong></p>\n</li>\n<li><p>集合只能&#x3D;&#x3D;存储引用数据类型的数据。&#x3D;&#x3D;</p>\n</li>\n<li><p>集合非常适合做元素的增删操作。</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"2、集合的体系\"><a href=\"#2、集合的体系\" class=\"headerlink\" title=\"2、集合的体系\"></a>2、集合的体系</h1><p><img src=\"https://img-blog.csdnimg.cn/02ca9ce32f35478d9927ba410c02e5a7.png#pic_center\"></p>\n<p>&#x3D;&#x3D;<strong>List系列集合:添加的元素是有序、可重复、有索引。</strong>&#x3D;&#x3D;</p>\n<ul>\n<li>&#x3D;&#x3D;ArrayList、LinekdList :有序、可重复、有索引。&#x3D;&#x3D;</li>\n</ul>\n<p>&#x3D;&#x3D;<strong>Set系列集合:添加的元素是无序、不重复、无索引。</strong>&#x3D;&#x3D;</p>\n<ul>\n<li>&#x3D;&#x3D;HashSet:无序、不重复、无索引;&#x3D;&#x3D;</li>\n<li>&#x3D;&#x3D;LinkedHashSet:有序、不重复、无索引。&#x3D;&#x3D;</li>\n<li>&#x3D;&#x3D;TreeSet:按照大小默认升序排序、不重复、无索引。&#x3D;&#x3D;</li>\n</ul>\n<p>集合都是支持泛型的，可以在编译阶段约束集合只能操作某种数据类型。</p>\n<hr>\n<h1 id=\"3、Collection的常用方法\"><a href=\"#3、Collection的常用方法\" class=\"headerlink\" title=\"3、Collection的常用方法\"></a>3、Collection的常用方法</h1><p>Collection是单列集合的祖宗接口，它的功能是全部单列集合都可以继承使用的。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">称说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public boolean add(E e)</td>\n<td align=\"center\">把给定的对象添加到当前集合中</td>\n</tr>\n<tr>\n<td align=\"center\">public void clear()</td>\n<td align=\"center\">清空集合中所有的元素</td>\n</tr>\n<tr>\n<td align=\"center\">public boolean remove(E e)</td>\n<td align=\"center\">把给定的对象在当前集合中删除</td>\n</tr>\n<tr>\n<td align=\"center\">public boolean contains(Object obj)</td>\n<td align=\"center\">判断当前集合中是否包含给定的对象</td>\n</tr>\n<tr>\n<td align=\"center\">public boolean isEmpty()</td>\n<td align=\"center\">判断当前集合是否为空</td>\n</tr>\n<tr>\n<td align=\"center\">public int size()</td>\n<td align=\"center\">返回集合中元素的个数</td>\n</tr>\n<tr>\n<td align=\"center\">public Object[] toArray()</td>\n<td align=\"center\">把集合中的元素，存储到数组中</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\n\npublic class CollectionDemo &#123;\n    public static void main(String[] args) &#123;\n        // HashSet:添加的元素是无序，不重复，无索引。\n        Collection&lt;String&gt; c = new ArrayList&lt;&gt;();\n        // 1.添加元素, 添加成功返回true。\n        c.add(&quot;Java&quot;);\n        c.add(&quot;HTML&quot;);\n        System.out.println(c.add(&quot;HTML&quot;));\n        c.add(&quot;MySQL&quot;);\n        c.add(&quot;Java&quot;);\n        System.out.println(c.add(&quot;后端&quot;));\n        System.out.println(c); // [Java, HTML, HTML, MySQL, Java, 后端]\n\n        // 2.清空集合的元素。\n        // c.clear();\n        // System.out.println(c);\n\n        // 3.判断集合是否为空 是空返回true,反之。\n        // System.out.println(c.isEmpty());\n\n        // 4.获取集合的大小。\n        System.out.println(c.size());\n\n        // 5.判断集合中是否包含某个元素。\n        System.out.println(c.contains(&quot;Java&quot;));  // true\n        System.out.println(c.contains(&quot;java&quot;)); // false\n        System.out.println(c.contains(&quot;后端&quot;)); // true\n\n        // 6.删除某个元素:如果有多个重复元素默认删除前面的第一个！\n        System.out.println(c.remove(&quot;java&quot;)); // false\n        System.out.println(c);\n        System.out.println(c.remove(&quot;Java&quot;)); // true\n        System.out.println(c);\n\n        // 7.把集合转换成数组  [HTML, HTML, MySQL, Java, 后端]\n        Object[] arrs = c.toArray();\n        System.out.println(&quot;数组：&quot; + Arrays.toString(arrs));\n\n        System.out.println(&quot;----------------------拓展----------------------&quot;);\n        Collection&lt;String&gt; c1 = new ArrayList&lt;&gt;();\n        c1.add(&quot;java1&quot;);\n        c1.add(&quot;java2&quot;);\n        Collection&lt;String&gt; c2 = new ArrayList&lt;&gt;();\n        c2.add(&quot;赵敏&quot;);\n        c2.add(&quot;殷素素&quot;);\n        // addAll把c2集合的元素全部倒入到c1中去。\n        c1.addAll(c2);\n        System.out.println(c1);\n        System.out.println(c2);\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h1 id=\"4、集合的遍历方式\"><a href=\"#4、集合的遍历方式\" class=\"headerlink\" title=\"4、集合的遍历方式\"></a>4、集合的遍历方式</h1><h2 id=\"4-1-方式一：迭代器\"><a href=\"#4-1-方式一：迭代器\" class=\"headerlink\" title=\"4.1 方式一：迭代器\"></a>4.1 方式一：迭代器</h2><p>遍历就是一个一个的把容器中的元素访问一遍。</p>\n<p>&#x3D;&#x3D;迭代器在Java中的代表是lterator，迭代器是集合的专用遍历方式。&#x3D;&#x3D;</p>\n<p><strong>Collection集合获取迭代器</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Iterator<E> iterator()</td>\n<td align=\"center\">返回集合中的迭代器对象，该迭代器对象默认指向当前集合的O索引</td>\n</tr>\n</tbody></table>\n<p><strong>lterator中的常用方法</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">boolean hasNext()</td>\n<td align=\"center\">询问当前位置是否有元素存在，存在返回true ,不存在返回false</td>\n</tr>\n<tr>\n<td align=\"center\">E next()</td>\n<td align=\"center\">获取当前位置的元素，并同时将迭代器对象移向下一个位置，注意防止取出越界</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">import java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        ArrayList&lt;String&gt; lists = new ArrayList&lt;&gt;();\n        lists.add(&quot;赵敏&quot;);\n        lists.add(&quot;小昭&quot;);\n        lists.add(&quot;素素&quot;);\n        lists.add(&quot;灭绝&quot;);\n        System.out.println(lists);\n        // [赵敏, 小昭, 素素, 灭绝]\n\n        // 1、得到当前集合的迭代器对象。\n        Iterator&lt;String&gt; it = lists.iterator();\n\n        // 2、定义while循环\n        while (it.hasNext())&#123;\n            String ele = it.next();\n            System.out.println(ele);\n        &#125;\n        System.out.println(&quot;-----------------------------&quot;);\n    &#125;\n&#125;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/b86948eeea6848edac96e346478c265c.png#pic_center\"></p>\n<h2 id=\"4-2-方式二：foreach-增强for循环\"><a href=\"#4-2-方式二：foreach-增强for循环\" class=\"headerlink\" title=\"4.2 方式二：foreach&#x2F;增强for循环\"></a>4.2 方式二：foreach&#x2F;增强for循环</h2><p>&#x3D;&#x3D;增强for循环，既可以遍历集合也可以遍历数组。&#x3D;&#x3D;</p>\n<pre><code class=\"java\">for(元素数据类型 变量名:数组或者Collection集合)&#123;\n    //在此处使用变量即可，该变量就是元素\n&#125;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/804e585ef1a54b078056dc69eb425cc7.png#pic_center\"></p>\n<pre><code class=\"java\">import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        Collection&lt;String&gt; lists = new ArrayList&lt;&gt;();\n        lists.add(&quot;赵敏&quot;);\n        lists.add(&quot;小昭&quot;);\n        lists.add(&quot;殷素素&quot;);\n        lists.add(&quot;周芷若&quot;);\n        System.out.println(lists);\n        // [赵敏, 小昭, 殷素素, 周芷若]\n        //  ele\n\n        for (String ele : lists) &#123;\n            System.out.println(ele);\n        &#125;\n\n        System.out.println(&quot;------------------&quot;);\n        double[] scores = &#123;100, 99.5 , 59.5&#125;;\n        for (double score : scores) &#123;\n            System.out.println(score);\n//            if(score == 59.5)&#123;\n//                score = 100.0; // 修改无意义，不会影响数组的元素值。\n//            &#125;\n        &#125;\n        System.out.println(Arrays.toString(scores));\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"4-3-方式三：lambda表达式\"><a href=\"#4-3-方式三：lambda表达式\" class=\"headerlink\" title=\"4.3 方式三：lambda表达式\"></a>4.3 方式三：lambda表达式</h2><p>得益于JDK 8开始的新技术Lambda表达式，提供了一种更简单、更直接的遍历集合的方式。</p>\n<p>Collection结合Lambda遍历的APl</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">default void forEach(consumer&lt; ?super T&gt; action):</td>\n<td align=\"center\">结合lambda遍历集合</td>\n</tr>\n<tr>\n<td align=\"center\"><img src=\"https://img-blog.csdnimg.cn/e33fb48f9a9842c59556cc0d44176df4.png#pic_center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">import java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.function.Consumer;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        Collection&lt;String&gt; lists = new ArrayList&lt;&gt;();\n        lists.add(&quot;赵敏&quot;);\n        lists.add(&quot;小昭&quot;);\n        lists.add(&quot;殷素素&quot;);\n        lists.add(&quot;周芷若&quot;);\n        System.out.println(lists);\n        // [赵敏, 小昭, 殷素素, 周芷若]\n        //  s\n        lists.forEach(new Consumer&lt;String&gt;() &#123;\n            @Override\n            public void accept(String s) &#123;\n                System.out.println(s);\n            &#125;\n        &#125;);\n\n//        lists.forEach(s -&gt; &#123;\n//                System.out.println(s);\n//        &#125;);\n\n        // lists.forEach(s -&gt;  System.out.println(s) );\n\n        lists.forEach(System.out::println );\n\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h1 id=\"5、-集合存储自定义类型的对象\"><a href=\"#5、-集合存储自定义类型的对象\" class=\"headerlink\" title=\"5、 集合存储自定义类型的对象\"></a>5、 集合存储自定义类型的对象</h1><pre><code class=\"java\">public class Movie &#123;\n    private String name;\n    private double score;\n    private String actor;\n\n    public Movie() &#123;\n    &#125;\n\n    public Movie(String name, double score, String actor) &#123;\n        this.name = name;\n        this.score = score;\n        this.actor = actor;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public double getScore() &#123;\n        return score;\n    &#125;\n\n    public void setScore(double score) &#123;\n        this.score = score;\n    &#125;\n\n    public String getActor() &#123;\n        return actor;\n    &#125;\n\n    public void setActor(String actor) &#123;\n        this.actor = actor;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Movie&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, score=&quot; + score +\n                &quot;, actor=&#39;&quot; + actor + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">import java.util.ArrayList;\nimport java.util.Collection;\n\npublic class TestDemo &#123;\n    public static void main(String[] args) &#123;\n        // 1、定义一个电影类\n        // 2、定义一个集合对象存储3部电影对象\n        Collection&lt;Movie&gt; movies = new ArrayList&lt;&gt;();\n        movies.add(new Movie(&quot;《你好，李焕英》&quot;, 9.5, &quot;张小斐,贾玲,沈腾,陈赫&quot;));\n        movies.add(new Movie(&quot;《唐人街探案》&quot;, 8.5, &quot;王宝强,刘昊然,美女&quot;));\n        movies.add(new Movie(&quot;《刺杀小说家》&quot;,8.6, &quot;雷佳音,杨幂&quot;));\n\n        System.out.println(movies);\n\n        // 3、遍历集合容器中的每个电影对象\n        for (Movie movie : movies) &#123;\n            System.out.println(&quot;片名：&quot; + movie.getName());\n            System.out.println(&quot;得分：&quot; + movie.getScore());\n            System.out.println(&quot;主演：&quot; + movie.getActor());\n        &#125;\n\n    &#125;\n&#125;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/8f2956eb108547f7978d2746eb3cea3f.png#pic_center\"><br><strong>集合中存储的是元素对象的地址。</strong></p>\n<hr>\n<h1 id=\"6、常见的数据结构\"><a href=\"#6、常见的数据结构\" class=\"headerlink\" title=\"6、常见的数据结构\"></a>6、常见的数据结构</h1><p>参见数据结构系列博客    <a href=\"https://blog.csdn.net/ASHIYI66/article/details/123036987\">数据结构笔记</a>。</p>\n<hr>\n<h1 id=\"7、List系列集合\"><a href=\"#7、List系列集合\" class=\"headerlink\" title=\"7、List系列集合\"></a>7、List系列集合</h1><h2 id=\"7-1-List集合特点\"><a href=\"#7-1-List集合特点\" class=\"headerlink\" title=\"7.1 List集合特点\"></a>7.1 List集合特点</h2><p>&#x3D;&#x3D;ArrayList、 LinekdList :有序，可重复，有索引。&#x3D;&#x3D;</p>\n<ul>\n<li>有序:存储和取出的元素顺序一致</li>\n<li>有索引:可以通过索引操作元素</li>\n<li>可重复: 存储的元素可以重复</li>\n</ul>\n<p>&#x3D;&#x3D;ArrayList底层是基于数组实现的,根据查询元素快,增删相对慢。&#x3D;&#x3D;<br>&#x3D;&#x3D;LinkedList底层基于双链表实现的，查询元素慢,增删首尾元素是非常快的。&#x3D;&#x3D;</p>\n<p><strong>List集合特有方法</strong></p>\n<p>List集合因为支持索引， 所以多了很多索弓|操作的独特api,其他Collection的功能List也都继承了。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">void add(int index,E element)</td>\n<td align=\"center\">在此集合中的指定位置插入指定的元素</td>\n</tr>\n<tr>\n<td align=\"center\">E remove(int index)</td>\n<td align=\"center\">删除指定索引处的元素，返回被删除的元素</td>\n</tr>\n<tr>\n<td align=\"center\">E set(int index,E element)</td>\n<td align=\"center\">修改指定索引处的元素，返回被修改的元素</td>\n</tr>\n<tr>\n<td align=\"center\">E get(int index)</td>\n<td align=\"center\">返回指定索引</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">import java.util.ArrayList;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        // 1.创建一个ArrayList集合对象：\n        // List:有序，可重复，有索引的。\n        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); // 一行经典代码！\n        list.add(&quot;Java&quot;);\n        list.add(&quot;Java&quot;);\n        list.add(&quot;HTML&quot;);\n        list.add(&quot;HTML&quot;);\n        list.add(&quot;MySQL&quot;);\n        list.add(&quot;MySQL&quot;);\n\n        // 2.在某个索引位置插入元素。\n        list.add(2, &quot;后端&quot;);\n        System.out.println(list);\n\n        // 3.根据索引删除元素,返回被删除元素\n        System.out.println(list.remove(1));\n        System.out.println(list);\n\n        // 4.根据索引获取元素:public E get(int index):返回集合中指定位置的元素。\n        System.out.println(list.get(1));\n\n        // 5.修改索引位置处的元素: public E set(int index, E element)\n        System.out.println(list.set(1, &quot;前端&quot;));\n        System.out.println(list);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"7-2-List集合遍历\"><a href=\"#7-2-List集合遍历\" class=\"headerlink\" title=\"7.2 List集合遍历\"></a>7.2 List集合遍历</h2><ol>\n<li>迭代器</li>\n<li>增强for循环</li>\n<li>Lambda表达式</li>\n<li>for循环(因为List集合存在索引)</li>\n</ol>\n<pre><code class=\"java\">import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class Test&#123;\n    public static void main(String[] args) &#123;\n        List&lt;String&gt; lists = new ArrayList&lt;&gt;();\n        lists.add(&quot;java1&quot;);\n        lists.add(&quot;java2&quot;);\n        lists.add(&quot;java3&quot;);\n\n        /* （1）for循环。 */\n        System.out.println(&quot;-----------------------&quot;);\n\n        for (int i = 0; i &lt; lists.size(); i++) &#123;\n            String ele = lists.get(i);\n            System.out.println(ele);\n        &#125;\n\n\n        /* （2）迭代器。 */\n        System.out.println(&quot;-----------------------&quot;);\n        Iterator&lt;String&gt; it = lists.iterator();\n        while (it.hasNext())&#123;\n            String ele = it.next();\n            System.out.println(ele);\n        &#125;\n\n        /* （3）foreach */\n        System.out.println(&quot;-----------------------&quot;);\n        for (String ele : lists) &#123;\n            System.out.println(ele);\n        &#125;\n\n        /* （4）JDK 1.8开始之后的Lambda表达式  */\n        System.out.println(&quot;-----------------------&quot;);\n        lists.forEach(s -&gt; &#123;\n            System.out.println(s);\n        &#125;);\n\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"7-3-ArrayList集合的底层原理\"><a href=\"#7-3-ArrayList集合的底层原理\" class=\"headerlink\" title=\"7.3 ArrayList集合的底层原理\"></a>7.3 ArrayList集合的底层原理</h2><ul>\n<li>Araylist底层是基于数组实现的:根据索引定位元素快，增删需要做元素的移位操作。</li>\n<li>第一次创建集合并添加第一个元素的时候， 在底层创建一个默认长度为10的数组。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/fb19b2c22e2e4d8abd0e8fa3d8b773fd.png#pic_center\"></p>\n<hr>\n<h2 id=\"7-4-LinkedList集合的底层原理\"><a href=\"#7-4-LinkedList集合的底层原理\" class=\"headerlink\" title=\"7.4 LinkedList集合的底层原理\"></a>7.4 LinkedList集合的底层原理</h2><p>底层数据结构是双链表，查询慢，首尾操作的速度是极快的，所以多了很多首尾操作的特有API。</p>\n<p>LinkedList集合的特有功能</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public void adFirst(E e)</td>\n<td align=\"center\">在该列表开头插入指定的元素</td>\n</tr>\n<tr>\n<td align=\"center\">public void addLast(E e)</td>\n<td align=\"center\">将指定的元素追加到此列表的末尾</td>\n</tr>\n<tr>\n<td align=\"center\">public E getFirst()</td>\n<td align=\"center\">返回此列表中的第一个元素</td>\n</tr>\n<tr>\n<td align=\"center\">public E getLast()</td>\n<td align=\"center\">返回此列表中的最后一个元素</td>\n</tr>\n<tr>\n<td align=\"center\">public E removeFirst()</td>\n<td align=\"center\">从此列表中删除并返回第一个元素</td>\n</tr>\n<tr>\n<td align=\"center\">public E removeLast()</td>\n<td align=\"center\">从此列表中删除并返回最后一个元素</td>\n</tr>\n<tr>\n<td align=\"center\"><img src=\"https://img-blog.csdnimg.cn/f12064ea288142328c47ada6c8cb6402.png#pic_center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<hr>\n<h1 id=\"8、集合的并发修改异常问题\"><a href=\"#8、集合的并发修改异常问题\" class=\"headerlink\" title=\"8、集合的并发修改异常问题\"></a>8、集合的并发修改异常问题</h1><p>当我们从集合中找出某个元素并删除的时候可能出现一 种并发修改异常问题。</p>\n<p>哪些遍历存在问题?</p>\n<ul>\n<li>迭代器遍历集合且直接用集合删除元素的时候可能出现。</li>\n<li>增强for循环遍历集合且直接用集合删除元素的时候可能出现。</li>\n</ul>\n<p>哪种遍历且删除元素不出问题</p>\n<ul>\n<li>迭代器遍历集合但是用迭代器自己的删除方法操作可以解决。</li>\n<li>使用for循环遍历并删除元素不会存在这个问题。</li>\n</ul>\n<hr>\n<h1 id=\"9、泛型深入\"><a href=\"#9、泛型深入\" class=\"headerlink\" title=\"9、泛型深入\"></a>9、泛型深入</h1><h2 id=\"9-1-泛型的概述和优势\"><a href=\"#9-1-泛型的概述和优势\" class=\"headerlink\" title=\"9.1 泛型的概述和优势\"></a>9.1 泛型的概述和优势</h2><p>泛型概述</p>\n<ul>\n<li>泛型:是JDK5中引入的特性,可以在编译阶段约束操作的数据类型，并进行检查。</li>\n<li>泛型的格式: &lt;数据类型&gt;; 注意:泛型只能支持引|用数据类型。</li>\n<li>集合体系的全部接口和实现类都是支持泛型的使用的。</li>\n</ul>\n<p>泛型的好处:</p>\n<ul>\n<li>统一数据类型。</li>\n<li>把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为编译阶段类型就能确定下来。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/561dac4782724f07984bde3b74762ba8.png#pic_center\"></p>\n<h2 id=\"9-2-自定义泛型类\"><a href=\"#9-2-自定义泛型类\" class=\"headerlink\" title=\"9.2 自定义泛型类\"></a>9.2 自定义泛型类</h2><p>泛型类的概述</p>\n<ul>\n<li>定义类时同时定义了泛型的类就是泛型类。</li>\n<li>泛型类的格式:修饰符class类名&lt;泛型变量&gt;{ }</li>\n</ul>\n<pre><code class=\"java\">范例: public class MyArrayList&lt;T&gt; &#123; &#125;\n</code></pre>\n<p>此处泛型变量T可以随便写为任意标识, 常见的如E、T、K、V等。</p>\n<p>作用:编译阶段可以指定数据类型，类似于集合的作用。</p>\n<p>模拟ArrayList集合自定义一 个集合MyArrayList集合,完成添加和删除功能的泛型设计即可。</p>\n<pre><code class=\"java\">import java.util.ArrayList;\n\npublic class MyArrayList&lt;E&gt; &#123;\n    private ArrayList lists = new ArrayList();\n\n    public void add(E e)&#123;\n        lists.add(e);\n    &#125;\n\n    public void remove(E e)&#123;\n        lists.remove(e);\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return lists.toString();\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Test &#123;\n    public static void main(String[] args) &#123;\n        MyArrayList&lt;String&gt; list = new MyArrayList&lt;&gt;();\n        list.add(&quot;Java&quot;);\n        list.add(&quot;Java&quot;);\n        list.add(&quot;MySQL&quot;);\n        list.remove(&quot;MySQL&quot;);\n        System.out.println(list);\n\n        MyArrayList&lt;Integer&gt; list2 = new MyArrayList&lt;&gt;();\n        list2.add(23);\n        list2.add(24);\n        list2.add(25);\n        list2.remove(25);\n        System.out.println(list2);\n    &#125;\n&#125;\n</code></pre>\n<p>泛型类的原理:</p>\n<p><strong>把出现泛型变量的地方全部替换成传输的真实数据类型。</strong></p>\n<h2 id=\"9-3-自定义泛型方法\"><a href=\"#9-3-自定义泛型方法\" class=\"headerlink\" title=\"9.3 自定义泛型方法\"></a>9.3 自定义泛型方法</h2><p>泛型方法的概述</p>\n<ul>\n<li>定义方法时同时定义了泛型的方法就是泛型方法。</li>\n<li>泛型方法的格式:修饰符&lt;泛型变量&gt;方法返回值方法名称(形参列表){}</li>\n</ul>\n<pre><code class=\"java\">范例: public &lt;T&gt; void show(T t)&#123; &#125;\n</code></pre>\n<p>作用:方法中可以使用泛型接收一切实际类型的参数，方法更具备通用性。</p>\n<pre><code class=\"java\">public class Test &#123;\n    public static void main(String[] args) &#123;\n        String[] names = &#123;&quot;小璐&quot;, &quot;蓉容&quot;, &quot;小何&quot;&#125;;\n        printArray(names);\n\n        Integer[] ages = &#123;10, 20, 30&#125;;\n        printArray(ages);\n\n        Integer[] ages2 = getArr(ages);\n        String[]  names2 = getArr(names);\n    &#125;\n\n    public static &lt;T&gt; T[] getArr(T[] arr)&#123;\n        return arr;\n    &#125;\n\n    public static &lt;T&gt; void printArray(T[] arr)&#123;\n        if(arr != null)&#123;\n            StringBuilder sb = new StringBuilder(&quot;[&quot;);\n            for (int i = 0; i &lt; arr.length; i++) &#123;\n                sb.append(arr[i]).append(i == arr.length - 1 ? &quot;&quot; : &quot;, &quot;);\n            &#125;\n            sb.append(&quot;]&quot;);\n            System.out.println(sb);\n        &#125;else &#123;\n            System.out.println(arr);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>给你任何一个类型的数组，都能返回它的内容。也就是实现Arrays.toString(数组)的功能! </p>\n<p>泛型方法的原理:</p>\n<p><strong>把出现泛型变量的地方全部替换成传输的真实数据类型。</strong></p>\n<h2 id=\"9-4-自定义泛型接口\"><a href=\"#9-4-自定义泛型接口\" class=\"headerlink\" title=\"9.4 自定义泛型接口\"></a>9.4 自定义泛型接口</h2><p>泛型接口的概述</p>\n<ul>\n<li>使用了泛型定义的接口就是泛型接口。</li>\n<li>泛型接口的格式:修饰符interface 接口名称&lt;泛型变量&gt;{}</li>\n</ul>\n<pre><code class=\"java\">范例: public interface Data&lt;E&gt;&#123;&#125;\n</code></pre>\n<p>作用:泛型接口可以让实现类选择当前功能需要操作的数据类型</p>\n<p>泛型接口的原理:</p>\n<p><strong>实现类可以在实现接口的时候传入自己操作的数据类型,这样重写的方法都将是针对于该类型的操作。</strong></p>\n<h2 id=\"9-5-泛型通配符、上下限\"><a href=\"#9-5-泛型通配符、上下限\" class=\"headerlink\" title=\"9.5 泛型通配符、上下限\"></a>9.5 泛型通配符、上下限</h2><p>通配符:?</p>\n<ul>\n<li>?可以在“使用泛型”的时候代表一切类型。</li>\n<li>ET KV是在定义泛型的时候使用的。</li>\n</ul>\n<p>开发一个极品飞车的游戏,所有的汽车都能一 起参与比赛。</p>\n<pre><code class=\"java\">import java.util.ArrayList;\n\npublic class GenericDemo &#123;\n    public static void main(String[] args) &#123;\n        ArrayList&lt;BMW&gt; bmws = new ArrayList&lt;&gt;();\n        bmws.add(new BMW());\n        bmws.add(new BMW());\n        bmws.add(new BMW());\n        go(bmws);\n\n        ArrayList&lt;BENZ&gt; benzs = new ArrayList&lt;&gt;();\n        benzs.add(new BENZ());\n        benzs.add(new BENZ());\n        benzs.add(new BENZ());\n        go(benzs);\n\n        ArrayList&lt;Dog&gt; dogs = new ArrayList&lt;&gt;();\n        dogs.add(new Dog());\n        dogs.add(new Dog());\n        dogs.add(new Dog());\n        // go(dogs);\n    &#125;\n\n    /**\n       所有车比赛\n     */\n    public static void go(ArrayList&lt;? extends Car&gt; cars)&#123;\n    &#125;\n&#125;\n\nclass Dog&#123;\n\n&#125;\n\nclass BENZ extends Car&#123;\n&#125;\n\nclass BMW extends Car&#123;\n&#125;\n\n// 父类\nclass Car&#123;\n&#125;\n</code></pre>\n<p>注意:<br>●虽然BMW和BENZ都继承了Car但是ArrayList &lt; BMW&gt;和ArrayList<BENZ>与ArrayList<Car>没有关系的! !</p>\n<p>泛型的上下限: .</p>\n<ul>\n<li>? extends Car: ?必须是Car或者其子类泛型上限</li>\n<li>? super Car : ?必须是Car或者其父类 泛型下限</li>\n</ul>\n<hr>\n","feature":true,"text":"Java集合是编程中重要的概念，提供有序对象操作。Collection是基本接口，List是其子接口，实现有序可重复元素序列。使用List简化开发和维护工作，处理数据如员工名单、商品列表更高效方便。提供排序、查找、过滤等算法和工具类，支持泛型确保类型安全。掌握Java集合是必备技能。...","permalink":"/post/Java程序设计 -- 集合(上)（十二）","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1%E3%80%81%E9%9B%86%E5%90%88%E7%9A%84%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1、集合的概述</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2%E3%80%81%E9%9B%86%E5%90%88%E7%9A%84%E4%BD%93%E7%B3%BB\"><span class=\"toc-text\">2、集合的体系</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3%E3%80%81Collection%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">3、Collection的常用方法</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4%E3%80%81%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">4、集合的遍历方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8\"><span class=\"toc-text\">4.1 方式一：迭代器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2-%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9Aforeach-%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">4.2 方式二：foreach&#x2F;增强for循环</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-3-%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9Alambda%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">4.3 方式三：lambda表达式</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5%E3%80%81-%E9%9B%86%E5%90%88%E5%AD%98%E5%82%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">5、 集合存储自定义类型的对象</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#6%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">6、常见的数据结构</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#7%E3%80%81List%E7%B3%BB%E5%88%97%E9%9B%86%E5%90%88\"><span class=\"toc-text\">7、List系列集合</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-1-List%E9%9B%86%E5%90%88%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">7.1 List集合特点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-2-List%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">7.2 List集合遍历</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-3-ArrayList%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">7.3 ArrayList集合的底层原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-4-LinkedList%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">7.4 LinkedList集合的底层原理</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#8%E3%80%81%E9%9B%86%E5%90%88%E7%9A%84%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">8、集合的并发修改异常问题</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#9%E3%80%81%E6%B3%9B%E5%9E%8B%E6%B7%B1%E5%85%A5\"><span class=\"toc-text\">9、泛型深入</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-1-%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%A6%82%E8%BF%B0%E5%92%8C%E4%BC%98%E5%8A%BF\"><span class=\"toc-text\">9.1 泛型的概述和优势</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%B1%BB\"><span class=\"toc-text\">9.2 自定义泛型类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">9.3 自定义泛型方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">9.4 自定义泛型接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-5-%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6%E3%80%81%E4%B8%8A%E4%B8%8B%E9%99%90\"><span class=\"toc-text\">9.5 泛型通配符、上下限</span></a></li></ol></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Java程序设计--集合(下)","uid":"d48d7238235ebfe7d1b58dbbcb25bc7c","slug":"Java程序设计 -- 集合(下)（十三）","date":"2022-03-24T10:16:55.000Z","updated":"2025-07-14T15:12:20.462Z","comments":true,"path":"api/articles/Java程序设计 -- 集合(下)（十三）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","text":"Java集合框架是Java编程中至关重要的组成部分，其中Set和Map是两个核心接口。Set接口代表着不含重复元素的集合，而Map接口则表示键值对的映射关系。通过Set和Map，开发者能够高效地处理各种数据，并且这两个接口提供了丰富的方法和功能，如查找、遍历、添加和删除等。...","permalink":"/post/Java程序设计 -- 集合(下)（十三）","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true},"next_post":{"title":"Java程序设计--常用API(下)","uid":"65aeac242f4186aad4881b96128bffa6","slug":"Java程序设计 -- 常用API(下)（十一）","date":"2022-03-22T11:19:57.000Z","updated":"2025-07-14T15:12:20.460Z","comments":true,"path":"api/articles/Java程序设计 -- 常用API(下)（十一）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","text":"日期类是Java中用于处理日期和时间的类，提供了日期和时间的操作、格式化和解析等功能。正则表达式是一种用于匹配和操作字符串的强大工具，Java通过Pattern和Matcher类提供了对正则表达式的支持。Lambda表达式是Java 8引入的一种新特性，用于简化函数式编程的表达方式，可以更简洁地表示匿名函数，提高代码的可读性和简洁性。...","permalink":"/post/Java程序设计 -- 常用API(下)（十一）","photos":[],"count_time":{"symbolsCount":"29k","symbolsTime":"26 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true}}