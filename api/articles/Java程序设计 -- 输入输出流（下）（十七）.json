{"title":"Java程序设计--输入输出流(下)","uid":"5dfd375e1addf174b025352719cc8bb2","slug":"Java程序设计 -- 输入输出流（下）（十七）","date":"2022-04-04T07:22:51.000Z","updated":"2025-07-14T15:12:20.461Z","comments":true,"path":"api/articles/Java程序设计 -- 输入输出流（下）（十七）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","content":"<hr>\n<h1 id=\"1、缓冲流\"><a href=\"#1、缓冲流\" class=\"headerlink\" title=\"1、缓冲流\"></a>1、缓冲流</h1><h2 id=\"1-1-缓冲流概述\"><a href=\"#1-1-缓冲流概述\" class=\"headerlink\" title=\"1.1 缓冲流概述\"></a>1.1 缓冲流概述</h2><ul>\n<li>缓冲流也称为高效流、或者高级流。之前学习的字节流可以称为原始流。</li>\n<li>&#x3D;&#x3D;作用:缓冲流自带缓冲区、可以提高原始字节流、字符流读写数据的性能。&#x3D;&#x3D;</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/e18dce6a32984c2bbd7c05fcac9d7f30.png#pic_center\"></p>\n<h2 id=\"1-2-字节缓冲流\"><a href=\"#1-2-字节缓冲流\" class=\"headerlink\" title=\"1.2 字节缓冲流\"></a>1.2 字节缓冲流</h2><p><strong>字节缓冲流性能优化原理:</strong></p>\n<ul>\n<li>字节缓冲输入流自带了<strong>8KB缓冲池</strong>，以后我们直接从缓冲池读取数据，所以性能较好。</li>\n<li>字节缓冲输出流自带了<strong>8KB缓冲池</strong>，数据就直接写入到缓冲池中去，写数据性能极高了。</li>\n</ul>\n<p><strong>字节缓冲流</strong></p>\n<ul>\n<li>字节缓冲输入流: BufferedInputStream，提高字节输入流读取数据的性能，读写功能上并无变化。</li>\n<li>字节缓冲输出流: BufferedOutputStream，提高字节输出流读取数据的性能，读写功能上并无变化。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">构造器</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public BufferedInputStream(InputStream is)</td>\n<td align=\"center\">可以把低级的字节输入流包装成一个高级的缓冲字节输入流管道，从而提高字节输入流读数据的性能</td>\n</tr>\n<tr>\n<td align=\"center\">public BufferedOutputStream(OutputStream os)</td>\n<td align=\"center\">可以把低级的字节输出流包装成一个高级的缓冲字节输出流，从而提高写数据的性能</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">import java.io.*;\n\n/**\n    使用字节缓冲流完成数据的读写操作。\n */\npublic class ByteBufferDemo &#123;\n    public static void main(String[] args) &#123;\n\n        try (\n                // 这里面只能放置资源对象，用完会自动关闭：自动调用资源对象的close方法关闭资源（即使出现异常也会做关闭操作）\n                // 1、创建一个字节输入流管道与原视频接通\n                InputStream is = new FileInputStream(&quot;D:\\\\resources\\\\demo.jpeg&quot;);\n                // a.把原始的字节输入流包装成高级的缓冲字节输入流\n                InputStream bis = new BufferedInputStream(is);\n                // 2、创建一个字节输出流管道与目标文件接通\n                OutputStream os = new FileOutputStream(&quot;D:\\\\resources\\\\demo222.jpeg&quot;);\n                // b.把字节输出流管道包装成高级的缓冲字节输出流管道\n                OutputStream bos = new BufferedOutputStream(os);\n\n        ) &#123;\n\n            // 3、定义一个字节数组转移数据\n            byte[] buffer = new byte[1024];\n            int len; // 记录每次读取的字节数。\n            while ((len = bis.read(buffer)) != -1)&#123;\n                bos.write(buffer, 0 , len);\n            &#125;\n            System.out.println(&quot;复制完成了！&quot;);\n\n        &#125; catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;\n\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"1-3-字符缓冲流概述\"><a href=\"#1-3-字符缓冲流概述\" class=\"headerlink\" title=\"1.3 字符缓冲流概述\"></a>1.3 字符缓冲流概述</h2><p>字符缓冲输入流:BufferedReader。</p>\n<ul>\n<li>作用:提高字符输入流读取数据的性能，除此之外多了按照行读取数据的功能。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">构造器</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public BufferedReader( Reader r)</td>\n<td align=\"center\">可以把低级的字符输入流包装成一个高级的缓冲字符输入流管道，从而提高字符输入流读数据的性能</td>\n</tr>\n</tbody></table>\n<p><strong>字符缓冲输入流新增功能</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public String readLine()</td>\n<td align=\"center\">读取一行数据返回，如果读取没有完毕，无行可读返回null</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.Reader;\n\n/**\n    学会使用缓冲字符输入流提高字符输入流的性能，新增了按照行读取的方法(经典代码)\n */\npublic class BufferedReaderDemo1 &#123;\n    public static void main(String[] args) &#123;\n        try (\n                // 1、创建一个文件字符输入流与源文件接通。\n                Reader fr = new FileReader(&quot;io-app2/src/data01.txt&quot;);\n                // a、把低级的字符输入流包装成高级的缓冲字符输入流。\n                BufferedReader br = new BufferedReader(fr);\n                )&#123;\n              String line;\n              while ((line = br.readLine()) != null)&#123;\n                  System.out.println(line);\n              &#125;\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>字符缓冲输出流:BufferedWriter。</p>\n<ul>\n<li>作用:提高字符输出流写取数据的性能，除此之外多了换行功能</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">构造器</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public BufferedWriter(Writer w)</td>\n<td align=\"center\">可以把低级的字符输出流包装成一个高级的缓冲字符输出流管道，从而提高字符输出流写数据的性能</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>字符缓冲输出流新增功能</strong></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">方法</td>\n<td align=\"center\">说明</td>\n</tr>\n<tr>\n<td align=\"center\">:-:</td>\n<td align=\"center\">:-:</td>\n</tr>\n<tr>\n<td align=\"center\">public void newLine()</td>\n<td align=\"center\">换行操作</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">import java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.Writer;\n\n/**\n        缓冲字符输出流的使用，学会它多出来的一个功能：newLine();\n */\npublic class BufferedWriterDemo2 &#123;\n    public static void main(String[] args) throws Exception &#123;\n        // 1、创建一个字符输出流管道与目标文件接通\n        Writer fw = new FileWriter(&quot;io-app2/src/out02.txt&quot;); // 覆盖管道，每次启动都会清空文件之前的数据\n       //Writer fw = new FileWriter(&quot;io-app2/src/out02.txt&quot;, true); // 追加数据\n        BufferedWriter bw = new BufferedWriter(fw);\n\n//      a.public void write(int c):写一个字符出去\n        bw.write(98);\n        bw.write(&#39;a&#39;);\n        bw.write(&#39;徐&#39;); // 不会出问题了\n        bw.newLine(); // bw.write(&quot;\\r\\n&quot;); // 换行\n\n//       b.public void write(String c)写一个字符串出去\n        bw.write(&quot;abc我是中国人&quot;);\n        bw.newLine(); // bw.write(&quot;\\r\\n&quot;); // 换行\n\n\n//       c.public void write(char[] buffer):写一个字符数组出去\n        char[] chars = &quot;abc我是中国人&quot;.toCharArray();\n        bw.write(chars);\n        bw.newLine(); // bw.write(&quot;\\r\\n&quot;); // 换行\n\n\n//       d.public void write(String c ,int pos ,int len):写字符串的一部分出去\n        bw.write(&quot;abc我是中国人&quot;, 0, 5);\n        bw.newLine(); // bw.write(&quot;\\r\\n&quot;); // 换行\n\n//       e.public void write(char[] buffer ,int pos ,int len):写字符数组的一部分出去\n        bw.write(chars, 3, 5);\n        bw.newLine(); // bw.write(&quot;\\r\\n&quot;); // 换行\n\n\n        // fw.flush();// 刷新后流可以继续使用\n        bw.close(); // 关闭包含刷线，关闭后流不能使用\n\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h1 id=\"2、转换流\"><a href=\"#2、转换流\" class=\"headerlink\" title=\"2、转换流\"></a>2、转换流</h1><h2 id=\"2-1-字符输入转换流\"><a href=\"#2-1-字符输入转换流\" class=\"headerlink\" title=\"2.1 字符输入转换流\"></a>2.1 字符输入转换流</h2><p><strong>字符输入转换流: InputStreamReader，可以把原始的字节流按照指定编码转换成字符输入流。&#x3D;&#x3D;可以解决字符流读取不同编码乱码问题。&#x3D;&#x3D;</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">构造器</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public InputStreamReader(InputStream is)</td>\n<td align=\"center\">可以把原始的字节流按照代码默认编码转换成字符输入流。几乎不用，与默认的FileReader—样。</td>\n</tr>\n<tr>\n<td align=\"center\">public InputStreamReader(InputStream is , String charset)</td>\n<td align=\"center\">可以把原始的字节流按照指定编码转换成字符输入流，这样字符流中的字符就不乱码了(重点)</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">import java.io.*;\n\npublic class InputStreamReaderDemo &#123;\n    public static void main(String[] args) throws Exception &#123;\n        // 代码UTF-8   文件 GBK  &quot;D:\\\\resources\\\\data.txt&quot;\n        // 1、提取GBK文件的原始字节流。   abc 我\n        //                            ooo oo\n        InputStream is = new FileInputStream(&quot;D:\\\\resources\\\\data.txt&quot;);\n        // 2、把原始字节流转换成字符输入流\n        // Reader isr = new InputStreamReader(is); // 默认以UTF-8的方式转换成字符流。 还是会乱码的  跟直接使用FileReader是一样的\n        Reader isr = new InputStreamReader(is , &quot;GBK&quot;); // 以指定的GBK编码转换成字符输入流  完美的解决了乱码问题\n\n        BufferedReader br = new BufferedReader(isr);\n        String line;\n        while ((line = br.readLine()) != null)&#123;\n            System.out.println(line);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"2-2-字符输出转换流\"><a href=\"#2-2-字符输出转换流\" class=\"headerlink\" title=\"2.2 字符输出转换流\"></a>2.2 字符输出转换流</h2><p>字符输入转换流:OutputStreamWriter，可以把字节输出流按照指定编码转换成字符输出流。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">构造器</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public OutputStreamWriter(OutputStream os)</td>\n<td align=\"center\">可以把原始的字节输出流按照代码默</td>\n</tr>\n<tr>\n<td align=\"center\">public OutputStreamWriter(OutputStream os，String charset)</td>\n<td align=\"center\">可以把原始的字节输出流按照指定编码转换成字符输出流(重点)</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">import java.io.*;\nimport java.nio.Buffer;\n\npublic class OutputStreamWriterDemo &#123;\n    public static void main(String[] args) throws Exception &#123;\n        // 1、定义一个字节输出流\n        OutputStream os = new FileOutputStream(&quot;io-app2/src/out03.txt&quot;);\n\n        // 2、把原始的字节输出流转换成字符输出流\n        // Writer osw = new OutputStreamWriter(os); // 以默认的UTF-8写字符出去 跟直接写FileWriter一样\n        Writer osw = new OutputStreamWriter(os , &quot;GBK&quot;); // 指定GBK的方式写字符出去\n\n        // 3、把低级的字符输出流包装成高级的缓冲字符输出流。\n        BufferedWriter bw = new BufferedWriter(osw);\n\n        bw.write(&quot;我爱中国1~~&quot;);\n        bw.write(&quot;我爱中国2~~&quot;);\n        bw.write(&quot;我爱中国3~~&quot;);\n\n        bw.close();\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h1 id=\"3、序列化对象\"><a href=\"#3、序列化对象\" class=\"headerlink\" title=\"3、序列化对象\"></a>3、序列化对象</h1><h2 id=\"3-1-对象序列化\"><a href=\"#3-1-对象序列化\" class=\"headerlink\" title=\"3.1 对象序列化\"></a>3.1 对象序列化</h2><p><img src=\"https://img-blog.csdnimg.cn/3f2b01982330422aa70a16a2e102b61d.png#pic_center\"></p>\n<p>对象序列化:</p>\n<ul>\n<li><strong>作用:以内存为基准，把内存中的对象存储到磁盘文件中去，称为对象序列化(对象必须实现序列化接口)。</strong></li>\n<li>使用到的流是对象字节输出流:ObjectOutputStream</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/0f6dc6605311450d9e96a1cc42dea948.png#pic_center\"></p>\n<p>使用到的流是对象字节输出流:ObjectOutputStream</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">构造器</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public ObjectOutputstream(Outputstream out)</td>\n<td align=\"center\">把低级字节输出流包装成高级的对象字节输出流</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>ObjectOutputStream序列化方法</strong></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">方法名称</td>\n<td align=\"center\">说明</td>\n</tr>\n<tr>\n<td align=\"center\">:-:</td>\n<td align=\"center\">:-:</td>\n</tr>\n<tr>\n<td align=\"center\">public final void writeObject(object obj)</td>\n<td align=\"center\">把对象写出去到对象序列化流的文件中去</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">import java.io.Serializable;\n\n/**\n  对象如果要序列化，必须实现Serializable序列化接口。\n */\npublic class Student implements Serializable &#123;\n    // 申明序列化的版本号码\n    // 序列化的版本号与反序列化的版本号必须一致才不会出错！\n    private static final long serialVersionUID = 1;\n    private String name;\n    private String loginName;\n    // transient修饰的成员变量不参与序列化了\n    private transient String passWord;\n    private int age ;\n\n    public Student()&#123;\n    &#125;\n\n    public Student(String name, String loginName, String passWord, int age) &#123;\n        this.name = name;\n        this.loginName = loginName;\n        this.passWord = passWord;\n        this.age = age;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public String getLoginName() &#123;\n        return loginName;\n    &#125;\n\n    public void setLoginName(String loginName) &#123;\n        this.loginName = loginName;\n    &#125;\n\n    public String getPassWord() &#123;\n        return passWord;\n    &#125;\n\n    public void setPassWord(String passWord) &#123;\n        this.passWord = passWord;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Student&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, loginName=&#39;&quot; + loginName + &#39;\\&#39;&#39; +\n                &quot;, passWord=&#39;&quot; + passWord + &#39;\\&#39;&#39; +\n                &quot;, age=&quot; + age +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">import java.io.FileOutputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.PrintStream;\n\npublic class ObjectOutputStreamDemo &#123;\n    public static void main(String[] args) throws Exception &#123;\n        // 1、创建学生对象\n        Student s = new Student(&quot;陈磊&quot;, &quot;chenlei&quot;,&quot;1314520&quot;, 21);\n\n        // 2、对象序列化：使用对象字节输出流包装字节输出流管道\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;io-app2/src/obj.txt&quot;));\n\n        // 3、直接调用序列化方法\n        oos.writeObject(s);\n\n        // 4、释放资源\n        oos.close();\n        System.out.println(&quot;序列化完成了~~&quot;);\n\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"3-2对象反序列化\"><a href=\"#3-2对象反序列化\" class=\"headerlink\" title=\"3.2对象反序列化\"></a>3.2对象反序列化</h2><p>对象反序列化:</p>\n<ul>\n<li>使用到的流是对象字节输入流:ObjectlnputStream</li>\n<li><strong>作用:以内存为基准，把存储到磁盘文件中去的对象数据恢复成内存中的对象，称为对象反序列化。</strong><br><img src=\"https://img-blog.csdnimg.cn/d6caa7b7ccfb4e67bce2fa393323d5b8.png#pic_center\"></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">构造器</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public objectInputstream(Inputstream out)</td>\n<td align=\"center\">把低级字节输如流包装成高级的对象字节输入流</td>\n</tr>\n</tbody></table>\n<p><strong>objectInputStream序列化方法</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public Obiect readObiect()</td>\n<td align=\"center\">把存储到磁盘文件中去的对象数据恢复成内存中的对象返回</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">import java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.ObjectInputStream;\n\n/**\n    目标：学会进行对象反序列化：使用对象字节输入流把文件中的对象数据恢复成内存中的Java对象。\n */\npublic class ObjectInputStreamDemo &#123;\n    public static void main(String[] args) throws Exception &#123;\n        // 1、创建对象字节输入流管道包装低级的字节输入流管道\n        ObjectInputStream is = new ObjectInputStream(new FileInputStream(&quot;io-app2/src/obj.txt&quot;));\n\n        // 2、调用对象字节输入流的反序列化方法\n        Student s = (Student) is.readObject();\n\n        System.out.println(s);\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h1 id=\"4、打印流\"><a href=\"#4、打印流\" class=\"headerlink\" title=\"4、打印流\"></a>4、打印流</h1><h2 id=\"4-1-PrintStream、PrintWriter\"><a href=\"#4-1-PrintStream、PrintWriter\" class=\"headerlink\" title=\"4.1 PrintStream、PrintWriter\"></a>4.1 PrintStream、PrintWriter</h2><p><img src=\"https://img-blog.csdnimg.cn/e9775321b6084fb588cfd52d2ffcc9a7.png#pic_center\"></p>\n<p>打印流</p>\n<ul>\n<li>作用: &#x3D;&#x3D;打印流可以实现方便、高效的打印数据到文件中去。&#x3D;&#x3D; 打印流一般是指: PrintStream，PrintWriter两个类。</li>\n<li>可以实现打印什么数据就是什么数据，例如打印整数97写出去就是97，打印boolean的true，写出去就是true。</li>\n</ul>\n<p><strong>PrintStream</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">构造器</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public PrintStream(OutputStream os)</td>\n<td align=\"center\">打印流直接通向字节输出流管道</td>\n</tr>\n<tr>\n<td align=\"center\">public printStream(File f)</td>\n<td align=\"center\">打印流直接通向文件对象</td>\n</tr>\n<tr>\n<td align=\"center\">public PrintStream(String filepath)</td>\n<td align=\"center\">打印流直接通向文件路径</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public void print(Xxx xx)</td>\n<td align=\"center\">打印任意类型的数据出去</td>\n</tr>\n</tbody></table>\n<p><strong>PrintWriter</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">构造器</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public Printwriter(OutputStream os)</td>\n<td align=\"center\">打印流直接通向字节输出流管道</td>\n</tr>\n<tr>\n<td align=\"center\">public printwriter (Writer w)</td>\n<td align=\"center\">打印流直接通向字符输出流管道</td>\n</tr>\n<tr>\n<td align=\"center\">public Printwriter (File f)</td>\n<td align=\"center\">打印流直接通向文件对象</td>\n</tr>\n<tr>\n<td align=\"center\">public Printwriter (String filepath)</td>\n<td align=\"center\">打印流直接通向文件路径</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public void print(Xxx xx)</td>\n<td align=\"center\">打印任意类型的数据出去</td>\n</tr>\n</tbody></table>\n<p><strong>PrintStream和PrintWriter的区别</strong></p>\n<ul>\n<li>打印数据功能上是一模一样的，都是使用方便，性能高效（核心优势)</li>\n<li>PrintStream继承自字节输出流OutputStream，支持写字节数据的方法。</li>\n<li>PrintWriter继承自字符输出流Writer，支持写字符数据出去。</li>\n</ul>\n<pre><code class=\"java\">import java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\n\n/**\n    学会使用打印流 高效  方便写数据到文件。\n */\npublic class PrintDemo &#123;\n    public static void main(String[] args) throws Exception &#123;\n        PrintWriter ps = new PrintWriter(&quot;io-app2/src/ps.txt&quot;); // 打印功能上与PrintStream的使用没有区别\n\n        ps.println(97);\n        ps.println(&#39;a&#39;);\n        ps.println(23.3);\n        ps.println(true);\n        ps.println(&quot;我是打印流输出的，我是啥就打印啥&quot;);\n\n        ps.close();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"4-2-输出语句的重定向\"><a href=\"#4-2-输出语句的重定向\" class=\"headerlink\" title=\"4.2 输出语句的重定向\"></a>4.2 输出语句的重定向</h2><p><strong>属于打印流的一种应用，可以把输出语句的打印位置改到文件。</strong></p>\n<pre><code class=\"java\">import java.io.FileOutputStream;\nimport java.io.PrintStream;\n\n/**\n    目标：了解改变输出语句的位置到文件\n */\npublic class PrintDemo2 &#123;\n    public static void main(String[] args) throws Exception &#123;\n        System.out.println(&quot;锦瑟无端五十弦&quot;);\n        System.out.println(&quot;一弦一柱思华年&quot;);\n\n        // 改变输出语句的位置（重定向）\n        PrintStream ps = new PrintStream(&quot;io-app2/src/log.txt&quot;);\n        System.setOut(ps); // 把系统打印流改成我们自己的打印流\n\n        System.out.println(&quot;庄生晓梦迷蝴蝶&quot;);\n        System.out.println(&quot;望帝春心托杜鹃&quot;);\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h1 id=\"5、Properties\"><a href=\"#5、Properties\" class=\"headerlink\" title=\"5、Properties\"></a>5、Properties</h1><p><img src=\"https://img-blog.csdnimg.cn/5803eb78fd184218add730201799e497.png#pic_center\"></p>\n<p><strong>Properties属性集对象</strong></p>\n<ul>\n<li>其实就是一个Map集合，但是我们一般不会当集合使用，因为HashMap更好用。</li>\n</ul>\n<p><strong>Properties核心作用:</strong></p>\n<ul>\n<li>Properties代表的是一个属性文件，可以把自己对象中的键值对信息存入到一个属性文件中去。</li>\n<li>属性文件:后缀是.properties结尾的文件,里面的内容都是key&#x3D;value，后续做系统配置信息的。</li>\n</ul>\n<p>Properties的API:</p>\n<p>Properties和IO流结合的方法:</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">构造器</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">void load(InputStream inStream)</td>\n<td align=\"center\">从输入字节流读取属性列表(键和元素对)</td>\n</tr>\n<tr>\n<td align=\"center\">void load(Reader reader)</td>\n<td align=\"center\">从输入字符流读取属性列表（键和元素对)</td>\n</tr>\n<tr>\n<td align=\"center\">void store(OutputStream out，String comments)</td>\n<td align=\"center\">将此属性列表（键和元素对)写入此 Properties表中，以适合于使用load(InputStream)</td>\n</tr>\n<tr>\n<td align=\"center\">void store(Writer writer,String comments)</td>\n<td align=\"center\">将此属性列表（键和元素对)写入此 Properties表中以适合使用load(Reader)方法的格式写入输出字符流</td>\n</tr>\n<tr>\n<td align=\"center\">public object setProperty(String key，String value)</td>\n<td align=\"center\">保存键值对(put)</td>\n</tr>\n<tr>\n<td align=\"center\">public object setProperty(String key)</td>\n<td align=\"center\">使用此属性列表中指定的键搜索属性值(get)</td>\n</tr>\n<tr>\n<td align=\"center\">public Set&lt; string &gt; stringPropertyNames()</td>\n<td align=\"center\">所有键的名称的集合(keySet())</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">import java.io.FileWriter;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Scanner;\n\n\npublic class PropertiesDemo &#123;\n    public static void main(String[] args) throws Exception &#123;\n        // 需求：使用Properties把键值对信息存入到属性文件中去。\n        Properties properties = new Properties();\n        properties.setProperty(&quot;admin&quot;, &quot;123456&quot;);\n        properties.setProperty(&quot;dlei&quot;, &quot;003197&quot;);\n        properties.setProperty(&quot;heima&quot;, &quot;itcast&quot;);\n        System.out.println(properties);\n\n        /**\n           参数一：保存管道 字符输出流管道\n           参数二：保存心得\n         */\n        properties.store(new FileWriter(&quot;io-app2/src/users.properties&quot;)\n                , &quot;this is users!! i am very happy! give me 100!&quot;);\n\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h1 id=\"6、IO框架\"><a href=\"#6、IO框架\" class=\"headerlink\" title=\"6、IO框架\"></a>6、IO框架</h1><p><strong>commons-io概述</strong></p>\n<ul>\n<li>commons-io是apache开源基金组织提供的一组有关IO操作的类库，可以提高IO功能开发的效率。</li>\n<li>commons-io工具包提供了很多有关io操作的类。有两个主要的类FileUtils, IOUtils</li>\n</ul>\n<p><strong>FileUtils主要有如下方法:</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">String readFileToString(File file，string encoding)</td>\n<td align=\"center\">读取文件中的数据,返回字符串。</td>\n</tr>\n<tr>\n<td align=\"center\">void copyFile(File srcFile，File destFile)</td>\n<td align=\"center\">复制文件。</td>\n</tr>\n<tr>\n<td align=\"center\">void copyDirectoryToDirectory(File srcDir，File destDir)</td>\n<td align=\"center\">复制文件夹。</td>\n</tr>\n</tbody></table>\n<hr>\n","feature":true,"text":"缓冲流、转换流、序列化对象和打印流是Java中常用的IO操作工具。缓冲流可以提高读写效率，通过一次读写多个字节来减少IO次数。转换流用于字符流和字节流之间的相互转换，方便处理不同类型的数据。序列化对象允许将对象转换为字节序列，以便于数据的存储和传输。打印流则是一种方便输出格式化数据的工具，可用于生成可读性强的输出。...","permalink":"/post/Java程序设计 -- 输入输出流（下）（十七）","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"12 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1%E3%80%81%E7%BC%93%E5%86%B2%E6%B5%81\"><span class=\"toc-text\">1、缓冲流</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E7%BC%93%E5%86%B2%E6%B5%81%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1.1 缓冲流概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81\"><span class=\"toc-text\">1.2 字节缓冲流</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1.3 字符缓冲流概述</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2%E3%80%81%E8%BD%AC%E6%8D%A2%E6%B5%81\"><span class=\"toc-text\">2、转换流</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E8%BD%AC%E6%8D%A2%E6%B5%81\"><span class=\"toc-text\">2.1 字符输入转换流</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E8%BD%AC%E6%8D%A2%E6%B5%81\"><span class=\"toc-text\">2.2 字符输出转换流</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">3、序列化对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96\"><span class=\"toc-text\">3.1 对象序列化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2%E5%AF%B9%E8%B1%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96\"><span class=\"toc-text\">3.2对象反序列化</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4%E3%80%81%E6%89%93%E5%8D%B0%E6%B5%81\"><span class=\"toc-text\">4、打印流</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-PrintStream%E3%80%81PrintWriter\"><span class=\"toc-text\">4.1 PrintStream、PrintWriter</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2-%E8%BE%93%E5%87%BA%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91\"><span class=\"toc-text\">4.2 输出语句的重定向</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5%E3%80%81Properties\"><span class=\"toc-text\">5、Properties</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#6%E3%80%81IO%E6%A1%86%E6%9E%B6\"><span class=\"toc-text\">6、IO框架</span></a></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Java程序设计--多线程","uid":"4efd1e259b597b69971ef5e65a102b02","slug":"Java程序设计 -- 多线程基础（十八）","date":"2022-04-12T14:02:36.000Z","updated":"2025-07-14T15:12:20.459Z","comments":true,"path":"api/articles/Java程序设计 -- 多线程基础（十八）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","text":"多线程编程允许程序同时执行多个任务，提高系统利用率。线程池则管理和复用线程，降低线程创建和销毁的开销。线程通信是多线程间交换信息和协调工作的机制。合理运用多线程和线程池可以提升程序性能，而线程通信则能确保线程之间的协调和同步。这些技术在并发编程中起着重要作用，对于提升系统的效率和响应能力至关重要。...","permalink":"/post/Java程序设计 -- 多线程基础（十八）","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true},"next_post":{"title":"Java程序设计--输入输出流(上)","uid":"b7639bc085f01665e0869b23fc927b0f","slug":"Java程序设计 -- 输入输出流（上）（十六）","date":"2022-04-02T01:35:33.000Z","updated":"2025-07-14T15:12:20.461Z","comments":true,"path":"api/articles/Java程序设计 -- 输入输出流（上）（十六）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","text":"字符集是一种用于表示字符编码的标准，它定义了字符与二进制数据之间的映射关系。在IO流操作中，字节流是处理二进制数据的基本流类型，它以字节为单位进行读写操作。通过合理选择字符集和使用字节流，我们可以实现字符和字节之间的转换，有效地处理文本和二进制数据的输入输出。...","permalink":"/post/Java程序设计 -- 输入输出流（上）（十六）","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true}}