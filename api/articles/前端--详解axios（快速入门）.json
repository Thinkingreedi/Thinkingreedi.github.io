{"title":"Axios进阶指南：构建可靠的前端网络请求","uid":"ccba9309aa28da995832d41b5289f1c2","slug":"前端--详解axios（快速入门）","date":"2023-01-31T01:25:07.000Z","updated":"2025-07-14T15:12:20.467Z","comments":true,"path":"api/articles/前端--详解axios（快速入门）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/a9b45d876424411993cb1ae4218a5f93.jpeg","content":"<h1 id=\"Axios\"><a href=\"#Axios\" class=\"headerlink\" title=\"Axios\"></a>Axios</h1><h2 id=\"1、Axios的理解和使用\"><a href=\"#1、Axios的理解和使用\" class=\"headerlink\" title=\"1、Axios的理解和使用\"></a>1、Axios的理解和使用</h2><h3 id=\"1-1-Axios概述\"><a href=\"#1-1-Axios概述\" class=\"headerlink\" title=\"1.1 Axios概述\"></a>1.1 Axios概述</h3><ol>\n<li><p>前端最流行的ajax请求库</p>\n</li>\n<li><p>react&#x2F;vue官方都推荐使用axios 发ajax 请求 </p>\n</li>\n<li><p><strong>文档:</strong> <a href=\"https://github.com/axios/axios\">https://github.com/axios/axios</a></p>\n</li>\n<li><p>axios中文网：<a href=\"http://www.axios-js.com/\">axios中文网|axios API 中文文档 | axios (axios-js.com)</a></p>\n</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/2adafdd0431e4173b25a9aa62e43fa90.png#pic_center\"></p>\n<h3 id=\"1-2-Axios特点\"><a href=\"#1-2-Axios特点\" class=\"headerlink\" title=\"1.2 Axios特点\"></a>1.2 Axios特点</h3><ol>\n<li>基于xhr + promise的异步ajax请求库</li>\n<li>浏览器端&#x2F;node端都可以使用</li>\n<li>支持请求&#x2F;响应拦截器</li>\n<li>支持请求取消</li>\n<li>请求&#x2F;响应数据转换</li>\n<li>批量发送多个请求</li>\n</ol>\n<h3 id=\"1-3-Axios常用语法\"><a href=\"#1-3-Axios常用语法\" class=\"headerlink\" title=\"1.3 Axios常用语法\"></a>1.3 Axios常用语法</h3><ul>\n<li>axios(config):通用&#x2F;最本质的发任意类型请求的方式</li>\n<li>axios(url[, config]):可以只指定url发get 请求</li>\n<li>axios.request(config):等同于axios(config)</li>\n<li>axios.get(url[, config]):发get请求</li>\n<li>axios.delete(url[, config]):发delete请求</li>\n<li>axios.post(url[, data, config]):发post请求</li>\n<li>axios.put(url[, data, configl):发put 请求</li>\n<li>axios.defaults.xxx:请求的默认全局配置</li>\n<li>axios.interceptors.request.use():添加请求拦截器</li>\n<li>axios.interceptors.response.use():添加响应拦截器</li>\n<li>axios.create([config]):创建一个新的axios(它没有下面的功能)</li>\n<li>axios.Cancel():用于创建取消请求的错误对象</li>\n<li>axios.CancelToken():用于创建取消请求的token对象</li>\n<li>axios.isCancel():是否是一个取消请求的错误</li>\n<li>axios.all(promises):用于批量执行多个异步请求</li>\n<li>axios.spread():用来指定接收所有成功数据的回调函数的方法</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/5ec0d6b391d9486eb0b52cb41a3b925f.png#pic_center\"></p>\n<ul>\n<li>axios基本使用</li>\n</ul>\n<pre><code class=\"js\">    //获取按钮\n    const btns = document.querySelectorAll(&#39;button&#39;);\n\n    //第一个\n    btns[0].onclick = function () &#123;\n        //发送 AJAX 请求\n        axios(&#123;\n            //请求类型\n            method: &#39;GET&#39;,\n            //URL\n            url: &#39;http://localhost:3000/posts/2&#39;,\n        &#125;).then(response =&gt; &#123;\n            console.log(response);\n        &#125;);\n    &#125;\n\n    //添加一篇新的文章\n    btns[1].onclick = function () &#123;\n        //发送 AJAX 请求\n        axios(&#123;\n            //请求类型\n            method: &#39;POST&#39;,\n            //URL\n            url: &#39;http://localhost:3000/posts&#39;,\n            //设置请求体\n            data: &#123;\n                title: &quot;今天天气不错, 还挺风和日丽的&quot;,\n                author: &quot;张三&quot;\n            &#125;\n        &#125;).then(response =&gt; &#123;\n            console.log(response);\n        &#125;);\n    &#125;\n\n    //更新数据\n    btns[2].onclick = function () &#123;\n        //发送 AJAX 请求\n        axios(&#123;\n            //请求类型\n            method: &#39;PUT&#39;,\n            //URL\n            url: &#39;http://localhost:3000/posts/3&#39;,\n            //设置请求体\n            data: &#123;\n                title: &quot;今天天气不错, 还挺风和日丽的&quot;,\n                author: &quot;李四&quot;\n            &#125;\n        &#125;).then(response =&gt; &#123;\n            console.log(response);\n        &#125;);\n    &#125;\n\n    //删除数据\n    btns[3].onclick = function () &#123;\n        //发送 AJAX 请求\n        axios(&#123;\n            //请求类型\n            method: &#39;delete&#39;,\n            //URL\n            url: &#39;http://localhost:3000/posts/3&#39;,\n        &#125;).then(response =&gt; &#123;\n            console.log(response);\n        &#125;);\n    &#125;\n</code></pre>\n<ul>\n<li>axios其他使用</li>\n</ul>\n<pre><code class=\"js\">//获取按钮\n    const btns = document.querySelectorAll(&#39;button&#39;);\n\n    //发送 GET 请求\n    btns[0].onclick = function () &#123;\n        // axios()\n        axios.request(&#123;\n            method: &#39;GET&#39;,\n            url: &#39;http://localhost:3000/comments&#39;\n        &#125;).then(response =&gt; &#123;\n            console.log(response);\n        &#125;)\n    &#125;\n\n    //发送 POST 请求\n    btns[1].onclick = function () &#123;\n        // axios()\n        axios.post(\n            &#39;http://localhost:3000/comments&#39;,\n            &#123;\n                &quot;body&quot;: &quot;喜大普奔&quot;,\n                &quot;postId&quot;: 2\n            &#125;).then(response =&gt; &#123;\n                console.log(response);\n            &#125;)\n    &#125;\n</code></pre>\n<ul>\n<li>axios默认配置</li>\n</ul>\n<pre><code class=\"js\">    //获取按钮\n    const btns = document.querySelectorAll(&#39;button&#39;);\n    //默认配置\n    axios.defaults.method = &#39;GET&#39;;//设置默认的请求类型为 GET\n    axios.defaults.baseURL = &#39;http://localhost:3000&#39;;//设置基础 URL\n    axios.defaults.params = &#123; id: 100 &#125;;\n    axios.defaults.timeout = 3000;//\n\n    btns[0].onclick = function () &#123;\n        axios(&#123;\n            url: &#39;/posts&#39;\n        &#125;).then(response =&gt; &#123;\n            console.log(response);\n        &#125;)\n    &#125;\n</code></pre>\n<h3 id=\"1-4-难点语法的理解和使用\"><a href=\"#1-4-难点语法的理解和使用\" class=\"headerlink\" title=\"1.4 难点语法的理解和使用\"></a>1.4 难点语法的理解和使用</h3><p> <strong>axios.create(config)</strong></p>\n<ol>\n<li>根据指定配置创建一个新的axios，也就是每个新axios都有自己的配置</li>\n<li>新axios 只是没有取消请求和批量发请求的方法，其它所有语法都是一致的</li>\n<li>为什么要设计这个语法?<br>(1)需求:项目中有部分接口需要的配置与另一部分接口需要的配置不太一<br>样，如何处理<br>(2)解决:创建2个新axios，每个都有自己特有的配置，分别应用到不同要<br>求的接口请求中</li>\n</ol>\n<p><strong>拦截器函数&#x2F;ajax请求&#x2F;请求的回调函数的调用顺序</strong></p>\n<ol>\n<li>说明:调用axios()并不是立即发送ajax请求，而是需要经历一个较长的流程</li>\n<li>流程:请求拦截器2&#x3D;&gt;请求拦截器1&#x3D;&gt;发ajax请求&#x3D;&gt;响应拦截器1&#x3D;&gt;响<br>应拦截器2&#x3D;&gt;请求的回调  <strong>(unshift,push)</strong></li>\n<li>注意:此流程是通过promise串连起来的，请求拦截器传递的是config，响应<br>拦截器传递的是response</li>\n</ol>\n<ul>\n<li>代码：</li>\n</ul>\n<pre><code class=\"js\">    // Promise\n    // 设置请求拦截器  config 配置对象\n    axios.interceptors.request.use(function (config) &#123;\n        console.log(&#39;请求拦截器 成功 - 1号&#39;);\n        //修改 config 中的参数\n        config.params = &#123; a: 100 &#125;;\n\n        return config;\n    &#125;, function (error) &#123;\n        console.log(&#39;请求拦截器 失败 - 1号&#39;);\n        return Promise.reject(error);\n    &#125;);\n\n    axios.interceptors.request.use(function (config) &#123;\n        console.log(&#39;请求拦截器 成功 - 2号&#39;);\n        //修改 config 中的参数\n        config.timeout = 2000;\n        return config;\n    &#125;, function (error) &#123;\n        console.log(&#39;请求拦截器 失败 - 2号&#39;);\n        return Promise.reject(error);\n    &#125;);\n\n    // 设置响应拦截器\n    axios.interceptors.response.use(function (response) &#123;\n        console.log(&#39;响应拦截器 成功 1号&#39;);\n        return response.data;\n        // return response;\n    &#125;, function (error) &#123;\n        console.log(&#39;响应拦截器 失败 1号&#39;)\n        return Promise.reject(error);\n    &#125;);\n\n    axios.interceptors.response.use(function (response) &#123;\n        console.log(&#39;响应拦截器 成功 2号&#39;)\n        return response;\n    &#125;, function (error) &#123;\n        console.log(&#39;响应拦截器 失败 2号&#39;)\n        return Promise.reject(error);\n    &#125;);\n\n    //发送请求\n    axios(&#123;\n        method: &#39;GET&#39;,\n        url: &#39;http://localhost:3000/posts&#39;\n    &#125;).then(response =&gt; &#123;\n        console.log(&#39;自定义回调处理成功的结果&#39;);\n        console.log(response);\n    &#125;);\n</code></pre>\n<p><strong>取消请求</strong></p>\n<ol>\n<li>基本流程<br>配置cancelToken对象<br>缓存用于取消请求的cancel函数<br>在后面特定时机调用cancel函数取消请求<br>在错误回调中判断如果error是cancel，做相应处理</li>\n<li>实现功能<br>点击按钮，取消某个正在请求中的请求</li>\n</ol>\n<ul>\n<li>代码：</li>\n</ul>\n<pre><code class=\"js\">    //获取按钮\n    const btns = document.querySelectorAll(&#39;button&#39;);\n    //2.声明全局变量\n    let cancel = null;\n    //发送请求\n    btns[0].onclick = function () &#123;\n        //检测上一次的请求是否已经完成\n        if (cancel !== null) &#123;\n            //取消上一次的请求\n            cancel();\n        &#125;\n        axios(&#123;\n            method: &#39;GET&#39;,\n            url: &#39;http://localhost:3000/posts&#39;,\n            //1. 添加配置对象的属性\n            cancelToken: new axios.CancelToken(function (c) &#123;\n                //3. 将 c 的值赋值给 cancel\n                cancel = c;\n            &#125;)\n        &#125;).then(response =&gt; &#123;\n            console.log(response);\n            //将 cancel 的值初始化\n            cancel = null;\n        &#125;)\n    &#125;\n\n    //绑定第二个事件取消请求\n    btns[1].onclick = function () &#123;\n        cancel();\n    &#125;\n</code></pre>\n<h2 id=\"2、Axios源码分析\"><a href=\"#2、Axios源码分析\" class=\"headerlink\" title=\"2、Axios源码分析\"></a>2、Axios源码分析</h2><h3 id=\"2-1-源码目录结构\"><a href=\"#2-1-源码目录结构\" class=\"headerlink\" title=\"2.1 源码目录结构\"></a>2.1 源码目录结构</h3><p><img src=\"https://img-blog.csdnimg.cn/012dc3125db54ac89c62f3eefad5bd8f.png#pic_center\"></p>\n<h3 id=\"2-2-源码分析\"><a href=\"#2-2-源码分析\" class=\"headerlink\" title=\"2.2 源码分析\"></a>2.2 源码分析</h3><p><strong>axios 与Axios的关系</strong></p>\n<ol>\n<li>从语法上来说: axios不是Axios 的实例  <strong>(对象，函数，实例对象的方法添加到函数身上)</strong></li>\n<li>从功能上来说: axios是Axios的实例   <strong>(拥有实例对象上的方法)</strong></li>\n<li>axios是Axios.prototype.request 函数bind()返回的函数</li>\n<li>axios作为对象有Axios原型对象上的所有方法，有Axios对象上所有属性</li>\n</ol>\n<p><strong>instance 与axios的区别</strong></p>\n<ol>\n<li><p>相同:<br>(1都是一个能发任意请求的函数: request(config)</p>\n<p>(2)都有发特定请求的各种方法:get()&#x2F;post()&#x2F;put()&#x2F;delete()</p>\n<p>(3)都有默认配置和拦截器的属性: defaults&#x2F;interceptors</p>\n</li>\n<li><p>不同:</p>\n<p>(1)默认配置很可能不一样</p>\n<p>(2)instance没有axios后面添加的一些方法: create()&#x2F;CancelToken()&#x2F;all()</p>\n</li>\n</ol>\n<p><strong>axios运行的整体流程</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/042b6292616349c584af2e0543d61540.png#pic_center\"></p>\n<ol>\n<li><p>整体流程:<br>request(config) &#x3D;&#x3D;&gt; dispatchRequest(config)  &#x3D;&#x3D;&gt; xhrAdapter(config)</p>\n</li>\n<li><p>request(config):<br>将请求拦截器&#x2F; dispatchRequest()&#x2F;响应拦截器通过promise链串连起来，返回promise</p>\n</li>\n<li><p>dispatchRequest(config):<br>转换请求数据&#x3D;&#x3D; &#x3D;&gt;调用xhrAdapter()发请求 &#x3D;&#x3D;&#x3D;&gt;请求返回后转换响应数据.返回 promise</p>\n</li>\n<li><p>xhrAdapter(config):<br>创建XHR对象，根据config进行相应设置，发送特定请求，并接收响应数据，返回promise</p>\n</li>\n</ol>\n<p><strong>axios的请求&#x2F;响应拦截器是什么</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/6489a46d7e1a4709870445a164ed0d03.png#pic_center\"></p>\n<ol>\n<li>请求拦截器:<ul>\n<li>在真正发送请求前执行的回调函数</li>\n<li>可以对请求进行检查或配置进行特定处理</li>\n<li>成功的回调函数，传递的默认是config(也必须是)</li>\n<li>失败的回调函数，传递的默认是error</li>\n</ul>\n</li>\n<li>响应拦截器<ul>\n<li>在请求得到响应后执行的回调函数</li>\n<li>可以对响应数据进行特定处理</li>\n<li>成功的回调函数，传递的默认是response</li>\n<li>失败的回调函数，传递的默认是error</li>\n</ul>\n</li>\n</ol>\n<p><strong>axios的请求&#x2F;响应数据转换器是什么</strong></p>\n<ol>\n<li>请求转换器:对请求头和请求体数据进行特定处理的函数<br>if (utils.isObject(data)) {<br>setContentTypelfUnset(headers, ‘application&#x2F;json;charset&#x3D;utf-8’);<br>return JSON.stringify(data);<br>}</li>\n<li>响应转换器:将响应体json字符串解析为js对象或数组的函数<br>response.data &#x3D; JSON.parse(response.data)</li>\n</ol>\n<p><strong>response的整体结构</strong><br>{<br>data,</p>\n<p>status,</p>\n<p>statusText,</p>\n<p>headers,</p>\n<p>config,</p>\n<p>request<br>}</p>\n<p><strong>error的整体结构</strong><br>{<br>message,</p>\n<p>response,<br>request,<br>}</p>\n<p><strong>如何取消未完成的请求</strong></p>\n<ol>\n<li><p>当配置了cancelToken对象时，保存cancel函数</p>\n<p>(1创建一个用于将来中断请求的cancelPromise</p>\n<p>(2)并定义了一个用于取消请求的cancel函数</p>\n<p>(3)将cancel函数传递出来</p>\n</li>\n<li><p>调用cancel()取消请求</p>\n<p>(1)执行cacel 函数，传入错误信息message</p>\n<p>(2)内部会让cancelPromise变为成功，且成功的值为一个Cancel对象</p>\n<p>(3)在cancelPromise 的成功回调中中断请求，并让发请求的 proimse失败，<br>失败的reason为 Cancel对象</p>\n</li>\n</ol>\n","feature":true,"text":"Axios是一种基于Promise的HTTP客户端，主要用于在前端开发中进行网络请求。它提供了简洁、直观的API接口，支持异步请求、拦截器、取消请求等功能。通过使用Axios，前端开发者可以轻松地与后端进行数据交互，获取和发送数据。...","permalink":"/post/前端--详解axios（快速入门）","photos":[],"count_time":{"symbolsCount":"8.5k","symbolsTime":"8 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"Axios","slug":"Axios","count":1,"path":"api/tags/Axios.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Axios\"><span class=\"toc-text\">Axios</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1%E3%80%81Axios%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">1、Axios的理解和使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-Axios%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1.1 Axios概述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-Axios%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">1.2 Axios特点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-Axios%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">1.3 Axios常用语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-%E9%9A%BE%E7%82%B9%E8%AF%AD%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">1.4 难点语法的理解和使用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2%E3%80%81Axios%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\"><span class=\"toc-text\">2、Axios源码分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">2.1 源码目录结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\"><span class=\"toc-text\">2.2 源码分析</span></a></li></ol></li></ol></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"计算机网络概述","uid":"42ad5343960ce09baf2db672de3117be","slug":"计算机网络基础知识点","date":"2023-02-02T02:13:39.000Z","updated":"2025-07-14T15:12:20.470Z","comments":true,"path":"api/articles/计算机网络基础知识点.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/direct/4ec43504e6e445a5b4d30bd12fb42fa7.jpeg","text":"计算机网络基础知识包括IP地址、子网掩码、网关、DNS、HTTP等关键概念。IP地址是计算机在网络中的唯一标识，子网掩码用于划分网络和主机部分，网关连接不同网络，实现数据转发。DNS解析域名为IP地址，HTTP是应用层协议，用于传输和接收网页等资源。...","permalink":"/post/计算机网络基础知识点","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"计算机科学与技术","slug":"计算机科学与技术","count":6,"path":"api/categories/计算机科学与技术.json"}],"tags":[{"name":"计算机网络","slug":"计算机网络","count":1,"path":"api/tags/计算机网络.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true},"next_post":{"title":"从回调地狱到Promise天堂：前端异步革命","uid":"0da050a8ade26330ecd92d326adb320f","slug":"前端--Promise详解与手写实现","date":"2023-01-28T00:56:24.000Z","updated":"2025-07-14T15:12:20.464Z","comments":true,"path":"api/articles/前端--Promise详解与手写实现.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/direct/ea4f563866fc420facc03cf475d9ad7a.png","text":"在前端开发中，Promise是一种用于处理异步操作的对象，可简化回调函数嵌套，有效管理复杂的异步代码。通过Promise，可以更清晰地表达和处理异步操作的结果，避免回调地狱问题，提高代码的可读性和可维护性。...","permalink":"/post/前端--Promise详解与手写实现","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"Promise","slug":"Promise","count":1,"path":"api/tags/Promise.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true}}