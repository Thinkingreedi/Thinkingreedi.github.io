{"title":"Java程序设计--面向对象进阶(上)","uid":"85159c9648aa55d2d25caaf72205c399","slug":"Java程序设计 -- 面向对象进阶(上)（七）","date":"2022-03-20T01:40:03.000Z","updated":"2025-07-14T15:12:20.462Z","comments":true,"path":"api/articles/Java程序设计 -- 面向对象进阶(上)（七）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","content":"<hr>\n<h1 id=\"1、静态关键字–static\"><a href=\"#1、静态关键字–static\" class=\"headerlink\" title=\"1、静态关键字–static\"></a>1、静态关键字–static</h1><h2 id=\"1-1-static修饰成员变量的基本用法\"><a href=\"#1-1-static修饰成员变量的基本用法\" class=\"headerlink\" title=\"1.1 static修饰成员变量的基本用法\"></a>1.1 static修饰成员变量的基本用法</h2><p>sctatic是静态的意思，可以修饰成员变量和成员方法。</p>\n<p><strong>&#x3D;&#x3D;static修饰成员变量表示该成员变量只在内存中只存储一份，可以被共享访问、修改。&#x3D;&#x3D;</strong></p>\n<p><strong>静态成员变量</strong>(有static修饰，属于类，内存中加载一次)∶常表示如在线人数信息、等需要被共享的信息，可以被共享访问。</p>\n<pre><code class=\"java\">类名.静态成员变量(推荐)\n\n对象.静态成员变量(不推荐)\n</code></pre>\n<p><strong>实例成员变量</strong>（无static修饰，存在于每个对象中)︰常表示姓名name、年龄age、等属于每个对象的信息。</p>\n<pre><code class=\"java\">对象.实例成员变量\n</code></pre>\n<pre><code class=\"java\">public class User &#123;\n    // 在线人数信息：静态成员变量\n    public static int onLineNumber = 161;\n    // 实例成员变量\n    private String name;\n    private int age;\n\n    public static void main(String[] args) &#123;\n        // 1、类名.静态成员变量\n        User.onLineNumber++;\n        // 注意：同一个类中访问静态成员变量，类名可以省略不写\n        System.out.println(onLineNumber);\n\n        // 2、对象.实例成员变量\n        // System.out.println(name);\n        User u1 = new User();\n        u1.name = &quot;猪八戒&quot;;\n        u1.age = 36;\n        System.out.println(u1.name);\n        System.out.println(u1.age);\n        // 对象.静态成员变量(不推荐这样访问)\n        u1.onLineNumber++;\n\n        User u2 = new User();\n        u2.name = &quot;孙悟空&quot;;\n        u2.age = 38;\n        System.out.println(u2.name);\n        System.out.println(u2.age);\n        // 对象.静态成员变量(不推荐这样访问)\n        u2.onLineNumber++;\n\n        System.out.println(onLineNumber);\n\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"1-2-static修饰成员变量的内存原理\"><a href=\"#1-2-static修饰成员变量的内存原理\" class=\"headerlink\" title=\"1.2 static修饰成员变量的内存原理\"></a>1.2 static修饰成员变量的内存原理</h2><p><img src=\"https://img-blog.csdnimg.cn/94165753368641a79d1b22399c695a5a.png#pic_center\"></p>\n<h2 id=\"1-3-static修饰成员方法的基本用法\"><a href=\"#1-3-static修饰成员方法的基本用法\" class=\"headerlink\" title=\"1.3 static修饰成员方法的基本用法\"></a>1.3 static修饰成员方法的基本用法</h2><p>成员方法的分类:</p>\n<ul>\n<li><strong>静态成员方法</strong>（有static修饰，属于类)，建议用类名访问，也可以用对象访问。</li>\n<li><strong>实例成员方法</strong>（无static修饰，属于对象)，只能用对象触发访问。</li>\n</ul>\n<p>使用场景</p>\n<ul>\n<li>表示对象自己的行为的，且方法中需要访问实例成员的，则该方法必须申明成实例方法。</li>\n<li>如果该方法是以执行一个共用功能为目的，则可以申明成静态方法。</li>\n</ul>\n<pre><code class=\"java\">public class Student &#123;\n    private String name;\n    private int age;\n\n    /**\n        实例方法：无static修饰，属于对象的，通常表示对象自己的行为，可以访问对象的成员变量\n     */\n    public void study()&#123;\n        System.out.println(name + &quot;在好好学习，天天向上~~&quot;);\n    &#125;\n\n    /**\n        静态方法：有static修饰，属于类，可以被类和对象共享访问。\n     */\n    public static void getMax(int a, int b)&#123;\n        System.out.println(a &gt; b ? a : b);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        // 1、类名.静态方法\n        Student.getMax(10, 100);\n        // 注意：同一个类中访问静态成员 可以省略类名不写\n        getMax(200, 20);\n\n        // 2、对象.实例方法\n        // study(); // 报错的\n        Student s = new Student();\n        s.name = &quot;全蛋儿&quot;;\n        s.study();\n\n        // 3、对象.静态方法(不推荐)\n        s.getMax(300,20);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"1-4-static修饰成员方法的内存原理\"><a href=\"#1-4-static修饰成员方法的内存原理\" class=\"headerlink\" title=\"1.4 static修饰成员方法的内存原理\"></a>1.4 static修饰成员方法的内存原理</h2><p><img src=\"https://img-blog.csdnimg.cn/73363084218841b5ad9638497640b2b9.png#pic_center\"></p>\n<h2 id=\"1-5-static实际应用案例\"><a href=\"#1-5-static实际应用案例\" class=\"headerlink\" title=\"1.5 static实际应用案例\"></a>1.5 static实际应用案例</h2><p><strong>工具类中定义的都是一些静态方法，每个方法都是以完成一个共用的功能为目的。</strong></p>\n<p>工具类的好处</p>\n<ul>\n<li>调用方便</li>\n<li>提高了代码复用</li>\n</ul>\n<p>工具类的定义注意</p>\n<ul>\n<li>&#x3D;&#x3D;建议将工具类的构造器进行私有，工具类无需创建对象。&#x3D;&#x3D;</li>\n<li>&#x3D;&#x3D;里面都是静态方法，直接用类名访问即可。&#x3D;&#x3D;</li>\n</ul>\n<pre><code class=\"java\">public class ArrayUtils &#123;\n    /**\n       把它的构造器私有化\n     */\n    private ArrayUtils()&#123;\n    &#125;\n\n    /**\n       静态方法，工具方法\n     */\n    public static String toString(int[] arr)&#123;\n        if(arr != null )&#123;\n            String result = &quot;[&quot;;\n            for (int i = 0; i &lt; arr.length; i++) &#123;\n                result += (i == arr.length - 1 ? arr[i] : arr[i] + &quot;, &quot;);\n            &#125;\n            result += &quot;]&quot;;\n            return result;\n        &#125;else &#123;\n            return null;\n        &#125;\n    &#125;\n\n    /**\n     静态方法，工具方法\n     */\n    public static double getAverage(int[] arr)&#123;\n        // 总和  最大值 最小值\n        int max = arr[0];\n        int min = arr[0];\n        int sum = 0;\n        for (int i = 0; i &lt; arr.length; i++) &#123;\n            if(arr[i] &gt; max)&#123;\n                max = arr[i];\n            &#125;\n            if(arr[i] &lt; min)&#123;\n                min = arr[i];\n            &#125;\n            sum += arr[i];\n        &#125;\n        return (sum - max - min)*1.0 / (arr.length - 2);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Test &#123;\n    public static void main(String[] args) &#123;\n        int[] arr = &#123;10, 20, 30&#125;;\n        System.out.println(arr);\n        System.out.println(ArrayUtils.toString(arr));\n        System.out.println(ArrayUtils.getAverage(arr));\n\n        int[] arr1 = null;\n        System.out.println(ArrayUtils.toString(arr1));\n        int[] arr2 = &#123;&#125;;\n        System.out.println(ArrayUtils.toString(arr2));\n\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"1-6-static的注意事项\"><a href=\"#1-6-static的注意事项\" class=\"headerlink\" title=\"1.6 static的注意事项\"></a>1.6 static的注意事项</h2><ul>\n<li>&#x3D;&#x3D;静态方法只能访问静态的成员，不可以直接访问实例成员。&#x3D;&#x3D;</li>\n<li>&#x3D;&#x3D;实例方法可以访问静态的成员，也可以访问实例成员。&#x3D;&#x3D;</li>\n<li>&#x3D;&#x3D;静态方法中是不可以出现this关键字的。&#x3D;&#x3D;</li>\n</ul>\n<hr>\n<h1 id=\"2、static应用–代码块\"><a href=\"#2、static应用–代码块\" class=\"headerlink\" title=\"2、static应用–代码块\"></a>2、static应用–代码块</h1><p>代码块概述</p>\n<ul>\n<li>代码块是类的5大成分之一(成员变量、构造器，方法，代码块，内部类)，定义在类中方法外。</li>\n<li>在Java类下，使用{}括起来的代码被称为代码块。</li>\n</ul>\n<p>代码块分为</p>\n<ul>\n<li><strong>静态代码块:</strong><br> - 格式: static{}<br> - 特点:需要通过static关键字修饰，随着类的加载而加载，并且自动触发、只执行一次<br> - 使用场景:在类加载的时候做一些静态数据初始化的操作，以便后续使用。</li>\n</ul>\n<pre><code class=\"java\">public class TestDemo1 &#123;\n\n    public static String schoolName;\n\n    public static void main(String[] args) &#123;\n        // 目标：学习静态代码块的特点、基本作用\n        System.out.println(&quot;=========main方法被执行输出===========&quot;);\n        System.out.println(schoolName);\n    &#125;\n\n    /**\n     特点：与类一起加载，自动触发一次，优先执行\n     作用：可以在程序加载时进行静态数据的初始化操作（准备内容）\n     */\n    static&#123;\n        System.out.println(&quot;==静态代码块被触发执行==&quot;);\n        schoolName = &quot;河工大&quot;;\n    &#125;\n&#125;\n</code></pre>\n<ul>\n<li>构造代码块（了解，用的少):<br> - 格式:{}<br> - 特点:每次创建对象，调用构造器执行时，都会执行该代码块中的代码，并且在构造器执行前执行<br> - 使用场景:初始化实例资源。</li>\n</ul>\n<pre><code class=\"java\">public class TestDemo2 &#123;\n\n    private String name;\n\n    /**\n       属于对象的，与对象一起加载，自动触发执行。\n     */\n    &#123;\n        System.out.println(&quot;==构造代码块被触发执行一次==&quot;);\n        name = &quot;老王&quot;;\n    &#125;\n\n    public TestDemo2()&#123;\n        System.out.println(&quot;==构造器被触发执行==&quot;);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        // 目标：学习构造代码块的特点、基本作用\n        TestDemo2 t = new TestDemo2();\n        System.out.println(t.name);\n\n        TestDemo2 t1 = new TestDemo2();\n        System.out.println(t1.name);\n    &#125;\n\n&#125;\n</code></pre>\n<hr>\n<h1 id=\"3、static应用–单例设计模式\"><a href=\"#3、static应用–单例设计模式\" class=\"headerlink\" title=\"3、static应用–单例设计模式\"></a>3、static应用–单例设计模式</h1><h2 id=\"3-1-设计模式\"><a href=\"#3-1-设计模式\" class=\"headerlink\" title=\"3.1 设计模式\"></a>3.1 设计模式</h2><p>设计模式(Design pattern)：开发中经常遇到一些问题，一个问题通常有n种解法的，但其中肯定有一种解法是最优的，这个最优的解法被人总结出来了，称之为设计模式。<br>设计模式有20多种，对应20多种软件开发中会遇到的问题，学设计模式主要是学2点:</p>\n<ol>\n<li>这种模式用来解决什么问题。</li>\n<li>遇到这种问题了，该模式是怎么写的，他是如何解决这个问题的。</li>\n</ol>\n<p><strong>单例模式</strong></p>\n<p>可以保证系统中，应用该模式的这个类永远只有一个实例，即一个类永远只能创建一个对象。例如任务管理器对象我们只需要一个就可以解决问题了，这样可以节省内存空间。</p>\n<h2 id=\"3-2-饿汉单例设计模式\"><a href=\"#3-2-饿汉单例设计模式\" class=\"headerlink\" title=\"3.2 饿汉单例设计模式\"></a>3.2 饿汉单例设计模式</h2><p><strong>在用类获取对象的时候，对象已经提前为你创建好了。</strong></p>\n<p>设计步骤</p>\n<ul>\n<li>定义一个类，把构造器私有。</li>\n<li>定义一个静态变量存储一个对象。</li>\n</ul>\n<pre><code class=\"java\">/**\n    目标：学会使用饿汉单例模式设计单例类\n */\npublic class SingleInstance1 &#123;\n    /**\n       static修饰的成员变量，静态成员变量，加载一次，只有一份\n     */\n    // public static int onLineNumber = 21;\n    public static SingleInstance1 instance = new SingleInstance1();\n\n    /**\n        1、必须私有构造器：私有构造器对外不能被访问。\n     */\n    private SingleInstance1()&#123;\n    &#125;\n\n\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Test1 &#123;\n    public static void main(String[] args) &#123;\n//        SingleInstance1 s1 = new SingleInstance1();\n//        SingleInstance1 s2 = new SingleInstance1();\n//        SingleInstance1 s3 = new SingleInstance1();\n\n        SingleInstance1 s1 = SingleInstance1.instance;\n        SingleInstance1 s2 = SingleInstance1.instance;\n        SingleInstance1 s3 = SingleInstance1.instance;\n        System.out.println(s1);\n        System.out.println(s2);\n        System.out.println(s3);\n        System.out.println(s1 == s2);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"3-3-懒汉单例设计模式\"><a href=\"#3-3-懒汉单例设计模式\" class=\"headerlink\" title=\"3.3 懒汉单例设计模式\"></a>3.3 懒汉单例设计模式</h2><p><strong>在真正需要该对象的时候，才去创建一个对象（延迟加载对象）</strong></p>\n<p>设计步骤</p>\n<ul>\n<li>定义一个类，把构造器私有</li>\n<li>定义一个静态变量存储一个对象</li>\n<li>提供一个返回单例对象的方法</li>\n</ul>\n<pre><code class=\"java\">/**\n    目标：设计懒汉单例\n */\npublic class SingleInstance2 &#123;\n    /**\n       2、定义一个静态的成员变量用于存储一个对象，一开始不要初始化对象，因为人家是懒汉\n     */\n    private static SingleInstance2 instance;\n\n    /**\n       1、私有构造器啊\n     */\n    private SingleInstance2()&#123;\n    &#125;\n\n    /**\n      3、提供一个方法暴露，真正调用这个方法的时候才创建一个单例对象\n     */\n    public static SingleInstance2 getInstance()&#123;\n        if(instance == null)&#123;\n            // 第一次来拿对象，为他做一个对象\n            instance = new SingleInstance2();\n        &#125;\n        return instance;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Test2 &#123;\n    public static void main(String[] args) &#123;\n        // 得到一个对象\n        SingleInstance2 s1 = SingleInstance2.getInstance();\n        SingleInstance2 s2 = SingleInstance2.getInstance();\n\n        System.out.println(s1 == s2);\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h1 id=\"4、面向对象特征–继承\"><a href=\"#4、面向对象特征–继承\" class=\"headerlink\" title=\"4、面向对象特征–继承\"></a>4、面向对象特征–继承</h1><h2 id=\"4-1-继承\"><a href=\"#4-1-继承\" class=\"headerlink\" title=\"4.1 继承\"></a>4.1 继承</h2><p>Java中提供一个关键字extends，用这个关键字，我们可以让一个类和另一个类建立起父子关系。</p>\n<pre><code class=\"java\">public class 子类 extends 父类 &#123;\n&#125;\n</code></pre>\n<p>使用继承的好处：</p>\n<p>当子类继承父类后，就可以直接使用父类公共的属性和方法了。因此，用好这个技术可以很好的我们提高代码的复用性</p>\n<pre><code class=\"java\">public class People &#123;\n    private String name;\n    private int age;\n\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Student extends People&#123;\n    /**\n       独有的行为\n     */\n    public void study()&#123;\n        System.out.println(getName() + &quot;学生开始学习~~~~~&quot;);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Teacher extends People&#123;\n    /**\n       独有的行为\n     */\n    public void teach()&#123;\n        System.out.println(&quot;老师在快乐的教Java~~~~~&quot;);\n    &#125;\n\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Test &#123;\n    public static void main(String[] args) &#123;\n        // 创建子类对象，看是否可以使用父类的属性和行为\n        Student s = new Student();\n        s.setName(&quot;杰哥&quot;); // 父类的\n        s.setAge(25);// 父类的\n        System.out.println(s.getName());// 父类的\n        System.out.println(s.getAge());// 父类的\n        s.study();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"4-2-继承的原理\"><a href=\"#4-2-继承的原理\" class=\"headerlink\" title=\"4.2 继承的原理\"></a>4.2 继承的原理</h2><p>继承设计规范:</p>\n<p>子类们相同特征（共性属性，共性方法)放在父类中定义，子类独有的的属性和行为应该定义在子类自己里面。</p>\n<h2 id=\"4-3-继承的特点\"><a href=\"#4-3-继承的特点\" class=\"headerlink\" title=\"4.3 继承的特点\"></a>4.3 继承的特点</h2><ul>\n<li><strong>&#x3D;&#x3D;子类可以继承父类的属性和行为，但是子类不能继承父类的构造器。&#x3D;&#x3D;</strong></li>\n<li>Java不支持多继承、但是支持多层继承。Java中所有的类都是Object类的子类。</li>\n<li>Java是单继承模式:一个类只能继承一个直接父类，支持多层继承。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/77a52685ed214a56b53553d360b2e64b.png#pic_center\"></p>\n<ul>\n<li>子类不可以继承父类的构造器，子类有自己的构造器，父类构造器用于初始化父类对象。</li>\n<li>子类可以继承父类的私有成员，只是不能直接访问。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/e1c2aadb80cf48a4abee1d501eebad45.png#pic_center\"></p>\n<ul>\n<li>子类不可以继承父类的静态成员，可以直接使用（共享并非继承）</li>\n</ul>\n<h2 id=\"4-4-继承后的访问\"><a href=\"#4-4-继承后的访问\" class=\"headerlink\" title=\"4.4 继承后的访问\"></a>4.4 继承后的访问</h2><p>在子类方法中访问成员（成员变量、成员方法)满足:<strong>就近原则</strong></p>\n<ul>\n<li>先子类局部范围找</li>\n<li>然后子类成员范围找</li>\n<li>然后父类成员范围找，如果父类范围还没有找到则报错。</li>\n</ul>\n<p>&#x3D;&#x3D;如果子父类中，出现了重名的成员，会优先使用子类的，此时如果一定要在子类中使用父类可以通过super关键字，指定访问父类的成员。&#x3D;&#x3D;</p>\n<pre><code class=\"java\">super.父类成员变量/父类成员方法\n</code></pre>\n<pre><code class=\"java\">public class ExtendsDemo &#123;\n    public static void main(String[] args) &#123;\n        Wolf w = new Wolf();\n        System.out.println(w.name); // 子类的\n        w.showName();\n    &#125;\n&#125;\n\nclass Animal&#123;\n    public String name = &quot;父类动物&quot;;\n&#125;\n\nclass Wolf extends Animal&#123;\n    public String name = &quot;子类动物&quot;;\n\n    public void showName()&#123;\n        String name = &quot;局部名称&quot;;\n        System.out.println(name); // 局部的\n        System.out.println(this.name); // 子类name\n        System.out.println(super.name); // 父类name\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"4-5-继承后的方法重写\"><a href=\"#4-5-继承后的方法重写\" class=\"headerlink\" title=\"4.5 继承后的方法重写\"></a>4.5 继承后的方法重写</h2><p><strong>什么是方法重写?</strong></p>\n<p>&#x3D;&#x3D;在继承体系中，子类出现了和父类中一模一样的方法声明，我们就称子类这个方法是重写的方法。&#x3D;&#x3D;</p>\n<p><strong>方法重写的应用场景</strong></p>\n<ul>\n<li>当子类需要父类的功能，但父类的该功能不完全满足自己的需求时。</li>\n<li>子类可以重写父类中的方法。</li>\n</ul>\n<p><strong>Override重写注解</strong></p>\n<ul>\n<li>&#x3D;&#x3D;@Override是放在重写后的方法上，作为重写是否正确的校验注解。&#x3D;&#x3D;</li>\n<li>加上该注解后如果重写错误，编译阶段会出现错误提示。</li>\n<li>建议重写方法都加@Override注解，代码安全，优雅!</li>\n</ul>\n<p><strong>方法重写注意事项和要求</strong></p>\n<ul>\n<li>&#x3D;&#x3D;重写方法的名称、形参列表必须与被重写方法的名称和参数列表一致。&#x3D;&#x3D;</li>\n<li>&#x3D;&#x3D;私有方法不能被重写。&#x3D;&#x3D;</li>\n<li>&#x3D;&#x3D;子类重写父类方法时，访问权限必须大于或者等于父类（暂时了解∶缺省&lt;protected &lt; public)&#x3D;&#x3D;</li>\n<li>&#x3D;&#x3D;子类不能重写父类的静态方法，如果重写会报错的。&#x3D;&#x3D;</li>\n</ul>\n<pre><code class=\"java\">public class Phone &#123;\n    public void call()&#123;\n        System.out.println(&quot;打电话开始~~~&quot;);\n    &#125;\n\n    public void sendMessage()&#123;\n        System.out.println(&quot;发送短信开始~~~&quot;);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class NewPhone extends Phone&#123;\n    /**\n      方法重写了\n     */\n    @Override\n    public void call() &#123;\n        super.call();\n        System.out.println(&quot;支持视频通话~~~&quot;);\n    &#125;\n\n    /**\n     方法重写了\n     */\n    @Override\n    public void sendMessage() &#123;\n        super.sendMessage();\n        System.out.println(&quot;支持发送图片和视频~~~&quot;);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Test &#123;\n    public static void main(String[] args) &#123;\n        NewPhone huawei = new NewPhone();\n        huawei.call();\n        huawei.sendMessage();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"4-6-继承后的子类构造器\"><a href=\"#4-6-继承后的子类构造器\" class=\"headerlink\" title=\"4.6 继承后的子类构造器\"></a>4.6 继承后的子类构造器</h2><p>子类继承父类后构造器的特点:</p>\n<ul>\n<li>子类中所有的构造器默认都会先访问父类中无参的构造器，再执行自己。</li>\n<li>子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据。</li>\n<li>子类初始化之前，一定要调用父类构造器先完成父类数据空间的初始化。</li>\n</ul>\n<p>怎么调用父类构造器的</p>\n<ul>\n<li>子类构造器的第一行语句默认都是:super()，不写也存在。</li>\n</ul>\n<p>&#x3D;&#x3D;super调用父类有参数构造器的作用:初始化继承自父类的数据。&#x3D;&#x3D;</p>\n<p>如果父类中没有无参数构造器，只有有参构造器，会报错。因为子类默认是调用父类无参构造器的。</p>\n<p>子类构造器中可以通过书写super(.….)，手动调用父类的有参数构造器</p>\n<h2 id=\"4-7-this、super使用总结\"><a href=\"#4-7-this、super使用总结\" class=\"headerlink\" title=\"4.7 this、super使用总结\"></a>4.7 this、super使用总结</h2><p>&#x3D;&#x3D;this:代表本类对象的引用; super:代表父类存储空间的标识。&#x3D;&#x3D;</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">关键字</th>\n<th align=\"center\">访问成员变量</th>\n<th align=\"center\">访问成员方法</th>\n<th align=\"center\">访问构造方法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">this</td>\n<td align=\"center\">this.成员变量 访问本类成员变量</td>\n<td align=\"center\">this.成员方法(…) 访问本类成员方法</td>\n<td align=\"center\">this(…) 访问本类构造器</td>\n</tr>\n<tr>\n<td align=\"center\">super</td>\n<td align=\"center\">super.成员变量 访问父类成员变量</td>\n<td align=\"center\">super.成员方法 访问父类成员方法</td>\n<td align=\"center\">super(…) 访问父类构造器</td>\n</tr>\n</tbody></table>\n<p>this(…)和super(..)使用注意点:</p>\n<ul>\n<li>子类通过this (..） 去调用本类的其他构造器，本类其他构造器会通过super去手动调用父类的构造器，最终还是会调用父类构造器的。</li>\n<li>this(..) super(..)都只能放在构造器的第一行，所以二者不能共存在同一个构造器中。</li>\n</ul>\n<pre><code class=\"java\">public class Student &#123;\n    private String name;\n    private String schoolName;\n\n    public Student() &#123;\n    &#125;\n\n    public Student(String name) &#123;\n        // 借用兄弟构造器！\n        this(name, &quot;河工大&quot;);\n    &#125;\n\n\n    public Student(String name, String schoolName) &#123;\n        this.name = name;\n        this.schoolName = schoolName;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public String getSchoolName() &#123;\n        return schoolName;\n    &#125;\n\n    public void setSchoolName(String schoolName) &#123;\n        this.schoolName = schoolName;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Test &#123;\n    public static void main(String[] args) &#123;\n        Student s1 = new Student(&quot;杰哥&quot;, &quot;南德大学&quot;);\n        System.out.println(s1.getName());\n        System.out.println(s1.getSchoolName());\n\n\n        Student s2 = new Student(&quot;阿伟&quot;);\n        System.out.println(s2.getName());\n        System.out.println(s2.getSchoolName());\n    &#125;\n&#125;\n</code></pre>\n<hr>\n","feature":true,"text":"在Java中，关键字static用于声明静态成员，这些成员属于类本身而不是对象。静态成员在类加载时被初始化，可以通过类名直接访问，无需创建对象。继承和静态成员的结合使用可以实现代码的重用和扩展。通过继承，子类可以继承父类的属性和方法。而通过静态成员，可以在不创建对象的情况下直接访问类的成员。...","permalink":"/post/Java程序设计 -- 面向对象进阶(上)（七）","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1%E3%80%81%E9%9D%99%E6%80%81%E5%85%B3%E9%94%AE%E5%AD%97%E2%80%93static\"><span class=\"toc-text\">1、静态关键字–static</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-static%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">1.1 static修饰成员变量的基本用法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-static%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1.2 static修饰成员变量的内存原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-static%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">1.3 static修饰成员方法的基本用法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4-static%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E7%9A%84%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1.4 static修饰成员方法的内存原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-5-static%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">1.5 static实际应用案例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-6-static%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">1.6 static的注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2%E3%80%81static%E5%BA%94%E7%94%A8%E2%80%93%E4%BB%A3%E7%A0%81%E5%9D%97\"><span class=\"toc-text\">2、static应用–代码块</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3%E3%80%81static%E5%BA%94%E7%94%A8%E2%80%93%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">3、static应用–单例设计模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">3.1 设计模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-%E9%A5%BF%E6%B1%89%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">3.2 饿汉单例设计模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-%E6%87%92%E6%B1%89%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">3.3 懒汉单例设计模式</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81%E2%80%93%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">4、面向对象特征–继承</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">4.1 继承</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">4.2 继承的原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-3-%E7%BB%A7%E6%89%BF%E7%9A%84%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">4.3 继承的特点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-4-%E7%BB%A7%E6%89%BF%E5%90%8E%E7%9A%84%E8%AE%BF%E9%97%AE\"><span class=\"toc-text\">4.4 继承后的访问</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-5-%E7%BB%A7%E6%89%BF%E5%90%8E%E7%9A%84%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99\"><span class=\"toc-text\">4.5 继承后的方法重写</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-6-%E7%BB%A7%E6%89%BF%E5%90%8E%E7%9A%84%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8\"><span class=\"toc-text\">4.6 继承后的子类构造器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-7-this%E3%80%81super%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">4.7 this、super使用总结</span></a></li></ol></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Java程序设计--面向对象进阶(下)","uid":"d1d7e86490a5e69b9e63a3257b8f9b8b","slug":"Java程序设计 -- 面向对象进阶(下)（八）","date":"2022-03-21T03:01:58.000Z","updated":"2025-07-14T15:12:20.462Z","comments":true,"path":"api/articles/Java程序设计 -- 面向对象进阶(下)（八）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","text":"final用于修饰不可改变的类、方法或变量；抽象类不能实例化，只能作为父类，可以包含抽象方法和具体方法；接口定义方法签名但不提供实现，类可以实现多个接口。它们能够提供代码的安全性、可维护性和灵活性。...","permalink":"/post/Java程序设计 -- 面向对象进阶(下)（八）","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"17 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true},"next_post":{"title":"Java程序设计--面向对象基础（六）","uid":"43ba7a87029e6d08249bdb5a925cb91f","slug":"Java程序设计 -- 面向对象基础（六）","date":"2022-03-19T14:24:11.000Z","updated":"2025-07-14T15:12:20.462Z","comments":true,"path":"api/articles/Java程序设计 -- 面向对象基础（六）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","text":"类是Java中的核心概念，用于创建对象。构造器是创建和初始化对象的特殊方法。this关键字表示当前对象的引用，用于访问成员变量和方法。Javabean是符合规范的Java类，用于数据封装和访问。它们在面向对象编程中扮演重要角色，提高代码的模块化和可维护性。...","permalink":"/post/Java程序设计 -- 面向对象基础（六）","photos":[],"count_time":{"symbolsCount":"6k","symbolsTime":"5 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true}}