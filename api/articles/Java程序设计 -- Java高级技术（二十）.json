{"title":"Java程序设计--Java高级技术","uid":"bec3c05a6e5145a0f9bf9077827e54de","slug":"Java程序设计 -- Java高级技术（二十）","date":"2022-04-17T08:21:11.000Z","updated":"2025-07-14T15:12:20.459Z","comments":true,"path":"api/articles/Java程序设计 -- Java高级技术（二十）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","content":"<hr>\n<h1 id=\"1、单元测试\"><a href=\"#1、单元测试\" class=\"headerlink\" title=\"1、单元测试\"></a>1、单元测试</h1><h2 id=\"1-1-单元测试概述\"><a href=\"#1-1-单元测试概述\" class=\"headerlink\" title=\"1.1 单元测试概述\"></a>1.1 单元测试概述</h2><p>单元测试就是针对最小的功能单元编写测试代码，Java程序最小的功能单元是方法，因此，单元测试就是针对Java方法的测试，进而检查方法的正确性。</p>\n<p><strong>目前测试方法</strong></p>\n<ul>\n<li>只有一个main方法，如果一个方法的测试失败了，其他方法测试会受到影响。</li>\n<li>无法得到测试的结果报告，需要程序员自己去观察测试是否成功。</li>\n<li>无法实现自动化测试。</li>\n</ul>\n<p><strong>Junit单元测试框架</strong></p>\n<ul>\n<li>JUnit是使用Java语言实现的单元测试框架，它是开源的，Java开发者都应当学习并使用JUnit编写单元测试。</li>\n<li>此外，几乎所有的IDE工具都集成了JUnit，这样我们就可以直接在IDE中编写并运行JUnit测试，JUnit目前最新版本是5。</li>\n</ul>\n<p><strong>JUnit优点</strong></p>\n<ul>\n<li>&#x3D;&#x3D;JUnit可以灵活的选择执行哪些测试方法，可以一键执行全部测试方法。&#x3D;&#x3D;</li>\n<li>&#x3D;&#x3D;Junit可以生成全部方法的测试报告，测试良好则是绿色，测试失败则是红色。&#x3D;&#x3D;</li>\n<li>&#x3D;&#x3D;单元测试中的某个方法测试失败了，不会影响其他测试方法的测试。&#x3D;&#x3D;</li>\n</ul>\n<h2 id=\"1-2-单元测试快速入门\"><a href=\"#1-2-单元测试快速入门\" class=\"headerlink\" title=\"1.2 单元测试快速入门\"></a>1.2 单元测试快速入门</h2><p>需求:使用单元测试进行业务方法预期结果、正确性测试的快速入门</p>\n<p>分析:</p>\n<ol>\n<li><p><strong>将JUnit的jar包导入到项目中</strong><br>- IDEA通常整合好了Junit框架，一般不需要导入。<br>- 如果IDEA没有整合好，需要自己手工导入如下2个JUnit的jar包到模块<br>- <img src=\"https://img-blog.csdnimg.cn/20bf9a788cea4d8d8e3cf6ce097c2923.png#pic_center\"></p>\n</li>\n<li><p><strong>编写测试方法:该测试方法必须是公共的无参数无返回值的非静态方法。</strong></p>\n</li>\n<li><p><strong>在测试方法上使用@Test注解:标注该方法是一个测试方法</strong></p>\n</li>\n<li><p><strong>在测试方法中完成被测试方法的预期正确性测试。</strong></p>\n</li>\n<li><p><strong>选中测试方法，选择“JUnit运行”，如果测试良好则是绿色;如果测试失败，则是红色</strong><br><img src=\"https://img-blog.csdnimg.cn/a6fb2cba53864739b9f5f30951dcaadf.png#pic_center\"></p>\n</li>\n</ol>\n<h2 id=\"1-3-单元测试常用注解\"><a href=\"#1-3-单元测试常用注解\" class=\"headerlink\" title=\"1.3 单元测试常用注解\"></a>1.3 单元测试常用注解</h2><p><strong>Junit常用注解(Junit 5.xxxx版本)</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">注解</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">@Test</td>\n<td align=\"center\">测试方法</td>\n</tr>\n<tr>\n<td align=\"center\">@BeforeEach</td>\n<td align=\"center\">用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。</td>\n</tr>\n<tr>\n<td align=\"center\">@AfterEach</td>\n<td align=\"center\">用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。</td>\n</tr>\n<tr>\n<td align=\"center\">@BeforeAll</td>\n<td align=\"center\">用来静态修饰方法，该方法会在所有测试方法之前只执行一次。</td>\n</tr>\n<tr>\n<td align=\"center\">@AfterAll</td>\n<td align=\"center\">用来静态修饰方法，该方法会在所有测试方法之后只执行一次。</td>\n</tr>\n</tbody></table>\n<ul>\n<li>开始执行的方法:初始化资源。</li>\n<li>执行完之后的方法:释放资源。</li>\n</ul>\n<pre><code class=\"java\">/**\n   业务方法\n */\npublic class UserService &#123;\n    public String loginName(String loginName , String passWord)&#123;\n        if(&quot;admin&quot;.equals(loginName) &amp;&amp; &quot;123456&quot;.equals(passWord))&#123;\n            return &quot;登录成功&quot;;\n        &#125;else &#123;\n            return &quot;用户名或者密码有问题&quot;;\n        &#125;\n    &#125;\n\n    public void selectNames()&#123;\n        System.out.println(10/2);\n        System.out.println(&quot;查询全部用户名称成功~~&quot;);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">import org.junit.*;\n\n/**\n   测试类\n */\npublic class TestUserService &#123;\n\n    // 修饰实例方法的\n    @Before\n    public void before()&#123;\n        System.out.println(&quot;===before方法执行一次===&quot;);\n    &#125;\n\n    @After\n    public void after()&#123;\n        System.out.println(&quot;===after方法执行一次===&quot;);\n    &#125;\n\n    // 修饰静态方法\n    @BeforeClass\n    public static void beforeClass()&#123;\n        System.out.println(&quot;===beforeClass方法执行一次===&quot;);\n    &#125;\n\n    @AfterClass\n    public static void afterClass()&#123;\n        System.out.println(&quot;===afterClass方法执行一次===&quot;);\n    &#125;\n\n\n    /**\n       测试方法\n       注意点：\n            1、必须是公开的，无参数 无返回值的方法\n            2、测试方法必须使用@Test注解标记。\n     */\n    @Test\n    public void testLoginName()&#123;\n        UserService userService = new UserService();\n        String rs = userService.loginName(&quot;admin&quot;,&quot;123456&quot;);\n\n        // 进行预期结果的正确性测试：断言。\n        Assert.assertEquals(&quot;您的登录业务可能出现问题&quot;, &quot;登录成功&quot;, rs );\n    &#125;\n\n    @Test\n    public void testSelectNames()&#123;\n        UserService userService = new UserService();\n        userService.selectNames();\n    &#125;\n\n&#125;\n</code></pre>\n<hr>\n<h1 id=\"2、反射\"><a href=\"#2、反射\" class=\"headerlink\" title=\"2、反射\"></a>2、反射</h1><h2 id=\"2-1-反射概述\"><a href=\"#2-1-反射概述\" class=\"headerlink\" title=\"2.1 反射概述\"></a>2.1 反射概述</h2><ul>\n<li>&#x3D;&#x3D;反射是指对于任何一个Class类，在”运行的时候”都可以直接得到这个类全部成分。&#x3D;&#x3D;</li>\n<li>在运行时,可以直接得到这个类的构造器对象:Constructor</li>\n<li>在运行时,可以直接得到这个类的成员变量对象:Field</li>\n<li>在运行时,可以直接得到这个类的成员方法对象:Method</li>\n<li>这种运行时动态获取类信息以及动态调用类中成分的能力称为Java语言的反射机制。</li>\n</ul>\n<p><strong>反射的关键:</strong></p>\n<p>反射的第一步都是先得到编译后的Class类对象，然后就可以得到Class的全部成分。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/23a7391c0f8e419dab10e1616f95dda7.png#pic_center\"></p>\n<h2 id=\"2-2-反射获取对象\"><a href=\"#2-2-反射获取对象\" class=\"headerlink\" title=\"2.2 反射获取对象\"></a>2.2 反射获取对象</h2><p><strong>反射获取类对象</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/5d8739a9aa364249b889cbf0c0821e2e.png#pic_center\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/ba85a66617384094a9a835db50f96676.png#pic_center\"></p>\n<pre><code class=\"java\">public class Student &#123;\n&#125;\n</code></pre>\n<pre><code class=\"java\">/**\n   反射的第一步：获取Class对象\n */\npublic class Test &#123;\n    public static void main(String[] args) throws Exception &#123;\n        // 1、Class类中的一个静态方法：forName(全限名：包名 + 类名)\n        Class c = Class.forName(&quot;com.itheima.d2_reflect_class.Student&quot;);\n        System.out.println(c); // Student.class\n\n        // 2、类名.class\n        Class c1 = Student.class;\n        System.out.println(c1);\n\n        // 3、对象.getClass() 获取对象对应类的Class对象。\n        Student s = new Student();\n        Class c2 = s.getClass();\n        System.out.println(c2);\n    &#125;\n&#125;\n</code></pre>\n<p><strong>反射获取构造器对象</strong><br><img src=\"https://img-blog.csdnimg.cn/470c52622d9640d9b2704b11ce62f7fc.png#pic_center\"></p>\n<p>使用反射技术获取构造器对象并使用</p>\n<ul>\n<li>反射的第一步是先得到类对象，然后从类对象中获取类的成分对象。</li>\n<li>Class类中用于获取构造器的方法</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Constructor&lt;?&gt;[] getConstructors()</td>\n<td align=\"center\">返回所有构造器对象的数组(只能拿public的)</td>\n</tr>\n<tr>\n<td align=\"center\">Constructor&lt;?&gt;[ ] getDeclaredConstructors()</td>\n<td align=\"center\">返回所有构造器对象的数组，存在就能拿到</td>\n</tr>\n<tr>\n<td align=\"center\">Constructor&lt; T &gt; getConstructor(class&lt;?&gt;… parameterTypes)</td>\n<td align=\"center\">返回单个构造器对象(只能拿public的)</td>\n</tr>\n<tr>\n<td align=\"center\">Constructor&lt; T &gt; getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</td>\n<td align=\"center\">返回单个构造器对象，存在就能拿到</td>\n</tr>\n</tbody></table>\n<p>Constructor类中用于创建对象的方法</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">T newInstance(Object.. initargs)</td>\n<td align=\"center\">根据指定的构造器创建对象</td>\n</tr>\n<tr>\n<td align=\"center\">public void setAccessible(boolean flag)</td>\n<td align=\"center\">设置为true,表示取消访问检查，进行暴力反射</td>\n</tr>\n</tbody></table>\n<p>如果是非public的构造器，需要打开权限（暴力反射)，然后再创建对象，setAccessible(boolean)，反射可以破坏封装性，私有的也可以执行了。</p>\n<pre><code class=\"java\">public class Student &#123;\n    private String name;\n    private int age;\n\n    private Student()&#123;\n        System.out.println(&quot;无参数构造器执行！&quot;);\n    &#125;\n\n    public Student(String name, int age) &#123;\n        System.out.println(&quot;有参数构造器执行！&quot;);\n        this.name = name;\n        this.age = age;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Student&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, age=&quot; + age +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">import org.junit.Test;\n\nimport java.lang.reflect.Constructor;\n\npublic class TestStudent01 &#123;\n    // 1. getConstructors:\n    // 获取全部的构造器：只能获取public修饰的构造器。\n    // Constructor[] getConstructors()\n    @Test\n    public void getConstructors()&#123;\n        // a.第一步：获取类对象\n        Class c = Student.class;\n        // b.提取类中的全部的构造器对象(这里只能拿public修饰)\n        Constructor[] constructors = c.getConstructors();\n        // c.遍历构造器\n        for (Constructor constructor : constructors) &#123;\n            System.out.println(constructor.getName() + &quot;===&gt;&quot; + constructor.getParameterCount());\n        &#125;\n    &#125;\n\n\n    // 2.getDeclaredConstructors():\n    // 获取全部的构造器：只要你敢写，这里就能拿到，无所谓权限是否可及。\n    @Test\n    public void getDeclaredConstructors()&#123;\n        // a.第一步：获取类对象\n        Class c = Student.class;\n        // b.提取类中的全部的构造器对象\n        Constructor[] constructors = c.getDeclaredConstructors();\n        // c.遍历构造器\n        for (Constructor constructor : constructors) &#123;\n            System.out.println(constructor.getName() + &quot;===&gt;&quot; + constructor.getParameterCount());\n        &#125;\n    &#125;\n\n    // 3.getConstructor(Class... parameterTypes)\n    // 获取某个构造器：只能拿public修饰的某个构造器\n    @Test\n    public void getConstructor() throws Exception &#123;\n        // a.第一步：获取类对象\n        Class c = Student.class;\n        // b.定位单个构造器对象 (按照参数定位无参数构造器 只能拿public修饰的某个构造器)\n        Constructor cons = c.getConstructor();\n        System.out.println(cons.getName() + &quot;===&gt;&quot; + cons.getParameterCount());\n    &#125;\n\n\n    // 4.getConstructor(Class... parameterTypes)\n    // 获取某个构造器：只要你敢写，这里就能拿到，无所谓权限是否可及。\n    @Test\n    public void getDeclaredConstructor() throws Exception &#123;\n        // a.第一步：获取类对象\n        Class c = Student.class;\n        // b.定位单个构造器对象 (按照参数定位无参数构造器)\n        Constructor cons = c.getDeclaredConstructor();\n        System.out.println(cons.getName() + &quot;===&gt;&quot; + cons.getParameterCount());\n\n        // c.定位某个有参构造器\n        Constructor cons1 = c.getDeclaredConstructor(String.class, int.class);\n        System.out.println(cons1.getName() + &quot;===&gt;&quot; + cons1.getParameterCount());\n\n    &#125;\n\n&#125;\n</code></pre>\n<p><strong>反射获取成员变量对象</strong><br><img src=\"https://img-blog.csdnimg.cn/412facf3054a4f5a90fc13fc3e056937.png#pic_center\"><br>使用反射技术获取成员变量对象并使用</p>\n<ul>\n<li>反射的第一步是先得到类对象，然后从类对象中获取类的成分对象。</li>\n<li>Class类中用于获取成员变量的方法。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Field [ ] getFields()</td>\n<td align=\"center\">返回所有成员变量对象的数组(只能拿public的)</td>\n</tr>\n<tr>\n<td align=\"center\">Field[ ] getDeclaredFields()</td>\n<td align=\"center\">返回所有成员变量对象的数组，存在就能拿到</td>\n</tr>\n<tr>\n<td align=\"center\">Field getField(String name)</td>\n<td align=\"center\">返回单个成员变量对象(只能拿public的)</td>\n</tr>\n<tr>\n<td align=\"center\">Field getDeclaredField(String name)</td>\n<td align=\"center\">返回单个成员变量对象，存在就能拿到</td>\n</tr>\n</tbody></table>\n<p>获取成员变量的作用依然是在某个对象中取值、赋值</p>\n<p><strong>Field类中用于取值、赋值的方法</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">void set(Object obj, Object value):</td>\n<td align=\"center\">赋值</td>\n</tr>\n<tr>\n<td align=\"center\">Object get(Object obj)</td>\n<td align=\"center\">获取值</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">public class Student &#123;\n    private String name;\n    private int age;\n    public static String schoolName;\n    public static final String  COUNTTRY = &quot;中国&quot;;\n\n    public Student()&#123;\n        System.out.println(&quot;无参数构造器执行！&quot;);\n    &#125;\n\n    public Student(String name, int age) &#123;\n        System.out.println(&quot;有参数构造器执行！&quot;);\n        this.name = name;\n        this.age = age;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Student&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, age=&quot; + age +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">import org.junit.Test;\n\nimport java.io.File;\nimport java.lang.reflect.Field;\n\npublic class FieldDemo01 &#123;\n    /**\n     * 1.获取全部的成员变量。\n     * Field[] getDeclaredFields();\n     *  获得所有的成员变量对应的Field对象，只要申明了就可以得到\n     */\n    @Test\n    public void getDeclaredFields()&#123;\n        // a.定位Class对象\n        Class c = Student.class;\n        // b.定位全部成员变量\n        Field[] fields = c.getDeclaredFields();\n        // c.遍历一下\n        for (Field field : fields) &#123;\n            System.out.println(field.getName() + &quot;==&gt;&quot; + field.getType());\n        &#125;\n    &#125;\n\n    /**\n        2.获取某个成员变量对象 Field getDeclaredField(String name);\n     */\n    @Test\n    public void getDeclaredField() throws Exception &#123;\n        // a.定位Class对象\n        Class c = Student.class;\n        // b.根据名称定位某个成员变量\n        Field f = c.getDeclaredField(&quot;age&quot;);\n        System.out.println(f.getName() +&quot;===&gt;&quot; + f.getType());\n    &#125;\n\n&#125;\n\n</code></pre>\n<p><strong>反射获取对象方法</strong><br><img src=\"https://img-blog.csdnimg.cn/a832e26f2d1d4b29beca725badb76e1d.png#pic_center\"><br>使用反射技术获取方法对象并使用</p>\n<ul>\n<li>反射的第一步是先得到类对象，然后从类对象中获取类的成分对象。</li>\n<li>Class类中用于获取成员方法的方法</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Method[ ] getMethods()</td>\n<td align=\"center\">返回所有成员方法对象的数组(只能拿public的)</td>\n</tr>\n<tr>\n<td align=\"center\">Method[ ] getDeclaredMethods()</td>\n<td align=\"center\">返回所有成员方法对象的数组，存在就能拿到</td>\n</tr>\n<tr>\n<td align=\"center\">Method getMethod(String name，Class&lt;?&gt;… parameterTypes)</td>\n<td align=\"center\">返回单个成员方法对象(只能拿public的)</td>\n</tr>\n<tr>\n<td align=\"center\">Method getDeclaredNethod(String name，Class&lt;?&gt;… parameterTypes)</td>\n<td align=\"center\">返回单个成员方法对象，存在就能拿到</td>\n</tr>\n</tbody></table>\n<p>获取成员方法的作用依然是在某个对象中进行执行此方法Method类中用于触发执行的方法</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">object invoke(0bject obj，object. . . args)</td>\n<td align=\"center\">运行方法\\参数一:用obj对象调用该方法\\参数二:调用方法的传递的参数(如果没有就不写)返回值:方法的返回值(如果没有就不写)</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">public class Dog &#123;\n    private String name ;\n    public Dog()&#123;\n    &#125;\n\n    public Dog(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public void run()&#123;\n        System.out.println(&quot;狗跑的贼快~~&quot;);\n    &#125;\n\n    private void eat()&#123;\n        System.out.println(&quot;狗吃骨头&quot;);\n    &#125;\n\n    private String eat(String name)&#123;\n        System.out.println(&quot;狗吃&quot; + name);\n        return &quot;吃的很开心！&quot;;\n    &#125;\n\n    public static void inAddr()&#123;\n        System.out.println(&quot;在学习Java!&quot;);\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n&#125;\n</code></pre>\n<pre><code class=\"java\">import org.junit.Test;\n\nimport java.lang.reflect.Method;\n\npublic class MethodDemo01 &#123;\n    /**\n     * 1.获得类中的所有成员方法对象\n     */\n    @Test\n    public void getDeclaredMethods()&#123;\n        // a.获取类对象\n        Class c = Dog.class;\n        // b.提取全部方法；包括私有的\n        Method[] methods = c.getDeclaredMethods();\n        // c.遍历全部方法\n        for (Method method : methods) &#123;\n            System.out.println(method.getName() +&quot; 返回值类型：&quot; + method.getReturnType() + &quot; 参数个数：&quot; + method.getParameterCount());\n        &#125;\n    &#125;\n\n    /**\n     * 2. 获取某个方法对象\n     */\n    @Test\n    public void getDeclardMethod() throws Exception &#123;\n        // a.获取类对象\n        Class c = Dog.class;\n        // b.提取单个方法对象\n        Method m = c.getDeclaredMethod(&quot;eat&quot;);\n        Method m2 = c.getDeclaredMethod(&quot;eat&quot;, String.class);\n\n        // 暴力打开权限了\n        m.setAccessible(true);\n        m2.setAccessible(true);\n\n        // c.触发方法的执行\n        Dog d = new Dog();\n        // 注意：方法如果是没有结果回来的，那么返回的是null.\n        Object result = m.invoke(d);\n        System.out.println(result);\n\n        Object result2 = m2.invoke(d, &quot;骨头&quot;);\n        System.out.println(result2);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"2-3-反射的作用\"><a href=\"#2-3-反射的作用\" class=\"headerlink\" title=\"2.3 反射的作用\"></a>2.3 反射的作用</h2><p><strong>反射的作用-绕过编译阶段为集合添加数据</strong></p>\n<p>反射是作用在运行时的技术，此时集合的泛型将不能产生约束了，此时是可以为集合存入其他任意类型的元素的。</p>\n<pre><code class=\"java\">ArrayList&lt; Integer &gt; list = new ArrayList&lt;&gt;();\nlist.add(100);\n// list.add(“黑马&quot;);//报错\nlist.add(99);\n</code></pre>\n<p>&#x3D;&#x3D;泛型只是在编译阶段可以约束集合只能操作某种数据类型，在编译成Class文件进入运行阶段的时候，其真实类型都是ArrayList了，泛型相当于被擦除了。反射是作用在运行时的技术，此时已经不存在泛型了。&#x3D;&#x3D;</p>\n<pre><code class=\"java\">import java.lang.reflect.Method;\nimport java.util.ArrayList;\n\npublic class ReflectDemo &#123;\n    public static void main(String[] args) throws Exception &#123;\n        // 需求：反射实现泛型擦除后，加入其他类型的元素\n        ArrayList&lt;String&gt; lists1 = new ArrayList&lt;&gt;();\n        ArrayList&lt;Integer&gt; lists2 = new ArrayList&lt;&gt;();\n\n        System.out.println(lists1.getClass());\n        System.out.println(lists2.getClass());\n\n        System.out.println(lists1.getClass() ==  lists2.getClass());  // ArrayList.class\n\n        System.out.println(&quot;---------------------------&quot;);\n        ArrayList&lt;Integer&gt; lists3 = new ArrayList&lt;&gt;();\n        lists3.add(23);\n        lists3.add(22);\n        // lists3.add(&quot;33&quot;);\n\n        Class c = lists3.getClass(); // ArrayList.class  ===&gt; public boolean add(E e)\n        // 定位c类中的add方法\n        Method add = c.getDeclaredMethod(&quot;add&quot;, Object.class);\n        boolean rs = (boolean) add.invoke(lists3, &quot;33&quot;);\n        System.out.println(rs);\n\n        System.out.println(lists3);\n\n        ArrayList list4 = lists3;\n        list4.add(&quot;44&quot;);\n        list4.add(false);\n        System.out.println(lists3);\n    &#125;\n&#125;\n</code></pre>\n<p><strong>反射做通用框架</strong></p>\n<ul>\n<li>可以在运行时得到一个类的全部成分然后操作。</li>\n<li>可以破坏封装性。(很突出)</li>\n<li>也可以破坏泛型的约束性。(很突出)</li>\n<li>更重要的用途是适合:做Java高级框架。</li>\n<li>基本上主流框架都会基于反射设计一些通用技术功能。</li>\n</ul>\n<hr>\n<h1 id=\"3、注解\"><a href=\"#3、注解\" class=\"headerlink\" title=\"3、注解\"></a>3、注解</h1><h2 id=\"3-1-注解概述\"><a href=\"#3-1-注解概述\" class=\"headerlink\" title=\"3.1 注解概述\"></a>3.1 注解概述</h2><p>&#x3D;&#x3D;Java注解(Annotation）又称Java标注，是JDK5.0引入的一种注释机制。Java语言中的类、构造器、方法、成员变量、参数等都可以被注解进行标注。&#x3D;&#x3D;</p>\n<p><img src=\"https://img-blog.csdnimg.cn/bd743b30a38a452799a222da07441ec5.png#pic_center\"></p>\n<p>注解的作用：&#x3D;&#x3D;对Java中类、方法、成员变量做标记，然后进行特殊处理，至于到底做何种处理由业务需求来决定。&#x3D;&#x3D;例如:JUnit框架中，标记了注解@Test的方法就可以被当成测试方法执行，而没有标记的就不能当成测试方法执行。</p>\n<h2 id=\"3-2-自定义注解\"><a href=\"#3-2-自定义注解\" class=\"headerlink\" title=\"3.2  自定义注解\"></a>3.2  自定义注解</h2><p>&#x3D;&#x3D;自定义注解就是自己做一个注解来使用。&#x3D;&#x3D;</p>\n<pre><code class=\"java\">public @interface 注解名称&#123;\n    public 属性名称 属性名()default 默认值;\n&#125;\n</code></pre>\n<p>特殊属性</p>\n<ul>\n<li>value属性，如果只有一个value属性的情况下，使用value属性的时候可以省略value名称不写!!</li>\n<li>但是如果有多个属性，且多个属性没有默认值，那么value名称是不能省略的。</li>\n</ul>\n<pre><code class=\"java\">/**\n   学会自定义注解。掌握其定义格式和语法。\n */\n@MyBook(name=&quot;《精通JavaSE》&quot;,authors = &#123;&quot;佚名&quot;, &quot;dlei&quot;&#125; , price = 199.5)\n//@Book(value = &quot;/delete&quot;)\n// @Book(&quot;/delete&quot;)\n@Book(value = &quot;/delete&quot;, price = 23.5)\n//@Book(&quot;/delete&quot;)\npublic class AnnotationDemo1 &#123;\n\n    @MyBook(name=&quot;《精通JavaSE2》&quot;,authors = &#123;&quot;佚名&quot;, &quot;dlei&quot;&#125; , price = 199.5)\n    private AnnotationDemo1()&#123;\n\n    &#125;\n\n    @MyBook(name=&quot;《精通JavaSE1》&quot;,authors = &#123;&quot;佚名&quot;, &quot;dlei&quot;&#125; , price = 199.5)\n    public static void main(String[] args) &#123;\n        @MyBook(name=&quot;《精通JavaSE2》&quot;,authors = &#123;&quot;佚名&quot;, &quot;dlei&quot;&#125; , price = 199.5)\n        int age = 21;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"3-3-元注解元注解\"><a href=\"#3-3-元注解元注解\" class=\"headerlink\" title=\"3.3 元注解元注解\"></a>3.3 元注解元注解</h2><p>&#x3D;&#x3D;元注解:就是注解注解的注解。&#x3D;&#x3D;</p>\n<p>元注解有两个:</p>\n<ul>\n<li><strong>@Target:约束自定义注解只能在哪些地方使用</strong></li>\n<li><strong>@Retention:申明注解的生命周期</strong></li>\n</ul>\n<p>@Target中可使用的值定义在ElementType枚举类中，常用值如下</p>\n<ul>\n<li>TYPE，类，接口</li>\n<li>FIELD,成员变量</li>\n<li>METHOD,成员方法</li>\n<li>PARAMETER,方法参数</li>\n<li>CONSTRUCTOR,构造器</li>\n<li>LOCAL_VARIABLE，局部变量</li>\n</ul>\n<p>@Retention中可使用的值定义在RetentionPolicy枚举类中，常用值如下</p>\n<ul>\n<li>SOURCE:注解只作用在源码阶段，生成的字节码文件中不存在</li>\n<li>CLASS:注解作用在源码阶段，字节码文件阶段，运行阶段不存在，默认值</li>\n<li>RUNTIME:注解作用在源码阶段，字节码文件阶段，运行阶段(开发常用)</li>\n</ul>\n<pre><code class=\"java\">import java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(&#123;ElementType.METHOD,ElementType.FIELD&#125;) // 元注解\n@Retention(RetentionPolicy.RUNTIME) // 一直活着，在运行阶段这个注解也不消失\npublic @interface MyTest &#123;\n&#125;\n</code></pre>\n<h2 id=\"3-4-注解解析\"><a href=\"#3-4-注解解析\" class=\"headerlink\" title=\"3.4 注解解析\"></a>3.4 注解解析</h2><p><strong>注解的解析</strong></p>\n<p>&#x3D;&#x3D;注解的操作中经常需要进行解析，注解的解析就是判断是否存在注解，存在注解就解析出内容。&#x3D;&#x3D;</p>\n<p><strong>与注解解析相关的接口</strong></p>\n<ul>\n<li>Annotation:注解的顶级接口，注解都是Annotation类型的对象</li>\n<li>AnnotatedElement:该接口定义了与注解解析相关的解析方法</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Annotationl]getDeclaredAnnotations()</td>\n<td align=\"center\">获得当前对象上使用的所有注解，返回注解数组。</td>\n</tr>\n<tr>\n<td align=\"center\">T getDeclaredAnnotation(Class&lt; T &gt; annotationClass)</td>\n<td align=\"center\">根据注解类型获得对应注解对象</td>\n</tr>\n<tr>\n<td align=\"center\">boolean isAnnotationPresent(Class&lt; Annotation &gt; annotationClass)</td>\n<td align=\"center\">判断当前对象是否使用了指定的注解如果使用了则返回true，否则false</td>\n</tr>\n</tbody></table>\n<p>所有的类成分Class, Method ,Field , Constructor，都实现了AnnotatedElement接口他们都拥有解析注解的能力</p>\n<pre><code class=\"java\">public @interface Book &#123;\n    String value(); // 特殊属性\n    double price() ;\n    //double price() default 9.9;\n&#125;\n</code></pre>\n<pre><code class=\"java\">import java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Bookk &#123;\n    String value();\n    double price() default 100;\n    String[] author();\n&#125;\n</code></pre>\n<pre><code class=\"java\">import org.junit.Test;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\n\n/**\n   目标：完成注解的解析\n */\npublic class AnnotationDemo3 &#123;\n    @Test\n    public void parseClass()&#123;\n        // a.先得到类对象\n        Class c = BookStore.class;\n        // b.判断这个类上面是否存在这个注解\n        if(c.isAnnotationPresent(Bookk.class))&#123;\n            //c.直接获取该注解对象\n            Bookk book = (Bookk) c.getDeclaredAnnotation(Bookk.class);\n            System.out.println(book.value());\n            System.out.println(book.price());\n            System.out.println(Arrays.toString(book.author()));\n        &#125;\n    &#125;\n\n    @Test\n    public void parseMethod() throws NoSuchMethodException &#123;\n        // a.先得到类对象\n        Class c = BookStore.class;\n\n        Method m = c.getDeclaredMethod(&quot;test&quot;);\n\n        // b.判断这个类上面是否存在这个注解\n        if(m.isAnnotationPresent(Bookk.class))&#123;\n            //c.直接获取该注解对象\n            Bookk book = (Bookk) m.getDeclaredAnnotation(Bookk.class);\n            System.out.println(book.value());\n            System.out.println(book.price());\n            System.out.println(Arrays.toString(book.author()));\n        &#125;\n    &#125;\n&#125;\n\n@Bookk(value = &quot;《情深深雨濛濛》&quot;, price = 99.9, author = &#123;&quot;琼瑶&quot;, &quot;dlei&quot;&#125;)\nclass BookStore&#123;\n\n    @Bookk(value = &quot;《三少爷的剑》&quot;, price = 399.9, author = &#123;&quot;古龙&quot;, &quot;熊耀华&quot;&#125;)\n    public void test()&#123;\n    &#125;\n&#125;\n</code></pre>\n<p>解析注解的技巧</p>\n<ul>\n<li>注解在哪个成分上，我们就先拿哪个成分对象。</li>\n<li>比如注解作用成员方法，则要获得该成员方法对应的Method对象，再来拿上面的注解</li>\n<li>比如注解作用在类上，则要该类的Class对象，再来拿上面的注解</li>\n<li>比如注解作用在成员变量上，则要获得该成员变量对应的Field对象，再来拿上面的注解</li>\n</ul>\n<hr>\n<h1 id=\"4、动态代理\"><a href=\"#4、动态代理\" class=\"headerlink\" title=\"4、动态代理\"></a>4、动态代理</h1><p><strong>模拟企业业务功能开发，并完成每个功能的性能统计</strong></p>\n<p>需求</p>\n<p>模拟某企业用户管理业务，需包含用户登录，用户删除，用户查询功能，并要统计每个功能的耗时</p>\n<p>分析</p>\n<ol>\n<li>定义一个UserService表示用户业务接口，规定必须完成用户登录，用户删除，用户查询功能。</li>\n<li>定义一个实现类UserServicelmpl实现UserService，并完成相关功能，且统计每个功能的耗时。</li>\n<li>定义测试类，创建实现类对象，调用方法。</li>\n</ol>\n<pre><code class=\"java\">public class UserServiceImpl implements UserService&#123;\n    @Override\n    public String login(String loginName, String passWord)  &#123;\n        try &#123;\n            Thread.sleep(1000);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n        if(&quot;admin&quot;.equals(loginName) &amp;&amp; &quot;1234&quot;.equals(passWord)) &#123;\n            return &quot;success&quot;;\n        &#125;\n        return &quot;登录名和密码可能有毛病&quot;;\n\n    &#125;\n\n    @Override\n    public void selectUsers() &#123;\n        System.out.println(&quot;查询了100个用户数据！&quot;);\n        try &#123;\n            Thread.sleep(2000);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n    @Override\n    public boolean deleteUsers() &#123;\n        try &#123;\n            System.out.println(&quot;删除100个用户数据！&quot;);\n            Thread.sleep(500);\n            return true;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n            return false;\n        &#125;\n    &#125;\n\n    @Override\n    public void updateUsers() &#123;\n        try &#123;\n            System.out.println(&quot;修改100个用户数据！&quot;);\n            Thread.sleep(2500);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">/**\n   模拟用户业务功能\n */\npublic interface UserService &#123;\n    String login(String loginName , String passWord) ;\n    void selectUsers();\n    boolean deleteUsers();\n    void updateUsers();\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Test &#123;\n    public static void main(String[] args) &#123;\n        // 1、把业务对象，直接做成一个代理对象返回，代理对象的类型也是 UserService类型\n        UserService userService = ProxyUtil.getProxy(new UserServiceImpl());\n        System.out.println(userService.login(&quot;admin&quot;, &quot;1234&quot;));\n        System.out.println(userService.deleteUsers());\n        userService.selectUsers();\n        userService.updateUsers(); // 走代理\n    &#125;\n&#125;\n</code></pre>\n<p>此案例中业务对象的每个方法都要进行性能统计，存在大量重复的代码。</p>\n<p><strong>动态代理</strong></p>\n<p>代理就是被代理者没有能力或者不愿意去完成某件事情，需要找个人代替自己去完成这件事，动态代理就是用来对业务功能（方法）进行代理的。</p>\n<p><strong>关键步骤</strong></p>\n<ol>\n<li>必须有接口，实现类要实现接口（代理通常是基于接口实现的)。</li>\n<li>创建一个实现类的对象，该对象为业务对象，紧接着为业务对象做一个代理对象。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/126321a5b06f42b08a56d05489ed969d.png#pic_center\"></p>\n<pre><code class=\"java\">import java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n/**\n    public static Object newProxyInstance(ClassLoader loader,  Class&lt;?&gt;[] interfaces, InvocationHandler h)\n    参数一：类加载器，负责加载代理类到内存中使用。\n    参数二：获取被代理对象实现的全部接口。代理要为全部接口的全部方法进行代理\n    参数三：代理的核心处理逻辑\n */\npublic class ProxyUtil &#123;\n    /**\n      生成业务对象的代理对象。\n     * @param obj\n     * @return\n     */\n    public static &lt;T&gt; T  getProxy(T obj) &#123;\n        // 返回了一个代理对象了\n        return (T)Proxy.newProxyInstance(obj.getClass().getClassLoader(),\n                obj.getClass().getInterfaces(),\n                new InvocationHandler() &#123;\n                    @Override\n                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n                        // 参数一：代理对象本身。一般不管\n                        // 参数二：正在被代理的方法\n                        // 参数三：被代理方法，应该传入的参数\n                       long startTimer = System .currentTimeMillis();\n                        // 马上触发方法的真正执行。(触发真正的业务功能)\n                        Object result = method.invoke(obj, args);\n\n                        long endTimer = System.currentTimeMillis();\n                        System.out.println(method.getName() + &quot;方法耗时：&quot; + (endTimer - startTimer) / 1000.0 + &quot;s&quot;);\n\n                        // 把业务功能方法执行的结果返回给调用者\n                        return result;\n                    &#125;\n                &#125;);\n    &#125;\n&#125;\n</code></pre>\n<p><strong>动态代理的优点</strong></p>\n<ul>\n<li>非常的灵活，支持任意接口类型的实现类对象做代理，也可以直接为接本身做代理。</li>\n<li>可以为被代理对象的所有方法做代理。</li>\n<li>可以在不改变方法源码的情况下，实现对方法功能的增强。</li>\n<li>不仅简化了编程工作、提高了软件系统的可扩展性，同时也提高了开发效率。</li>\n</ul>\n<hr>\n","feature":true,"text":"Java单元测试是一种测试方法，用于确保程序模块的正确性。反射是Java语言提供的一组API，能够在运行时动态获取类信息和操作对象。注解是一种元数据机制，可用于标记、配置和描述程序元素。动态代理则是一种设计模式，为其他对象提供一个代理，以控制对该对象的访问。合理运用Java单元测试、反射、注解和动态代理可以提升程序的可维护性和可扩展性。...","permalink":"/post/Java程序设计 -- Java高级技术（二十）","photos":[],"count_time":{"symbolsCount":"22k","symbolsTime":"20 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">1、单元测试</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1.1 单元测试概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8\"><span class=\"toc-text\">1.2 单元测试快速入门</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">1.3 单元测试常用注解</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%8F%8D%E5%B0%84\"><span class=\"toc-text\">2、反射</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E5%8F%8D%E5%B0%84%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">2.1 反射概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">2.2 反射获取对象</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">2.3 反射的作用</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">3、注解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-%E6%B3%A8%E8%A7%A3%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">3.1 注解概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">3.2  自定义注解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-%E5%85%83%E6%B3%A8%E8%A7%A3%E5%85%83%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">3.3 元注解元注解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-4-%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">3.4 注解解析</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">4、动态代理</span></a></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Java程序设计--XML、设计模式","uid":"95d5eb05aae54932675ce4d24d2c2637","slug":"Java程序设计 -- XML、设计模式（二十一）","date":"2022-04-19T12:38:36.000Z","updated":"2025-07-14T15:12:20.459Z","comments":true,"path":"api/articles/Java程序设计 -- XML、设计模式（二十一）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","text":"XML（可扩展标记语言）是一种用于描述数据结构和信息传递的标记语言。它具有自定义标签和结构化数据的特点，被广泛应用于配置文件、数据交换和Web服务等领域。设计模式是在软件设计中常用的解决问题的经验总结，如单例模式、工厂模式等。合理使用XML和设计模式可以提高程序的可读性、可维护性和灵活性，使开发过程更加高效和可靠。...","permalink":"/post/Java程序设计 -- XML、设计模式（二十一）","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true},"next_post":{"title":"Java程序设计--网络编程","uid":"fcaa2443e4f23837ea39b8c51bbe3746","slug":"Java程序设计 -- 网络编程（十九）","date":"2022-04-15T02:39:59.000Z","updated":"2025-07-14T15:12:20.461Z","comments":true,"path":"api/articles/Java程序设计 -- 网络编程（十九）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","text":"网络通信是计算机网络中的重要组成部分，常用的协议有UDP和TCP。UDP协议提供了快速的数据传输，但不保证数据的可靠性和顺序；而TCP协议则提供了可靠的数据传输和数据包的排序机制。合理选择UDP或TCP协议可根据具体应用场景决定。网络通信在现代互联网中扮演着重要角色，掌握网络通信技术能够提升系统的交互和数据传输效率。...","permalink":"/post/Java程序设计 -- 网络编程（十九）","photos":[],"count_time":{"symbolsCount":"29k","symbolsTime":"26 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true}}