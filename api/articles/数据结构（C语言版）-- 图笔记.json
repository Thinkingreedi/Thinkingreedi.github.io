{"title":"图","uid":"0b9c5318228023fdd1e179358a45ba07","slug":"数据结构（C语言版）-- 图笔记","date":"2022-02-20T12:59:01.000Z","updated":"2025-07-14T15:12:20.468Z","comments":true,"path":"api/articles/数据结构（C语言版）-- 图笔记.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/56d020cfc5f84516b5980d6710ece105.png","content":"<hr>\n<h1 id=\"1、图的定义和基本术语\"><a href=\"#1、图的定义和基本术语\" class=\"headerlink\" title=\"1、图的定义和基本术语\"></a>1、图的定义和基本术语</h1><h2 id=\"①-图的定义\"><a href=\"#①-图的定义\" class=\"headerlink\" title=\"①.图的定义\"></a>①.图的定义</h2><p>&#x3D;&#x3D;图(Graph )G由两个集合V和E组成，记为<strong>G&#x3D;(V,E)<strong>，其中</strong>V是顶点的有穷非空集合</strong>，<strong>E是V中顶点偶对的有穷集合</strong>，这些顶点偶对称为边&#x3D;&#x3D;。V(G)和E(G)通常分别表示图G的顶点集合和边集合，E(G)可以为空集。若E(G)为空，则图G只有顶点而没有边。</p>\n<p><strong>有向图:</strong></p>\n<p>每条边都是有方向的，边也称作弧，如G1</p>\n<p><strong>无向图:</strong></p>\n<p>每条边都是无方向的，如G2</p>\n<p><img src=\"https://img-blog.csdnimg.cn/5889e557346c44588921b4fa3d27b51f.png#pic_center\"></p>\n<h2 id=\"②-图的基本术语\"><a href=\"#②-图的基本术语\" class=\"headerlink\" title=\"②.图的基本术语\"></a>②.图的基本术语</h2><p>设n表示图中顶点数目，e表示边的数目</p>\n<p>&#x3D;&#x3D;<strong>完全图</strong>：任意两个点都有一条边相连&#x3D;&#x3D;</p>\n<p><img src=\"https://img-blog.csdnimg.cn/c6aad8d28a404598928f30fcad5a6c86.png#pic_center\"></p>\n<p>&#x3D;&#x3D;<strong>稀疏图</strong>：如果边或弧的个数满足e &lt; n log<del>2</del>n ,则称作稀疏图，否则称作稠密图&#x3D;&#x3D;</p>\n<p>&#x3D;&#x3D;<strong>子图</strong>：设有两个图G&#x3D;(V，{E}) 、G1&#x3D; (V1，{E1})，若V1⊆ V，E1⊆ E，则称G1是G的子图。&#x3D;&#x3D;</p>\n<p><img src=\"https://img-blog.csdnimg.cn/fa863bdd35674aa29a319187177bbd89.png#pic_center\"></p>\n<p>&#x3D;&#x3D;<strong>权与网</strong>：图中边或弧所具有的数称为权。表明从一个顶点到另一个顶点的距离或耗费。带权的图称为网。&#x3D;&#x3D;</p>\n<p>&#x3D;&#x3D;对无向图来说：<br><strong>邻接点</strong>:若顶点v和顶点w之间存在一条边a，则称顶点v和w互为邻接点。边a与顶点v和w相关联。<br><strong>度</strong>:与顶点v关联的边的数目，记为TD(v)&#x3D;&#x3D;</p>\n<p>&#x3D;&#x3D;对有向图来说：<br>&lt;x,y&gt;为有向边（弧），<br>x为有向边的起点（弧尾)，y为有向边的终点（弧头）<br><strong>顶点v的入度</strong>是以v为终点的有向边的条数,记作ID(v)<br><strong>顶点v的出度</strong>是以v为始点的有向边的条数,记作OD(v)&#x3D;&#x3D;</p>\n<p>&#x3D;&#x3D;<strong>路径</strong>:接续的边构成的顶点序列。&#x3D;&#x3D;</p>\n<p>&#x3D;&#x3D;<strong>路径长度</strong>:路径上边或弧的数目。&#x3D;&#x3D;</p>\n<p>&#x3D;&#x3D;<strong>简单路径</strong>:除路径起点和终点可以相同外，其余顶点均不相同的路径。&#x3D;&#x3D;</p>\n<p>&#x3D;&#x3D;<strong>简单回路(简单环)</strong>:除路径起点和终点相同外，其余顶点均不相同的路径.&#x3D;&#x3D;</p>\n<p><img src=\"https://img-blog.csdnimg.cn/e158eb694bec4fbe85d988fffaa92ffe.png#pic_center\"></p>\n<p>&#x3D;&#x3D;若无向图中任意两个顶点之间都有路径相通，则称此图为<strong>连通图</strong>(G1);若无向图为非连通图，则图中各个连通子图称作此图的<strong>连通分量</strong>(G2)。&#x3D;&#x3D;</p>\n<p>&#x3D;&#x3D;若有向图中任意两个顶点之间都存在一条有向路径，则称此有向图为强连通图，否则，其各个强连通子图称作它的<strong>强连通分量</strong>。&#x3D;&#x3D;</p>\n<p><img src=\"https://img-blog.csdnimg.cn/033ac64c141141baa9d7db44a11d660d.png#pic_center\"></p>\n<hr>\n<h1 id=\"2、图的类型定义\"><a href=\"#2、图的类型定义\" class=\"headerlink\" title=\"2、图的类型定义\"></a>2、图的类型定义</h1><p><strong>图的抽象数据类型定义：</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/510eb32f1b894c3fb5fcb0f0bc9ee5af.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/d213c4028c1e48c4b25ca3f7b6c3299b.png#pic_center\"></p>\n<hr>\n<h1 id=\"3、图的存储结构\"><a href=\"#3、图的存储结构\" class=\"headerlink\" title=\"3、图的存储结构\"></a>3、图的存储结构</h1><p>由于图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数据元素在存储区中的物理位置来表示元素之间的关系，即<strong>图没有顺序存储结构</strong>，但可以借助二维数组来表示元素之间的关系，即邻接矩阵表示法。另一方面，由于图的任意两个顶点间都可能存在关系，因此，用链式存储表示图是很自然的事，图的链式存储有多种，有邻接表、十字链表和邻接多重表，应根据实际需要的不同选择不同的存储结构。</p>\n<h2 id=\"①-邻接矩阵\"><a href=\"#①-邻接矩阵\" class=\"headerlink\" title=\"①.邻接矩阵\"></a>①.邻接矩阵</h2><p><strong>邻接矩阵表示法</strong></p>\n<p><strong>邻接矩阵是表示顶点之间相邻关系的矩阵。设G（V，E）是具有n个顶点的图，则G的邻接矩阵是具有如下性质的n阶方阵。</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/97522e6906ef4913bb0b4fcdbdcf36b9.png#pic_center\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/079231c04e2641b78e9b8db50d9e07f4.png#pic_center\"></p>\n<p>在有向图的邻接矩阵中，</p>\n<ul>\n<li><strong>第i行含义︰以结点v;为起点的边(即出度边);</strong></li>\n<li><strong>第i列含义:以结点v;为终点的边(即入度边)。</strong></li>\n</ul>\n<p>有向图的邻接矩阵可能是不对称的。</p>\n<ul>\n<li><strong>顶点的出度-第i行元素之和</strong></li>\n<li><strong>顶点的入度-第i列元素之和</strong></li>\n<li><strong>顶点的度-第i行元素之和+第i列元素之和</strong></li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/c12873e1d7794b12802953ca6dea50c1.png#pic_center\"></p>\n<p>无向图的邻接矩阵是对称的;</p>\n<ul>\n<li><strong>顶点i的度&#x3D;第i 行（列)中1的个数;</strong></li>\n<li><strong>图的边数&#x3D;所有非0元素之和的一半;</strong></li>\n<li><strong>完全图的邻接矩阵中，对角元素为0，其余1。</strong></li>\n</ul>\n<p>若G是网，则邻接矩阵可以定义为：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/4f0bd60aab4d459a918215b44eef9e45.png#pic_center\"></p>\n<p>其中，w<del>i,j</del>表示边上的权值;∞表示计算机允许的、大于所有边上权值的数。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/6fd74f7f3ea24ebbacb2d89879db1178.png#pic_center\"><br>邻接矩阵表示法的特点</p>\n<ul>\n<li>优点:容易实现图的操作。<br>如:求某顶点的度、判断顶点之间是否有边、找顶点的邻接点……</li>\n<li>缺点:n个顶点需要n*n个单元存储边;空间效率为O(n^2^)。<br>对稀疏图而言尤其浪费空间。</li>\n</ul>\n<pre><code class=\"cpp\">//图的邻接矩阵存储表示\n#define MaxInt 32767     //表示极大值，即∞\n#define MVNum 100        //最大顶点数\ntypedef char VerTexType; //假设顶点的数据类型为字符型\ntypedef int ArcType;     //假设边的权值类型为整型\ntypedef struct\n&#123;\n    VerTexType vexs[MVNum];     //顶点表\n    ArcType arcs[MVNum][MVNum]; //邻接矩阵\n    int vexnum, arcnum;         //图的当前顶点数和边数\n&#125; AMGraph;\n</code></pre>\n<p><strong>采用邻接矩阵表示法创建无向网</strong></p>\n<ol>\n<li>输入总顶点数和总边数。</li>\n<li>依次输入点的信息存入顶点表中。</li>\n<li>初始化邻接矩阵，使每个权值初始化为极大值。</li>\n<li>构造邻接矩阵。依次输人每条边依附的顶点和其权值，确定两个顶点在图中的位置之后，使相应边赋予相应的权值，同时使其对称边赋予相同的权值。</li>\n</ol>\n<pre><code class=\"cpp\">Status CreateUDN(AMGraph &amp;G)\n&#123;                                //采用邻接矩阵表示法，创建无向网G\n    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; //输入总顶点数，总边数\n    for (i = 0; i &lt; G.vexnum; ++i)\n        cin &gt;&gt; G.vexs[i];          //依次输入点的信息\n    for (i = 0; i &lt; G.vexnum; ++i) //初始化邻接矩阵，边的权值均置为极大值\n        for (j = 0; j &lt; G.vexnum; ++j)\n            G.arcs[i][j] = MaxInt;\n    for (k = 0; k &lt; G.arcnum; ++k) //构造邻接矩阵\n    &#123;\n        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w; //输入一条边依附的顶点及权值\n        i = LocateVex(G, v1);\n        j = LocateVex(G, v2);        //确定v1和v2在G中的位置\n        G.arcs[i][j] = w;            //边&lt;v1, v2&gt;的权值置为w\n        G.arcs[j][i] = G.arcs[i][j]; //置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w\n    &#125;                                // for\n    return OK;\n&#125; // CreateUDN\n</code></pre>\n<p>该算法的时间复杂度是&#x3D;&#x3D;O(n^2^)&#x3D;&#x3D;。</p>\n<p>若要建立无向图，只需对上述算法做两处小的改动:一是初始化邻接矩阵时，将边的权值均初始化为0;二是构造邻接矩阵时，将权值w改为常量值1即可。同样，将该算法稍做修改即可建立一个有向网或有向图。</p>\n<h2 id=\"②-邻接表\"><a href=\"#②-邻接表\" class=\"headerlink\" title=\"②.邻接表\"></a>②.邻接表</h2><p><strong>邻接表(Adjacency List）是图的一种链式存储结构。在邻接表中，对图中每个顶点v;建立一个单链表，把与v相邻接的顶点放在这个链表中。邻接表中每个单链表的第一个结点存放有关顶点的信息，把这一结点看成链表的表头，其余结点存放有关边的信息，这样邻接表便由两部分组成:表头结点表和边表。</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/d1027b1a3cad48f6b2ec2bdfa3704b19.png#pic_center\"></p>\n<p>无向图的邻接表表示</p>\n<p><img src=\"https://img-blog.csdnimg.cn/534bbdd59a674d96a0049d0659f6bba5.png#pic_center\"></p>\n<p>有向图的邻接表表示</p>\n<p><img src=\"https://img-blog.csdnimg.cn/8deb9cf11caf4b97b816347b2017ecb5.png#pic_center\"></p>\n<pre><code class=\"cpp\">//图的邻接表存储表示\n#define MVNum 100 //最大顶点数\ntypedef struct ArcNode\n&#123;\n    int adjvex;              // 该边所指向的顶点的位置\n    struct ArcNode *nextarc; // 指向下一条边的指针\n    OtherInfo info;          // 和边相关的信息\n&#125; ArcNode;\ntypedef struct VNode\n&#123;\n    VertexType data;     // 顶点信息\n    ArcNode *firstarc;   // 指向第一条依附该顶点的边\n&#125; VNode, AdjList[MVNum]; // AdjList表示邻接表类型\ntypedef struct\n&#123;\n    AdjList vertices;   // vertices—vertex的复数\n    int vexnum, arcnum; //图的当前顶点数和边数\n&#125; ALGraph;\n</code></pre>\n<p><strong>采用邻接表表示法创建无向图</strong></p>\n<ol>\n<li>输人总顶点数和总边数。</li>\n<li>依次输入点的信息存入顶点表中，使每个表头结点的指针域初始化为NULL。</li>\n<li>创建邻接表。依次输入每条边依附的两个顶点，确定这两个顶点的序号i和j之后，将此边结点分别插入v<del>i</del>和v<del>j</del>对应的两个边链表的头部。</li>\n</ol>\n<pre><code class=\"cpp\">Status CreateUDG(ALGraph &amp;G)\n&#123;                                //采用邻接表表示法，创建无向图G\n    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; //输入顶点数和弧数\n    for (i = 0; i &lt; G.vexnum; ++i)\n    &#123;                                  //输入各点，构造表头结点表\n        cin &gt;&gt; G.vertices[i].data;     //输入顶点值\n        G.vertices[i].firstarc = NULL; //初始化表头结点的指针域为NULL\n    &#125;\n    for (k = 0; k &lt; G.arcnum; ++k) //输入各边，构造邻接表，头插法\n    &#123;\n        cin &gt;&gt; v1 &gt;&gt; v2; //输入一条边依附的两个顶点\n        i = LocateVex(G, v1);\n        j = LocateVex(G, v2);\n        p1 = new ArcNode; //生成一个新的边结点*p1\n        p1-&gt;adjvex = j;   //邻接点序号为j\n        p1-&gt;nextarc = G.vertices[i].firstarc;\n        G.vertices[i].firstarc = p1;          //将新结点*p1插入到顶点vi的边表头部\n        p2 = new ArcNode;                     //生成一个新的边结点*p2\n        p2-&gt;adjvex = i;                       //邻接点序号为j\n        p2-&gt;nextarc = G.vertices[j].firstarc; //插入弧结点到单链表\n        G.vertices[j].firstarc = p2;          //将新结点*p2插入到顶点vj的边表头部\n    &#125;                                         //头插法\n    return OK;\n&#125; // CreateUDG\n</code></pre>\n<p>该算法的时间复杂度是&#x3D;&#x3D;O(n+e)&#x3D;&#x3D;。</p>\n<p>建立有向图的邻接表与此类似，只是更加简单，每读入一个顶点对序号&lt;i,j&gt;，仅需生成一个邻接点序号为j的边表结点，并将其插入到v的边链表头部即可。若要创建网的邻接表，可以将边的权值存储在info域中。</p>\n<p><strong>邻接矩阵与邻接表的比较</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/c44dc1fe4ddc40c7b0be7728e53515a3.png#pic_center\"></p>\n<p>例1：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d8a7f7784fb54c86abe0370349473e93.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/9d43c13493ec41bab804a3904bc51f75.png#pic_center\"></p>\n<p>例2：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/b7da64ef02c64970888ca29b97ccc4a9.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/5295de9604764fcf9c07dbf032b016f2.png#pic_center\"></p>\n<h2 id=\"④-十字链表\"><a href=\"#④-十字链表\" class=\"headerlink\" title=\"④.十字链表\"></a>④.十字链表</h2><p><strong>十字链表(Orthogonal List)是有向图的另一种链式存储结构。可以看成是将有向图的邻接表和逆邻接表结合起来得到的一种链表。在十字链表中，对应于有向图中每一条弧有一个结点，对应于每个顶点也有一个结点。</strong></p>\n<p>在弧结点中有5个域:其中尾域( tailvex )和头域( headvex )分别指示弧尾和弧头这两个顶点在图中的位置，链域hlink指向弧头相同的下一条弧，而链域tlink 指向弧尾相同的下一条弧，info域指向该弧的相关信息。弧头相同的弧在同一链表上，弧尾相同的弧也在同一链表上。它们的头结点即为顶点结点，它由3个域组成:其中 data域存储和顶点相关的信息，如顶点的名称等;firstin和 firstout为两个链域，分别指向以该顶点为弧头或弧尾的第一个弧结点。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">tailvex</td>\n<td align=\"center\">指示弧尾顶点在图中的位置。</td>\n</tr>\n<tr>\n<td align=\"center\">headtex</td>\n<td align=\"center\">指示弧头顶点在图中的位置。</td>\n</tr>\n<tr>\n<td align=\"center\">hlink</td>\n<td align=\"center\">是指向弧头相同的下一条弧的指针。</td>\n</tr>\n<tr>\n<td align=\"center\">tlink</td>\n<td align=\"center\">是指向弧尾相同的下一条弧的指针。</td>\n</tr>\n<tr>\n<td align=\"center\">Info</td>\n<td align=\"center\">指向该弧的相关信息。</td>\n</tr>\n</tbody></table>\n<p><img src=\"https://img-blog.csdnimg.cn/3f6e27895ee541ffb35fb0ff9e26a537.png#pic_center\"></p>\n<pre><code class=\"cpp\">//有向图的十字链表存储表示\n#define MAX_VERTEX_NUM 20\ntypedef struct ArcBox\n&#123;\n    int tailvex, headvex;\n    struct ArcBox *hlink, *tlink;\n    InfoType *info;\n&#125; ArcBox;\ntypedef struct VexNode // ArcBox为弧结点变量\n&#123;\n    VertexType data;\n    ArcBox *firstin, *firstout;\n&#125; VexNode;\ntypedef struct // VexNode为顶点变量\n&#123;\n    VexNode xlist[MAX_VERTEX_NUM]; // 表头向\n    int vexnum, arcnum;            // 有向图的当前顶点数和弧数\n&#125; OLGraph;\n</code></pre>\n<p>例：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/a6aea7ac55ed4f42bfcdb5bb37200f2a.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/a920d93055314208999e55367e9ff6e7.png#pic_center\"></p>\n<h2 id=\"④-邻接多重表\"><a href=\"#④-邻接多重表\" class=\"headerlink\" title=\"④.邻接多重表\"></a>④.邻接多重表</h2><p><strong>邻接多重表是无向图的另一种链式存储结构，由于用邻接表存储无向图时，虽然容易求出顶点和边的各种信息，但在邻接表中每一条边有两个结点，分别在第i和第j个链表中，给图的某些操作带来不便。在邻接多重表中，每一条边只有一个边结点，为有关边的处理提供了方便。</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">mark</td>\n<td align=\"center\">为标志域，可用以标记该条边是否被搜索过</td>\n</tr>\n<tr>\n<td align=\"center\">ivex和jvex</td>\n<td align=\"center\">为该边依附的两个顶点在图中的位置;</td>\n</tr>\n<tr>\n<td align=\"center\">ilnk</td>\n<td align=\"center\">指向下一条依附于顶点ivex的边;</td>\n</tr>\n<tr>\n<td align=\"center\">jlink</td>\n<td align=\"center\">指向下一条依附于顶点jvex的边</td>\n</tr>\n<tr>\n<td align=\"center\">info</td>\n<td align=\"center\">为指向和边相关的各种信息的指针域。</td>\n</tr>\n</tbody></table>\n<p>例：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/1d52ad2eb0564c46af086ad8ff60083d.png#pic_center\"></p>\n<pre><code class=\"cpp\">//无向图的邻接多重表存储表示\n#define MAX_VERTEX_NUM 20\ntypedef enum\n&#123;\n    unvisited,\n    viseited\n&#125; ViseitIF;\ntypedef struct EBox\n&#123;\n    VisitIf mark;               //访问标志域\n    int ivex, jvex;             //该边依附的两个顶点在表头数组中位置\n    struct EBox *ilink, *jlink; //分别指向依附于ivex和jvex的下一条边\n    InfoType *info;\n&#125; Ebox;\ntypedef struct VexBox\n&#123;\n    VertexType data; //存与顶点有关的信息\n    EBox *firstedge; //指向第一条依附于该顶点的边\n&#125; VexBox;\ntypedef struct\n&#123;\n    VexBox adjmulist[MAX_VERTEX_NUM]; // 表头向量\n    int vexnum, edgenum;              // 无向图的当前顶点数和弧数\n&#125; AMLGraph;\n</code></pre>\n<p>例：画出无向图G的邻接多重表</p>\n<p><img src=\"https://img-blog.csdnimg.cn/c9411620611f4952a1d84b33c3bc19cf.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/a38fd52e3137451e8ffdd29969663cd1.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/22495a9e70204f52bbd695cb5c10a458.png#pic_center\"></p>\n<hr>\n<h1 id=\"4、图的遍历\"><a href=\"#4、图的遍历\" class=\"headerlink\" title=\"4、图的遍历\"></a>4、图的遍历</h1><p>从图中某个顶点V。出发，沿着一些边访问图中所有的顶点，且使每个顶点被访问一次且只访问一次，就叫做图的遍历。它是图的基本运算。</p>\n<h2 id=\"①-深度优先搜索\"><a href=\"#①-深度优先搜索\" class=\"headerlink\" title=\"①.深度优先搜索\"></a>①.深度优先搜索</h2><p>&#x3D;&#x3D;深度优先搜索( Depth First Search，DFS)遍历类似于树的先序遍历，是树的先序遍历的推广&#x3D;&#x3D;。对于一个连通图，深度优先搜索遍历的过程如下。</p>\n<ol>\n<li>从图中某个顶点v出发，访问v。</li>\n<li>找出刚访问过的顶点的第一个未被访问的邻接点，访问该顶点。以该顶点为新顶点，重复此步骤,直至刚访问过的顶点没有未被访问的邻接点为止。</li>\n<li>返回前一个访问过的且仍有未被访问的邻接点的顶点，找出该顶点的下一个未被访问的邻接点，访问该顶点。</li>\n<li>重复步骤（2）和（3)，直至图中所有顶点都被访问过，搜索结束。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/a510d5470cc247dfa2fcf56f4fb3469b.png#pic_center\"></p>\n<p>对无向连通图，如果将一次深度优先搜索时前进操作所经过的边保留下来则可构成一棵深度优先搜索生成树。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/a44a9d7a871b44c09d087e2090402098.png#pic_center\"></p>\n<p><strong>深度优先搜索遍历的算法实现</strong></p>\n<p>显然，深度优先搜索遍历连通图是一个递归的过程。为了在遍历过程中便于区分顶点是否已被访问，需附设访问标志数组visited[n]，其初值为“false”，一旦某个顶点被访问，则其相应的分量置为“true”。</p>\n<ol>\n<li>从图中某个顶点v出发，访问v，并置visited[y]的值为true。</li>\n<li>依次检查v的所有邻接点w，如果visited[w]的值为false，再从w出发进行递归遍历,直到图中所有顶点都被访问过。</li>\n</ol>\n<pre><code class=\"cpp\">//深度优先搜索遍历连通图的递归算法\n\n#include &lt;iostream&gt;\nusing namespace std;\n\n#define MVNum 100        //最大顶点数\ntypedef char VerTexType; //假设顶点的数据类型为字符型\ntypedef int ArcType;     //假设边的权值类型为整型\n\ntypedef struct\n&#123;\n    VerTexType vexs[MVNum];     //顶点表\n    ArcType arcs[MVNum][MVNum]; //邻接矩阵\n    int vexnum, arcnum;         //图的当前点数和边数\n&#125; Graph;\n\nbool visited[MVNum];                   //访问标志数组，其初值为&quot;false&quot;\nint FirstAdjVex(Graph G, int v);       //返回v的第一个邻接点\nint NextAdjVex(Graph G, int v, int w); //返回v相对于w的下一个邻接点\n\nint LocateVex(Graph G, VerTexType v)\n&#123;\n    //确定点v在G中的位置\n    for (int i = 0; i &lt; G.vexnum; ++i)\n        if (G.vexs[i] == v)\n            return i;\n    return -1;\n&#125; // LocateVex\n\nvoid CreateUDN(Graph &amp;G)\n&#123;\n    //采用邻接矩阵表示法，创建无向网G\n    int i, j, k;\n    cout &lt;&lt; &quot;请输入总顶点数，总边数 , 以空格隔开:&quot;;\n    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; //输入总顶点数，总边数\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;输入点的名称，如 a：&quot; &lt;&lt; endl;\n\n    for (i = 0; i &lt; G.vexnum; ++i)\n    &#123;\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (i + 1) &lt;&lt; &quot;个点的名称:&quot;;\n        cin &gt;&gt; G.vexs[i]; //依次输入点的信息\n    &#125;\n    cout &lt;&lt; endl;\n\n    for (i = 0; i &lt; G.vexnum; ++i) //初始化邻接矩阵，边的权值均置为极大值MaxInt\n        for (j = 0; j &lt; G.vexnum; ++j)\n            G.arcs[i][j] = 0;\n    cout &lt;&lt; &quot;输入边依附的顶点，如：a b&quot; &lt;&lt; endl;\n    for (k = 0; k &lt; G.arcnum; ++k)\n    &#123; //构造邻接矩阵\n        VerTexType v1, v2;\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (k + 1) &lt;&lt; &quot;条边依附的顶点:&quot;;\n        cin &gt;&gt; v1 &gt;&gt; v2; //输入一条边依附的顶点及权值\n        i = LocateVex(G, v1);\n        j = LocateVex(G, v2);            //确定v1和v2在G中的位置，即顶点数组的下标\n        G.arcs[j][i] = G.arcs[i][j] = 1; //置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w\n    &#125;                                    // for\n&#125; // CreateUDN\n\nvoid DFS(Graph G, int v)\n&#123; //从第v个顶点出发递归地深度优先遍历图G\n    cout &lt;&lt; G.vexs[v] &lt;&lt; &quot;    &quot;;\n    visited[v] = true; //访问第v个顶点，并置访问标志数组相应分量值为true\n    int w;\n    for (w = FirstAdjVex(G, v); w &gt;= 0; w = NextAdjVex(G, v, w))\n        //依次检查v的所有邻接点w ，FirstAdjVex(G, v)表示v的第一个邻接点\n        // NextAdjVex(G, v, w)表示v相对于w的下一个邻接点，w≥0表示存在邻接点\n        if (!visited[w])\n            DFS(G, w); //对v的尚未访问的邻接顶点w递归调用DFS\n&#125; // DFS\n\nint FirstAdjVex(Graph G, int v)\n&#123;\n    int i;\n    for (i = 0; i &lt; G.vexnum; ++i)\n    &#123;\n        if (G.arcs[v][i] == 1 &amp;&amp; visited[i] == false)\n            return i;\n    &#125;\n    return -1;\n&#125; // FirstAdjVex\n\nint NextAdjVex(Graph G, int v, int w)\n&#123;\n    int i;\n    for (i = w; i &lt; G.vexnum; ++i)\n    &#123;\n        if (G.arcs[v][i] == 1 &amp;&amp; visited[i] == false)\n            return i;\n    &#125;\n    return -1;\n&#125; // NextAdjVex\n\nint main()\n&#123;\n    cout &lt;&lt; &quot;************深度优先搜索遍历连通图的递归算法**************&quot; &lt;&lt; endl\n         &lt;&lt; endl;\n    Graph G;\n    CreateUDN(G);\n    cout &lt;&lt; endl;\n    cout &lt;&lt; &quot;无向连通图G创建完成！&quot; &lt;&lt; endl\n         &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;请输入遍历连通图的起始点：&quot;;\n    VerTexType c;\n    cin &gt;&gt; c;\n\n    int i;\n    for (i = 0; i &lt; G.vexnum; ++i)\n    &#123;\n        if (c == G.vexs[i])\n            break;\n    &#125;\n    cout &lt;&lt; endl;\n    while (i &gt;= G.vexnum)\n    &#123;\n        cout &lt;&lt; &quot;该点不存在，请重新输入！&quot; &lt;&lt; endl;\n        cout &lt;&lt; &quot;请输入遍历连通图的起始点：&quot;;\n        cin &gt;&gt; c;\n        for (i = 0; i &lt; G.vexnum; ++i)\n        &#123;\n            if (c == G.vexs[i])\n                break;\n        &#125;\n    &#125;\n    cout &lt;&lt; &quot;深度优先搜索遍历连通图结果：&quot; &lt;&lt; endl;\n    DFS(G, i);\n\n    cout &lt;&lt; endl;\n    return 0;\n&#125; // main\n</code></pre>\n<pre><code class=\"cpp\">//深度优先搜索遍历非连通图\n\n#include &lt;iostream&gt;\nusing namespace std;\n\n#define MVNum 100        //最大顶点数\ntypedef char VerTexType; //假设顶点的数据类型为字符型\ntypedef int ArcType;     //假设边的权值类型为整型\n\n//-------------图的邻接矩阵-----------------\ntypedef struct\n&#123;\n    VerTexType vexs[MVNum];     //顶点表\n    ArcType arcs[MVNum][MVNum]; //邻接矩阵\n    int vexnum, arcnum;         //图的当前点数和边数\n&#125; Graph;\n\nbool visited[MVNum];                   //访问标志数组，其初值为&quot;false&quot;\nint FirstAdjVex(Graph G, int v);       //返回v的第一个邻接点\nint NextAdjVex(Graph G, int v, int w); //返回v相对于w的下一个邻接点\n\nint LocateVex(Graph G, VerTexType v)\n&#123;\n    //确定点v在G中的位置\n    for (int i = 0; i &lt; G.vexnum; ++i)\n        if (G.vexs[i] == v)\n            return i;\n    return -1;\n&#125; // LocateVex\n\nvoid CreateUDN(Graph &amp;G)\n&#123;\n    //采用邻接矩阵表示法，创建无向网G\n    int i, j, k;\n    cout &lt;&lt; &quot;请输入总顶点数，总边数，以空格隔开:&quot;;\n    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; //输入总顶点数，总边数\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;输入点的名称，如a&quot; &lt;&lt; endl;\n    for (i = 0; i &lt; G.vexnum; ++i)\n    &#123;\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (i + 1) &lt;&lt; &quot;个点的名称:&quot;;\n        cin &gt;&gt; G.vexs[i]; //依次输入点的信息\n    &#125;\n    cout &lt;&lt; endl;\n    for (i = 0; i &lt; G.vexnum; ++i) //初始化邻接矩阵，边的权值均置为极大值MaxInt\n        for (j = 0; j &lt; G.vexnum; ++j)\n            G.arcs[i][j] = 0;\n    cout &lt;&lt; &quot;输入边依附的顶点，如a b&quot; &lt;&lt; endl;\n    for (k = 0; k &lt; G.arcnum; ++k)\n    &#123; //构造邻接矩阵\n        VerTexType v1, v2;\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (k + 1) &lt;&lt; &quot;条边依附的顶点:&quot;;\n        cin &gt;&gt; v1 &gt;&gt; v2; //输入一条边依附的顶点及权值\n        i = LocateVex(G, v1);\n        j = LocateVex(G, v2);            //确定v1和v2在G中的位置，即顶点数组的下标\n        G.arcs[j][i] = G.arcs[i][j] = 1; //置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w\n    &#125;                                    // for\n&#125; // CreateUDN\n\nvoid DFS(Graph G, int v)\n&#123;\n    //从第v个顶点出发递归地深度优先遍历图G\n    cout &lt;&lt; G.vexs[v] &lt;&lt; &quot;    &quot;;\n    visited[v] = true; //访问第v个顶点，并置访问标志数组相应分量值为true\n    int w;\n    for (w = FirstAdjVex(G, v); w &gt;= 0; w = NextAdjVex(G, v, w))\n        //依次检查v的所有邻接点w ，FirstAdjVex(G, v)表示v的第一个邻接点\n        // NextAdjVex(G, v, w)表示v相对于w的下一个邻接点，w≥0表示存在邻接点\n        if (!visited[w])\n            DFS(G, w); //对v的尚未访问的邻接顶点w递归调用DFS\n&#125; // DFS\n\nvoid DFSTraverse(Graph G)\n&#123;\n    //对非连通图G做深度优先遍历\n    int v;\n    for (v = 0; v &lt; G.vexnum; ++v)\n        visited[v] = false;        //访问标志数组初始化\n    for (v = 0; v &lt; G.vexnum; ++v) //循环调用算法6.3\n        if (!visited[v])\n            DFS(G, v); //对尚未访问的顶点调用DFS\n&#125; // DFSTraverse\n\nint FirstAdjVex(Graph G, int v)\n&#123;\n    //返回v的第一个邻接点\n    int i;\n    for (i = 0; i &lt; G.vexnum; ++i)\n    &#123;\n        if (G.arcs[v][i] == 1 &amp;&amp; visited[i] == false)\n            return i;\n    &#125;\n    return -1;\n&#125; // FirstAdjVex\n\nint NextAdjVex(Graph G, int v, int w)\n&#123;\n    //返回v相对于w的下一个邻接点\n    int i;\n    for (i = w; i &lt; G.vexnum; ++i)\n    &#123;\n        if (G.arcs[v][i] == 1 &amp;&amp; visited[i] == false)\n            return i;\n    &#125;\n    return -1;\n&#125; // NextAdjVex\n\nint main()\n&#123;\n    cout &lt;&lt; &quot;************深度优先搜索遍历非连通图**************&quot; &lt;&lt; endl\n         &lt;&lt; endl;\n    Graph G;\n    CreateUDN(G);\n    cout &lt;&lt; endl;\n    cout &lt;&lt; &quot;无向图G创建完成！&quot; &lt;&lt; endl\n         &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;深度优先搜索遍历非连通图结果：&quot; &lt;&lt; endl;\n    DFSTraverse(G);\n\n    cout &lt;&lt; endl;\n    return 0;\n&#125; // main\n</code></pre>\n<h2 id=\"②-广度优先搜索\"><a href=\"#②-广度优先搜索\" class=\"headerlink\" title=\"②.广度优先搜索\"></a>②.广度优先搜索</h2><p>&#x3D;&#x3D;广度优先搜索（ Breadth First Search，BFS）遍历类似于树的按层次遍历的过程。&#x3D;&#x3D;</p>\n<p>广度优先搜索遍历的过程如下。</p>\n<ol>\n<li>从图中某个顶点v出发，访问v。</li>\n<li>依次访问v的各个未曾访问过的邻接点。</li>\n<li>分别从这些邻接点出发依次访问它们的邻接点，并使“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接点”被访问。重复步骤3，直至图中所有已被访问的顶点的邻接点都被访问到。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/b38d873f7db345fb9e1af669a1ca2a33.png#pic_center\"><br>广度优先生成树：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/5d8d5d18139b45ceb9cea446061845b4.png#pic_center\"><br><strong>广度优先搜索遍历连通图</strong></p>\n<ol>\n<li>从图中某个顶点v出发，访问v，并置 visited[y]的值为true，然后将v进队。</li>\n<li>只要队列不空，则重复下述操作:<br>- 队头顶点u出队;<br>- 依次检查u的所有邻接点w，如果visited[w]的值为false，则访问w，并置visited[w]的值为true，然后将w进队。</li>\n</ol>\n<pre><code class=\"cpp\">//广度优先搜索遍历连通图\n\n#include &lt;iostream&gt;\nusing namespace std;\n\n#define MVNum 100                       \t//最大顶点数\n#define MAXQSIZE 100\t\t\t\t\t\t//最大队列长度\n                        \ntypedef char VerTexType;              \t\t//假设顶点的数据类型为字符型\ntypedef int ArcType;                  \t\t//假设边的权值类型为整型\nbool visited[MVNum];           \t\t\t\t//访问标志数组，其初值为&quot;false&quot; \n\n//-----图的邻接矩阵存储表示----- \ntypedef struct&#123; \n    VerTexType vexs[MVNum];            \t\t//顶点表\n    ArcType arcs[MVNum][MVNum];      \t\t//邻接矩阵\n    int vexnum,arcnum;                \t\t//图的当前点数和边数\n&#125;Graph;\n\n//----队列的定义及操作--------\ntypedef struct&#123;\n    ArcType *base;\t\t\t\t\t\t\t//初始化的动态分配存储空间\n    int front;\t\t\t\t\t\t\t\t//头指针，若队列不空，指向队头元素\n    int rear;\t\t\t\t\t\t\t\t//尾指针，若队列不空，指向队尾元素的下一个位置\n&#125;sqQueue;\n\nvoid InitQueue(sqQueue &amp;Q)&#123;\n    //构造一个空队列Q\n    Q.base = new ArcType[MAXQSIZE];\n    if(!Q.base)     exit(1);\t\t\t\t//存储分配失败\n    Q.front = Q.rear = 0;\n&#125;//InitQueue\n\nvoid EnQueue(sqQueue &amp;Q, ArcType e)&#123;\n    //插入元素e为Q的新的队尾元素\n    if((Q.rear + 1) % MAXQSIZE == Q.front)\n        return;\n    Q.base[Q.rear] = e;\n    Q.rear = (Q.rear + 1) % MAXQSIZE;\n&#125;//EnQueue\n\nbool QueueEmpty(sqQueue Q)&#123;\n    //判断是否为空队\n    if(Q.rear == Q.front)\n        return true;\n    return false;\n&#125;//QueueEmpty\n\nvoid DeQueue(sqQueue &amp;Q, ArcType &amp;u)&#123;\n    //队头元素出队并置为u \n    u = Q.base[Q.front];\n    Q.front = (Q.front + 1) % MAXQSIZE;\n&#125;//DeQueue   \t\t\t\t\t\t\t\t\n//--------------------------------------------------\n\nint LocateVex(Graph G , VerTexType v)&#123;\n    //确定点v在G中的位置\n    for(int i = 0; i &lt; G.vexnum; ++i)\n        if(G.vexs[i] == v)\n            return i;\n        return -1;\n&#125;//LocateVex\n\nvoid CreateUDN(Graph &amp;G)&#123; \n    //采用邻接矩阵表示法，创建无向网G \n    int i , j , k;\n    cout &lt;&lt;&quot;请输入总顶点数，总边数，以空格隔开:&quot;;\n    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;\t\t\t\t\t\t\t//输入总顶点数，总边数\n    cout &lt;&lt; endl;\n    cout &lt;&lt; &quot;输入点的名称，如a&quot; &lt;&lt; endl;\n    for(i = 0; i &lt; G.vexnum; ++i)&#123;   \n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (i+1) &lt;&lt; &quot;个点的名称:&quot;;\n        cin &gt;&gt; G.vexs[i];                        \t\t\t//依次输入点的信息 \n    &#125;\n    cout &lt;&lt; endl;\n    for(i = 0; i &lt; G.vexnum; ++i)                \t\t\t//初始化邻接矩阵，边的权值均置为极大值MaxInt \n        for(j = 0; j &lt; G.vexnum; ++j)   \n            G.arcs[i][j] = 0; \n    cout &lt;&lt; &quot;输入边依附的顶点，如a b&quot; &lt;&lt; endl;\n    for(k = 0; k &lt; G.arcnum;++k)&#123;\t\t\t\t\t\t\t//构造邻接矩阵 \n        VerTexType v1 , v2;\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (k + 1) &lt;&lt; &quot;条边依附的顶点:&quot;;\n        cin &gt;&gt; v1 &gt;&gt; v2;\t\t\t\t\t\t\t\t\t//输入一条边依附的顶点\n        i = LocateVex(G, v1);  j = LocateVex(G, v2);\t\t//确定v1和v2在G中的位置，即顶点数组的下标 \n        G.arcs[i][j] = 1;\t\t\t\t\t\t\t\t\t//边&lt;v1, v2&gt;的权值置为w \n        G.arcs[j][i] = G.arcs[i][j];\t\t\t\t\t\t//置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w \n    &#125;//for \n&#125;//CreateUDN\n\nint FirstAdjVex(Graph G , int v)&#123;\n    //返回v的第一个邻接点\n    int i;\n    for(i = 0 ; i &lt; G.vexnum ; ++i)&#123;\n        if(G.arcs[v][i] == 1 &amp;&amp; visited[i] == false)\n            return i;\n    &#125;\n    return -1;\n&#125;//FirstAdjVex\n\nint NextAdjVex(Graph G , int u , int w)&#123;\n    //返回v相对于w的下一个邻接点\n    int i;\n    for(i = w ; i &lt; G.vexnum ; ++i)&#123;\n        if(G.arcs[u][i] == 1 &amp;&amp; visited[i] == false)\n            return i;\n    &#125;\n    return -1;\n&#125;//NextAdjVex\n\nvoid BFS (Graph G, int v)&#123; \n    //按广度优先非递归遍历连通图G \n    sqQueue Q;\n    ArcType u;\n    ArcType w;\n\n    cout &lt;&lt; G.vexs[v] &lt;&lt; &quot;  &quot;;    visited[v] = true;     \t\t\t\t\t\t//访问第v个顶点，并置访问标志数组相应分量值为true \n    InitQueue(Q);              \t\t\t\t\t\t\t\t\t\t\t\t\t//辅助队列Q初始化，置空         \n    EnQueue(Q, v);            \t\t\t\t\t\t\t\t\t\t\t\t\t//v进队 \n    while(!QueueEmpty(Q))&#123;   \t\t\t\t\t\t\t\t\t\t\t\t\t//队列非空 \n        DeQueue(Q, u);       \t\t\t\t\t\t\t\t\t\t\t\t\t//队头元素出队并置为u\n        for(w = FirstAdjVex(G, u); w &gt;= 0; w = NextAdjVex(G, u, w))&#123;\n            //依次检查u的所有邻接点w ，FirstAdjVex(G, u)表示u的第一个邻接点 \n            //NextAdjVex(G, u, w)表示u相对于w的下一个邻接点，w≥0表示存在邻接点 \n            if(!visited[w])&#123;\t           \t\t\t\t\t\t\t\t\t\t//w为u的尚未访问的邻接顶点 \n                cout &lt;&lt; G.vexs[w] &lt;&lt; &quot;  &quot;;   visited[w] = true;\t\t\t\t\t//访问w，并置访问标志数组相应分量值为true \n                EnQueue(Q, w);\t\t\t\t\t\t\t\t\t\t\t\t\t//w进队 \n            &#125;//if \n        &#125;//for\n    &#125;//while \n&#125;//BFS \n\nint main()&#123;\n    cout &lt;&lt; &quot;************算法广度优先搜索遍历连通图**************&quot; &lt;&lt; endl &lt;&lt; endl;\n    Graph G;\n    CreateUDN(G);\n    cout &lt;&lt; endl;\n    cout &lt;&lt; &quot;无向连通图G创建完成！&quot; &lt;&lt; endl &lt;&lt; endl;\n    \n    cout &lt;&lt; &quot;请输入遍历连通图的起始点：&quot;;\n    VerTexType c;\n    cin &gt;&gt; c;\n    \n    int i;\n    for(i = 0 ; i &lt; G.vexnum ; ++i)&#123;\n        if(c == G.vexs[i])\n            break;\n    &#125;\n    cout &lt;&lt; endl;\n    while(i &gt;= G.vexnum)&#123;\n        cout &lt;&lt; &quot;该点不存在，请重新输入！&quot; &lt;&lt; endl;\n        cout &lt;&lt; &quot;请输入遍历连通图的起始点：&quot;;\n        cin &gt;&gt; c;\n        for(i = 0 ; i &lt; G.vexnum ; ++i)&#123;\n            if(c == G.vexs[i])\n                break;\n        &#125;\n    &#125;\n    cout &lt;&lt; &quot;深度优先搜索遍历连通图结果：&quot; &lt;&lt; endl;\n    BFS(G , i);\n    \n    cout &lt;&lt;endl;\n    return 0;\n&#125;//main\n</code></pre>\n<hr>\n<h1 id=\"5、图的应用\"><a href=\"#5、图的应用\" class=\"headerlink\" title=\"5、图的应用\"></a>5、图的应用</h1><h2 id=\"①-最小生成树\"><a href=\"#①-最小生成树\" class=\"headerlink\" title=\"①.最小生成树\"></a>①.最小生成树</h2><p>&#x3D;&#x3D;<strong>极小连通子图</strong>:该子图是G的连通子图，在该子图中删除任何一条边，子图不再连通。&#x3D;&#x3D;</p>\n<p>&#x3D;&#x3D;<strong>生成树</strong>:包含图G所有顶点的极小连通子图&#x3D;&#x3D;</p>\n<p>生成树的顶点集合与图的顶点集合相等，顶点数为n；不存在回路，边数为n-1</p>\n<p><img src=\"https://img-blog.csdnimg.cn/7aa8f27f6d864a329b6750fd66fbb135.png#pic_center\"></p>\n<p><strong>在网的多个生成树中，寻找一个各边权值之和最小的生成树，即最小生成树</strong></p>\n<p>构造最小生成树的准则：</p>\n<ul>\n<li>必须只使用该网中的边来构造最小生成树;</li>\n<li>必须使用且仅使用n-1条边来联结网络中的n个顶点</li>\n<li>不能使用产生回路的边</li>\n</ul>\n<p><strong>普里姆算法（加点法）</strong></p>\n<p>假设N&#x3D;(V,E)是连通网，TE是N上最小生成树中边的集合。</p>\n<ol>\n<li>U&#x3D; {u<del>0</del>}(u<del>0</del>∈V)，TE&#x3D;{}。</li>\n<li>在所有u∈U，v∈V-U的边(u,v)∈E中找一条权值最小的边(u<del>0</del>, v<del>0</del>)并入集合TE，同时v<del>0</del>并人U。</li>\n<li>重复②，直至U&#x3D;V为止。</li>\n</ol>\n<p>此时TE中必有n-1条边，则T&#x3D;(V，TE)为N的最小生成树。</p>\n<p>普里姆算法构造最小生成树的过程：<br><img src=\"https://img-blog.csdnimg.cn/7c65af846b0e43f7a91af401c9275f28.png#pic_center\"><br>图采用邻接矩阵存储，二维数组closedeg，记录从U到V-U具有最小代价的边。<br>对每个顶点vi, v-U在辅助数组存在一个相应的分量closedge[i-1]，它包括两个域:</p>\n<pre><code class=\"cpp\">typedef struct\n&#123;\n    VertexType adjvex; // 最小边的顶点\n    VRType lowcost;    // 最小边的权值\n&#125; closedge[MAX_VERTEX_NUM];\n</code></pre>\n<p>adjvex:依附于这条最小代价边的另一个顶点。</p>\n<ul>\n<li>等于0表示顶点i已在U中;</li>\n<li>大于0表示顶点i还在V-U中。</li>\n</ul>\n<p>所以，每次循环须在lowcost &gt;0(在集合V-U中)的那些顶点中选择lowcost最小的顶点加入到集合U中，同时将相关顶点的closedge作相应的调整。</p>\n<pre><code class=\"cpp\">//普里姆算法\n#include &lt;iostream&gt;\nusing namespace std;\n\ntypedef char VerTexType;\ntypedef int ArcType;\n#define MVNum 100\n#define MaxInt 32767                    \t//表示极大值，即∞\n\n//辅助数组的定义，用来记录从顶点集U到V-U的权值最小的边\nstruct&#123;\n    VerTexType adjvex;\t\t\t\t\t\t//最小边在U中的那个顶点\n    ArcType lowcost;\t\t\t\t\t\t//最小边上的权值\n&#125;closedge[MVNum];\n\n//- - - - -图的邻接表存储表示- - - - - \t\t\t\t\t\t\ntypedef char VerTexType;              \t\t//假设顶点的数据类型为字符型 \ntypedef int ArcType;                  \t\t//假设边的权值类型为整型 \ntypedef struct&#123; \n    VerTexType vexs[MVNum];            \t\t//顶点表 \n    ArcType arcs[MVNum][MVNum];      \t\t//邻接矩阵 \n    int vexnum,arcnum;                \t\t//图的当前点数和边数 \n&#125;AMGraph;\n\nint LocateVex(AMGraph G , VerTexType v)&#123;\n    //确定点v在G中的位置\n    for(int i = 0; i &lt; G.vexnum; ++i)\n        if(G.vexs[i] == v)\n            return i;\n        return -1;\n&#125;//LocateVex\n\nvoid CreateUDN(AMGraph &amp;G)&#123; \n    //采用邻接矩阵表示法，创建无向网G \n    int i , j , k;\n    cout &lt;&lt;&quot;请输入总顶点数，总边数，以空格隔开:&quot;;\n    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;\t\t\t\t\t\t\t//输入总顶点数，总边数\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;输入点的名称，如a&quot; &lt;&lt; endl;\n\n    for(i = 0; i &lt; G.vexnum; ++i)&#123;   \n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (i+1) &lt;&lt; &quot;个点的名称:&quot;;\n        cin &gt;&gt; G.vexs[i];                        \t\t\t//依次输入点的信息 \n    &#125;\n    cout &lt;&lt; endl;\n    for(i = 0; i &lt; G.vexnum; ++i)                \t\t\t//初始化邻接矩阵，边的权值均置为极大值MaxInt \n        for(j = 0; j &lt; G.vexnum; ++j)   \n            G.arcs[i][j] = MaxInt;\n    cout &lt;&lt; &quot;输入边依附的顶点及权值，如a b 5&quot; &lt;&lt; endl;\n    for(k = 0; k &lt; G.arcnum;++k)&#123;\t\t\t\t\t\t\t//构造邻接矩阵 \n        VerTexType v1 , v2;\n        ArcType w;\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (k + 1) &lt;&lt; &quot;条边依附的顶点及权值:&quot;;\n        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;\t\t\t\t\t\t\t\t//输入一条边依附的顶点及权值\n        i = LocateVex(G, v1);  j = LocateVex(G, v2);\t\t//确定v1和v2在G中的位置，即顶点数组的下标 \n        G.arcs[i][j] = w;\t\t\t\t\t\t\t\t\t//边&lt;v1, v2&gt;的权值置为w \n        G.arcs[j][i] = G.arcs[i][j];\t\t\t\t\t\t//置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w \n    &#125;//for\n&#125;//CreateUDN \n\nint Min(AMGraph G)&#123;\n    //返回权值最小的点\n    int i;\n    int index = -1;\n    int min = MaxInt;\n    for(i = 0 ; i &lt; G.vexnum ; ++i)&#123;\n        if(min &gt; closedge[i].lowcost &amp;&amp; closedge[i].lowcost != 0)&#123;\n            min = closedge[i].lowcost;\n            index = i;\n        &#125;\n    &#125;//for\n    return index;\n&#125;//Min\n\nvoid MiniSpanTree_Prim(AMGraph G, VerTexType u)&#123; \n    //无向网G以邻接矩阵形式存储，从顶点u出发构造G的最小生成树T，输出T的各条边  \n    int k , j , i;\n    VerTexType u0 , v0;\n    k =LocateVex(G, u);           \t\t\t\t\t\t\t\t\t\t//k为顶点u的下标 \n    for(j = 0; j &lt; G.vexnum; ++j)&#123;     \t\t\t\t\t\t\t\t\t//对V-U的每一个顶点vi，初始化closedge[i] \n        if(j != k)&#123;  \n            closedge[j].adjvex = u;\n            closedge[j].lowcost = G.arcs[k][j];\t\t\t\t\t\t\t//&#123;adjvex, lowcost&#125;\n        &#125;//if\n    &#125;//for\n    closedge[k].lowcost = 0;        \t\t\t\t\t\t\t\t\t//初始，U = &#123;u&#125;\n    for(i = 1; i &lt; G.vexnum; ++i)&#123;     \t\t\t\t\t\t\t\t\t//选择其余n-1个顶点，生成n-1条边(n= G.vexnum) \n        k = Min(G);  \n        //求出T的下一个结点：第k个顶点，closedge[k]中存有当前最小边 \n        u0 = closedge[k].adjvex;     \t\t\t\t\t\t\t\t\t//u0为最小边的一个顶点，u0∈U \n        v0 = G.vexs[k];            \t\t\t\t\t\t\t\t\t\t//v0为最小边的另一个顶点，v0∈V-U \n        cout &lt;&lt; &quot;边  &quot; &lt;&lt;u0 &lt;&lt; &quot;---&gt;&quot; &lt;&lt; v0 &lt;&lt; endl;           \t\t\t//输出当前的最小边(u0, v0) \n        closedge[k].lowcost = 0;   \t\t//第k个顶点并入U集 \n        for(j = 0; j &lt; G.vexnum; ++j) \n            if(G.arcs[k][j] &lt; closedge[j].lowcost)&#123;\t\t\t\t\t\t//新顶点并入U后重新选择最小边 \n                closedge[j].adjvex = G.vexs[k];\n                closedge[j].lowcost = G.arcs[k][j];\n            &#125;//if \n    &#125;//for \n&#125;//MiniSpanTree_Prim \n\nint main()&#123;\n    cout &lt;&lt; &quot;************普里姆算法**************&quot; &lt;&lt; endl &lt;&lt; endl;\n    AMGraph G;\n    CreateUDN(G);\n    cout &lt;&lt; endl;\n    cout &lt;&lt; &quot;无向图G创建完成！&quot; &lt;&lt; endl;\n    cout &lt;&lt;endl;\n\n    cout &lt;&lt; &quot;******利用普里姆算法构造最小生成树结果：******&quot; &lt;&lt; endl;\n    MiniSpanTree_Prim(G , &#39;a&#39;);\n    cout &lt;&lt;endl;\n    return 0;\n&#125;//main\n</code></pre>\n<p>例：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/68cdd0b7c94e4c80801213acdbe9c2a6.png#pic_center\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/8a355d87f12b4b6eb539091803185229.png#pic_center\"></p>\n<p><strong>克鲁斯卡尔算法（加边法）</strong></p>\n<p>假设连通网N&#x3D;(V,E)，将Ⅳ中的边按权值从小到大的顺序排列。</p>\n<ol>\n<li>初始状态为只有n个顶点而无边的非连通图T&#x3D;(V, {),图中每个顶点自成一个连通分量。</li>\n<li>在E中选择权值最小的边，若该边依附的顶点落在T中不同的连通分量上（即不形成回路)，则将此边加人到T中，否则舍去此边而选择下一条权值最小的边。</li>\n<li>重复②，直至T中所有顶点都在同一连通分量上为止。</li>\n</ol>\n<p>克鲁斯卡尔算法构造最小生成树的过程：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/a43e87665309443fa2522ac0c235f508.png#pic_center\"></p>\n<p>算法的实现要引人以下辅助的数据结构。</p>\n<ol>\n<li>结构体数组Edge:存储边的信息，包括边的两个顶点信息和权值。</li>\n</ol>\n<pre><code class=\"cpp\">//辅助数组Edges的定义\nstruct\n&#123;\n    VerTexType Head; //边的始点\n    VerTexType Tail; //边的终点\n    ArcType lowcost; //边上的权值\n&#125; Edge[arcnnum];\n</code></pre>\n<ol start=\"2\">\n<li>Vexset[i]:标识各个顶点所属的连通分量。对每个顶点v,EV，在辅助数组中存在一个相应元素Vexset[i]表示该顶点所在的连通分量。初始时Vexset[i]&#x3D;i，表示各顶点自成一个连通分量。</li>\n</ol>\n<pre><code class=\"cpp\">//辅助数组Vexset的定义\nint Vexset[MVNum];\n</code></pre>\n<ol>\n<li>将数组Edge中的元素按权值从小到大排序。</li>\n<li>依次查看数组Edge中的边,循环执行以下操作:</li>\n</ol>\n<ul>\n<li>依次从排好序的数组 Edge 中选出一条边(U<del>1</del>,U<del>2</del>);</li>\n<li>在Vexset中分别查找v<del>1</del>和v<del>2</del>所在的连通分量vs<del>1</del>和 vs<del>2</del>，进行判断:<br>  - 如果vs<del>1</del>,和vs<del>2</del>不等、表明所选的两个顶点分属不同的连通分量,输出此边,并合并vs<del>1</del>,和 vs<del>2</del>两个连通分量;<br>  - 如果vs<del>1</del>,和 vs<del>2</del>相等，表明所选的两个顶点属于同一个连通分量，舍去此边而选择下一条权值最小的边。</li>\n</ul>\n<pre><code class=\"cpp\">//克鲁斯卡尔算法\n\n#include &lt;iostream&gt;\nusing namespace std;\n\ntypedef char VerTexType;              \t\t//假设顶点的数据类型为字符型 \ntypedef int ArcType;   \n#define MVNum 100                       \t//最大顶点数\n#define MaxInt 32767                    \t//表示极大值，即∞\n\n//----------------图的邻接矩阵---------------------\ntypedef struct&#123; \n    VerTexType vexs[MVNum];            \t\t//顶点表 \n    ArcType arcs[MVNum][MVNum];      \t\t//邻接矩阵 \n    int vexnum,arcnum;                \t\t//图的当前点数和边数 \n&#125;AMGraph;\n\n//辅助数组Edges的定义\nstruct&#123;\n    VerTexType Head;\t\t\t\t\t\t//边的始点\n    VerTexType Tail;\t\t\t\t\t\t//边的终点\n    ArcType lowcost;\t\t\t\t\t\t//边上的权值\n&#125;Edge[(MVNum * (MVNum - 1)) / 2];\n\nint Vexset[MVNum];\t\t\t\t\t\t\t//辅助数组Vexset的定义\n\nint LocateVex(AMGraph G , VerTexType v)&#123;\n    //确定点v在G中的位置\n    for(int i = 0; i &lt; G.vexnum; ++i)\n        if(G.vexs[i] == v)\n            return i;\n        return -1;\n&#125;//LocateVex\n\nvoid CreateUDN(AMGraph &amp;G)&#123; \n    //采用邻接矩阵表示法，创建无向网G \n    int i , j , k;\n    cout &lt;&lt;&quot;请输入总顶点数，总边数，以空格隔开:&quot;;\n    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;\t\t\t\t\t\t//输入总顶点数，总边数\n    cout &lt;&lt; endl;\n    \n    cout &lt;&lt; &quot;输入点的名称，如a&quot; &lt;&lt; endl;\n\n    for(i = 0; i &lt; G.vexnum; ++i)&#123;   \n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (i+1) &lt;&lt; &quot;个点的名称:&quot;;\n        cin &gt;&gt; G.vexs[i];                        \t\t//依次输入点的信息 \n    &#125;\n    cout &lt;&lt; endl;\n    for(i = 0; i &lt; G.vexnum; ++i)                \t\t//初始化邻接矩阵，边的权值均置为极大值MaxInt \n        for(j = 0; j &lt; G.vexnum; ++j) \n            G.arcs[i][j] = MaxInt; \n    cout &lt;&lt; &quot;输入边依附的顶点及权值，如a b 6&quot; &lt;&lt; endl;\n    for(k = 0; k &lt; G.arcnum;++k)&#123;\t\t\t\t\t\t//构造邻接矩阵 \n        VerTexType v1 , v2;\n        ArcType w;\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (k + 1) &lt;&lt; &quot;条边依附的顶点及权值:&quot;;\n        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;                           //输入一条边依附的顶点及权值\n        i = LocateVex(G, v1);  j = LocateVex(G, v2);\t//确定v1和v2在G中的位置，即顶点数组的下标 \n        G.arcs[i][j] = w;\t\t\t\t\t\t\t\t//边&lt;v1, v2&gt;的权值置为w \n        G.arcs[j][i] = G.arcs[i][j];\t\t\t\t\t//置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w \n        Edge[k].lowcost = w;\n        Edge[k].Head = v1;\n        Edge[k].Tail = v2;\n    &#125;//for\n&#125;//CreateUDN \n\n//----------冒泡排序-------------------\nvoid Sort(AMGraph G)&#123;\n    int m = G.arcnum - 2;\n    int flag = 1;\n    while((m &gt; 0) &amp;&amp; flag == 1)&#123;\n        flag = 0;\n        for(int j = 0 ; j &lt;= m ; j++)&#123;\n            if(Edge[j].lowcost &gt; Edge[j+ 1].lowcost)&#123;\n                flag = 1;\n\n                VerTexType temp_Head = Edge[j].Head;\n                Edge[j].Head = Edge[j+ 1].Head;\n                Edge[j + 1].Head = temp_Head;\n                \n\n                VerTexType temp_Tail = Edge[j].Tail;\n                Edge[j].Tail = Edge[j+ 1].Tail;\n                Edge[j + 1].Tail = temp_Tail;\n                \n                ArcType temp_lowcost = Edge[j].lowcost;\n                Edge[j].lowcost = Edge[j+ 1].lowcost;\n                Edge[j + 1].lowcost = temp_lowcost;\n            &#125;//if\n        &#125;//for\n        --m;\n    &#125;//while\n&#125;//Sort\n\nvoid MiniSpanTree_Kruskal(AMGraph G)&#123; \n    //无向网G以邻接矩阵形式存储，构造G的最小生成树T，输出T的各条边     \n    int i , j , v1 , v2 , vs1 , vs2;\n    Sort(G);                 \t\t\t\t\t\t\t//将数组Edge中的元素按权值从小到大排序 \n    for(i = 0; i &lt; G.vexnum; ++i)     \t\t\t\t\t//辅助数组，表示各顶点自成一个连通分量 \n        Vexset[i] = i;\n    for(i = 0; i &lt; G.arcnum; ++i)&#123;      \n        //依次查看排好序的数组Edge中的边是否在同一连通分量上     \n        v1 =LocateVex(G, Edge[i].Head);     \t\t\t//v1为边的始点Head的下标 \n        v2 =LocateVex(G, Edge[i].Tail);     \t\t\t//v2为边的终点Tail的下标 \n        vs1 = Vexset[v1];       \t\t\t\t\t\t//获取边Edge[i]的始点所在的连通分量vs1 \n        vs2 = Vexset[v2];       \t\t\t\t\t\t//获取边Edge[i]的终点所在的连通分量vs2 \n        if(vs1 != vs2)&#123;         \t\t\t\t\t\t//边的两个顶点分属不同的连通分量 \n            cout &lt;&lt; Edge[i].Head &lt;&lt; &quot;--&gt;&quot; &lt;&lt; Edge[i].Tail &lt;&lt; endl;\t\t//输出此边 \n            for(j = 0; j &lt; G.vexnum; ++j)      \t\t\t//合并vs1和vs2两个分量，即两个集合统一编号 \n                if(Vexset[j] == vs2) Vexset[j] = vs1;\t//集合编号为vs2的都改为vs1 \n        &#125;//if \n    &#125;//for \n&#125;//MiniSpanTree_Kruskal\n\nvoid main()&#123;\n    cout &lt;&lt; &quot;************克鲁斯卡尔算法**************&quot; &lt;&lt; endl &lt;&lt; endl;\n    AMGraph G;\n    CreateUDN(G);\n    \n    cout &lt;&lt;endl;\n    cout &lt;&lt; &quot;*****无向网G创建完成！*****&quot; &lt;&lt; endl;\n\n    cout &lt;&lt;endl;\n    MiniSpanTree_Kruskal(G);\n&#125;///main\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/a8e58fb9d70c4c5280aa65a5254f5042.png#pic_center\"></p>\n<h2 id=\"②-最短路径\"><a href=\"#②-最短路径\" class=\"headerlink\" title=\"②.最短路径\"></a>②.最短路径</h2><p>&#x3D;&#x3D;对于图来说，从一个顶点到另一个顶点可能存在多条路径，每条路径的所包含的边数可能不同。<strong>把所包含的边数最少的那条称为最短路径</strong>。&#x3D;&#x3D;</p>\n<p><strong>最短路径</strong>:对于网(带权的图)来说，从一个顶点到另一个顶点所经过的边的权值之和称为带权路径长度，把带权路径长度最短的那条称为最短路径</p>\n<p><strong>从某个源点到其余各顶点的最短路径——迪杰斯特拉(Dijkstra)算法</strong></p>\n<ol>\n<li>初始化:先找出从源点v<del>0</del>到各终点v的直达路径(v<del>0</del>,v<del>k</del>)，即通过一条弧到达的路径。</li>\n<li>选择:从这些路径中找出一条长度最短的路径(v<del>0</del>,u) 。</li>\n<li>更新:然后对其余各条路径进行适当调整。</li>\n</ol>\n<p>若在图中存在弧(u，v<del>k</del>) ，(v<del>0</del>，u) +(u，v<del>k</del>)&lt; (v<del>0</del>，v<del>k</del>) ,则以路径(v<del>0</del>,u,v<del>k</del>)代替（v<del>0</del>，v<del>k</del>)。<br>在调整后的各条路径中，再找长度最短的路径。</p>\n<p><strong>主要存储结构</strong>︰邻接矩阵G [n][n] (或者邻接表)</p>\n<p><strong>辅助存储结构︰</strong></p>\n<p><strong>数组S[n]:记录相应顶点是否已被确定最短距离</strong><br>true:确定 false:未确定</p>\n<p><strong>数组D[n]:记录源点到相应顶点路径长度</strong><br>初值:如果v0到vi有弧，则D[i]为弧上权值;否则为∞</p>\n<p><strong>数组Path[n]:记录相应顶点的前驱顶点</strong><br>初值:如果v0到vi有弧，则Path[i]为v0，否则为-1</p>\n<p><img src=\"https://img-blog.csdnimg.cn/038a7079b88046a596939a4f7bb02e22.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/a7e8feebb53f4e9ab82572c897006119.png#pic_center\"></p>\n<ol>\n<li><p>初始化:<br>将源点v0加到S中，即S[v0] &#x3D; true;<br>将v0到各个终点的最短路径长度初始化为权值，即D[i]&#x3D; G.arcs[v0][vi]，(vi∈V -S);<br>如果v0和顶点vi之间有弧，则将vi的前驱置为v0，即Path[i] &#x3D; v0，否则Path[i] &#x3D; -1。</p>\n</li>\n<li><p>循环n-1次，执行以下操作:<br>选择下一条最短路径的终点vk，使得:D[k]&#x3D;Min{D[i]viEV-S}<br>将vk加到S中，即S[vk] &#x3D; true。<br>更新从v0出发到集合V-S上任一顶点的最短路径的长度，同时更改vi的前驱为vk。<br>若S[i]&#x3D;false 且D[k]+G.arcs[k][i]&lt;D[i]，则更新D[i]-D[k]+ G.arcs[k][i; Path [i]&#x3D;k;。</p>\n</li>\n</ol>\n<pre><code class=\"cpp\">//最短路径--迪杰斯特拉算法\n#include &lt;iostream&gt;\nusing namespace std;\n\n#define MaxInt 32767                    \t\t\t\t\t//表示极大值，即∞\n#define MVNum 100                       \t\t\t\t\t//最大顶点数\ntypedef char VerTexType;              \t\t\t\t\t\t//假设顶点的数据类型为字符型 \ntypedef int ArcType;                  \t\t\t\t\t\t//假设边的权值类型为整型\n\nint *D=new int[MVNum];\t                    \t\t\t\t//用于记录最短路的长度\nbool *S=new bool[MVNum];          \t\t\t\t\t\t\t//标记顶点是否进入S集合\nint *Path=new int[MVNum];\t\t\t\t\t\t\t\t\t//用于记录最短路顶点的前驱\n\n//------------图的邻接矩阵-----------------\ntypedef struct&#123; \n    VerTexType vexs[MVNum];            \t\t\t\t\t\t//顶点表 \n    ArcType arcs[MVNum][MVNum];      \t\t\t\t\t\t//邻接矩阵 \n    int vexnum,arcnum;                \t\t\t\t\t\t//图的当前点数和边数 \n&#125;AMGraph;\n\nint LocateVex(AMGraph G , VerTexType v)&#123;\n    //确定点v在G中的位置\n    for(int i = 0; i &lt; G.vexnum; ++i)\n        if(G.vexs[i] == v)\n            return i;\n   return -1;\n&#125;//LocateVex\n\nvoid CreateUDN(AMGraph &amp;G)&#123; \n    //采用邻接矩阵表示法，创建无向网G \n    int i , j , k;\n    cout &lt;&lt;&quot;请输入总顶点数，总边数，以空格隔开:&quot;;\n    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;\t\t\t\t\t\t\t//输入总顶点数，总边数\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;输入点的名称:，如a&quot; &lt;&lt; endl;\n\n    for(i = 0; i &lt; G.vexnum; ++i)&#123;   \n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (i+1) &lt;&lt; &quot;个点的名称:&quot;;\n        cin &gt;&gt; G.vexs[i];                        \t\t\t//依次输入点的信息 \n    &#125;\n    cout &lt;&lt; endl;\n    for(i = 0; i &lt; G.vexnum; ++i)                \t\t\t//初始化邻接矩阵，边的权值均置为极大值MaxInt \n        for(j = 0; j &lt; G.vexnum; ++j)   \n            G.arcs[i][j] = MaxInt; \n    cout &lt;&lt; &quot;输入边依附的顶点及权值，如a b 7&quot; &lt;&lt; endl;\n    for(k = 0; k &lt; G.arcnum;++k)&#123;\t\t\t\t\t\t\t//构造邻接矩阵 \n        VerTexType v1 , v2;\n        ArcType w;\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (k + 1) &lt;&lt; &quot;条边依附的顶点及权值:&quot;;\n        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;\t\t\t\t\t\t\t\t//输入一条边依附的顶点及权值\n        i = LocateVex(G, v1);  j = LocateVex(G, v2);\t\t//确定v1和v2在G中的位置，即顶点数组的下标 \n        G.arcs[i][j] = w;\t\t\t\t\t\t\t\t\t//边&lt;v1, v2&gt;的权值置为w \n        G.arcs[j][i] = G.arcs[i][j];\t\t\t\t\t\t//置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w \n    &#125;//for\n&#125;//CreateUDN\n\nvoid ShortestPath_DIJ(AMGraph G, int v0)&#123; \n    //用Dijkstra算法求有向网G的v0顶点到其余顶点的最短路径 \n    int v , i , w , min;\n    int n = G.vexnum;                    \t\t\t\t\t//n为G中顶点的个数 \n\n    for(v = 0; v &lt; n; ++v)&#123;             \t\t\t\t\t//n个顶点依次初始化 \n        S[v] = 0;                  \t\t\t\t\t\t//S初始为空集 \n        D[v] = G.arcs[v0][v];           \t\t\t\t\t//将v0到各个终点的最短路径长度初始化为弧上的权值 \n        if(D[v] &lt; MaxInt)  Path [v] = v0;  \t\t\t\t\t//如果v0和v之间有弧，则将v的前驱置为v0 \n        else Path [v] = -1;               \t\t\t\t\t//如果v0和v之间无弧，则将v的前驱置为-1 \n    &#125;//for \n\n    S[v0]=true;                    \t\t\t\t\t\t\t//将v0加入S \n    D[v0]=0;                      \t\t\t\t\t\t\t//源点到源点的距离为0 \n\n    /*―初始化结束，开始主循环，每次求得v0到某个顶点v的最短路径，将v加到S集―*/ \n    for(i = 1;i &lt; n; ++i)&#123;\t\t\t\t\t\t\t\t\t//对其余n-1个顶点，依次进行计算 \n        min= MaxInt; \n        for(w = 0; w &lt; n; ++w) \n            if(!S[w] &amp;&amp; D[w] &lt; min)&#123;\t\t\t\t\t\t//选择一条当前的最短路径，终点为v \n                v = w; \n                min = D[w];\n            &#125;//if         \t\n        S[v]=true;                   \t\t\t\t\t\t//将v加入S \n        for(w = 0;w &lt; n; ++w)           \t\t\t\t\t//更新从v0出发到集合V?S上所有顶点的最短路径长度 \n            if(!S[w] &amp;&amp; (D[v] + G.arcs[v][w] &lt; D[w]))&#123; \n                D[w] = D[v] + G.arcs[v][w];   \t\t\t\t//更新D[w] \n                Path [w] = v;              \t\t\t\t\t//更改w的前驱为v \n            &#125;//if \n    &#125;//for  \n&#125;//ShortestPath_DIJ\n\nvoid DisplayPath(AMGraph G , int begin ,int temp )&#123;\n    //显示最短路\n    if(Path[temp] != -1)&#123;\n        DisplayPath(G , begin ,Path[temp]);\n        cout &lt;&lt; G.vexs[Path[temp]] &lt;&lt; &quot;--&gt;&quot;;\n    &#125;\n&#125;//DisplayPath\n\nint main()\n&#123;\n    cout &lt;&lt; &quot;************迪杰斯特拉算法**************&quot; &lt;&lt; endl &lt;&lt; endl;\n    AMGraph G; \n    int i , j ,num_start , num_destination;\n    VerTexType start , destination;\n    CreateUDN(G);\n    cout &lt;&lt;endl;\n    cout &lt;&lt; &quot;*****无向网G创建完成！*****&quot; &lt;&lt; endl;\n    \n    for(i = 0 ; i &lt; G.vexnum ; ++i)&#123;\n        for(j = 0; j &lt; G.vexnum; ++j)&#123;\n            if(j != G.vexnum - 1)&#123;\n                if(G.arcs[i][j] != MaxInt)\n                    cout &lt;&lt; G.arcs[i][j] &lt;&lt; &quot;\\t&quot;;\n                else\n                    cout &lt;&lt; &quot;∞&quot; &lt;&lt; &quot;\\t&quot;;\n            &#125;\n            else&#123;\n                if(G.arcs[i][j] != MaxInt)\n                    cout &lt;&lt; G.arcs[i][j] &lt;&lt;endl;\n                else\n                    cout &lt;&lt; &quot;∞&quot; &lt;&lt;endl;\n            &#125;\n        &#125;\n    &#125;//for\n    cout &lt;&lt; endl;\n    cout &lt;&lt; &quot;请依次输入起始点、终点名称：&quot;;\n    cin &gt;&gt; start &gt;&gt; destination;\n    num_start = LocateVex(G , start);\n    num_destination = LocateVex(G , destination);\n    ShortestPath_DIJ(G , num_start);\n    cout &lt;&lt; endl &lt;&lt;&quot;最短路径为：&quot;;\n    DisplayPath(G , num_start , num_destination);\n    cout &lt;&lt; G.vexs[num_destination]&lt;&lt;endl;\n&#125;//main\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/4e8ee1ea34e94afc836d76cfa65c6023.png#pic_center\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/4c87f7ab6ffd433789da118140851b63.png#pic_center\"></p>\n<p><strong>每一对顶点之间的最短路径——弗洛伊德(Floyd)算法</strong></p>\n<p>从图的带权邻接矩阵G.arcs出发，<br>假设求顶点Vi到Vj的最短路径。如果从Vi到Vj有弧，则从Vi到Vj存在—条长度为G.arcs[i]i]的路径，但该路径是否一定是最短路径，还需要进行n次试探。</p>\n<ol>\n<li>第一次，判别( Vi, V0 ）和( V0, Vj ) ，即判别(Vi, V0 , Vj)是否存在，若存在，则比较（Vi,<br>Vj）和(Vi, V0 , Vj)的长度，取长度较短的为从Vi到Vj的中间顶点序号不大于0的最短路径。</li>\n<li>第二次，再加一个顶点V1，如果(Vi,… , V1)和(V1,…,<br>Vj)分别是当前找到的中间顶点序号不大于0的最短路径，那么(Vi,… ,V1,…,<br>Vj）就有可能是从Vi到Vj的中间顶点序号不大于1的最短路径。将它和已经得到的从Vi到Vj之间顶点序号不大于0的最短路径相比较，取较短者为从Vi到Vj的中间顶点序号不大于1的最短路径。</li>\n<li>第三次，再加一个顶点V2，继续进行试探。</li>\n</ol>\n<p><strong>求最短路径步骤:</strong></p>\n<ol>\n<li>初始时设置一个n阶方阵,令其对角线元素为0，若存在弧&lt;V<del>i</del>，V<del>j</del> &gt;，则对应元素为权值;否则为无穷大。</li>\n<li>逐步试着在原直接路径中增加中间顶点，若加入中间顶点后路径变短，则修改之;否则，维持原值。所有顶点试探完毕，算法结束。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/cec207c29cff42d29bc1a5b9cdefad02.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/4efd153b2556458a96cbc792a5a112b5.png#pic_center\"></p>\n<pre><code class=\"cpp\">//弗洛伊德算法\n\n#include &lt;iostream&gt;\nusing namespace std;\n\n#define MaxInt 32767                    \t//表示极大值，即∞\n#define MVNum 100                       \t//最大顶点数\n\ntypedef char VerTexType;              \t\t//假设顶点的数据类型为字符型 \ntypedef int ArcType;                  \t\t//假设边的权值类型为整型 \n\nint Path[MVNum][MVNum];\t\t\t\t\t\t//最短路径上顶点vj的前一顶点的序号\nint D[MVNum][MVNum];\t\t\t\t\t\t//记录顶点vi和vj之间的最短路径长度\n\n//------------图的邻接矩阵---------------\ntypedef struct&#123; \n    VerTexType vexs[MVNum];            \t\t//顶点表 \n    ArcType arcs[MVNum][MVNum];      \t\t//邻接矩阵 \n    int vexnum,arcnum;                \t\t//图的当前点数和边数 \n&#125;AMGraph;\n\nint LocateVex(AMGraph G , VerTexType v)&#123;\n    //确定点v在G中的位置\n    for(int i = 0; i &lt; G.vexnum; ++i)\n        if(G.vexs[i] == v)\n            return i;\n        return -1;\n&#125;//LocateVex\n\nvoid CreateUDN(AMGraph &amp;G)&#123; \n    //采用邻接矩阵表示法，创建有向网G \n    int i , j , k;\n    cout &lt;&lt;&quot;请输入总顶点数，总边数，以空格隔开:&quot;;\n    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;\t\t\t\t\t\t\t//输入总顶点数，总边数\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;输入点的名称，如a&quot; &lt;&lt; endl;\n\n    for(i = 0; i &lt; G.vexnum; ++i)&#123;   \n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (i+1) &lt;&lt; &quot;个点的名称:&quot;;\n        cin &gt;&gt; G.vexs[i];                        \t\t\t//依次输入点的信息 \n    &#125;\n    cout &lt;&lt; endl;\n    for(i = 0; i &lt; G.vexnum; ++i)&#123;                \t\t\t//初始化邻接矩阵，边的权值均置为极大值MaxInt \n        for(j = 0; j &lt; G.vexnum; ++j)&#123;  \n            if(j != i)\n                G.arcs[i][j] = MaxInt;  \n            else\n                G.arcs[i][j] = 0;\n        &#125;//for\n    &#125;//for\n\n    cout &lt;&lt; &quot;输入边依附的顶点及权值，如a b 3&quot; &lt;&lt; endl;\n    for(k = 0; k &lt; G.arcnum;++k)&#123;\t\t\t\t\t\t//构造邻接矩阵 \n        VerTexType v1 , v2;\n        ArcType w;\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (k + 1) &lt;&lt; &quot;条边依附的顶点及权值:&quot;;\n        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;                           //输入一条边依附的顶点及权值\n        i = LocateVex(G, v1);  j = LocateVex(G, v2);\t//确定v1和v2在G中的位置，即顶点数组的下标 \n        G.arcs[i][j] = w;\t\t\t\t\t\t\t\t//边&lt;v1, v2&gt;的权值置为w \n    &#125;//for\n&#125;//CreateUDN \n\nvoid ShortestPath_Floyed(AMGraph G)&#123; \n    //用Floyd算法求有向网G中各对顶点i和j之间的最短路径 \n    int i , j , k ;\n    for (i = 0; i &lt; G.vexnum; ++i)          \t\t//各对结点之间初始已知路径及距离 \n        for(j = 0; j &lt; G.vexnum; ++j)&#123; \n            D[i][j] = G.arcs[i][j]; \n            if(D[i][j] &lt; MaxInt &amp;&amp; i != j)  Path[i][j]=i;  \t//如果i和j之间有弧，则将j的前驱置为i \n            else Path [i][j] = -1;              \t\t//如果i和j之间无弧，则将j的前驱置为-1 \n        &#125;//for\n        for(k = 0; k &lt; G.vexnum; ++k) \n            for(i = 0; i &lt; G.vexnum; ++i) \n                for(j = 0; j &lt; G.vexnum; ++j)\n                    if(D[i][k] + D[k][j] &lt; D[i][j])&#123;   \t\t//从i经k到j的一条路径更短 \n                        D[i][j] = D[i][k]+D[k][j];    \t\t//更新D[i][j] \n                        Path[i][j] = Path[k][j];       \t\t\t//更改j的前驱为k \n                    &#125;//if \n&#125;//ShortestPath_Floyed\n\nvoid DisplayPath(AMGraph G , int begin ,int temp )&#123;\n    //显示最短路径\n    if(Path[begin][temp] != -1)&#123;\n        DisplayPath(G , begin ,Path[begin][temp]);\n        cout &lt;&lt; G.vexs[Path[begin][temp]] &lt;&lt; &quot;--&gt;&quot;;\n    &#125;\n&#125;//DisplayPath\n\nvoid main()&#123;\n    cout &lt;&lt; &quot;************弗洛伊德算法**************&quot; &lt;&lt; endl &lt;&lt; endl;\n    AMGraph G;\n    char start , destination;\n    int num_start , num_destination;\n\n    CreateUDN(G);\n    \n    cout &lt;&lt;endl;\n    cout &lt;&lt; &quot;有向网G创建完成！&quot; &lt;&lt; endl;\n    ShortestPath_Floyed(G);\n\n    cout &lt;&lt; &quot;请依次输入路径的起点与终点的名称：&quot;;\n    cin &gt;&gt; start &gt;&gt; destination;\n    num_start = LocateVex(G , start);\n    num_destination = LocateVex(G , destination);\n\n    DisplayPath(G , num_start , num_destination);\n    cout &lt;&lt; G.vexs[num_destination] &lt;&lt; endl;\n    cout &lt;&lt; &quot;最短路径的长度为：&quot; &lt;&lt; D[num_start][num_destination] &lt;&lt; endl;\n    cout &lt;&lt;endl;\n&#125;//main\n</code></pre>\n<h2 id=\"③-拓扑排序\"><a href=\"#③-拓扑排序\" class=\"headerlink\" title=\"③.拓扑排序\"></a>③.拓扑排序</h2><p>对一项工程，我们最关心两个问题:</p>\n<ol>\n<li>工程能否顺利完成;(拓扑排序)</li>\n<li>整个工程完成所必需的最短工期。(关键路径)</li>\n</ol>\n<p>&#x3D;&#x3D;有向无环图—-无环的有向图，简称DAG图( directed acycling graph)&#x3D;&#x3D;</p>\n<p>&#x3D;&#x3D;AOV网:用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以顶点表示活动，弧表示活动之间的优先制约关系，称这种有向图为顶点表示活动的网，简称AOV网。&#x3D;&#x3D;</p>\n<p>&#x3D;&#x3D;<strong>AOV网应该是一个有向无环图即DAG图。</strong>&#x3D;&#x3D;</p>\n<p><strong>拓扑排序</strong>：</p>\n<p>就是将AOV网中所有顶点排成一个线性序列(称为拓扑序列)，该序列满足∶<br>若在AOV网中由顶点vi到vj有一条路径，则在该线性序列中的顶点v<del>i</del>必定在v<del>j</del>之前</p>\n<ol>\n<li>在有向图中选一个无前驱的顶点且输出它（即入度为0)</li>\n<li>从图中删除该顶点和所有以它为起点的边</li>\n<li>重复(1)(2)，直至不存在无前驱的顶点</li>\n<li>若此时输出的顶点数小于有向图的顶点数，则说明有向图中存在环，否则输出的顶点序列为一个拓扑序列</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/8b9b6fa6e0574148b006be0fbe84b6ca.png#pic_center\"></p>\n<p>拓扑排序实现</p>\n<ol>\n<li><p>求出个顶点的入度存入数组indegree[i]中，并将入度为0的顶点入栈。</p>\n</li>\n<li><p>只要栈不空，重复以下操作<br>- 将栈顶顶点vi出栈并保存在拓扑序列数组topo中;<br>- 对顶点vi的每个邻接点vk的入度减1，如果vk的入度变为0，则将vk入栈</p>\n</li>\n<li><p>如果输出顶点个数少于AOV网的顶点个数，则网址存在有向环，无法进行拓扑排序，否则拓扑排序成功。</p>\n</li>\n</ol>\n<pre><code class=\"cpp\">//拓扑排序\n\n#include &lt;iostream&gt;\nusing namespace std;\n\n#define MVNum 100                       \t//最大顶点数\n#define OK 1\t\n#define ERROR 0 \n\ntypedef char VerTexType;\n\n//- - - - -图的邻接表存储表示- - - - - \ntypedef struct ArcNode&#123;                \t\t//边结点 \n    int adjvex;                          \t//该边所指向的顶点的位置 \n    struct ArcNode *nextarc;          \t\t//指向下一条边的指针 \n&#125;ArcNode; \n\ntypedef struct VNode&#123; \n    VerTexType data;                    \t//顶点信息 \n    ArcNode *firstarc;                \t\t//指向第一条依附该顶点的边的指针 \n&#125;VNode, AdjList[MVNum];               \t\t//AdjList表示邻接表类型 \n\ntypedef struct&#123; \n    AdjList vertices;                 \t\t//邻接表 \n    AdjList converse_vertices;\t\t\t\t//逆邻接表\n    int vexnum, arcnum;              \t\t//图的当前顶点数和边数 \n&#125;ALGraph;\n//- - - - - - - - - - - - - - - -\n\n//- - - - -顺序栈的定义- - - - -\ntypedef struct&#123;\n    int *base;\n    int *top;\n    int stacksize;\n&#125;spStack;\n//- - - - - - - - - - - - - - - -\n\nint indegree[MVNum];\t\t\t\t\t\t//数组indegree存放个顶点的入度\nspStack S;\n\n//------------栈的相关操作----------------------\nvoid InitStack(spStack &amp;S)&#123;\n    //初始化栈\n    S.base = new int[MVNum];\n    if(!S.base)\n        exit(1);\n    S.top = S.base;\n    S.stacksize = MVNum;\n&#125;//InitStack\n\nvoid Push(spStack &amp;S , int i)&#123;\n    //进栈\n    if(S.top - S.base == S.stacksize)\n        return;\n    *S.top++ = i;\n&#125;//Push\n\nvoid Pop(spStack &amp;S , int &amp;i)&#123;\n    //出栈\n    if(S.top == S.base)\n        return;\n    i = *--S.top;\n&#125;//Pop\n\nbool StackEmpty(spStack S)&#123;\n    //判断栈是否为空\n    if(S.top == S.base)\n        return true;\n    return false;\n&#125;//StackEmpty\n//-------------------------------------------------\n\nint LocateVex(ALGraph G , VerTexType v)&#123;\n    //确定点v在G中的位置\n    for(int i = 0; i &lt; G.vexnum; ++i)\n        if(G.vertices[i].data == v)\n            return i;\n        return -1;\n&#125;//LocateVex\n\nint CreateUDG(ALGraph &amp;G)&#123; \n    //创建有向图G的邻接表、逆邻接表\n    int i , k;\n    \n    cout &lt;&lt;&quot;请输入总顶点数，总边数，以空格隔开:&quot;;\n    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;\t\t\t\t//输入总顶点数，总边数 \n    cout &lt;&lt; endl;\n    \n    cout &lt;&lt; &quot;输入点的名称，如a&quot; &lt;&lt; endl;\n    \n    for(i = 0; i &lt; G.vexnum; ++i)&#123;          \t//输入各点，构造表头结点表\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (i+1) &lt;&lt; &quot;个点的名称:&quot;;\n        cin &gt;&gt; G.vertices[i].data;           \t//输入顶点值\n        G.converse_vertices[i].data = G.vertices[i].data;\n        //初始化表头结点的指针域为NULL \n        G.vertices[i].firstarc=NULL;\t\t\t\n        G.converse_vertices[i].firstarc=NULL;\n    &#125;//for\n    cout &lt;&lt; endl;\n    cout &lt;&lt; &quot;输入边依附的顶点，如a b&quot; &lt;&lt; endl;\n    for(k = 0; k &lt; G.arcnum;++k)&#123;        \t\t//输入各边，构造邻接表\n        VerTexType v1 , v2;\n        int i , j;\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (k + 1) &lt;&lt; &quot;条边依附的顶点:&quot;;\n        cin &gt;&gt; v1 &gt;&gt; v2;                \t\t//输入一条边依附的两个顶点\n        i = LocateVex(G, v1);  j = LocateVex(G, v2);\n        //确定v1和v2在G中位置，即顶点在G.vertices中的序号 \n\n        ArcNode *p1=new ArcNode;               \t//生成一个新的边结点*p1 \n        p1-&gt;adjvex=j;                   \t\t//邻接点序号为j\n        p1-&gt;nextarc = G.vertices[i].firstarc;  G.vertices[i].firstarc=p1;\n        //将新结点*p1插入顶点vi的边表头部\n\n        ArcNode *p2=new ArcNode;               \t//生成一个新的边结点*p1 \n        p2-&gt;adjvex=i;                   \t\t//逆邻接点序号为i\n        p2-&gt;nextarc = G.converse_vertices[j].firstarc;  G.converse_vertices[j].firstarc=p2;\n        //将新结点*p1插入顶点vi的边表头部\n    &#125;//for \n    return OK; \n&#125;//CreateUDG\n\nvoid FindInDegree(ALGraph G)&#123;\n    //求出各顶点的入度存入数组indegree中 \n    int i , count;\n\n    for(i = 0 ; i &lt; G.vexnum ; i++)&#123;\n        count = 0;\n        ArcNode *p = G.converse_vertices[i].firstarc;\n        if(p)&#123;\n            while(p)&#123;\n                p = p-&gt;nextarc;\n                count++;\n            &#125;\n        &#125;\n        indegree[i] = count;\n    &#125;\n&#125;//FindInDegree\n\nint TopologicalSort(ALGraph G , int topo[])&#123; \n    //有向图G采用邻接表存储结构 \n    //若G无回路，则生成G的一个拓扑序列topo[]并返回OK，否则ERROR \n    int i , m;\n    FindInDegree(G);              \t\t\t\t//求出各顶点的入度存入数组indegree中 \n    InitStack(S);                          \t\t//栈S初始化为空 \n    for(i = 0; i &lt; G.vexnum; ++i)\n        if(!indegree[i]) Push(S, i);     \t\t//入度为0者进栈 \n    m = 0;                               \t\t//对输出顶点计数，初始为0 \n    while(!StackEmpty(S))&#123;                \t\t//栈S非空 \n        Pop(S, i);                          \t//将栈顶顶点vi出栈\n        topo[m]=i;                         \t\t//将vi保存在拓扑序列数组topo中 \n        ++m;                             \t\t//对输出顶点计数 \n        ArcNode *p = G.vertices[i].firstarc;    //p指向vi的第一个邻接点 \n        while(p)&#123;\n            int k = p-&gt;adjvex;\t\t\t\t\t//vk为vi的邻接点   \n            --indegree[k];                   \t//vi的每个邻接点的入度减1 \n            if(indegree[k] ==0)  Push(S, k);\t//若入度减为0，则入栈 \n            p = p-&gt;nextarc;                \t\t//p指向顶点vi下一个邻接结点 \n        &#125;//while \n    &#125;//while\n    \n    if(m &lt; G.vexnum)  return ERROR;    \t\t\t//该有向图有回路 \n    else return OK;\n&#125;//TopologicalSort \n\nint main()&#123;\n    cout &lt;&lt; &quot;************拓扑排序**************&quot; &lt;&lt; endl &lt;&lt; endl;\n    ALGraph G;\n    CreateUDG(G);\n    int *topo = new int [G.vexnum];\n    \n    cout &lt;&lt; endl;\n    cout &lt;&lt; &quot;有向图的邻接表、逆邻接表创建完成!&quot; &lt;&lt; endl &lt;&lt; endl;\n\n    if(TopologicalSort(G , topo))&#123;\n        cout &lt;&lt; &quot;该有向图的拓扑有序序列为：&quot;;\n        for(int j = 0 ; j &lt; G.vexnum; j++)&#123;\n            if(j != G.vexnum - 1)\n                cout &lt;&lt; G.vertices[topo[j]].data &lt;&lt; &quot; , &quot;;\n            else\n                cout &lt;&lt; G.vertices[topo[j]].data &lt;&lt; endl &lt;&lt; endl;\n        &#125;//for\n    &#125;\n    else\n        cout &lt;&lt; &quot;网中存在环，无法进行拓扑排序！&quot; &lt;&lt;endl &lt;&lt; endl;\n    return OK;\n&#125;//main\n</code></pre>\n<h2 id=\"④-关键路径\"><a href=\"#④-关键路径\" class=\"headerlink\" title=\"④.关键路径\"></a>④.关键路径</h2><p><strong>AOE网(Activity On Edges)—用边表示活动的网络用一个有向图表示一个工程的各子工程及其相互制约的关系，弧表示活动，权表示活动持续的时间，顶点表示事件（活动的开始或结束时间)，称这种有向图为边表示活动的网，简称AOE网;AOE网用来估算工程的完成时间。</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">源点</td>\n<td align=\"center\">入度为0的顶点（只有1个)</td>\n</tr>\n<tr>\n<td align=\"center\">汇点</td>\n<td align=\"center\">出度为0的顶点(只有1个)</td>\n</tr>\n<tr>\n<td align=\"center\">路径长度</td>\n<td align=\"center\">路径上各活动持续时间之和</td>\n</tr>\n<tr>\n<td align=\"center\">整个工程完成的时间</td>\n<td align=\"center\">从有向图的源点到汇点的最长路径</td>\n</tr>\n<tr>\n<td align=\"center\">关键路径</td>\n<td align=\"center\">路径长度最长的路径</td>\n</tr>\n<tr>\n<td align=\"center\">关键活动</td>\n<td align=\"center\">关键路径上的活动，边上的权值增加将使有向图上的最长路径的长度增加。</td>\n</tr>\n<tr>\n<td align=\"center\">ve(j)</td>\n<td align=\"center\">表示事件V的最早发生时间</td>\n</tr>\n<tr>\n<td align=\"center\">vl(j)</td>\n<td align=\"center\">表示事件V,的最迟发生时间</td>\n</tr>\n<tr>\n<td align=\"center\">e(i)</td>\n<td align=\"center\">表示活动a<del>i</del>的最早开始时间</td>\n</tr>\n<tr>\n<td align=\"center\">l(i)</td>\n<td align=\"center\">表示活动a<del>i</del>的最迟开始时间</td>\n</tr>\n<tr>\n<td align=\"center\">l(i)-e(i)</td>\n<td align=\"center\">表示完成活动a<del>i</del>的时间余量</td>\n</tr>\n</tbody></table>\n<p>注意:在一个AOE网中，可以有不止一条的关键路径。</p>\n<p><strong>关键路径</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/03bd98a06aaf4878a15c01aa52f1cf08.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/1026465e17eb41a19c8436642a993ae6.png#pic_center\"></p>\n<pre><code class=\"cpp\">//关键路径算法\n\n#include &lt;iostream&gt;\nusing namespace std;\n\n#define MVNum 100                       \t//最大顶点数\n#define BDNum MVNum * (MVNum - 1)\t\t\t//最大边数\n#define OK 1\t\n#define ERROR 0 \n\ntypedef char VerTexType;\n\n//- - - - -图的邻接表存储表示- - - - - \ntypedef struct ArcNode&#123;                \t\t//边结点 \n    int adjvex;                          \t//该边所指向的顶点的位置\n    int weight;\t\t\t\t\t\t\t\t//权值\n    struct ArcNode *nextarc;          \t\t//指向下一条边的指针 \n&#125;ArcNode; \n\ntypedef struct VNode&#123; \n    VerTexType data;                    \t//顶点信息\n    ArcNode *firstarc;                \t\t//指向第一条依附该顶点的边的指针 \n&#125;VNode, AdjList[MVNum];               \t\t//AdjList表示邻接表类型 \n\ntypedef struct&#123; \n    AdjList vertices;                 \t\t//邻接表 \n    AdjList converse_vertices;\t\t\t\t//逆邻接表\n    int vexnum, arcnum;              \t\t//图的当前顶点数和边数 \n&#125;ALGraph;\n//- - - - - - - - - - - - - - - -\n\n//- - - - -顺序栈的定义- - - - -\ntypedef struct&#123;\n    int *base;\n    int *top;\n    int stacksize;\n&#125;spStack;\n//- - - - - - - - - - - - - - - -\n\nint indegree[MVNum];\t\t\t\t\t\t//数组indegree存放个顶点的入度\nint ve[BDNum];\t\t\t\t\t\t\t\t//事件vi的最早发生时间\nint vl[BDNum];\t\t\t\t\t\t\t\t//事件vi的最迟发生时间\nint topo[MVNum];\t\t\t\t\t\t\t//记录拓扑序列的顶点序号\nspStack S;\n\n//----------------栈的操作--------------------\nvoid InitStack(spStack &amp;S)&#123;\n    //栈的初始化\n    S.base = new int[MVNum];\n    if(!S.base)\n        exit(1);\n    S.top = S.base;\n    S.stacksize = MVNum;\n&#125;//InitStack\n\nvoid Push(spStack &amp;S , int i)&#123;\n    //入栈\n    if(S.top - S.base == S.stacksize)\n        return;\n    *S.top++ = i;\n&#125;//Push\n\nvoid Pop(spStack &amp;S , int &amp;i)&#123;\n    //出栈\n    if(S.top == S.base)\n        return;\n    i = *--S.top;\n&#125;//Pop\n\nbool StackEmpty(spStack S)&#123;\n    //判断栈是否为空\n    if(S.top == S.base)\n        return true;\n    return false;\n&#125;//StackEmpty\n//---------------------------------------\n\nint LocateVex(ALGraph G , VerTexType v)&#123;\n    //确定点v在G中的位置\n    for(int i = 0; i &lt; G.vexnum; ++i)\n        if(G.vertices[i].data == v)\n            return i;\n        return -1;\n&#125;//LocateVex\n\nint CreateUDG(ALGraph &amp;G)&#123; \n    //创建有向图G的邻接表、逆邻接表\n    int i , k;\n    \n    cout &lt;&lt;&quot;请输入总顶点数，总边数，以空格隔开:&quot;;\n    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;\t\t\t\t//输入总顶点数，总边数 \n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;输入点的名称，如a&quot; &lt;&lt; endl;\n    \n    for(i = 0; i &lt; G.vexnum; ++i)&#123;          \t\t//输入各点，构造表头结点表\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (i+1) &lt;&lt; &quot;个点的名称:&quot;;\n        cin &gt;&gt; G.vertices[i].data;           \t\t//输入顶点值\n        G.converse_vertices[i].data = G.vertices[i].data;\n        //初始化表头结点的指针域为NULL \n        G.vertices[i].firstarc=NULL;\t\t\t\n        G.converse_vertices[i].firstarc=NULL;\n    &#125;//for\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;输入边依附的顶点及其权值，如a b 3&quot; &lt;&lt; endl;\n\n    for(k = 0; k &lt; G.arcnum;++k)&#123;        \t\t\t//输入各边，构造邻接表\n        VerTexType v1 , v2;\n        int i , j , w;\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (k + 1) &lt;&lt; &quot;条边依附的顶点及其权值:&quot;;\n        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;                \t\t//输入一条边依附的两个顶点\n        i = LocateVex(G, v1);  j = LocateVex(G, v2);\n        //确定v1和v2在G中位置，即顶点在G.vertices中的序号 \n\n        ArcNode *p1=new ArcNode;               \t\t//生成一个新的边结点*p1 \n        p1-&gt;adjvex=j;                   \t\t\t//邻接点序号为j\n        p1-&gt;nextarc = G.vertices[i].firstarc;  G.vertices[i].firstarc=p1;\n        p1-&gt;weight = w;\n        //将新结点*p1插入顶点vi的边表头部\n\n        ArcNode *p2=new ArcNode;               \t\t//生成一个新的边结点*p1 \n        p2-&gt;adjvex=i;                   \t\t\t//逆邻接点序号为i\n        p2-&gt;nextarc = G.converse_vertices[j].firstarc;  G.converse_vertices[j].firstarc=p2;\n        p2-&gt;weight = w;\n        //将新结点*p1插入顶点vi的边表头部\n    &#125;//for \n    return OK; \n&#125;//CreateUDG\n\nvoid FindInDegree(ALGraph G)&#123;\n    //求出各顶点的入度存入数组indegree中 \n    int i , count;\n\n    for(i = 0 ; i &lt; G.vexnum ; i++)&#123;\n        count = 0;\n        ArcNode *p = G.converse_vertices[i].firstarc;\n        if(p)&#123;\n            while(p)&#123;\n                p = p-&gt;nextarc;\n                count++;\n            &#125;\n        &#125;//if\n        indegree[i] = count;\n    &#125;//for\n&#125;//FindInDegree\n\nint TopologicalOrder(ALGraph G , int topo[])&#123; \n    //有向图G采用邻接表存储结构 \n    //若G无回路，则生成G的一个拓扑序列topo[]并返回OK，否则ERROR \n    int i , m;\n    FindInDegree(G);              \t\t\t\t//求出各顶点的入度存入数组indegree中 \n    InitStack(S);                          \t\t//栈S初始化为空 \n    for(i = 0; i &lt; G.vexnum; ++i)\n        if(!indegree[i]) Push(S, i);     \t\t//入度为0者进栈 \n    m = 0;                               \t\t//对输出顶点计数，初始为0 \n    while(!StackEmpty(S))&#123;                \t\t//栈S非空 \n        Pop(S, i);                          \t//将栈顶顶点vi出栈\n        topo[m]=i;                         \t\t//将vi保存在拓扑序列数组topo中 \n        ++m;                             \t\t//对输出顶点计数 \n        ArcNode *p = G.vertices[i].firstarc;    //p指向vi的第一个邻接点 \n        while(p)&#123;\n            int k = p-&gt;adjvex;\t\t\t\t\t//vk为vi的邻接点   \n            --indegree[k];                   \t//vi的每个邻接点的入度减1 \n            if(indegree[k] ==0)  Push(S, k);\t//若入度减为0，则入栈 \n            p = p-&gt;nextarc;                \t\t//p指向顶点vi下一个邻接结点 \n        &#125;//while \n    &#125;//while\n    \n    if(m &lt; G.vexnum)  return ERROR;    \t\t\t//该有向图有回路 \n    else return OK;\n&#125;//TopologicalOrder\n\nint CriticalPath(ALGraph G)&#123; \n    //G为邻接表存储的有向网，输出G的各项关键活动\n    int n , i , k , j , e , l;\n    if (!TopologicalOrder(G, topo))  return ERROR; \n    //调用拓扑排序算法，使拓扑序列保存在topo中，若调用失败，则存在有向环，返回ERROR \n    n = G.vexnum;                  \t\t\t\t//n为顶点个数 \n    for(i = 0; i &lt; n; i++)               \t\t//给每个事件的最早发生时间置初值0 \n        ve[i] = 0; \n\n\n    /*――――――――――按拓扑次序求每个事件的最早发生时间－――――－―――――*/ \n    for(i = 0;i &lt; n; i++)&#123;                 \n        k = topo[i];                   \t\t\t//取得拓扑序列中的顶点序号k             \n        ArcNode *p = G.vertices[k].firstarc;    //p指向k的第一个邻接顶点  \n        while(p != NULL)&#123;            \t\t\t//依次更新k的所有邻接顶点的最早发生时间   \n            j = p-&gt;adjvex;               \t\t//j为邻接顶点的序号                   \n            if(ve[j] &lt; ve[k] + p-&gt;weight)    \t//更新顶点j的最早发生时间ve[j] \n                ve[j] = ve[k] + p-&gt;weight;     \n            p = p-&gt;nextarc;              \t\t//p指向k的下一个邻接顶点  \n        &#125; //while \n    &#125; //for \n\n    for(i=0;i&lt;n;i++)                 \t\t\t//给每个事件的最迟发生时间置初值ve[n-1] \n        vl[i]=ve[n-1];\n    \n    /*――――――――――按逆拓扑次序求每个事件的最迟发生时间－――――－―――――*/ \n    for(i = n - 1;i &gt;= 0; i--)&#123;               \n        k = topo[i];                   \t\t\t//取得拓扑序列中的顶点序号k             \n        ArcNode *p = G.vertices[k].firstarc;    //p指向k的第一个邻接顶点  \n        while(p != NULL)&#123;            \t\t\t//根据k的邻接点，更新k的最迟发生时间   \n            j = p-&gt;adjvex;              \t\t//j为邻接顶点的序号                   \n            if(vl[k] &gt; vl[j] - p-&gt;weight)    \t//更新顶点k的最迟发生时间vl[k] \n                vl[k] = vl[j] - p-&gt;weight;       \n            p = p-&gt;nextarc;              \t\t//p指向k的下一个邻接顶点  \n        &#125;//while \n    &#125;//for \n\n    /*――――――――――――判断每一活动是否为关键活动－――――――－―――――*/\n    cout &lt;&lt; endl;\n    cout &lt;&lt; &quot;关键活动路径为:&quot;;\n    for(i = 0;i &lt; n; i++)&#123;                \t\t//每次循环针对vi为活动开始点的所有活动 \n        ArcNode *p = G.vertices[i].firstarc;    //p指向i的第一个邻接顶点  \n        while(p != NULL) &#123;    \n            j = p-&gt;adjvex;             \t\t\t//j为i的邻接顶点的序号    \n            e = ve[i];                 \t\t\t//计算活动&lt;vi, vj&gt;的最早开始时间 \n            l = vl[j] - p-&gt;weight;      \t\t//计算活动&lt;vi, vj&gt;的最迟开始时间 \n            if(e == l)               \t\t\t//若为关键活动，则输出&lt;vi, vj&gt; \n                cout &lt;&lt; G.vertices[i].data &lt;&lt; &quot;--&gt;&quot; &lt;&lt; G.vertices[j].data &lt;&lt; &quot; &quot;;\n            p = p-&gt;nextarc;              \t\t//p指向i的下一个邻接顶点  \n        &#125; //while \n    &#125; //for  \n    return OK;\n&#125;//CriticalPath\n\nint main()&#123;\n    cout &lt;&lt; &quot;************关键路径算法**************&quot; &lt;&lt; endl &lt;&lt; endl;\n    ALGraph G;\n    CreateUDG(G);\n    int *topo = new int [G.vexnum];\n    \n    cout &lt;&lt; endl;\n    cout &lt;&lt; &quot;有向图创建完成!&quot; &lt;&lt; endl &lt;&lt; endl;\n    \n    if(!CriticalPath(G))\n        cout &lt;&lt; &quot;网中存在环，无法进行拓扑排序！&quot; &lt;&lt;endl &lt;&lt; endl;\n    cout &lt;&lt; endl;\n    return OK;\n&#125;//main\n</code></pre>\n<p>例：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/0112e31c04c044fea7681f791d8f37af.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/07d539f42eb9421989d5e7f8f0a219fc.png#pic_center\"></p>\n<hr>\n<h1 id=\"6、总结\"><a href=\"#6、总结\" class=\"headerlink\" title=\"6、总结\"></a>6、总结</h1><p><img src=\"https://img-blog.csdnimg.cn/bb6f82575a8441bbb467695e7c1674d0.png#pic_center\"></p>\n<p>(1)根据不同的分类规则,图分为多种类型:<strong>无向图、有向图、完全图、连通图、强连通图、带权图(网)、稀疏图和稠密图</strong>等。邻接点、路径、回路、度、连通分量、生成树等是在图的算法设计中常用到的重要术语。</p>\n<p>(2)图的存储方式有两大类:<strong>以边集合方式的表示法和以链接方式的表示法</strong>。其中，以边集合方式表示的为邻接矩阵，以链接方式表示的包括邻接表、十字链表和邻接多重表。邻接矩阵表示法借助二维数组来表示元素之间的关系，实现起来较为简单;邻接表、十字链表和邻接多重表都属于链式存储结构，实现起来较为复杂。在实际应用中具体采取哪种存储表示，可以根据图的类型和实际算法的基本思想进行选择。其中，邻接矩阵和邻接表是两种常用的存储结构，二者之间的比较如下图所示。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/6eadb60a2e3d4a1d98c3bb32b5545ae7.png#pic_center\"></p>\n<p>( 3 )图的遍历算法是实现图的其他运算的基础，<strong>图的遍历方法有两种:深度优先搜索遍历和广度优先搜索遍历。</strong>深度优先搜索遍历类似于树的先序遍历，借助于栈结构来实现(递归);广度优先搜索遍历类似于树的层次遍历，借助于队列结构来实现。两种遍历方法的不同之处仅仅在于对顶点访问的顺序不同，所以时间复杂度相同。当用邻接矩阵存储时，时间复杂度为均O(n^2^)，用邻接表存储时，时间复杂度均为O(n+e)。</p>\n<p>(4)图的很多算法与实际应用密切相关，比较常用的算法包括构造最小生成树算法、求解最短路径算法、拓扑排序和求解关键路径算法。<br>①<strong>构造最小生成树有普里姆算法和克鲁斯卡尔算法</strong>,两者都能达到同一目的。但前者算法思想的核心是归并点,时间复杂度是O(n^2^),适用于稠密网;后者是归并边,时间复杂度是O(elog<del>2</del>e),适用于稀疏网。<br>②<strong>最短路径算法</strong>:一种是<strong>迪杰斯特拉算法</strong>，求从某个源点到其余各顶点的最短路径，求解过程是按路径长度递增的次序产生最短路径，时间复杂度是O(n^2^);另一种是<strong>弗洛伊德算法</strong>，求每一对顶点之间的最短路径，时间复杂度是O(n^3^)，从实现形式上来说，这种算法比以图中的每个顶点为源点n次调用迪杰斯特拉算法更为简洁。<br>③<strong>拓扑排序和关键路径都是有向无环图的应用</strong>。拓扑排序是基于用顶点表示活动的有向图，即AOV-网。对于不存在环的有向图，图中所有顶点一定能够排成一个线性序列，即拓扑序列，拓扑序列是不唯一的。用邻接表表示图，拓扑排序的时间复杂度为O(n+e)。<br>④<strong>关键路径算法是基于用弧表示活动的有向图，即AOE-网。关键路径上的活动叫做关键活动</strong>，这些活动是影响工程进度的关键，它们的提前或拖延将使整个工程提前或拖延。关键路径是不唯一的。关键路径算法的实现是在拓扑排序的基础上，用邻接表表示图，关键路径算法的时间复杂度为O(n+e)。</p>\n<hr>\n<h1 id=\"7、例题与应用\"><a href=\"#7、例题与应用\" class=\"headerlink\" title=\"7、例题与应用\"></a>7、例题与应用</h1><p><img src=\"https://img-blog.csdnimg.cn/8ffe8a580c354314825d7454140091e5.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/e4309d6ae82d400d940897600191570c.png#pic_center\"></p>\n<ol>\n<li>编程实现如下功能：<br>（1）输入无向图的顶点数、边数及各条边的顶点对，建立用邻接矩阵表示的无向图。<br>（2）对图进行深度优先搜索和广度优先搜索遍历，并分别输出其遍历序列。</li>\n</ol>\n<p>测试样例无向图<br><img src=\"https://img-blog.csdnimg.cn/41dc11138d854308a4440953eaad5293.png#pic_center\"><br>运行结果<br><img src=\"https://img-blog.csdnimg.cn/1306f3f4609a4456a0c399a811380d54.png#pic_center\"></p>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define MVNum 100\n#define MAXQSIZE 100\ntypedef char VerTexType;\ntypedef int ArcType;\n//图的邻接矩阵存储表示\ntypedef struct\n&#123;\n    VerTexType vexs[MVNum];\n    ArcType arcs[MVNum][MVNum];\n    int vexnum, arcnum;\n&#125; Graph;\n//队列的定义及操作\ntypedef struct\n&#123;\n    ArcType *base;\n    int front;\n    int rear;\n&#125; sqQueue;\nbool visited[MVNum];\nbool visited1[MVNum];\nint FirstAdjVex(Graph G, int v);\nint NextAdjVex(Graph G, int v, int w);\n//构建空队列Q\nvoid InitQueue(sqQueue &amp;Q)\n&#123;\n    Q.base = new ArcType[MAXQSIZE];\n    if (!Q.base)\n        exit(1);\n    Q.front = Q.rear = 0;\n&#125;\n//插入元素e为Q的新的队尾元素\nvoid EnQueue(sqQueue &amp;Q, ArcType e)\n&#123;\n    if ((Q.rear + 1) % MAXQSIZE == Q.front)\n        return;\n    Q.base[Q.rear] = e;\n    Q.rear = (Q.rear + 1) % MAXQSIZE;\n&#125;\n//判断是否为空队\nbool QueueEmpty(sqQueue Q)\n&#123;\n    if (Q.rear == Q.front)\n        return true;\n    return false;\n&#125;\n//队头元素出队并置为u\nvoid DeQueue(sqQueue &amp;Q, ArcType &amp;u)\n&#123;\n    u = Q.base[Q.front];\n    Q.front = (Q.front + 1) % MAXQSIZE;\n&#125;\n//确定点v在G中的位置\nint LocateVex(Graph G, VerTexType v)\n&#123;\n    for (int i = 0; i &lt; G.vexnum; ++i)\n        if (G.vexs[i] == v)\n            return i;\n    return -1;\n&#125;\n//采用邻接矩阵表示法，创建无向网G\nvoid CreateUDN(Graph &amp;G)\n&#123;\n    int i, j, k;\n    cout &lt;&lt; &quot;输入总顶点数，总边数，以空格隔开:（例：3 2）&quot;;\n    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;输入点的名称（例：a）&quot; &lt;&lt; endl;\n\n    for (i = 0; i &lt; G.vexnum; ++i)\n    &#123;\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (i + 1) &lt;&lt; &quot;个点的名称:&quot;;\n        cin &gt;&gt; G.vexs[i];\n    &#125;\n    cout &lt;&lt; endl;\n\n    for (i = 0; i &lt; G.vexnum; ++i)\n        for (j = 0; j &lt; G.vexnum; ++j)\n            G.arcs[i][j] = 0;\n    cout &lt;&lt; &quot;输入边依附的顶点（例a b）&quot; &lt;&lt; endl;\n    for (k = 0; k &lt; G.arcnum; ++k)\n    &#123;\n        VerTexType v1, v2;\n        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (k + 1) &lt;&lt; &quot;条边依附的顶点:&quot;;\n        cin &gt;&gt; v1 &gt;&gt; v2;\n        i = LocateVex(G, v1);\n        j = LocateVex(G, v2);\n        G.arcs[j][i] = G.arcs[i][j] = 1;\n    &#125;\n&#125;\n// DFS\nvoid DFS(Graph G, int v)\n&#123;\n    int w;\n    cout &lt;&lt; G.vexs[v] &lt;&lt; &quot;    &quot;;\n    visited[v] = true;\n    for (w = 0; w &lt; G.vexnum; w++)\n        if ((G.arcs[v][w] != 0) &amp;&amp; (!visited[w]))\n            DFS(G, w);\n&#125;\n// BFS\nvoid BFS(Graph G, int v)\n&#123;\n    sqQueue Q;\n    ArcType u;\n    ArcType w;\n\n    cout &lt;&lt; G.vexs[v] &lt;&lt; &quot;    &quot;;\n    visited[v] = true;\n    InitQueue(Q);\n    EnQueue(Q, v);\n    while (!QueueEmpty(Q))\n    &#123;\n        DeQueue(Q, u);\n        for (w = FirstAdjVex(G, u); w &gt;= 0; w = NextAdjVex(G, u, w))\n        &#123;\n            if (!visited[w])\n            &#123;\n                cout &lt;&lt; G.vexs[w] &lt;&lt; &quot;    &quot;;\n                visited[w] = true;\n                EnQueue(Q, w);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n//返回v的第一个邻接点\nint FirstAdjVex(Graph G, int v)\n&#123;\n    int i;\n    for (i = 0; i &lt; G.vexnum; ++i)\n    &#123;\n        if (G.arcs[v][i] == 1 &amp;&amp; visited[i] == false)\n            return i;\n    &#125;\n    return -1;\n&#125;\n//返回v相对于w的下一个邻接点\nint NextAdjVex(Graph G, int v, int w)\n&#123;\n    int i;\n    for (i = w; i &lt; G.vexnum; ++i)\n    &#123;\n        if (G.arcs[v][i] == 1 &amp;&amp; visited[i] == false)\n            return i;\n    &#125;\n    return -1;\n&#125;\nint main()\n&#123;\n    Graph G;\n    CreateUDN(G);\n    cout &lt;&lt; endl;\n    cout &lt;&lt; &quot;无向图G创建完成！&quot; &lt;&lt; endl\n         &lt;&lt; endl;\n    cout &lt;&lt; &quot;输入遍历无向图G的起始点：&quot;;\n    VerTexType c;\n    cin &gt;&gt; c;\n    int i;\n    for (i = 0; i &lt; G.vexnum; ++i)\n    &#123;\n        if (c == G.vexs[i])\n            break;\n    &#125;\n    cout &lt;&lt; endl;\n    while (i &gt;= G.vexnum)\n    &#123;\n        cout &lt;&lt; &quot;该点不存在，请重新输入！&quot; &lt;&lt; endl;\n        cout &lt;&lt; &quot;请输入遍历连通图的起始点：&quot;;\n        cin &gt;&gt; c;\n        for (i = 0; i &lt; G.vexnum; ++i)\n        &#123;\n            if (c == G.vexs[i])\n                break;\n        &#125;\n    &#125;\n    cout &lt;&lt; &quot;深度优先搜索遍历无向图G结果：&quot; &lt;&lt; endl;\n    DFS(G, i);\n\n    for (int j = 1; j &lt;= G.vexnum; j++)\n        visited[j] = false;\n\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;广度优先搜索遍历无向图G结果：&quot; &lt;&lt; endl;\n    BFS(G, i);\n\n    cout &lt;&lt; endl;\n    return 0;\n&#125;\n</code></pre>\n","feature":true,"text":"图(Graph )G由两个集合V和E组成，记为G=(V,E)，其中V是顶点的有穷非空集合，E是V中顶点偶对的有穷集合，这些顶点偶对称为边。V(G)和E(G)通常分别表示图G的顶点集合和边集合，E(G)可以为空集。若E(G)为空，则图G只有顶点而没有边。...","permalink":"/post/数据结构（C语言版）-- 图笔记","photos":[],"count_time":{"symbolsCount":"62k","symbolsTime":"56 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"字节跳动青训营","slug":"字节跳动青训营","count":21,"path":"api/tags/字节跳动青训营.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD\"><span class=\"toc-text\">1、图的定义和基本术语</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">①.图的定义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD\"><span class=\"toc-text\">②.图的基本术语</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%9B%BE%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">2、图的类型定义</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">3、图的存储结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5\"><span class=\"toc-text\">①.邻接矩阵</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E9%82%BB%E6%8E%A5%E8%A1%A8\"><span class=\"toc-text\">②.邻接表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A3-%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">④.十字链表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A3-%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8\"><span class=\"toc-text\">④.邻接多重表</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4%E3%80%81%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">4、图的遍历</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2\"><span class=\"toc-text\">①.深度优先搜索</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2\"><span class=\"toc-text\">②.广度优先搜索</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5%E3%80%81%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">5、图的应用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91\"><span class=\"toc-text\">①.最小生成树</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">②.最短路径</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A2-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">③.拓扑排序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A3-%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">④.关键路径</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#6%E3%80%81%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">6、总结</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#7%E3%80%81%E4%BE%8B%E9%A2%98%E4%B8%8E%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">7、例题与应用</span></a></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"查找","uid":"c6ad7ccbed505349c9093570c864bff1","slug":"数据结构（C语言版）-- 查找笔记","date":"2022-02-20T13:03:12.000Z","updated":"2025-07-14T15:12:20.469Z","comments":true,"path":"api/articles/数据结构（C语言版）-- 查找笔记.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/db70ceb9e22c4eebb7eb82117f4787b5.png","text":"查找是数据处理中经常使用的一种操作。本章主要介绍了对查找表的查找，查找表实际上仅仅是一个集合，为了提高查找效率，将查找表组织成不同的数据结构，主要包括3种不同结构的查找表:线性表、树表和散列表。...","permalink":"/post/数据结构（C语言版）-- 查找笔记","photos":[],"count_time":{"symbolsCount":"27k","symbolsTime":"25 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"字节跳动青训营","slug":"字节跳动青训营","count":21,"path":"api/tags/字节跳动青训营.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true},"next_post":{"title":"树和二叉树","uid":"50552977e0ec8094596ba83ac872ee52","slug":"数据结构（C语言版）-- 树和二叉树笔记","date":"2022-02-16T04:56:11.000Z","updated":"2025-07-14T15:12:20.469Z","comments":true,"path":"api/articles/数据结构（C语言版）-- 树和二叉树笔记.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/050b725832464411bd17f7b08e4c7ff4.png","text":"树( Tree)是n(n≥0)个结点的有限集，它或为空树(n=0)；或为非空树，对于非空树T：1. 有且仅有一个称之为根的结点;2. 除根结点以外的其余结点可分为m (m>0)个互不相交的有限集T1，T2,…，Tm，其中每一个集合本身又是一棵树，并且称为根的子树( SubTree)。...","permalink":"/post/数据结构（C语言版）-- 树和二叉树笔记","photos":[],"count_time":{"symbolsCount":"27k","symbolsTime":"25 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"字节跳动青训营","slug":"字节跳动青训营","count":21,"path":"api/tags/字节跳动青训营.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true}}