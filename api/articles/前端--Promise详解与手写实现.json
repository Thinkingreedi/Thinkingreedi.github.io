{"title":"从回调地狱到Promise天堂：前端异步革命","uid":"0da050a8ade26330ecd92d326adb320f","slug":"前端--Promise详解与手写实现","date":"2023-01-28T00:56:24.000Z","updated":"2025-07-14T15:12:20.464Z","comments":true,"path":"api/articles/前端--Promise详解与手写实现.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/direct/ea4f563866fc420facc03cf475d9ad7a.png","content":"<h1 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h1><h2 id=\"1、Promise介绍与基本使用\"><a href=\"#1、Promise介绍与基本使用\" class=\"headerlink\" title=\"1、Promise介绍与基本使用\"></a>1、Promise介绍与基本使用</h2><h3 id=\"1-1-Promise概述\"><a href=\"#1-1-Promise概述\" class=\"headerlink\" title=\"1.1 Promise概述\"></a>1.1 Promise概述</h3><p><strong>理解</strong></p>\n<ol>\n<li><p>抽象表达:</p>\n<p>1)Promise是一门新的技术(ES6规范)</p>\n<p>2)Promise是Js中进行异步编程的新解决方案</p>\n<ul>\n<li>备注:旧方案是单纯使用回调函数</li>\n</ul>\n</li>\n<li><p>具体表达:</p>\n<p>  1)从语法上来说: Promise是一个构造函数</p>\n<p>  2)从功能上来说: promise对象用来封装一个异步操作(fs 文件操作、数据库操作、AJAX 、定时器 )并可以获取其成功&#x2F;失败的结果值</p>\n</li>\n</ol>\n<p><strong>Promise的状态改变</strong></p>\n<ol>\n<li>pending 变为resolved</li>\n<li>pending变为reject</li>\n</ol>\n<ul>\n<li>说明:只有这2种，且<strong>一个promise对象只能改变一次</strong>；无论变为成功还是失败，都会有一个结果数据；成功的结果数据一般称为value，失败的结果数据一般称为reason</li>\n</ul>\n<p><strong>Promise的基本流程</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/1111e7dc18634ec590363b9cc03474c9.png#pic_center\"></p>\n<h3 id=\"1-2-Promise的作用\"><a href=\"#1-2-Promise的作用\" class=\"headerlink\" title=\"1.2 Promise的作用\"></a>1.2 Promise的作用</h3><ul>\n<li><strong>指定回调函数的方式更加灵活</strong><ol>\n<li>旧的:必须在启动异步任务前指定</li>\n<li>promise:启动异步任务&#x3D;&gt;返回promie对象&#x3D;&gt;给promise对象绑定回调函数(甚至可以在异步任务结束后指定&#x2F;多个)</li>\n</ol>\n</li>\n<li><strong>支持链式调用，可以解决回调地狱问题</strong><ol>\n<li>什么是回调地狱 – 回调函数嵌套调用，外部回调函数异步执行的结果是嵌套的回调执行的条件</li>\n<li>回调地狱的缺点 – 不便于阅读，不便于异常处理</li>\n<li>解决方案 – promise链式调用</li>\n<li>终极解决方案 – async&#x2F;await</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"1-3-Promise的使用\"><a href=\"#1-3-Promise的使用\" class=\"headerlink\" title=\"1.3 Promise的使用\"></a>1.3 Promise的使用</h3><ul>\n<li>Promise实践练习-fs模块</li>\n</ul>\n<pre><code class=\"js\">const fs = require(&#39;fs&#39;);\n\n//回调函数 形式\n// fs.readFile(&#39;./resource/content.txt&#39;, (err, data) =&gt; &#123;\n//     // 如果出错 则抛出错误\n//     if(err)  throw err;\n//     //输出文件内容\n//     console.log(data.toString());\n// &#125;);\n\n//Promise 形式\nlet p = new Promise((resolve , reject) =&gt; &#123;\n    fs.readFile(&#39;./resource/content.txt&#39;, (err, data) =&gt; &#123;\n        //如果出错\n        if(err) reject(err);\n        //如果成功\n        resolve(data);\n    &#125;);\n&#125;);\n\n//调用 then \np.then(value=&gt;&#123;\n    console.log(value.toString());\n&#125;, reason=&gt;&#123;\n    console.log(reason);\n&#125;);\n</code></pre>\n<ul>\n<li>Promise封装练习-fs模块</li>\n</ul>\n<pre><code class=\"js\">/**\n * 封装一个函数 mineReadFile 读取文件内容\n * 参数:  path  文件路径\n * 返回:  promise 对象\n */\nfunction mineReadFile(path)&#123;\n    return new Promise((resolve, reject) =&gt; &#123;\n        //读取文件\n        require(&#39;fs&#39;).readFile(path, (err, data) =&gt;&#123;\n            //判断\n            if(err) reject(err);\n            //成功\n            resolve(data);\n        &#125;);\n    &#125;);\n&#125;\n\nmineReadFile(&#39;./resource/content.txt&#39;)\n.then(value=&gt;&#123;\n    //输出文件内容\n    console.log(value.toString());\n&#125;, reason=&gt;&#123;\n    console.log(reason);\n&#125;);\n</code></pre>\n<ul>\n<li>Promise实践练习-AJAX请求</li>\n</ul>\n<pre><code class=\"js\">        const btn = document.querySelector(&#39;#btn&#39;);\n\n        btn.addEventListener(&#39;click&#39;, function()&#123;\n            //创建 Promise\n            const p = new Promise((resolve, reject) =&gt; &#123;\n                //1.创建对象\n                const xhr = new XMLHttpRequest();\n                //2. 初始化\n                xhr.open(&#39;GET&#39;, &#39;https://api.apiopen.top/getJoke&#39;);\n                //3. 发送\n                xhr.send();\n                //4. 处理响应结果\n                xhr.onreadystatechange = function()&#123;\n                    if(xhr.readyState === 4)&#123;\n                        //判断响应状态码 2xx   \n                        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;\n                            //控制台输出响应体\n                            resolve(xhr.response);\n                        &#125;else&#123;\n                            //控制台输出响应状态码\n                            reject(xhr.status);\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;);\n            //调用then方法\n            p.then(value=&gt;&#123;\n                console.log(value);\n            &#125;, reason=&gt;&#123;\n                console.warn(reason);\n            &#125;);\n        &#125;);\n</code></pre>\n<ul>\n<li>Promise封装AJAX操作</li>\n</ul>\n<pre><code class=\"js\">        /**\n         * 封装一个函数 sendAJAX 发送 GET AJAX 请求\n         * 参数   URL\n         * 返回结果 Promise 对象\n         */\n        function sendAJAX(url)&#123;\n            return new Promise((resolve, reject) =&gt; &#123;\n                const xhr = new XMLHttpRequest();\n                xhr.responseType = &#39;json&#39;;\n                xhr.open(&quot;GET&quot;, url);\n                xhr.send();\n                //处理结果\n                xhr.onreadystatechange = function()&#123;\n                    if(xhr.readyState === 4)&#123;\n                        //判断成功\n                        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;\n                            //成功的结果\n                            resolve(xhr.response);\n                        &#125;else&#123;\n                            reject(xhr.status);\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;);\n        &#125;\n    \n        sendAJAX(&#39;https://api.apiopen.top/getJok&#39;)\n        .then(value =&gt; &#123;\n            console.log(value);\n        &#125;, reason =&gt; &#123;\n            console.warn(reason);\n        &#125;);\n</code></pre>\n<h2 id=\"2、Promise-API\"><a href=\"#2、Promise-API\" class=\"headerlink\" title=\"2、Promise API\"></a>2、Promise API</h2><ol>\n<li><p><strong>Promise构造函数</strong>: Promise (excutor){}</p>\n<p>(1)executor函数:执行器(resolve, reject)&#x3D;&gt;{}</p>\n<p>(2)resolve函数:内部定义成功时我们调用的函数value &#x3D;&gt;{}</p>\n<p>(3)reject 函数:内部定义失败时我们调用的函数reason &#x3D;&gt; {}</p>\n<ul>\n<li>说明: <strong>executor 会在 Promise 内部立即同步调用</strong>,异步操作在执行器中执行</li>\n</ul>\n</li>\n<li><p><strong>Promise.prototype.then</strong>方法:(onResolved, onRejected)&#x3D;&gt;{}</p>\n<p> (1)onResolved 函数:成功的回调函数(value)&#x3D;&gt;{}</p>\n<p>(2)onRejected 函数:失败的回调函数(reason)&#x3D;&gt;{}</p>\n<ul>\n<li>说明:指定用于得到成功value 的成功回调和用于得到失败reason的失败回调返回一个新的promise对象</li>\n</ul>\n</li>\n<li><p><strong>Promise.prototype.catch方法</strong>:(onRejected)&#x3D;&gt;{}</p>\n<ul>\n<li><p>onRejected 函数:失败的回调函数(reason)&#x3D;&gt; {}</p>\n</li>\n<li><p>说明: then()的语法糖，相当于: then(undefined, onRejected)</p>\n</li>\n</ul>\n</li>\n<li><p><strong>Promise.resolve方法</strong>:(value)&#x3D;&gt;{}</p>\n</li>\n</ol>\n<ul>\n<li><p>value:成功的数据或promise对象</p>\n</li>\n<li><p>说明:返回一个成功&#x2F;失败的promise对象</p>\n</li>\n</ul>\n<ol start=\"5\">\n<li><strong>Promise.reject方法</strong>: (reason)&#x3D;&gt;{}</li>\n</ol>\n<ul>\n<li><p>reason:失败的原因</p>\n</li>\n<li><p>说明:返回一个失败的promise对象</p>\n</li>\n</ul>\n<ol start=\"6\">\n<li><strong>Promise.all方法</strong>:(promises)&#x3D;&gt;{}</li>\n</ol>\n<ul>\n<li><p>promises:包含n个promise的数组</p>\n</li>\n<li><p>说明:<strong>返回一个新的promise，只有所有的promise都成功才成功，只要有一个失败了就直接失败</strong></p>\n</li>\n</ul>\n<ol start=\"7\">\n<li><p><strong>Promise.race方法</strong>:(promises)&#x3D;&gt;0</p>\n<ul>\n<li>promises:包含n个promise的数组</li>\n<li>说明:<strong>返回一个新的promise，第一个完成的promise 的结果状态就是最终的结果状态</strong></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"3、Promise关键问题\"><a href=\"#3、Promise关键问题\" class=\"headerlink\" title=\"3、Promise关键问题\"></a>3、Promise关键问题</h2><ol>\n<li><p>如何改变promise 的状态?</p>\n<p>(1)<strong>resolve(value)</strong>:如果当前是pending就会变为resolved</p>\n<p>(2)<strong>reject(reason)</strong>:如果当前是pending 就会变为rejected</p>\n<p>(3)<strong>抛出异常</strong>:如果当前是pending 就会变为rejected</p>\n</li>\n<li><p>一个promise指定多个成功&#x2F;失败回调函数，都会调用吗?</p>\n<p>当promise<strong>改变为对应状态时都会调用</strong></p>\n</li>\n<li><p>改变promise状态和指定回调函数谁先谁后?</p>\n<p>(1)都有可能，正常情况下是先指定回调再改变状态(异步任务)，但也可以先改状态再指定回调(同步任务)</p>\n<p>(2)如何先改状态再指定回调?</p>\n<ul>\n<li>在执行器中直接调用resolve()&#x2F;reject()</li>\n<li>延迟更长时间才调用then()</li>\n</ul>\n<p>(3)什么时候才能得到数据?</p>\n<ul>\n<li>如果先指定的回调，那当状态发生改变时，回调函数就会调用，得到数据(异步任务)</li>\n<li>如果先改变的状态，那当指定回调时，回调函数就会调用，得到数据(同步任务)</li>\n</ul>\n</li>\n<li><p>promise.then()返回的新promise的结果状态由什么决定?</p>\n<p>(1)简单表达:由 then()指定的回调函数执行的结果决定</p>\n<p>(2)详细表达:</p>\n<ul>\n<li>如果抛出异常，<strong>新promise变为rejected, reason为抛出的异常</strong></li>\n<li>如果返回的是非promise的任意值，<strong>新promise变为resolved, value为返回的值</strong></li>\n<li>如果返回的是另一个新promise，<strong>此promise的结果就会成为新promise的结果</strong></li>\n</ul>\n</li>\n<li><p>promise如何串连多个操作任务?</p>\n<p>(1)promise 的 then()返回一个新的promise，可以开成then()的链式调用</p>\n<p>(2)通过 then的链式调用串连多个同步&#x2F;异步任务</p>\n</li>\n<li><p>promise异常传透?</p>\n<p>(1)当使用promise的then链式调用时，可以在最后指定失败的回调</p>\n<p>(2)前面任何操作出了异常，都会传到最后失败的回调中处理</p>\n</li>\n<li><p>中断promise链?</p>\n<p>(1)当使用promise的then链式调用时，在中间中断，不再调用后面的回调函数</p>\n<p>(2)办法:<strong>在回调函数中返回一个pendding状态的 promise对象</strong></p>\n</li>\n</ol>\n<h2 id=\"4、Promise自定义封装\"><a href=\"#4、Promise自定义封装\" class=\"headerlink\" title=\"4、Promise自定义封装\"></a>4、Promise自定义封装</h2><ul>\n<li>自定义Promise</li>\n</ul>\n<pre><code class=\"js\">//声明构造函数\nfunction Promise(executor) &#123;\n    //添加属性\n    this.PromiseState = &#39;pending&#39;;\n    this.PromiseResult = null;\n    //声明属性\n    this.callbacks = [];\n    //保存实例对象的 this 的值\n    const self = this;// self _this that\n    //resolve 函数\n    function resolve(data) &#123;\n        //判断状态\n        if (self.PromiseState !== &#39;pending&#39;) return;\n        //1. 修改对象的状态 (promiseState)\n        self.PromiseState = &#39;fulfilled&#39;;// resolved\n        //2. 设置对象结果值 (promiseResult)\n        self.PromiseResult = data;\n        //调用成功的回调函数\n        setTimeout(() =&gt; &#123;\n            self.callbacks.forEach(item =&gt; &#123;\n                item.onResolved(data);\n            &#125;);\n        &#125;);\n    &#125;\n    //reject 函数\n    function reject(data) &#123;\n        //判断状态\n        if (self.PromiseState !== &#39;pending&#39;) return;\n        //1. 修改对象的状态 (promiseState)\n        self.PromiseState = &#39;rejected&#39;;// \n        //2. 设置对象结果值 (promiseResult)\n        self.PromiseResult = data;\n        //执行失败的回调\n        setTimeout(() =&gt; &#123;\n            self.callbacks.forEach(item =&gt; &#123;\n                item.onRejected(data);\n            &#125;);\n        &#125;)\n    &#125;\n    try &#123;\n        //同步调用『执行器函数』\n        executor(resolve, reject);\n    &#125; catch (e) &#123;\n        //修改 promise 对象状态为『失败』\n        reject(e);\n    &#125;\n&#125;\n\n//添加 then 方法\nPromise.prototype.then = function (onResolved, onRejected) &#123;\n    const self = this;\n    //判断回调函数参数\n    if (typeof onRejected !== &#39;function&#39;) &#123;\n        onRejected = reason =&gt; &#123;\n            throw reason;\n        &#125;\n    &#125;\n    if (typeof onResolved !== &#39;function&#39;) &#123;\n        onResolved = value =&gt; value;\n        //value =&gt; &#123; return value&#125;;\n    &#125;\n    return new Promise((resolve, reject) =&gt; &#123;\n        //封装函数\n        function callback(type) &#123;\n            try &#123;\n                //获取回调函数的执行结果\n                let result = type(self.PromiseResult);\n                //判断\n                if (result instanceof Promise) &#123;\n                    //如果是 Promise 类型的对象\n                    result.then(v =&gt; &#123;\n                        resolve(v);\n                    &#125;, r =&gt; &#123;\n                        reject(r);\n                    &#125;)\n                &#125; else &#123;\n                    //结果的对象状态为『成功』\n                    resolve(result);\n                &#125;\n            &#125; catch (e) &#123;\n                reject(e);\n            &#125;\n        &#125;\n        //调用回调函数  PromiseState\n        if (this.PromiseState === &#39;fulfilled&#39;) &#123;\n            setTimeout(() =&gt; &#123;\n                callback(onResolved);\n            &#125;)\n        &#125;\n        if (this.PromiseState === &#39;rejected&#39;) &#123;\n            setTimeout(() =&gt; &#123;\n                callback(onRejected);\n            &#125;)\n        &#125;\n        //判断 pending 状态\n        if (this.PromiseState === &#39;pending&#39;) &#123;\n            //保存回调函数\n            this.callbacks.push(&#123;\n                onResolved: function () &#123;\n                    callback(onResolved);\n                &#125;,\n                onRejected: function () &#123;\n                    callback(onRejected);\n                &#125;\n            &#125;);\n        &#125;\n    &#125;)\n&#125;\n\n//添加 catch 方法\nPromise.prototype.catch = function (onRejected) &#123;\n    return this.then(undefined, onRejected);\n&#125;\n\n//添加 resolve 方法\nPromise.resolve = function (value) &#123;\n    //返回promise对象\n    return new Promise((resolve, reject) =&gt; &#123;\n        if (value instanceof Promise) &#123;\n            value.then(v =&gt; &#123;\n                resolve(v);\n            &#125;, r =&gt; &#123;\n                reject(r);\n            &#125;)\n        &#125; else &#123;\n            //状态设置为成功\n            resolve(value);\n        &#125;\n    &#125;);\n&#125;\n\n//添加 reject 方法\nPromise.reject = function (reason) &#123;\n    return new Promise((resolve, reject) =&gt; &#123;\n        reject(reason);\n    &#125;);\n&#125;\n\n//添加 all 方法\nPromise.all = function (promises) &#123;\n    //返回结果为promise对象\n    return new Promise((resolve, reject) =&gt; &#123;\n        //声明变量\n        let count = 0;\n        let arr = [];\n        //遍历\n        for (let i = 0; i &lt; promises.length; i++) &#123;\n            //\n            promises[i].then(v =&gt; &#123;\n                //得知对象的状态是成功\n                //每个promise对象 都成功\n                count++;\n                //将当前promise对象成功的结果 存入到数组中\n                arr[i] = v;\n                //判断\n                if (count === promises.length) &#123;\n                    //修改状态\n                    resolve(arr);\n                &#125;\n            &#125;, r =&gt; &#123;\n                reject(r);\n            &#125;);\n        &#125;\n    &#125;);\n&#125;\n\n//添加 race 方法\nPromise.race = function (promises) &#123;\n    return new Promise((resolve, reject) =&gt; &#123;\n        for (let i = 0; i &lt; promises.length; i++) &#123;\n            promises[i].then(v =&gt; &#123;\n                //修改返回对象的状态为 『成功』\n                resolve(v);\n            &#125;, r =&gt; &#123;\n                //修改返回对象的状态为 『失败』\n                reject(r);\n            &#125;)\n        &#125;\n    &#125;);\n&#125;\n</code></pre>\n<h2 id=\"5、async与await\"><a href=\"#5、async与await\" class=\"headerlink\" title=\"5、async与await\"></a>5、async与await</h2><h3 id=\"5-1-mdn文档\"><a href=\"#5-1-mdn文档\" class=\"headerlink\" title=\"5.1. mdn文档\"></a>5.1. mdn文档</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async</a> function<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await</a></p>\n<h3 id=\"5-2-async函数\"><a href=\"#5-2-async函数\" class=\"headerlink\" title=\"5.2.async函数\"></a>5.2.async函数</h3><ol>\n<li><p>函数的返回值为promise对象</p>\n</li>\n<li><p>promise对象的结果由async函数执行的返回值决定</p>\n</li>\n</ol>\n<h3 id=\"5-3-await表达式\"><a href=\"#5-3-await表达式\" class=\"headerlink\" title=\"5.3.await表达式\"></a>5.3.await表达式</h3><ol>\n<li>await右侧的表达式一般为promise对象，但也可以是其它的值</li>\n<li>如果表达式是promise对象, await返回的是promise 成功的值</li>\n<li>如果表达式是其它值，直接将此值作为await的返回值</li>\n</ol>\n<h3 id=\"5-4-注意\"><a href=\"#5-4-注意\" class=\"headerlink\" title=\"5.4.注意\"></a>5.4.注意</h3><ol>\n<li>await 必须写在async函数中，但 async函数中可以没有await</li>\n<li>如果await 的promise失败了，就会抛出异常，需要通过try…catch 捕获处理</li>\n</ol>\n","feature":true,"text":"在前端开发中，Promise是一种用于处理异步操作的对象，可简化回调函数嵌套，有效管理复杂的异步代码。通过Promise，可以更清晰地表达和处理异步操作的结果，避免回调地狱问题，提高代码的可读性和可维护性。...","permalink":"/post/前端--Promise详解与手写实现","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"Promise","slug":"Promise","count":1,"path":"api/tags/Promise.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Promise\"><span class=\"toc-text\">Promise</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1%E3%80%81Promise%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">1、Promise介绍与基本使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-Promise%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1.1 Promise概述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-Promise%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">1.2 Promise的作用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-Promise%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">1.3 Promise的使用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2%E3%80%81Promise-API\"><span class=\"toc-text\">2、Promise API</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3%E3%80%81Promise%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">3、Promise关键问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4%E3%80%81Promise%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B0%81%E8%A3%85\"><span class=\"toc-text\">4、Promise自定义封装</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5%E3%80%81async%E4%B8%8Eawait\"><span class=\"toc-text\">5、async与await</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-mdn%E6%96%87%E6%A1%A3\"><span class=\"toc-text\">5.1. mdn文档</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-2-async%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">5.2.async函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-3-await%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">5.3.await表达式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-4-%E6%B3%A8%E6%84%8F\"><span class=\"toc-text\">5.4.注意</span></a></li></ol></li></ol></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Axios进阶指南：构建可靠的前端网络请求","uid":"ccba9309aa28da995832d41b5289f1c2","slug":"前端--详解axios（快速入门）","date":"2023-01-31T01:25:07.000Z","updated":"2025-07-14T15:12:20.467Z","comments":true,"path":"api/articles/前端--详解axios（快速入门）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/a9b45d876424411993cb1ae4218a5f93.jpeg","text":"Axios是一种基于Promise的HTTP客户端，主要用于在前端开发中进行网络请求。它提供了简洁、直观的API接口，支持异步请求、拦截器、取消请求等功能。通过使用Axios，前端开发者可以轻松地与后端进行数据交互，获取和发送数据。...","permalink":"/post/前端--详解axios（快速入门）","photos":[],"count_time":{"symbolsCount":"8.5k","symbolsTime":"8 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"Axios","slug":"Axios","count":1,"path":"api/tags/Axios.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true},"next_post":{"title":"Node.js入门指南","uid":"49049ff97839855eecbcd2b661106a8a","slug":"前端--详解Node.js(快速入门)","date":"2023-01-26T00:36:42.000Z","updated":"2025-07-14T15:12:20.467Z","comments":true,"path":"api/articles/前端--详解Node.js(快速入门).json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/b0f0273b8a054a6d9c9e5d3f2a5c267f.png","text":"Node.js是建立在Chrome V8引擎之上的JavaScript运行时环境，可用于快速构建可伸缩的网络应用。它采用事件驱动、非阻塞I/O模型，适用于实时数据处理。Node.js还拥有丰富的包管理工具，如npm，使得前端开发者能够方便地共享和重复使用代码。...","permalink":"/post/前端--详解Node.js(快速入门)","photos":[],"count_time":{"symbolsCount":"43k","symbolsTime":"39 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"Node","slug":"Node","count":1,"path":"api/tags/Node.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true}}