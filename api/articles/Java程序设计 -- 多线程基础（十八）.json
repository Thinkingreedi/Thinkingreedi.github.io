{"title":"Java程序设计--多线程","uid":"4efd1e259b597b69971ef5e65a102b02","slug":"Java程序设计 -- 多线程基础（十八）","date":"2022-04-12T14:02:36.000Z","updated":"2025-07-14T15:12:20.459Z","comments":true,"path":"api/articles/Java程序设计 -- 多线程基础（十八）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","content":"<hr>\n<h1 id=\"1、多线程的创建\"><a href=\"#1、多线程的创建\" class=\"headerlink\" title=\"1、多线程的创建\"></a>1、多线程的创建</h1><p><strong>线程(thread)是一个程序内部的一条执行路径。</strong></p>\n<p>我们之前启动程序执行后，main方法的执行其实就是一条单独的执行路径。</p>\n<pre><code class=\"java\">public static void main(String] args) &#123;\n//代码...\nfor (int i = 0; i &lt; 10; i++)&#123;System.out.println(i);\n//代码..\n&#125;\n</code></pre>\n<p><strong>程序中如果只有一条执行路径，那么这个程序就是单线程的程序。</strong></p>\n<p>&#x3D;&#x3D;<strong>多线程是指从软硬件上实现多条执行流程的技术。</strong>&#x3D;&#x3D;</p>\n<h2 id=\"1-1-创建方式一-继承Thread类\"><a href=\"#1-1-创建方式一-继承Thread类\" class=\"headerlink\" title=\"1.1 创建方式一 - - 继承Thread类\"></a>1.1 创建方式一 - - 继承Thread类</h2><p>Java是通过java.lang.Thread类来代表线程的。</p>\n<p>按照面向对象的思想，Thread类应该提供了实现多线程的方式。</p>\n<p>步骤：</p>\n<ol>\n<li><strong>定义一个子类MyThread继承线程类java.lang.Thread，重写run()方法</strong></li>\n<li><strong>创建MyThread类的对象</strong></li>\n<li><strong>调用线程对象的start()方法启动线程（启动后还是执行run方法的)</strong></li>\n</ol>\n<pre><code class=\"java\">public class ThreadDemo1 &#123;\n    public static void main(String[] args) &#123;\n        // 3、new一个新线程对象\n        Thread t = new MyThread();\n        // 4、调用start方法启动线程（执行的还是run方法）\n        t.start();\n\n        for (int i = 0; i &lt; 5; i++) &#123;\n            System.out.println(&quot;主线程执行输出：&quot; + i);\n        &#125;\n\n    &#125;\n&#125;\n\n/**\n   1、定义一个线程类继承Thread类\n */\nclass MyThread extends Thread&#123;\n    /**\n       2、重写run方法，里面是定义线程以后要干啥\n     */\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 5; i++) &#123;\n            System.out.println(&quot;子线程执行输出：&quot; + i);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>优缺点：</p>\n<ul>\n<li>优点:<strong>编码简单。</strong></li>\n<li>缺点:<strong>线程类已经继承Thread，无法继承其他类，不利于扩展。</strong></li>\n</ul>\n<h2 id=\"1-2-创建方式二-实现Runnable接口\"><a href=\"#1-2-创建方式二-实现Runnable接口\" class=\"headerlink\" title=\"1.2 创建方式二 - - 实现Runnable接口\"></a>1.2 创建方式二 - - 实现Runnable接口</h2><p>步骤：</p>\n<ol>\n<li><strong>定义一个线程任务类MyRunnable实现Runnable接口，重写run()方法创建</strong></li>\n<li><strong>MyRunnable任务对象</strong></li>\n<li><strong>把MyRunnable任务对象交给Thread处理</strong></li>\n<li><strong>调用线程对象的start()方法启动线程</strong></li>\n</ol>\n<p><strong>Thread的构造器</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">构造器</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public Thread(String name)</td>\n<td align=\"center\">可以为当前线程指定名称</td>\n</tr>\n<tr>\n<td align=\"center\">public Thread(Runnable target)</td>\n<td align=\"center\">封装Runnable对象成为线程对象</td>\n</tr>\n<tr>\n<td align=\"center\">public Thread(Runnable target ,String name )</td>\n<td align=\"center\">封装Runnable对象成为线程对象，并指定线程名称</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">public class ThreadDemo2 &#123;\n    public static void main(String[] args) &#123;\n        // 3、创建一个任务对象\n        Runnable target = new MyRunnable();\n        // 4、把任务对象交给Thread处理\n        Thread t = new Thread(target);\n        // Thread t = new Thread(target, &quot;1号&quot;);\n        // 5、启动线程\n        t.start();\n\n        for (int i = 0; i &lt; 10; i++) &#123;\n            System.out.println(&quot;主线程执行输出：&quot; + i);\n        &#125;\n    &#125;\n&#125;\n\n/**\n   1、定义一个线程任务类 实现Runnable接口\n */\nclass MyRunnable  implements Runnable &#123;\n    /**\n       2、重写run方法，定义线程的执行任务的\n     */\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 10; i++) &#123;\n            System.out.println(&quot;子线程执行输出：&quot; + i);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>优缺点：</p>\n<ul>\n<li>优点:<strong>线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强。</strong></li>\n<li>缺点:<strong>编程多一层对象包装，如果线程有执行结果是不可以直接返回的。</strong></li>\n</ul>\n<h2 id=\"1-3-创建方式三-实现Callable接口\"><a href=\"#1-3-创建方式三-实现Callable接口\" class=\"headerlink\" title=\"1.3 创建方式三 - - 实现Callable接口\"></a>1.3 创建方式三 - - 实现Callable接口</h2><p>前2种线程创建方式都存在一个问题:他们重写的run方法均不能直接返回结果。不适合需要返回线程执行结果的业务场景。</p>\n<p>JDK 5.0提供了Callable和FutureTask来实现。</p>\n<p><strong>这种方式的优点是:可以得到线程执行的结果。</strong></p>\n<ol>\n<li><strong>得到任务对象</strong><br>-\t1．定义类实现Callable接口，重写call方法，封装要做的事情。<br>-\t2.用FutureTask把Callable对象封装成线程任务对象。</li>\n<li><strong>把线程任务对象交给Thread处理</strong></li>\n<li><strong>调用Thread的start方法启动线程，执行任务</strong></li>\n<li><strong>线程执行完毕后、通过FutureTask的get方法去获取任务执行的结果</strong></li>\n</ol>\n<p>FutureTask的API</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public FutureTask&lt;&gt;(Callable call)</td>\n<td align=\"center\">把Callable对象封装成FutureTask对象。</td>\n</tr>\n<tr>\n<td align=\"center\">public V get() throws Exception</td>\n<td align=\"center\">获取线程执行call方法返回的结果。</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">import java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.FutureTask;\n\npublic class ThreadDemo3 &#123;\n    public static void main(String[] args) &#123;\n        // 3、创建Callable任务对象\n        Callable&lt;String&gt; call = new MyCallable(100);\n        // 4、把Callable任务对象 交给 FutureTask 对象\n        //  FutureTask对象的作用1： 是Runnable的对象（实现了Runnable接口），可以交给Thread了\n        //  FutureTask对象的作用2： 可以在线程执行完毕之后通过调用其get方法得到线程执行完成的结果\n        FutureTask&lt;String&gt; f1 = new FutureTask&lt;&gt;(call);\n        // 5、交给线程处理\n        Thread t1 = new Thread(f1);\n        // 6、启动线程\n        t1.start();\n\n\n        Callable&lt;String&gt; call2 = new MyCallable(200);\n        FutureTask&lt;String&gt; f2 = new FutureTask&lt;&gt;(call2);\n        Thread t2 = new Thread(f2);\n        t2.start();\n\n        try &#123;\n            // 如果f1任务没有执行完毕，这里的代码会等待，直到线程1跑完才提取结果。\n            String rs1 = f1.get();\n            System.out.println(&quot;第一个结果：&quot; + rs1);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        try &#123;\n            // 如果f2任务没有执行完毕，这里的代码会等待，直到线程2跑完才提取结果。\n            String rs2 = f2.get();\n            System.out.println(&quot;第二个结果：&quot; + rs2);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n/**\n    1、定义一个任务类 实现Callable接口  应该申明线程任务执行完毕后的结果的数据类型\n */\nclass MyCallable implements Callable&lt;String&gt;&#123;\n    private int n;\n    public MyCallable(int n) &#123;\n        this.n = n;\n    &#125;\n\n    /**\n       2、重写call方法（任务方法）\n     */\n    @Override\n    public String call() throws Exception &#123;\n        int sum = 0;\n        for (int i = 1; i &lt;= n ; i++) &#123;\n            sum += i;\n        &#125;\n        return &quot;子线程执行的结果是：&quot; + sum;\n    &#125;\n&#125;\n</code></pre>\n<p>优缺点:</p>\n<ul>\n<li>优点:<strong>线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强。可以在线程执行完毕后去获取线程执行的结果。</strong></li>\n<li>缺点:<strong>编码复杂一点。</strong></li>\n</ul>\n<hr>\n<h1 id=\"2、Thread的常用方法\"><a href=\"#2、Thread的常用方法\" class=\"headerlink\" title=\"2、Thread的常用方法\"></a>2、Thread的常用方法</h1><p><strong>Thread常见构造器</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">构造器</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public Thread(String name)</td>\n<td align=\"center\">可以为当前线程指定名称</td>\n</tr>\n<tr>\n<td align=\"center\">public Thread(Runnable target)</td>\n<td align=\"center\">把Runnable对象交给线程对象</td>\n</tr>\n<tr>\n<td align=\"center\">public Thread(Runnable target ,String name )</td>\n<td align=\"center\">把Runnable对象交给线程对象，并指定线程名称</td>\n</tr>\n</tbody></table>\n<p><strong>Thread常见方法</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">String getName()</td>\n<td align=\"center\">获取当前线程的名称，默认线程名称是Thread-索引</td>\n</tr>\n<tr>\n<td align=\"center\">void setName( String name)</td>\n<td align=\"center\">设置线程名称</td>\n</tr>\n<tr>\n<td align=\"center\">public static Thread currentThread( ) :</td>\n<td align=\"center\">返回对当前正在执行的线程对象的引用</td>\n</tr>\n<tr>\n<td align=\"center\">public static void sleep(long time)</td>\n<td align=\"center\">让线程休眠指定的时间，单位为毫秒。</td>\n</tr>\n<tr>\n<td align=\"center\">public void run()</td>\n<td align=\"center\">线程任务方法</td>\n</tr>\n<tr>\n<td align=\"center\">public void start()</td>\n<td align=\"center\">线程启动方法</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">public class MyThread extends Thread&#123;\n    public MyThread() &#123;\n    &#125;\n\n    public MyThread(String name) &#123;\n        // 为当前线程对象设置名称，送给父类的有参数构造器初始化名称\n        super(name);\n    &#125;\n\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 5; i++) &#123;\n            System.out.println( Thread.currentThread().getName() + &quot;输出：&quot; + i);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class ThreadDemo01 &#123;\n    // main方法是由主线程负责调度的\n    public static void main(String[] args) &#123;\n        Thread t1 = new MyThread(&quot;1号&quot;);\n        // t1.setName(&quot;1号&quot;);\n        t1.start();\n        System.out.println(t1.getName());\n\n        Thread t2 = new MyThread(&quot;2号&quot;);\n        // t2.setName(&quot;2号&quot;);\n        t2.start();\n        System.out.println(t2.getName());\n\n        // 哪个线程执行它，它就得到哪个线程对象（当前线程对象）\n        // 主线程的名称就叫main\n        Thread m = Thread.currentThread();\n        System.out.println(m.getName());\n        m.setName(&quot;最牛的线程&quot;);\n\n        for (int i = 0; i &lt; 5; i++) &#123;\n            System.out.println( m.getName() + &quot;输出：&quot; + i);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class ThreadDemo02 &#123;\n    // main方法是由主线程负责调度的\n    public static void main(String[] args) throws Exception &#123;\n        for (int i = 1; i &lt;= 5; i++) &#123;\n            System.out.println(&quot;输出：&quot; + i);\n            if(i == 3)&#123;\n                // 让当前线程进入休眠状态\n                // 段子：项目经理让我加上这行代码，如果用户愿意交钱，我就注释掉。\n                Thread.sleep(3000);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<hr>\n<h1 id=\"3、线程安全\"><a href=\"#3、线程安全\" class=\"headerlink\" title=\"3、线程安全\"></a>3、线程安全</h1><p>多个线程同时操作同一个共享资源的时候可能会出现业务安全问题，称为线程安全问题。</p>\n<p><strong>线程安全问题出现的原因：</strong></p>\n<ul>\n<li>&#x3D;&#x3D;存在多线程并发&#x3D;&#x3D;</li>\n<li>&#x3D;&#x3D;同时访问共享资源&#x3D;&#x3D;</li>\n<li>&#x3D;&#x3D;存在修改共享资源&#x3D;&#x3D;</li>\n</ul>\n<hr>\n<h1 id=\"4、线程同步\"><a href=\"#4、线程同步\" class=\"headerlink\" title=\"4、线程同步\"></a>4、线程同步</h1><p>&#x3D;&#x3D;<strong>线程同步是为了解决线程安全问题。</strong>&#x3D;&#x3D;</p>\n<p><strong>线程同步的核心思想</strong></p>\n<p>&#x3D;&#x3D;加锁，把共享资源进行上锁，每次只能一个线程进入访问完毕以后解锁，然后其他线程才能进来。&#x3D;&#x3D;</p>\n<h2 id=\"4-1-方式一-同步代码块\"><a href=\"#4-1-方式一-同步代码块\" class=\"headerlink\" title=\"4.1 方式一 - - 同步代码块\"></a>4.1 方式一 - - 同步代码块</h2><ul>\n<li>&#x3D;&#x3D;作用:把出现线程安全问题的核心代码给上锁。&#x3D;&#x3D;</li>\n<li>原理:每次只能一个线程进入，执行完毕后自动解锁，其他线程才可以进来执行。</li>\n</ul>\n<pre><code class=\"java\">synchronized(同步锁对象)&#123;\n    操作共享资源的代码(核心代码)\n&#125;\n</code></pre>\n<p>&#x3D;&#x3D;锁对象要求：理论上锁对象只要对于当前同时执行的线程来说是同一个对象即可。&#x3D;&#x3D;</p>\n<ul>\n<li><strong>规范上:建议使用共享资源作为锁对象。</strong></li>\n<li><strong>对于实例方法建议使用this作为锁对象。</strong></li>\n<li><strong>对于静态方法建议使用字节码(类名.class)对象作为锁对象。</strong></li>\n</ul>\n<pre><code class=\"java\">public class Account &#123;\n    private String cardId;\n    private double money; // 余额 关键信息\n\n    public Account() &#123;\n    &#125;\n\n    public Account(String cardId, double money) &#123;\n        this.cardId = cardId;\n        this.money = money;\n    &#125;\n\n    public String getCardId() &#123;\n        return cardId;\n    &#125;\n\n    public void setCardId(String cardId) &#123;\n        this.cardId = cardId;\n    &#125;\n\n    public double getMoney() &#123;\n        return money;\n    &#125;\n\n    public void setMoney(double money) &#123;\n        this.money = money;\n    &#125;\n\n    public void drawMoney(double money) &#123;\n        // 1、拿到是谁来取钱\n        String name = Thread.currentThread().getName();\n        // 同步代码块\n        // 小明 小红\n        // this == acc 共享账户\n        synchronized (this) &#123;\n            // 2、判断余额是否足够\n            if(this.money &gt;= money)&#123;\n                // 钱够了\n                System.out.println(name+&quot;来取钱，吐出：&quot; + money);\n                // 更新余额\n                this.money -= money;\n                System.out.println(name+&quot;取钱后，余额剩余：&quot; + this.money);\n            &#125;else&#123;\n                // 3、余额不足\n                System.out.println(name+&quot;来取钱，余额不足！&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class DrawThread extends Thread&#123;\n    private Account acc;\n    public DrawThread(Account acc, String name)&#123;\n        super(name);\n        this.acc = acc;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        // 小明 小红  ： acc\n        acc.drawMoney(100000);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class TestSafeDemo &#123;\n    public static void main(String[] args) &#123;\n        // 测试线程安全问题\n        // 1、创建一个共享的账户对象。\n        Account acc = new Account(&quot;ICBC-111&quot; , 100000);\n\n        // 2、创建2个线程对象，操作同一个账户对象\n        new DrawThread(acc, &quot;小明&quot;).start();\n        new DrawThread(acc,&quot;小红&quot;).start();\n\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"4-2-方式二-同步方法\"><a href=\"#4-2-方式二-同步方法\" class=\"headerlink\" title=\"4.2 方式二 - - 同步方法\"></a>4.2 方式二 - - 同步方法</h2><ul>\n<li>&#x3D;&#x3D;作用:把出现线程安全问题的核心方法给上锁。&#x3D;&#x3D;</li>\n<li>原理:每次只能一个线程进入，执行完毕以后自动解锁，其他线程才可以进来执行。</li>\n</ul>\n<pre><code class=\"java\">修饰符 synchronized 返回值类型 方法名称(形参列表)&#123;\n    操作共享资源的代码\n&#125;\n</code></pre>\n<pre><code class=\"java\">public synchronized void drawMoney(double money) &#123;\n        // 1、拿到是谁来取钱\n        String name = Thread.currentThread().getName();\n        // 2、判断余额是否足够\n        // 小明  小红\n        if(this.money &gt;= money)&#123;\n            // 钱够了\n            System.out.println(name+&quot;来取钱，吐出：&quot; + money);\n            // 更新余额\n            this.money -= money;\n            System.out.println(name+&quot;取钱后，余额剩余：&quot; + this.money);\n        &#125;else&#123;\n            // 3、余额不足\n            System.out.println(name+&quot;来取钱，余额不足！&quot;);\n        &#125;\n    &#125;\n</code></pre>\n<p><strong>同步方法底层原理</strong></p>\n<ul>\n<li><strong>同步方法其实底层也是有隐式锁对象的，只是锁的范围是整个方法代码。（相对于同步代码块锁范围更大）</strong></li>\n<li><strong>如果方法是实例方法:同步方法默认用this作为的锁对象。但是代码要高度面向对象!</strong></li>\n<li><strong>如果方法是静态方法:同步方法默认用类名.class作为的锁对象。</strong></li>\n</ul>\n<h2 id=\"4-3-方式三-Lock锁\"><a href=\"#4-3-方式三-Lock锁\" class=\"headerlink\" title=\"4.3 方式三 - - Lock锁\"></a>4.3 方式三 - - Lock锁</h2><ul>\n<li>为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock，更加灵活、方便。</li>\n<li>Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作。</li>\n<li>Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来构建Lock锁对象。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public ReentrantLock()</td>\n<td align=\"center\">获得Lock锁的实现类对象</td>\n</tr>\n</tbody></table>\n<p><strong>Lock的API</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">void lock()</td>\n<td align=\"center\">获得锁</td>\n</tr>\n<tr>\n<td align=\"center\">void unlock()</td>\n<td align=\"center\">释放锁</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">public void drawMoney(double money) &#123;\n        // 1、拿到是谁来取钱\n        String name = Thread.currentThread().getName();\n        // 2、判断余额是否足够\n        // 小明  小红\n        lock.lock(); // 上锁\n        try &#123;\n            if(this.money &gt;= money)&#123;\n                // 钱够了\n                System.out.println(name+&quot;来取钱，吐出：&quot; + money);\n                // 更新余额\n                this.money -= money;\n                System.out.println(name+&quot;取钱后，余额剩余：&quot; + this.money);\n            &#125;else&#123;\n                // 3、余额不足\n                System.out.println(name+&quot;来取钱，余额不足！&quot;);\n            &#125;\n        &#125; finally &#123;\n            lock.unlock(); // 解锁\n        &#125;\n\n    &#125;\n</code></pre>\n<hr>\n<h1 id=\"5、线程通信\"><a href=\"#5、线程通信\" class=\"headerlink\" title=\"5、线程通信\"></a>5、线程通信</h1><p>所谓线程通信就是线程间相互发送数据，线程间共享一个资源即可实现线程通信。</p>\n<p><strong>线程通信常见形式</strong></p>\n<ul>\n<li>通过共享一个数据的方式实现。</li>\n<li>根据共享数据的情况决定自己该怎么做，以及通知其他线程怎么做。</li>\n</ul>\n<p><strong>线程通信实际应用场景</strong></p>\n<ul>\n<li>生产者与消费者模型:生产者线程负责生产数据，消费者线程负责消费生产者产生的数据。</li>\n<li>要求:生产者线程生产完数据后唤醒消费者，然后等待自己，消费者消费完该数据后唤醒生产者，然后等待自己。</li>\n</ul>\n<p><strong>Object类的等待和唤醒方法:</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">void wait()</td>\n<td align=\"center\">让当前线程等待并释放所占锁，直到另一个线程调用notify()方法或notifyAll()</td>\n</tr>\n<tr>\n<td align=\"center\">void notify()</td>\n<td align=\"center\">唤醒正在等待的单个线程</td>\n</tr>\n<tr>\n<td align=\"center\">void notifyAll()</td>\n<td align=\"center\">唤醒正在等待的所有线程</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>注意：上述方法应该使用当前同步锁对象进行调用。</strong></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<hr>\n<h1 id=\"6、线程池\"><a href=\"#6、线程池\" class=\"headerlink\" title=\"6、线程池\"></a>6、线程池</h1><h2 id=\"6-1-线程池概述\"><a href=\"#6-1-线程池概述\" class=\"headerlink\" title=\"6.1 线程池概述\"></a>6.1 线程池概述</h2><p>&#x3D;&#x3D;线程池就是一个可以复用线程的技术。&#x3D;&#x3D;</p>\n<p>不使用线程池，如果用户每发起一个请求，后台就创建一个新线程来处理，下次新任务来了又要创建新线程，而创建新线程的开销是很大的，这样会严重影响系统的性能。<img src=\"https://img-blog.csdnimg.cn/5d3422bc397144e183eed3cfd33e00b9.png#pic_center\"></p>\n<h2 id=\"6-2-线程池相关API\"><a href=\"#6-2-线程池相关API\" class=\"headerlink\" title=\"6.2 线程池相关API\"></a>6.2 线程池相关API</h2><p>JDK 5.0起提供了代表线程池的接口: ExecutorService</p>\n<p>如何得到线程池对象</p>\n<ul>\n<li>方式一:<strong>使用ExecutorService的实现类ThreadPoolExecutor自创建一个线程池对象</strong></li>\n<li>方式二:<strong>使用Executors（线程池的工具类）调用方法返回不同特点的线程池对象</strong></li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/c792b748ef764921bf0550c64f24234c.png#pic_center\"></p>\n<pre><code class=\"java\">public class ThreadPoolDemo1 &#123;\n    public static void main(String[] args) &#123;\n        // 1、创建线程池对象\n        ExecutorService pool = new ThreadPoolExecutor(3, 5 ,\n                6, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(5) , Executors.defaultThreadFactory(),\n               new ThreadPoolExecutor.AbortPolicy() );\n\n        // 2、给任务线程池处理。\n        Runnable target = new MyRunnable();\n        pool.execute(target);\n        pool.execute(target);\n        pool.execute(target);\n\n        pool.execute(target);\n        pool.execute(target);\n        pool.execute(target);\n        pool.execute(target);\n        pool.execute(target);\n\n        // 创建临时线程\n        pool.execute(target);\n        pool.execute(target);\n//        // 不创建，拒绝策略被触发！！！\n//        pool.execute(target);\n\n        // 关闭线程池（开发中一般不会使用）。\n        // pool.shutdownNow(); // 立即关闭，即使任务没有完成，会丢失任务的！\n        pool.shutdown(); // 会等待全部任务执行完毕之后再关闭（建议使用的）\n    &#125;\n&#125;\n</code></pre>\n<p>&#x3D;&#x3D;新任务提交时发现核心线程都在忙，任务队列也满了，并且还可以创建临时线程，此时才会创建临时线程。&#x3D;&#x3D;</p>\n<p>&#x3D;&#x3D;核心线程和临时线程都在忙，任务队列也满了，新的任务过来的时候才会开始任务拒绝。&#x3D;&#x3D;</p>\n<h2 id=\"6-3-线程池处理任务\"><a href=\"#6-3-线程池处理任务\" class=\"headerlink\" title=\"6.3 线程池处理任务\"></a>6.3 线程池处理任务</h2><p><strong>ExecutorService的常用方法</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">void execute(Runnable command)</td>\n<td align=\"center\">执行任务&#x2F;命令，没有返回值，一般用来执行 Runnable 任务</td>\n</tr>\n<tr>\n<td align=\"center\">Future&lt; T &gt; submit(Callable&lt; T &gt; task)</td>\n<td align=\"center\">执行任务，返回未来任务对象获取线程结果，一般拿来执行callable任务</td>\n</tr>\n<tr>\n<td align=\"center\">void shutdown()</td>\n<td align=\"center\">等任务执行完毕后关闭线程池</td>\n</tr>\n<tr>\n<td align=\"center\">List&lt; Runnable &gt; shutdownNow()</td>\n<td align=\"center\">立刻关闭，停止正在执行的任务，并返回队列中未执行的任务</td>\n</tr>\n</tbody></table>\n<p><strong>新任务拒绝策略</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">策略</th>\n<th align=\"center\">详解</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">ThreadPoolExecutor.AbortPolicy</td>\n<td align=\"center\">丢弃任务并抛出RejectedExecutionException异常。是默认的策略</td>\n</tr>\n<tr>\n<td align=\"center\">ThreadPoolExecutor.DiscardPolicy:</td>\n<td align=\"center\">丢弃任务，但是不抛出异常这是不推荐的做法</td>\n</tr>\n<tr>\n<td align=\"center\">ThreadPoolExecutor.DiscardOldestpolicy</td>\n<td align=\"center\">抛弃队列中等待最久的任务然后把当前任务加入队列中</td>\n</tr>\n<tr>\n<td align=\"center\">ThreadPoolExecutor.callerRunsPolicy</td>\n<td align=\"center\">由主线程负责调用任务的run()方法从而绕过线程池直接执行</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>线程池处理Runnable任务</strong></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">public class MyRunnable implements Runnable&#123;\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 5; i++) &#123;\n            System.out.println(Thread.currentThread().getName() + &quot;输出了：HelloWorld ==&gt; &quot;  + i);\n        &#125;\n        try &#123;\n            System.out.println(Thread.currentThread().getName() + &quot;本任务与线程绑定了，线程进入休眠了~~~&quot;);\n            Thread.sleep(10000000);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>线程池处理Callable任务</strong></p>\n<pre><code class=\"java\">import java.util.concurrent.Callable;\n\n/**\n    1、定义一个任务类 实现Callable接口  应该申明线程任务执行完毕后的结果的数据类型\n */\npublic class MyCallable implements Callable&lt;String&gt;&#123;\n    private int n;\n    public MyCallable(int n) &#123;\n        this.n = n;\n    &#125;\n\n    /**\n       2、重写call方法（任务方法）\n     */\n    @Override\n    public String call() throws Exception &#123;\n        int sum = 0;\n        for (int i = 1; i &lt;= n ; i++) &#123;\n            sum += i;\n        &#125;\n        return Thread.currentThread().getName()\n                + &quot;执行 1-&quot; + n+ &quot;的和，结果是：&quot; + sum;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"6-4-Executors工具类实现线程池\"><a href=\"#6-4-Executors工具类实现线程池\" class=\"headerlink\" title=\"6.4 Executors工具类实现线程池\"></a>6.4 Executors工具类实现线程池</h2><p>Executors得到线程池对象的常用方法</p>\n<p>Executors:线程池的工具类通过调用方法返回不同类型的线程池对象。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名称</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public static ExecutorService newCachedThreadPool()</td>\n<td align=\"center\">线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了一段时间则会被回收掉。</td>\n</tr>\n<tr>\n<td align=\"center\">public static ExecutorService newFixedThreadPool(int nThreads)</td>\n<td align=\"center\">创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程替代它。</td>\n</tr>\n<tr>\n<td align=\"center\">public static Executorservice newSingleThreadExecutor ()</td>\n<td align=\"center\">创建只有一个线程的线程池对象，如果该线程出现异常而结束，那么线程池会补充一个新线程。</td>\n</tr>\n<tr>\n<td align=\"center\">public static ScheduledExecutorService newScheduledThreadPool(intcorePoolSize)</td>\n<td align=\"center\">创建一个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务。</td>\n</tr>\n</tbody></table>\n<p><strong>注意:Executors的底层其实也是基于线程池的实现类ThreadPoolExecutor创建线程池对象的。</strong></p>\n<p>Executors使用可能存在的陷阱<br>大型并发系统环境中使用Executors如果不注意可能会出现系统风险。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名称</th>\n<th align=\"center\">存在问题</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public static ExecutorService newFixedThreadPool(int nThreads) \\\\ public static ExecutorService newSingleThreadExecutor()</td>\n<td align=\"center\">允许请求的任务队列长度是Integer.MAX_VALUE，可能出现OOM错误( java.lang.OutOfMemoryError )</td>\n</tr>\n<tr>\n<td align=\"center\">public static ExecutorService newCachedThreadPool() \\\\ public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</td>\n<td align=\"center\">创建的线程数量最大上限是Integer.MAX_VALUE,线程数可能会随着任务1:1增长，也可能出现OOM错误( java.lang.OutOfMemoryError）</td>\n</tr>\n</tbody></table>\n<hr>\n<h1 id=\"7、定时器\"><a href=\"#7、定时器\" class=\"headerlink\" title=\"7、定时器\"></a>7、定时器</h1><ul>\n<li>定时器是一种控制任务延时调用，或者周期调用的技术。</li>\n<li>作用:闹钟、定时邮件发送。</li>\n</ul>\n<p><strong>定时器的实现方式</strong></p>\n<ul>\n<li>方式一: Timer</li>\n<li>方式二: ScheduledExecutorService</li>\n</ul>\n<p><strong>Timer定时器</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">构造</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public Timer()</td>\n<td align=\"center\">创建Timer定时器对象</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public void schedule(TimerTask task，long delay,long period)</td>\n<td align=\"center\">开启一个定时器,按照计划处理TimerTask任务</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">import java.util.Date;\nimport java.util.Timer;\nimport java.util.TimerTask;\n\n\npublic class TimerDemo1 &#123;\n    public static void main(String[] args) &#123;\n        // 1、创建Timer定时器\n        Timer timer = new Timer();  // 定时器本身就是一个单线程。\n        // 2、调用方法，处理定时任务\n        timer.schedule(new TimerTask() &#123;\n            @Override\n            public void run() &#123;\n                System.out.println(Thread.currentThread().getName() + &quot;执行AAA~~~&quot; + new Date());\n            &#125;\n        &#125;, 0, 2000);\n\n        timer.schedule(new TimerTask() &#123;\n            @Override\n            public void run() &#123;\n                System.out.println(Thread.currentThread().getName() + &quot;执行BB~~~&quot;+ new Date());\n                System.out.println(10/0);\n            &#125;\n        &#125;, 0, 2000);\n\n        timer.schedule(new TimerTask() &#123;\n            @Override\n            public void run() &#123;\n                System.out.println(Thread.currentThread().getName() + &quot;执行CCC~~~&quot;+ new Date());\n            &#125;\n        &#125;, 0, 3000);\n    &#125;\n&#125;\n</code></pre>\n<p><strong>Timer定时器的特点和存在的问题</strong></p>\n<ol>\n<li>Timer是单线程，处理多个任务按照顺序执行，存在延时与设置定时器的时间有出入。</li>\n<li>可能因为其中的某个任务的异常使Timer线程死掉，从而影响后续任务执行。</li>\n</ol>\n<p><strong>ScheduledExecutorService定时器</strong></p>\n<p>ScheduledExecutorService是jdk1.5中引入了并发包，目的是为了弥补Timer的缺陷, ScheduledExecutorService内部为线程池。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Executors的方法</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</td>\n<td align=\"center\">得到线程池对象</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"center\">ScheduledExecutorService的方法</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command，long initialDelay， long period,TimeUnit unit)</td>\n<td align=\"center\">周期调度方法</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">import java.util.Date;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\n/**\n    目标：Timer定时器的使用和了解。\n */\npublic class TimerDemo2 &#123;\n    public static void main(String[] args) &#123;\n        // 1、创建ScheduledExecutorService线程池，做定时器\n        ScheduledExecutorService pool = Executors.newScheduledThreadPool(3);\n\n        // 2、开启定时任务\n        pool.scheduleAtFixedRate(new TimerTask() &#123;\n            @Override\n            public void run() &#123;\n                System.out.println(Thread.currentThread().getName() + &quot;执行输出：AAA  ==》 &quot; + new Date());\n                try &#123;\n                    Thread.sleep(100000);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;, 0, 2, TimeUnit.SECONDS);\n\n\n        pool.scheduleAtFixedRate(new TimerTask() &#123;\n            @Override\n            public void run() &#123;\n                System.out.println(Thread.currentThread().getName() + &quot;执行输出：BBB  ==》 &quot; + new Date());\n                System.out.println(10 / 0);\n            &#125;\n        &#125;, 0, 2, TimeUnit.SECONDS);\n\n\n        pool.scheduleAtFixedRate(new TimerTask() &#123;\n            @Override\n            public void run() &#123;\n                System.out.println(Thread.currentThread().getName() + &quot;执行输出：CCC  ==》 &quot; + new Date());\n            &#125;\n        &#125;, 0, 2, TimeUnit.SECONDS);\n\n    &#125;\n&#125;\n</code></pre>\n<p>ScheduledExecutorService的优点</p>\n<ul>\n<li>基于线程池，某个任务的执行情况不会影响其他定时任务的执行。</li>\n</ul>\n<hr>\n<h1 id=\"8、并发、并行\"><a href=\"#8、并发、并行\" class=\"headerlink\" title=\"8、并发、并行\"></a>8、并发、并行</h1><p>并发与并行</p>\n<ul>\n<li>正在运行的程序（软件）就是一个独立的进程，线程是属于进程的，多个线程其实是并发与并行同时进行的。</li>\n</ul>\n<p>并发的理解:</p>\n<ul>\n<li>&#x3D;&#x3D;CPU同时处理线程的数量有限。&#x3D;&#x3D;</li>\n<li>&#x3D;&#x3D;CPU会轮询为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发。【CPU分时轮询的执行过程】&#x3D;&#x3D;</li>\n</ul>\n<p>并行的理解:</p>\n<ul>\n<li>&#x3D;&#x3D;在同一个时刻上，同时有多个线程在被CPU处理并执行。【同一时刻同时在执行】&#x3D;&#x3D;</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/694199db0e7f4d58be4cc6d0324071eb.png\"></p>\n<hr>\n<h1 id=\"9、线程的生命周期\"><a href=\"#9、线程的生命周期\" class=\"headerlink\" title=\"9、线程的生命周期\"></a>9、线程的生命周期</h1><p>线程的状态:也就是线程从生到死的过程，以及中间经历的各种状态及状态转换。理解线程的状态有利于提升并发编程的理解能力。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/32964b04a261497196f9f54606472fe7.png#pic_center\"><br>线程的6种状态总结</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">线程状态</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">NEW(新建)</td>\n<td align=\"center\">线程刚被创建，但是并未启动。</td>\n</tr>\n<tr>\n<td align=\"center\">Runnable(可运行)</td>\n<td align=\"center\">线程已经调用了start()等待CPU调度</td>\n</tr>\n<tr>\n<td align=\"center\">Blocked(锁阻塞)</td>\n<td align=\"center\">线程在执行的时候未竞争到锁对象，则该线程进入Blocked状态。</td>\n</tr>\n<tr>\n<td align=\"center\">Waiting(无限等待)</td>\n<td align=\"center\">一个线程进入Waiting状态，另一个线程调用notify或者notifyAll方法才能够唤醒</td>\n</tr>\n<tr>\n<td align=\"center\">Timed Waiting(计时等待)</td>\n<td align=\"center\">同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。带有超时参数的常用方法有Thread.sleep 、 Object.wait。</td>\n</tr>\n<tr>\n<td align=\"center\">Teminated(被终止)</td>\n<td align=\"center\">因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡</td>\n</tr>\n</tbody></table>\n<hr>\n","feature":true,"text":"多线程编程允许程序同时执行多个任务，提高系统利用率。线程池则管理和复用线程，降低线程创建和销毁的开销。线程通信是多线程间交换信息和协调工作的机制。合理运用多线程和线程池可以提升程序性能，而线程通信则能确保线程之间的协调和同步。这些技术在并发编程中起着重要作用，对于提升系统的效率和响应能力至关重要。...","permalink":"/post/Java程序设计 -- 多线程基础（十八）","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">1、多线程的创建</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E4%B8%80-%E7%BB%A7%E6%89%BFThread%E7%B1%BB\"><span class=\"toc-text\">1.1 创建方式一 - - 继承Thread类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E4%BA%8C-%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">1.2 创建方式二 - - 实现Runnable接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E4%B8%89-%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">1.3 创建方式三 - - 实现Callable接口</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2%E3%80%81Thread%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2、Thread的常用方法</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">3、线程安全</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4%E3%80%81%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">4、线程同步</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-%E6%96%B9%E5%BC%8F%E4%B8%80-%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97\"><span class=\"toc-text\">4.1 方式一 - - 同步代码块</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2-%E6%96%B9%E5%BC%8F%E4%BA%8C-%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">4.2 方式二 - - 同步方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-3-%E6%96%B9%E5%BC%8F%E4%B8%89-Lock%E9%94%81\"><span class=\"toc-text\">4.3 方式三 - - Lock锁</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5%E3%80%81%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">5、线程通信</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#6%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0\"><span class=\"toc-text\">6、线程池</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">6.1 线程池概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-2-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3API\"><span class=\"toc-text\">6.2 线程池相关API</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-3-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">6.3 线程池处理任务</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-4-Executors%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0\"><span class=\"toc-text\">6.4 Executors工具类实现线程池</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#7%E3%80%81%E5%AE%9A%E6%97%B6%E5%99%A8\"><span class=\"toc-text\">7、定时器</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#8%E3%80%81%E5%B9%B6%E5%8F%91%E3%80%81%E5%B9%B6%E8%A1%8C\"><span class=\"toc-text\">8、并发、并行</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#9%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">9、线程的生命周期</span></a></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Java程序设计--网络编程","uid":"fcaa2443e4f23837ea39b8c51bbe3746","slug":"Java程序设计 -- 网络编程（十九）","date":"2022-04-15T02:39:59.000Z","updated":"2025-07-14T15:12:20.461Z","comments":true,"path":"api/articles/Java程序设计 -- 网络编程（十九）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","text":"网络通信是计算机网络中的重要组成部分，常用的协议有UDP和TCP。UDP协议提供了快速的数据传输，但不保证数据的可靠性和顺序；而TCP协议则提供了可靠的数据传输和数据包的排序机制。合理选择UDP或TCP协议可根据具体应用场景决定。网络通信在现代互联网中扮演着重要角色，掌握网络通信技术能够提升系统的交互和数据传输效率。...","permalink":"/post/Java程序设计 -- 网络编程（十九）","photos":[],"count_time":{"symbolsCount":"29k","symbolsTime":"26 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true},"next_post":{"title":"Java程序设计--输入输出流(下)","uid":"5dfd375e1addf174b025352719cc8bb2","slug":"Java程序设计 -- 输入输出流（下）（十七）","date":"2022-04-04T07:22:51.000Z","updated":"2025-07-14T15:12:20.461Z","comments":true,"path":"api/articles/Java程序设计 -- 输入输出流（下）（十七）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","text":"缓冲流、转换流、序列化对象和打印流是Java中常用的IO操作工具。缓冲流可以提高读写效率，通过一次读写多个字节来减少IO次数。转换流用于字符流和字节流之间的相互转换，方便处理不同类型的数据。序列化对象允许将对象转换为字节序列，以便于数据的存储和传输。打印流则是一种方便输出格式化数据的工具，可用于生成可读性强的输出。...","permalink":"/post/Java程序设计 -- 输入输出流（下）（十七）","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"12 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true}}