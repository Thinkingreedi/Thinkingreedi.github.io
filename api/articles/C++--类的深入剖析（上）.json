{"title":"C++--类的深入剖析(上)","uid":"6830f8a00d81e25dd175ae13a91978e0","slug":"C++--类的深入剖析（上）","date":"2021-04-14T14:38:05.000Z","updated":"2025-07-14T15:12:20.456Z","comments":true,"path":"api/articles/C++--类的深入剖析（上）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/506e6842fd8542408c76ef139e90ebd3.png","content":"<h2 id=\"0-Time类的实例研究\"><a href=\"#0-Time类的实例研究\" class=\"headerlink\" title=\"0.Time类的实例研究\"></a>0.Time类的实例研究</h2><pre><code class=\"cpp\">//Time.h\n#ifndef TIME_H\n#define TIME_H\n\nclass Time\n&#123;\n    public:\n        Time();\n        void setTime(int,int,int);\n        void printUniversal();\n        void printStandard();\n    private:\n        int hour;\n        int minute;\n        int second;\n&#125;;\n#endif\n</code></pre>\n<pre><code class=\"cpp\">//Time.cpp\n#include&lt;iostream&gt;\nusing std::cout;\n\n#include&lt;iomanip&gt;\nusing std::setfill;\nusing std::setw;\n\n#include&quot;Time.h&quot;\n\nTime::Time()\n&#123;\n    hour=minute=second=0;\n&#125;\n\nvoid Time::setTime(int h,int m,int s)\n&#123;\n    hour = (h&gt;=0&amp;&amp;h&lt;24)?h:0;\n    minute = (m&gt;=0&amp;&amp;m&lt;60)?m:0;\n    second = (s&gt;=0&amp;&amp;s&lt;60)?s:0;\n&#125;\n\nvoid Time::printUniversal()\n&#123;\n    cout&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;setw(2)&lt;&lt;hour&lt;&lt;&quot;:&quot;\n    &lt;&lt;setw(2)&lt;&lt;minute&lt;&lt;&quot;:&quot;&lt;&lt;setw(2)&lt;&lt;second;\n&#125;\n\nvoid Time::printStandard()\n&#123;\n    cout&lt;&lt;((hour==0||hour==12)?12:hour%12)&lt;&lt;&quot;:&quot;\n    &lt;&lt;setfill(&#39;0&#39;)&lt;&lt;setw(2)&lt;&lt;minute&lt;&lt;&quot;:&quot;&lt;&lt;setw(2)\n    &lt;&lt;second&lt;&lt;(hour&lt;12?&quot;AM&quot;:&quot;PM&quot;);\n&#125;\n</code></pre>\n<pre><code class=\"cpp\">//TimeTest.cpp\n#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\n#include&quot;Time.h&quot;\n\nint main(void)\n&#123;\n    Time t;\n    cout&lt;&lt;&quot;The initial universal time is&quot;;\n    t.printUniversal();\n    cout&lt;&lt;&quot;\\nThe initial standard time is&quot;;\n    t.printStandard();\n    \n    t.setTime(13,27,6);\n    \n    cout&lt;&lt;&quot;\\n\\nUniversal time after setTime is&quot;;\n    t.printUniversal();\n    cout&lt;&lt;&quot;\\nStandard time after setTime is&quot;;\n    t.printStandard();\n    \n    t.setTime(99,99,99);\n\n    cout&lt;&lt;&quot;\\n\\nAfter attempting invalid settings&quot;;\n    cout&lt;&lt;&quot;\\nUniversal time:&quot;;\n    t.printUniversal();\n    cout&lt;&lt;&quot;\\nStandard time:&quot;;\n    t.printStandard();\n    cout&lt;&lt;endl;\n    \n    return 0;\t\n&#125;\n</code></pre>\n<p><strong>1)预处理器封套</strong><br>利用预处理器指令#ifndef、#define和#endif等构成预处理器封套，从而避免头文件在一个程序中被多次包含。预处理器指令中符号常量命名的通常约定是简单地将头文件名用大写形式，其中的原点用下划线代替。（如TIME_H)</p>\n<p><strong>2）数据成员初始化</strong><br>Time构造函数将数据成员初始化为0，这就确保了对象可以以一个可靠的状态开始。类的成员函数不能在类体中声明时初始化，推荐由类的构造函数初始化这些数据成员。（数据成员也可以由用Time类的设置函数来赋值）</p>\n<p><strong>3）“粘性设置和非粘性设置</strong><br>使用流操作元setfill，用于指定当输出域宽大于输出整数值中数字个数时所需显示的填充字符。一旦用setfill指定了填充字符，该字符将应用在后续值的显示中。也就是说，setfill是一个粘性设置；与setw相反，setw是一个非粘性设置，它只对紧接着显示的值起作用。每个粘性设置当不再需要时，应当将它恢复为以前的设置。如果不这样做，可能导致后面程序中输出格式的不正确。</p>\n<p><strong>4）成员函数与全局函数</strong><br>printUniversal函数和printStandard函数都不接收任何参数，因为这些成员函数隐式地知道他们将打印调用它们的特定Time对象的数据成员。（对象中封装了数据成员和成员函数，使成员函数有权访问数据成员）</p>\n<p><strong>5）对象大小</strong><br>从逻辑上来讲，程序员认为对象是包含了数据和函数。然而事实并非如此，对象只包含数据，所以同假设也包含了成员函数的对象相比要小的多。（可用sizeof检验，结果只报告该类数据成员的大小）</p>\n<h2 id=\"1-类的作用域和类成员的访问\"><a href=\"#1-类的作用域和类成员的访问\" class=\"headerlink\" title=\"1.类的作用域和类成员的访问\"></a>1.类的作用域和类成员的访问</h2><pre><code class=\"cpp\">#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\nclass Count\n&#123;\n    public:\n        void setX(int value)\n        &#123;\n            x=value;\n        &#125;\n        void print()\n        &#123;\n            cout&lt;&lt;x&lt;&lt;endl;\n        &#125;\n    private:\n        int x;\n&#125;;\n\nint main(void)\n&#123;\n    Count counter;//实例化一个对象\n    Count *counterPtr=&amp;counter;//指向类的成员的指针\n    Count &amp;counterRef=counter;//定义一个变量,这个变量指向的是一个对象,称为对象的引用\n    \n    cout&lt;&lt;&quot;Set x to 1 and print using the object&#39;s name:&quot;;\n    counter.setX(1);\n    counter.print();\n    \n    cout&lt;&lt;&quot;Set x to 2 and print using the object&#39;s name:&quot;;\n    counterRef.setX(2);\n    counterRef.print();\n    \n    cout&lt;&lt;&quot;Set x to 3 and print using the object&#39;s name:&quot;;\n    counterPtr-&gt;setX(3);\n    counterPtr-&gt;print();\n    return 0;\n&#125;\n</code></pre>\n<ul>\n<li>类的数据成员和成员函数属于该类的作用域。圆点成员选择运算符（.)前面加对象名称或者对象的引用，则可以访问对象的成员；箭头成员选择运算符（-&gt;)前面加对象的指针，则可以访问对象的成员。（可称为通过对象句柄来访问对象的成员函数）</li>\n</ul>\n<h2 id=\"2-访问函数和工具函数\"><a href=\"#2-访问函数和工具函数\" class=\"headerlink\" title=\"2.访问函数和工具函数\"></a>2.访问函数和工具函数</h2><ul>\n<li>访问函数可以读取或者显示数据。访问函数另一个常见的用法是测试条件是真还是假–常常称这样的函数为判定函数。如一开始的Time类，isAM和isPM就是一组有用的判定函数。</li>\n<li>工具函数不属于类的public接口部分，它是支持类的public成员函数操作的private成员函数。</li>\n</ul>\n<h2 id=\"3-Time类的实例研究：默认实参的构造函数\"><a href=\"#3-Time类的实例研究：默认实参的构造函数\" class=\"headerlink\" title=\"3.Time类的实例研究：默认实参的构造函数\"></a>3.Time类的实例研究：默认实参的构造函数</h2><pre><code class=\"cpp\">//Time.h\n#ifndef TIME_H\n#define TIME_H\n\nclass Time\n&#123;\n    public:\n        Time(int=0,int=0,int=0);\n        \n        void setTime(int,int,int);\n        void setHour(int);\n        void setMinute(int);\n        void setSecond(int);\n        \n        int getHour();\n        int getMinute();\n        int getSecond();\n        \n        void printUniversal();\n        void printStandard();\n    private:\n        int hour;\n        int minute;\n        int second;\n&#125;;\n#endif\n</code></pre>\n<pre><code class=\"cpp\">//Time.cpp\n#include&lt;iostream&gt;\nusing std::cout;\n\n#include&lt;iomanip&gt;\nusing std::setfill;\nusing std::setw;\n\n#include&quot;Time.h&quot;\n\nTime::Time(int hr,int min,int sec)\n&#123;\n    setTime(hr,min,sec);\n&#125;\n\nvoid Time::setTime(int h,int m,int s)\n&#123;\n    setHour(h);\n    setMinute(m);\n    setSecond(s);\n&#125;\n\nvoid Time::setHour(int h)\n&#123;\n    hour = (h&gt;=0&amp;&amp;h&lt;24)?h:0;\t\n&#125;\n\nvoid Time::setMinute(int m)\n&#123;\n    minute = (m&gt;=0&amp;&amp;m&lt;60)?m:0;\t\n&#125;\n\nvoid Time::setSecond(int s)\n&#123;\n    second = (s&gt;=0&amp;&amp;s&lt;60)?s:0;\t\n&#125;\n\nint Time::getHour()\n&#123;\n    return hour;\n&#125;\n\nint Time::getMinute()\n&#123;\n    return minute;\n&#125;\n\nint Time::getSecond()&#123;\n    return second;\n&#125;\n\nvoid Time::printUniversal()\n&#123;\n    cout&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;setw(2)&lt;&lt;hour&lt;&lt;&quot;:&quot;\n    &lt;&lt;setw(2)&lt;&lt;minute&lt;&lt;&quot;:&quot;&lt;&lt;setw(2)&lt;&lt;second;\n&#125;\n\nvoid Time::printStandard()\n&#123;\n    cout&lt;&lt;((hour==0||hour==12)?12:hour%12)&lt;&lt;&quot;:&quot;\n    &lt;&lt;setfill(&#39;0&#39;)&lt;&lt;setw(2)&lt;&lt;minute&lt;&lt;&quot;:&quot;&lt;&lt;setw(2)\n    &lt;&lt;second&lt;&lt;(hour&lt;12?&quot;AM&quot;:&quot;PM&quot;);\n&#125;\n</code></pre>\n<pre><code class=\"cpp\">//TimeTest.cpp\n#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\n#include&quot;Time.h&quot;\n\nint main(void)\n&#123;\n    Time t1;\n    Time t2(2);\n    Time t3(21,34);\n    Time t4(12,25,42);\n    Time t5(27,74,99);\n    \n    cout&lt;&lt;&quot;Constructed with:\\n\\nt1:all argument defaulted\\n&quot;;\n    t1.printUniversal();\n    cout&lt;&lt;endl;\n    t1.printStandard();\n    \n    cout&lt;&lt;&quot;\\n\\nt2:hour specified;minute and second defaulted\\n&quot;;\n    t2.printUniversal();\n    cout&lt;&lt;endl;\n    t2.printStandard();\n    \n    cout&lt;&lt;&quot;\\n\\nt3:hour and minute specified;second defaulted\\n&quot;;\n    t3.printUniversal();\n    cout&lt;&lt;endl;\n    t3.printStandard();\n    \n    cout&lt;&lt;&quot;\\n\\nt4:hour ,minute and second specified\\n&quot;;\n    t4.printUniversal();\n    cout&lt;&lt;endl;\n    t4.printStandard();\n    \n    cout&lt;&lt;&quot;\\n\\nt5:all invalues specified\\n&quot;;\n    t5.printUniversal();\n    cout&lt;&lt;endl;\n    t5.printStandard();\n    \n    return 0;\t\n&#125;\n</code></pre>\n<ul>\n<li>实参隐式地传递给构造函数。Time的设置函数和获取函数始终在类的内部调用。本来，printUniversal和printStandard函数可以不通过调用这些设置和获取函数而直接访问类的private数据。以这样的方式来对类进行设计，可以降低因改变类的实现方法而造成的编程出错的可能性。</li>\n</ul>\n<h2 id=\"4-析构函数\"><a href=\"#4-析构函数\" class=\"headerlink\" title=\"4.  析构函数\"></a>4.  析构函数</h2><pre><code class=\"cpp\">//CreatAndDestroy.h\n#include&lt;string&gt;\nusing std::string;\n\n#ifndef CREATE_H\n#define CREATE_H\n\nclass CreatAndDestroy\n&#123;\n    public:\n        CreatAndDestroy(int,string);\n        ~CreatAndDestroy();\n    private:\n        int objectID;\n        string message;\n&#125;;\n</code></pre>\n<pre><code class=\"cpp\">//CreatAndDestroy.cpp\n#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\n#include&quot;CreatAndDestroy.h&quot;\n\nCreatAndDestroy::CreatAndDestroy(int ID,string messageString)\n&#123;\n    objectID=ID;\n    message=messageString;\n    \n    cout&lt;&lt;&quot;Object &quot;&lt;&lt;objectID&lt;&lt;&quot; constructor runs  &quot;&lt;&lt;message&lt;&lt;endl;\n&#125;\nCreatAndDestroy::~CreatAndDestroy()\n&#123;\n    cout&lt;&lt;(objectID==1||objectID==6?&quot;\\n&quot;:&quot;&quot;);\n    \n    cout&lt;&lt;&quot;Object &quot;&lt;&lt;objectID&lt;&lt;&quot;  destructor runs  &quot;&lt;&lt;message&lt;&lt;endl;\n&#125;\n</code></pre>\n<pre><code class=\"cpp\">//CreatAndDestroytest.cpp\n#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\n#include&quot;CreatAndDestroy.h&quot;\n\nvoid creat(void);\n\nCreatAndDestroy first(1,&quot;(global before main)&quot;);\n\nint main(void)\n&#123;\n    cout&lt;&lt;&quot;\\nMAIN FUNCTION:EXECUTION BEGINS&quot;&lt;&lt;endl;\n    CreatAndDestroy second(2,&quot;(local automatic in main)&quot;);\n    static CreatAndDestroy third(3,&quot;(local static in main)&quot;);\n    \n    creat(); \n    \n    cout&lt;&lt;&quot;\\nMAIN FUNCTION:EXECUTION RESUMES&quot;&lt;&lt;endl;\n    CreatAndDestroy fouth(4,&quot;(local automatic in main)&quot;);\n    cout&lt;&lt;&quot;\\nMAIN FUNCTION:EXECUTION ENDS&quot;&lt;&lt;endl;\n    return 0; \n&#125;\nvoid creat(void)\n&#123;\n    cout&lt;&lt;&quot;\\nCREAT FUNCTION:EXECUYION BEGINS&quot;&lt;&lt;endl;\n    CreatAndDestroy fifth(5,&quot;(local static in creat)&quot;);\n    static CreatAndDestroy sixth(6,&quot;(local automatic in creat)&quot;);\n    CreatAndDestroy seventh(7,&quot;(local automatic in creat)&quot;);\n    cout&lt;&lt;&quot;\\nCREAT FUNCTION:EXECUTION ENDS&quot;&lt;&lt;endl; \n&#125;\n</code></pre>\n<ul>\n<li>析构函数是另一种特殊的成员函数，类的析构函数的名字是在类名之前添加发音字符（~）后形成的字符序列。析构函数不接收任何参数，也不返回任何值；当对象撤销后，类的析构函数会隐式地调用。构造函数和析构函数都被隐式调用，一般而言析构函数的调用顺序与相应构造函数的调用顺序相反。析构函数本身不释放对象占用的内存空间，它只是在系统回收对象的内存空间之前执行扫尾工作，这样内存可以成行用于保存新的对象。</li>\n<li><strong>全局作用域内</strong>定义的对象的构造函数，在文件内任何其他函数（包括main函数）开始执行前调用。当main函数执行结束时，相应的析构函数被调用。</li>\n<li>当程序执行到<strong>自动局部对象</strong>的定义处时，该对象的构造函数被调用；当程序执行离开对象的作用域时，相应的析构函数被调用。</li>\n<li><strong>static局部对象</strong>的构造函数只调用一次,即在程序第一次执行到该对象的定义处时；而相应的析构函数的调用则发生在main函数结束时。</li>\n<li>如果程序的终止是调用exit函数，那么自动对象的析构函数不被调用；如果程序的终止是调用abort函数，那么任何对象的析构函数不被调用；全局或者静态对象的撤销顺序与他们建立的顺序正好相反。</li>\n</ul>\n<h2 id=\"5-默认的逐个成员赋值\"><a href=\"#5-默认的逐个成员赋值\" class=\"headerlink\" title=\"5.默认的逐个成员赋值\"></a>5.默认的逐个成员赋值</h2><pre><code class=\"cpp\">//Date.h\n#ifndef DATE_H\n#define DATE_H\n\nclass Date\n&#123;\n    public:\n        Date(int=1,int=1,int=2000);\n        void print();\n    private:\n        int month;\n        int day;\n        int year;\n&#125;;\n\n#endif\n</code></pre>\n<pre><code class=\"cpp\">//Date.cpp\n#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\n#include&quot;Date.h&quot;\n\nDate::Date(int m,int d,int y)\n&#123;\n    month = m;\n    day = d;\n    year = y;\n&#125;\n\nvoid Date::print()\n&#123;\n    cout&lt;&lt;month&lt;&lt;&quot;/&quot;&lt;&lt;day&lt;&lt;&quot;/&quot;&lt;&lt;year;\n&#125;\n</code></pre>\n<pre><code class=\"cpp\">//DateTest.cpp\n#include&lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\n#include&quot;Date.h&quot;\n\nint main(void)\n&#123;\n    Date date1(7,4,2004);\n    Date date2;\n    \n    cout&lt;&lt;&quot;date1=&quot;;\n    date1.print();\n    cout&lt;&lt;&quot;\\ndate2=&quot;;\n    date2.print();\n    \n    date2=date1;\n    \n    cout&lt;&lt;&quot;\\n\\nAfter default memberwise assignment,date2=&quot;;\n    date2.print();\n    cout&lt;&lt;endl;\n    return 0;\n&#125;\n</code></pre>\n<ul>\n<li>赋值运算符可以将一个对象赋给另一个类型相同的对象。当所用类的数据成员包含指向动态分配内存的指针时，逐个成员赋值可能会引发严重的问题。</li>\n</ul>\n","feature":false,"text":"在C++中，析构函数是一种特殊的成员函数，主要作用是释放对象所占用的资源，如释放动态分配的内存、关闭文件或释放其他系统资源。它可以执行任何必要的清理操作，以确保对象的资源被正确处理。...","permalink":"/post/C++--类的深入剖析（上）","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"C++","slug":"C","count":6,"path":"api/categories/C.json"}],"tags":[{"name":"类和对象","slug":"类和对象","count":3,"path":"api/tags/类和对象.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0-Time%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E7%A0%94%E7%A9%B6\"><span class=\"toc-text\">0.Time类的实例研究</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE\"><span class=\"toc-text\">1.类的作用域和类成员的访问</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E8%AE%BF%E9%97%AE%E5%87%BD%E6%95%B0%E5%92%8C%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">2.访问函数和工具函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-Time%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E7%A0%94%E7%A9%B6%EF%BC%9A%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">3.Time类的实例研究：默认实参的构造函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">4.  析构函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E9%BB%98%E8%AE%A4%E7%9A%84%E9%80%90%E4%B8%AA%E6%88%90%E5%91%98%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">5.默认的逐个成员赋值</span></a></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"C++--类的深入剖析(下)","uid":"168349b15cc8fc12508a6c4a439d5818","slug":"C++--类的深入剖析（下）","date":"2021-04-22T02:58:09.000Z","updated":"2025-07-14T15:12:20.457Z","comments":true,"path":"api/articles/C++--类的深入剖析（下）.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/506e6842fd8542408c76ef139e90ebd3.png","text":"C++中的类有一些进阶概念，包括friend函数、this指针和static成员。友元函数可以突破类的封装边界，this指针可以在成员函数中区分成员变量和局部变量，static成员可以在类的所有对象之间共享数据和行为。...","permalink":"/post/C++--类的深入剖析（下）","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"11 mins."},"categories":[{"name":"C++","slug":"C","count":6,"path":"api/categories/C.json"}],"tags":[{"name":"类和对象","slug":"类和对象","count":3,"path":"api/tags/类和对象.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":false},"next_post":{"title":"C++--类和对象","uid":"7669cae9d33b780b1bd0b4de74a11898","slug":"C++--类和对象","date":"2021-04-14T04:52:28.000Z","updated":"2025-07-14T15:12:20.456Z","comments":true,"path":"api/articles/C++--类和对象.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/506e6842fd8542408c76ef139e90ebd3.png","text":"类和对象是C++中面向对象编程的基本概念。通过使用类和对象，可以实现封装、继承和多态等面向对象编程的特性。类和对象的使用能够提高代码的可维护性、重用性和扩展性，使程序更加模块化和灵活。...","permalink":"/post/C++--类和对象","photos":[],"count_time":{"symbolsCount":"8.4k","symbolsTime":"8 mins."},"categories":[{"name":"C++","slug":"C","count":6,"path":"api/categories/C.json"}],"tags":[{"name":"类和对象","slug":"类和对象","count":3,"path":"api/tags/类和对象.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":false}}