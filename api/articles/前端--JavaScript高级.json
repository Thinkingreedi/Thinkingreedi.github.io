{"title":"前端进阶：探索JavaScript高级语法","uid":"da652f0027f23ff5ab9b268e0c44336d","slug":"前端--JavaScript高级","date":"2023-01-07T05:22:11.000Z","updated":"2025-07-14T15:12:20.463Z","comments":true,"path":"api/articles/前端--JavaScript高级.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/de6c1a55cf774f9fa1e2cff7c25e5fc9.png","content":"<h1 id=\"JavaScript高级\"><a href=\"#JavaScript高级\" class=\"headerlink\" title=\"JavaScript高级\"></a>JavaScript高级</h1><h2 id=\"1、基础总结深入\"><a href=\"#1、基础总结深入\" class=\"headerlink\" title=\"1、基础总结深入\"></a>1、基础总结深入</h2><h3 id=\"1-1-数据类型的分类和判断\"><a href=\"#1-1-数据类型的分类和判断\" class=\"headerlink\" title=\"1.1 数据类型的分类和判断\"></a>1.1 数据类型的分类和判断</h3><ul>\n<li><p>基本(值)类型</p>\n<ul>\n<li>Number —  任意数值— typeof</li>\n<li>String —  任意字符串— typeof</li>\n<li>Boolean —  true&#x2F;false —  typeof</li>\n<li>undefined — undefined —– typeof&#x2F;&#x3D;&#x3D;&#x3D;(代表没有赋值)</li>\n<li>null —  null —  &#x3D;&#x3D;&#x3D;(代表赋值了, 只是值为null)</li>\n</ul>\n</li>\n<li><p>对象(引用)类型</p>\n<ul>\n<li>Object —  任意对象— typeof&#x2F;instanceof</li>\n<li>Array — 特别的对象类型(下标&#x2F;内部数据有序) — instanceof</li>\n<li>Function — 别的对象类型(可执行) — typeof</li>\n</ul>\n</li>\n<li><p>判断：</p>\n<ul>\n<li><p>typeof：</p>\n<ul>\n<li>可以区别: 数值, 字符串, 布尔值, undefined, function</li>\n<li><strong>不能区别: null与对象, 一般对象与数组</strong></li>\n<li><strong>typeof: 返回的是数据类型的字符串表达形式</strong></li>\n</ul>\n</li>\n<li><p>instanceof</p>\n<ul>\n<li><strong>专门用来判断对象数据的类型: Object, Array与Function</strong></li>\n</ul>\n</li>\n<li><p>&#x3D;&#x3D;&#x3D;</p>\n<ul>\n<li><strong>可以判断: undefined和null</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>代码：</p>\n</li>\n</ul>\n<pre><code class=\"html\">  &lt;script type=&quot;text/javascript&quot;&gt;\n    //1. 基本类型\n    var a\n    console.log(a, typeof a, a === undefined) // undefined &#39;undefined&#39; true\n    console.log(a === typeof a) // false  undefined ≠ &#39;undefined&#39;\n    //typeof返回字符串类型\n    a = 3\n    console.log(typeof a === &#39;number&#39;) // true\n    a = &#39;atguigu&#39;\n    console.log(typeof a === &#39;string&#39;) // true\n    a = true\n    console.log(typeof a === &#39;boolean&#39;) // true\n\n    a = null\n    console.log(a === null) // true\n    console.log(typeof a) // &#39;object&#39;\n\n    console.log(&#39;--------------------------------&#39;)\n\n    //2. 对象类型\n    var b1 = &#123;\n      b2: [2, &#39;abc&#39;, console.log],//number string function  \n      b3: function () &#123;\n        console.log(&#39;b3()&#39;)\n      &#125;\n    &#125;\n    console.log(b1 instanceof Object, typeof b1) // true &#39;object&#39;\n    console.log(b1.b2 instanceof Array, typeof b1.b2) // true &#39;object&#39;\n    console.log(b1.b3 instanceof Function, typeof b1.b3) // true &#39;function&#39;\n\n    console.log(typeof b1.b2[2]) // &#39;function&#39;\n    console.log(b1.b2[2](&#39;abc&#39;)) // 内&#39;abc&#39; 外undefined\n  &lt;/script&gt;\n</code></pre>\n<h3 id=\"1-2-数据-变量-内存的理解\"><a href=\"#1-2-数据-变量-内存的理解\" class=\"headerlink\" title=\"1.2 数据,变量, 内存的理解\"></a>1.2 数据,变量, 内存的理解</h3><ul>\n<li><p>数据</p>\n<ul>\n<li>在内存中可读的, 可传递的保存了特定信息的’东东’</li>\n<li>一切皆数据, 函数也是数据</li>\n<li>在内存中的所有操作的目标: 数据</li>\n</ul>\n</li>\n<li><p>变量</p>\n<ul>\n<li>在程序运行过程中它的值是允许改变的量</li>\n<li>一个变量对应一块小内存, 它的值保存在此内存中</li>\n</ul>\n</li>\n<li><p>内存</p>\n<ul>\n<li>内存条通电后产生的存储空间(临时的)</li>\n<li>一块内存包含2个方面的数据<ul>\n<li>内部存储的数据</li>\n<li>地址值数据</li>\n</ul>\n</li>\n<li>内存空间的分类<ul>\n<li>栈空间: 全局变量和局部变量</li>\n<li>堆空间: 对象</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>内存,数据, 变量三者之间的关系</p>\n<ul>\n<li>内存是容器, 用来存储不同数据</li>\n<li>变量是内存的标识, 通过变量我们可以操作(读&#x2F;写)内存中的数据</li>\n</ul>\n</li>\n<li><p>var a &#x3D; xxx, a内存中到底保存的是什么?</p>\n</li>\n<li><p>xxx是一个基本数据，保存的就是这个数据</p>\n</li>\n<li><p>xxx是一个对象，保存的是对象的地址值</p>\n</li>\n<li><p>xxx是一个变量，保存的是xxx的内容</p>\n</li>\n</ul>\n<h3 id=\"1-3-对象的理解和使用\"><a href=\"#1-3-对象的理解和使用\" class=\"headerlink\" title=\"1.3 对象的理解和使用\"></a>1.3 对象的理解和使用</h3><ul>\n<li>对象<ul>\n<li>多个数据(属性)的集合</li>\n<li>用来保存多个数据(属性)的容器</li>\n</ul>\n</li>\n<li>属性<ul>\n<li>属性名 : 字符串(标识)</li>\n<li>属性值 : 任意类型</li>\n</ul>\n</li>\n<li>属性的分类:<ul>\n<li>一般 : 属性值不是function  描述对象的状态</li>\n<li>方法 : 属性值为function的属性  描述对象的行为</li>\n</ul>\n</li>\n<li>特别的对象<ul>\n<li>数组: 属性名是0,1,2,3之类的索引</li>\n<li>函数: 可以执行的</li>\n</ul>\n</li>\n<li>如何操作内部属性(方法)<ul>\n<li><strong>.属性名: 编码简单, 但有时不能用</strong></li>\n<li><strong>[ ‘属性名’]: 编码麻烦, 但通用</strong>(属性名不是合法的标识名、属性名不确定)</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"html\">  &lt;script type=&quot;text/javascript&quot;&gt;\n    // 创建对象\n    var p = &#123;&#125;\n\n    /*情形一: 属性名不是合法的标识名*/\n    /*需求: 添加一个属性: content-type: text/json */\n    //  p.content-type = &#39;text/json&#39; //不正确\n    p[&#39;content-type&#39;] = &#39;text/json&#39;\n\n    /*情形二: 属性名不确定*/\n    var prop = &#39;xxx&#39;//变量 不确定\n    var value = 123\n    // p.prop = value  //不正确\n    p[prop] = value\n    console.log(p[&#39;content-type&#39;], p[prop])\n  &lt;/script&gt;\n</code></pre>\n<h3 id=\"1-4-函数的理解和使用\"><a href=\"#1-4-函数的理解和使用\" class=\"headerlink\" title=\"1.4 函数的理解和使用\"></a>1.4 函数的理解和使用</h3><ul>\n<li>函数<ul>\n<li>用来实现特定功能的, n条语句的封装体</li>\n<li>只有函数类型的数据是可以执行的, 其它的都不可以</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"html\">  &lt;script type=&quot;text/javascript&quot;&gt;\n    function f1() &#123; // 函数声明\n      console.log(&#39;f1()&#39;)\n    &#125;\n    var f2 = function () &#123; // 表达式\n      console.log(&#39;f2()&#39;)\n    &#125;\n    f1()\n    f2()\n  &lt;/script&gt;\n</code></pre>\n<ul>\n<li><p>为什么要用函数?</p>\n<ul>\n<li>提高复用性</li>\n<li>便于阅读交流</li>\n</ul>\n</li>\n<li><p>函数也是对象</p>\n<ul>\n<li>instanceof Object&#x3D;&#x3D;&#x3D;true</li>\n<li>函数有属性: prototype</li>\n<li>函数有方法: call()&#x2F;apply()</li>\n<li>可以添加新的属性&#x2F;方法</li>\n</ul>\n</li>\n<li><p>函数的3种不同角色</p>\n<ul>\n<li><strong>一般函数 : 直接调用</strong></li>\n<li><strong>构造函数 : 通过new调用</strong></li>\n<li><strong>对象 : 通过.调用内部的属性&#x2F;方法</strong></li>\n</ul>\n</li>\n</ul>\n<p><strong>函数中的this</strong></p>\n<ul>\n<li><strong>显式指定谁: obj.xxx()</strong></li>\n<li><strong>通过call&#x2F;apply指定谁调用: xxx.call(obj)</strong></li>\n<li><strong>不指定谁调用: xxx()  : window</strong></li>\n<li><strong>回调函数: 看背后是通过谁来调用的: window&#x2F;其它</strong></li>\n</ul>\n<pre><code class=\"html\">&lt;script type=&quot;text/javascript&quot;&gt;\n    function Person(color) &#123;\n      console.log(this)\n      this.color = color;\n      this.getColor = function () &#123;\n        console.log(this)\n        return this.color;\n      &#125;;\n      this.setColor = function (color) &#123;\n        console.log(this)\n        this.color = color;\n      &#125;;\n    &#125;\n    Person(&quot;red&quot;); //this是 windows\n    var p = new Person(&quot;yello&quot;); //this是 p\n    p.getColor(); //this是 p \n    var obj = &#123;&#125;;\n    p.setColor.call(obj, &quot;black&quot;); //this是 obj\n    var test = p.setColor;\n    test(); //this是 windows\n    function fun1() &#123;\n      function fun2() &#123;\n        console.log(this);\n      &#125;\n      fun2(); //this是 windows\n    &#125;\n    fun1();\n  &lt;/script&gt;\n</code></pre>\n<p><strong>匿名函数自调用</strong></p>\n<pre><code class=\"JavaScript\">  (function(w, obj)&#123;\n    //实现代码\n  &#125;)(window, obj)\n  \n  \n  (function (i) &#123;\n    var a = 4\n    function fn() &#123;\n      console.log(&#39;fn &#39;, i+a)//fn 7\n    &#125;\n    fn()\n  &#125;)(3)\n  \n</code></pre>\n<ul>\n<li>专业术语为: <strong>IIFE (Immediately Invoked Function Expression) 立即调用函数表达式</strong></li>\n</ul>\n<p>\t</p>\n<p><strong>回调函数</strong></p>\n<ul>\n<li>什么函数才是回调函数?<ul>\n<li>你定义的</li>\n<li>你没有调用</li>\n<li>但它最终执行了(在一定条件下或某个时刻)</li>\n</ul>\n</li>\n<li>常用的回调函数<ul>\n<li>dom事件回调函数</li>\n<li>定时器回调函数</li>\n<li>ajax请求回调函数</li>\n<li>生命周期回调函数</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"html\"> &lt;script type=&quot;text/javascript&quot;&gt;\n    //1. DOM事件函数\n    var btn = document.getElementById(&#39;btn&#39;)\n    btn.onclick = function () &#123;\n      alert(this.innerHTML)\n    &#125;\n    //2. 定时器函数\n    setInterval(function () &#123;\n      alert(&#39;到点啦!&#39;)\n    &#125;, 2000)\n  &lt;/script&gt;\n</code></pre>\n<h2 id=\"2、函数高级\"><a href=\"#2、函数高级\" class=\"headerlink\" title=\"2、函数高级\"></a>2、函数高级</h2><h3 id=\"2-1-原型与原型链\"><a href=\"#2-1-原型与原型链\" class=\"headerlink\" title=\"2.1 原型与原型链\"></a>2.1 原型与原型链</h3><ul>\n<li>所有函数都有一个特别的属性:<ul>\n<li><code>prototype</code> : 显式原型属性</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"JavaScript\">  // 每个函数都有一个prototype属性, 它默认指向一个对象(即称为: 原型对象)\n  function fn() &#123;\n\n  &#125;\n  console.log(fn.prototype, typeof fn.prototype)//object &#39;object&#39;\n \n// 原型对象中有一个属性constructor, 它指向函数对象\n  console.log(fn.prototype.constructor===fn)//true\n \n  // 2. 给原型对象添加属性(一般都是方法)\n  function F() &#123;\n\n  &#125;\n  F.prototype.age = 12 //添加属性\n  F.prototype.setAge = function (age) &#123; // 添加方法\n    this.age = age\n  &#125;\n  // 创建函数的实例对象\n  var f = new F()\n  console.log(f.age)//12\n  f.setAge(23)\n  console.log(f.age)//23\n</code></pre>\n<ul>\n<li>所有实例对象都有一个特别的属性:<ul>\n<li><code>__proto__</code> : 隐式原型属性</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"javascript\">  //对象的隐式原型的值为其对应构造函数的显式原型的值 \n  function Fn() &#123;\n\n  &#125;\n  var fn = new Fn()\n  console.log(Fn.prototype, fn.__proto__)//object  object\n  console.log(Fn.prototype===fn.__proto__)//true\n</code></pre>\n<ul>\n<li>显式原型与隐式原型的关系<ul>\n<li>函数的prototype: 定义函数时被自动赋值, 值默认为{}, 即用为原型对象</li>\n<li>实例对象的__ proto__: 在创建实例对象时被自动添加, 并赋值为构造函数的prototype值</li>\n<li>原型对象即为当前实例对象的父对象</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/216be40352e64c1f802c41e380756cae.png#pic_center\"></p>\n<ul>\n<li>原型链（隐式原型链）<ul>\n<li>所有的实例对象都有__ proto__属性, 它指向的就是原型对象</li>\n<li>这样<strong>通过__ proto__属性就形成了一个链的结构—-&gt;原型链</strong></li>\n<li>当<strong>查找对象内部的属性&#x2F;方法时</strong>, js引擎自动沿着这个原型链查找</li>\n<li>当给<strong>对象属性赋值时不会使用原型链</strong>, 而只是在当前对象中进行操作</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/6b74451bda0540daa123d1811e75019a.png#pic_center\"></p>\n<ul>\n<li><strong>函数的显示原型指向的对象默认是空object实例对象（但object除外）</strong></li>\n</ul>\n<pre><code class=\"JavaScript\">console.log(Object.prototype instanceof Object)//false\n</code></pre>\n<ul>\n<li><strong>所有函数都是Function的实例(包含Function)</strong></li>\n</ul>\n<pre><code class=\"JavaScript\">console.log(Function.__proto__===Function.prototype)//false\n</code></pre>\n<ul>\n<li><p><strong>Object的原型对象是原型链的尽头</strong></p>\n</li>\n<li><p>instanceof</p>\n<ul>\n<li>表达式: A instanceof B</li>\n<li>如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/b313fa0e35a4421a94e95dfb893282a3.png#pic_center\"></p>\n<pre><code class=\"JavaScript\">  function Foo() &#123;  &#125;\n  var f1 = new Foo();\n  console.log(f1 instanceof Foo);//true\n  console.log(f1 instanceof Object);//true\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/98dbeec5144540a4a7c726b45a0496d0.png#pic_center\"></p>\n<pre><code class=\"javascript\">  console.log(Object instanceof Function)//true\n  console.log(Object instanceof Object)//true\n  console.log(Function instanceof Object)//true\n  console.log(Function instanceof Function)//true\n  function Foo() &#123;&#125;\n  console.log(Object instanceof  Foo);//false\n</code></pre>\n<ul>\n<li>典例</li>\n</ul>\n<pre><code class=\"javascript\"> var A = function() &#123;\n\n  &#125;\n  A.prototype.n = 1\n\n  var b = new A()\n\n  A.prototype = &#123;\n    n: 2,\n    m: 3\n  &#125;\n\n  var c = new A()\n  console.log(b.n, b.m, c.n, c.m)//1 undefined 2 3\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/c6aabf4f5d1c4524bf5ceb730eea089f.png#pic_center\"></p>\n<pre><code class=\"JavaScript\">    var F = function () &#123; &#125;;\n    Object.prototype.a = function () &#123;\n      console.log(&#39;a()&#39;)\n    &#125;;\n    Function.prototype.b = function () &#123;\n      console.log(&#39;b()&#39;)\n    &#125;;\n    var f = new F();\n    f.a()//a()\n    f.b()//报错 原型链找不到\n    F.a()//a()\n    F.b()//b()\n</code></pre>\n<h3 id=\"2-2-执行上下文与执行上下文栈\"><a href=\"#2-2-执行上下文与执行上下文栈\" class=\"headerlink\" title=\"2.2 执行上下文与执行上下文栈\"></a>2.2 执行上下文与执行上下文栈</h3><ul>\n<li>变量提升与函数提升<ul>\n<li>变量提升: 在变量定义语句之前, 就可以访问到这个变量**(undefined)**</li>\n<li>函数提升: <strong>通过function声明的函数</strong>，在函数定义语句之前, 就执行该函数</li>\n<li><strong>先有变量提升, 再有函数提升</strong></li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"JavaScript\">    /*变量提升*/\n    console.log(a1) //可以访问, 但值是undefined\n    /*函数提升*/\n    a2() // 可以直接调用\n    var a1 = 3\n    function a2() &#123;\n      console.log(&#39;a2()&#39;)\n    &#125;\n</code></pre>\n<ul>\n<li>理解<ul>\n<li>执行上下文: 由js引擎自动创建的对象, 包含对应作用域中的所有变量属性</li>\n<li>执行上下文栈: 用来管理产生的多个执行上下文</li>\n</ul>\n</li>\n<li>分类:<ul>\n<li>全局: window</li>\n<li>函数: 对程序员来说是透明的</li>\n</ul>\n</li>\n<li>生命周期<ul>\n<li>全局 : 准备执行全局代码前产生, 当页面刷新&#x2F;关闭页面时死亡</li>\n<li>函数 : 调用函数时产生, 函数执行完时死亡</li>\n</ul>\n</li>\n<li>包含哪些属性:<ul>\n<li>全局 : <ul>\n<li><strong>用var定义的全局变量  &#x3D;&#x3D;&gt;undefined</strong></li>\n<li><strong>使用function声明的函数   &#x3D;&#x3D;&#x3D;&gt;function</strong></li>\n<li><strong>this   &#x3D;&#x3D;&#x3D;&gt;window</strong></li>\n</ul>\n</li>\n<li>函数<ul>\n<li><strong>用var定义的局部变量  &#x3D;&#x3D;&gt;undefined</strong></li>\n<li><strong>使用function声明的函数   &#x3D;&#x3D;&#x3D;&gt;function</strong></li>\n<li><strong>this   &#x3D;&#x3D;&#x3D;&gt; 调用函数的对象, 如果没有指定就是window</strong> </li>\n<li><strong>形参变量   &#x3D;&#x3D;&#x3D;&gt;对应实参值</strong></li>\n<li><strong>arguments &#x3D;&#x3D;&#x3D;&gt;实参列表的伪数组</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"JavaScript\">function fn (a1)&#123;\n    console.log(a1)//2\n    console.log(a2)//undefined\n    a3()//a3()\n    console.log(this)//window\n    console.log(atguments)//伪数组(2,3)\n    \n    var a2 = 3\n    function a3()&#123;\n        console.log(&#39;a3()&#39;)\n    &#125;\n&#125;\nfn(2,3)\n</code></pre>\n<ul>\n<li>执行上下文创建和初始化的过程<ul>\n<li>全局:<ul>\n<li>在全局代码执行前最先创建一个全局执行上下文(window)</li>\n<li>收集一些全局变量, 并初始化</li>\n<li>将这些变量设置为window的属性</li>\n</ul>\n</li>\n<li>函数:<ul>\n<li>在调用函数时, 在执行函数体之前先创建一个函数执行上下文</li>\n<li>收集一些局部变量, 并初始化</li>\n<li>将这些变量设置为执行上下文的属性</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"javascript\">    //1. 进入全局执行上下文\n    var a = 10\n    var bar = function (x) &#123;\n      var b = 5\n      foo(x + b)              //3. 进入foo执行上下文\n    &#125;\n    var foo = function (y) &#123;\n      var c = 5\n      console.log(a + c + y)\n    &#125;\n    bar(10)                    //2. 进入bar函数执行上下文\n</code></pre>\n<pre><code class=\"javascript\">     /*\n    测试题1: 先预处理变量, 后预处理函数\n    */\n    function a() &#123; &#125;\n    var a;\n    console.log(typeof a)//function\n    /*\n    测试题2: 变量预处理, in操作符\n     */\n    if (!(b in window)) &#123;\n      var b = 1;\n    &#125;\n    console.log(b)//undefined\n    /*\n    测试题3: 预处理, 顺序执行\n     */\n    var c = 1\n    //var c\n    function c(c) &#123;\n      console.log(c)\n      var c = 3\n    &#125;\n    //c = 1\n    c(2)//报错\n</code></pre>\n<h3 id=\"2-3-作用域与作用域链\"><a href=\"#2-3-作用域与作用域链\" class=\"headerlink\" title=\"2.3 作用域与作用域链\"></a>2.3 作用域与作用域链</h3><ul>\n<li>理解:<ul>\n<li>作用域: 一块代码区域, 在编码时就确定了, 不会再变化</li>\n<li>作用域链: 多个嵌套的作用域形成的由内向外的结构, 用于查找变量</li>\n</ul>\n</li>\n<li>分类:<ul>\n<li>全局作用域</li>\n<li>函数作用域</li>\n<li><strong>js没有块作用域(在ES6之前)</strong></li>\n</ul>\n</li>\n<li>作用<ul>\n<li>作用域: <strong>隔离变量</strong>, 可以在不同作用域定义同名的变量不冲突</li>\n<li>作用域链**: 查找变量**</li>\n</ul>\n</li>\n<li>区别作用域与执行上下文 <ul>\n<li>作用域: 静态的, 编码时就确定了(不是在运行时), 一旦确定就不会变化了</li>\n<li>执行上下文: 动态的, 执行代码时动态创建, 当执行结束消失</li>\n<li>联系: 执行上下文环境是在对应的作用域中的</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"javascript\">    var a = 10,\n      b = 20\n    function fn(x) &#123;\n      var a = 100,\n        c = 300；\n      console.log(&#39;fn()&#39;, a, b, c, x)\n      function bar(x) &#123;\n        var a = 1000,\n          d = 400\n        console.log(&#39;bar()&#39;, a, b, c, d, x)\n      &#125;\n\n      bar(100)//bar() 1000 20 300 400 100\n      bar(200)//bar() 1000 20 300 400 200\n    &#125;\n    fn(10)//fn() 100 20 300 10\n</code></pre>\n<pre><code class=\"javascript\">  var x = 10;\n  function fn() &#123;\n    console.log(x);\n  &#125;\n  function show(f) &#123;\n    var x = 20;\n    f();\n  &#125;\n  show(fn);//fn和show是同级函数\n</code></pre>\n<pre><code class=\"javascript\">    var fn = function () &#123;\n      console.log(fn)//输出函数\n    &#125;\n    fn()\n\n    var obj = &#123;\n      fn2: function () &#123;\n        console.log(fn2)//报错\n        //console.log(this.fn2)\n      &#125;\n    &#125;\n    obj.fn2()\n</code></pre>\n<h3 id=\"2-4-闭包\"><a href=\"#2-4-闭包\" class=\"headerlink\" title=\"2.4 闭包\"></a>2.4 闭包</h3><ul>\n<li><p>理解:</p>\n<ul>\n<li><strong>当嵌套的内部函数引用了外部函数的变量时就产生了闭包</strong></li>\n<li>通过chrome工具得知: 闭包本质是内部函数中的一个对象, 这个对象中包含引用的变量属性</li>\n</ul>\n</li>\n<li><p>作用:</p>\n<ul>\n<li>延长局部变量的生命周期</li>\n<li>让函数外部能操作内部的局部变量</li>\n</ul>\n</li>\n<li><p>常见的闭包</p>\n<pre><code class=\"JavaScript\">// 1. 将函数作为另一个函数的返回值\nfunction fn1() &#123;\n  var a = 2;\n  function fn2() &#123;\n    a++;\n    console.log(a);\n  &#125;\n  return fn2;\n&#125;\nvar f = fn1();\nf();//3\nf();//4\n\n\n// 2. 将函数作为实参传递给另一个函数调用\nfunction showMsgDelay(msg, time) &#123;\n  setTimeout(function () &#123;\n    console.log(msg)\n  &#125;, time)\n&#125;\nshowMsgDelay(&#39;hello&#39;, 1000)\n</code></pre>\n</li>\n<li><p>闭包的生命周期</p>\n<ul>\n<li>产生: 在嵌套内部函数<strong>定义执行</strong>完时就产生了(不是在调用)</li>\n<li>死亡: 在嵌套的内部函数成为<strong>垃圾对象</strong>时</li>\n</ul>\n</li>\n<li><p>闭包应用:</p>\n<ul>\n<li><strong>模块化: 封装一些数据以及操作数据的函数, 向外暴露一些行为</strong></li>\n<li>循环遍历加监听</li>\n<li>JS框架(jQuery)大量使用了闭包</li>\n</ul>\n</li>\n<li><p>缺点:</p>\n<ul>\n<li>变量占用内存的时间可能会过长</li>\n<li>可能导致内存泄露</li>\n<li>解决:<ul>\n<li>及时释放 : f &#x3D; null; &#x2F;&#x2F;让内部函数对象成为垃圾对象</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"javascript\">    //代码片段一\n    var name = &quot;The Window&quot;;\n    var object = &#123;\n      name: &quot;My Object&quot;,\n      getNameFunc: function () &#123;\n        return function () &#123;\n          return this.name;\n        &#125;;\n      &#125;\n    &#125;;\n    console.log(object.getNameFunc()());  //The Window 直接执行函数，this指向window 无闭包\n\n    //代码片段二\n    var name2 = &quot;The Window&quot;;\n    var object2 = &#123;\n      name2: &quot;My Object&quot;,\n      getNameFunc: function () &#123;\n        var that = this;\n        return function () &#123;\n          return that.name2;\n        &#125;;\n      &#125;\n    &#125;;\n    console.log(object2.getNameFunc()()); //My Object that保存的是函数 有闭包\n</code></pre>\n<pre><code class=\"JavaScript\">    function fun(n, o) &#123;\n      console.log(o)\n      return &#123;\n        fun: function (m) &#123;\n          return fun(m, n)\n        &#125;\n      &#125;\n    &#125;\n    var a = fun(0)\n    a.fun(1)\n    a.fun(2)\n    a.fun(3) //undefined,0,0,0 \n\n    var b = fun(0).fun(1).fun(2).fun(3) //undefined,0,1,2 闭包\n\n    var c = fun(0).fun(1)\n    c.fun(2)\n    c.fun(3) //undefined,0,1,1 前面闭包，后面是因为闭包延长局部变量的生命周期\n</code></pre>\n<h3 id=\"2-5-内存溢出与内存泄露\"><a href=\"#2-5-内存溢出与内存泄露\" class=\"headerlink\" title=\"2.5 内存溢出与内存泄露\"></a>2.5 内存溢出与内存泄露</h3><ol>\n<li>内存溢出</li>\n</ol>\n<ul>\n<li>一种程序运行出现的错误</li>\n<li>当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误</li>\n</ul>\n<ol start=\"2\">\n<li>内存泄露</li>\n</ol>\n<ul>\n<li>占用的内存没有及时释放</li>\n<li>内存泄露积累多了就容易导致内存溢出</li>\n<li>常见的内存泄露:<ul>\n<li>意外的全局变量</li>\n<li>没有及时清理的计时器或回调函数</li>\n<li>闭包</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3、对象高级\"><a href=\"#3、对象高级\" class=\"headerlink\" title=\"3、对象高级\"></a>3、对象高级</h2><h3 id=\"3-1-对象的创建模式\"><a href=\"#3-1-对象的创建模式\" class=\"headerlink\" title=\"3.1 对象的创建模式\"></a>3.1 对象的创建模式</h3><ul>\n<li><p>Object构造函数模式</p>\n<pre><code class=\"javascript\">//适用场景: 起始时不确定对象内部数据\n//问题: 语句太多\nvar obj = &#123;&#125;;\nobj.name = &#39;Tom&#39;\nobj.setName = function(name)&#123;this.name=name&#125;\n</code></pre>\n</li>\n<li><p>对象字面量模式</p>\n<pre><code class=\"javascript\">//适用场景: 起始时对象内部数据是确定的\n//问题: 如果创建多个对象, 有重复代码\nvar obj = &#123;\n  name : &#39;Tom&#39;,\n  setName : function(name)&#123;this.name = name&#125;\n&#125;\n</code></pre>\n</li>\n<li><p>工厂模式</p>\n<pre><code class=\"javascript\">// 工厂函数: 返回一个需要的数据的函数\n//适用场景: 需要创建多个对象\n//问题: 对象没有一个具体的类型, 都是Object类型\n  function createPerson(name, age) &#123;\n    var p = &#123;\n      name: name,\n      age: age,\n      setName: function (name) &#123;\n        this.name = name\n      &#125;\n    &#125;\n    return p\n  &#125;\n</code></pre>\n</li>\n<li><p>构造函数模式</p>\n<pre><code class=\"javascript\">//适用场景: 需要创建多个类型确定的对象\n//问题: 每个对象都有相同的数据, 浪费内存\nfunction Person(name, age) &#123;\n  this.name = name;\n  this.age = age;\n  this.setName = function(name)&#123;this.name=name;&#125;;\n&#125;\nnew Person(&#39;tom&#39;, 12);\n</code></pre>\n</li>\n<li><p>构造函数+原型的组合模式</p>\n<pre><code class=\"javascript\">//适用场景: 需要创建多个类型确定的对象\nfunction Person(name, age) &#123;\n  this.name = name;\n  this.age = age;\n&#125;\nPerson.prototype.setName = function(name)&#123;this.name=name;&#125;;\nnew Person(&#39;tom&#39;, 12);\n</code></pre>\n</li>\n</ul>\n<h3 id=\"3-2-继承模式\"><a href=\"#3-2-继承模式\" class=\"headerlink\" title=\"3.2 继承模式\"></a>3.2 继承模式</h3><ul>\n<li>原型链继承 : 得到方法,<strong>子类型的原型为父类型的一个实例对象</strong>(关键)<pre><code class=\"javascript\">function Parent()&#123;&#125;\nParent.prototype.test = function()&#123;&#125;;\n\nfunction Child()&#123;&#125;\nChild.prototype = new Parent(); // 子类型的原型指向父类型实例\n\nChild.prototype.constructor = Child\nvar child = new Child(); //有test()\n</code></pre>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/5e26c428bae2465383cb7cf354bba124.png#pic_center\"></p>\n<ul>\n<li><p>借用构造函数 : 得到属性，<strong>在子类型构造函数中通用super()调用父类型构造函数</strong>(关键)</p>\n<pre><code class=\"javascript\">function Parent(xxx)&#123;this.xxx = xxx&#125;\nParent.prototype.test = function()&#123;&#125;;\nfunction Child(xxx,yyy)&#123;\n    Parent.call(this, xxx);//借用构造函数   this.Parent(xxx)\n&#125;\nvar child = new Child(&#39;a&#39;, &#39;b&#39;);  //child.xxx为&#39;a&#39;, 但child没有test()\n</code></pre>\n</li>\n<li><p>组合</p>\n<pre><code class=\"javascript\">function Parent(xxx)&#123;this.xxx = xxx&#125;\nParent.prototype.test = function()&#123;&#125;;\nfunction Child(xxx,yyy)&#123;\n    Parent.call(this, xxx);//借用构造函数   this.Parent(xxx)\n&#125;\nChild.prototype = new Parent(); //得到test()\nvar child = new Child(); //child.xxx为&#39;a&#39;, 也有test()\n</code></pre>\n</li>\n<li><p>new一个对象背后做了些什么?</p>\n<ul>\n<li>创建一个空对象</li>\n<li>给对象设置__ proto__ , 值为构造函数对象的prototype属性值   this.__ proto__ &#x3D; Fn.prototype</li>\n<li>执行构造函数体(给对象添加属性&#x2F;方法)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4、线程机制与事程机制\"><a href=\"#4、线程机制与事程机制\" class=\"headerlink\" title=\"4、线程机制与事程机制\"></a>4、线程机制与事程机制</h2><h3 id=\"4-1-线程与进程\"><a href=\"#4-1-线程与进程\" class=\"headerlink\" title=\"4.1 线程与进程\"></a>4.1 线程与进程</h3><ul>\n<li>进程:<ul>\n<li>程序的一次执行, 它占有一片独有的内存空间</li>\n<li>可以通过windows任务管理器查看进程</li>\n</ul>\n</li>\n<li>线程:<ul>\n<li>是进程内的一个独立执行单元</li>\n<li>是程序执行的一个完整流程</li>\n<li><strong>是CPU的基本调度单元</strong></li>\n</ul>\n</li>\n<li>关系<ul>\n<li>一个进程至少有一个线程(主)</li>\n<li>程序是在某个进程中的某个线程执行的</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-2-浏览器内核模块组成\"><a href=\"#4-2-浏览器内核模块组成\" class=\"headerlink\" title=\"4.2 浏览器内核模块组成\"></a>4.2 浏览器内核模块组成</h3><ul>\n<li>主线程<ul>\n<li>js引擎模块 : 负责js程序的编译与运行</li>\n<li>html,css文档解析模块 : 负责页面文本的解析</li>\n<li>DOM&#x2F;CSS模块 : 负责dom&#x2F;css在内存中的相关处理 </li>\n<li>布局和渲染模块 : 负责页面的布局和效果的绘制(内存中的对象)</li>\n</ul>\n</li>\n<li>分线程<ul>\n<li>定时器模块 : 负责定时器的管理</li>\n<li>DOM事件模块 : 负责事件的管理</li>\n<li>网络请求模块 : 负责Ajax请求</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-3-js线程\"><a href=\"#4-3-js线程\" class=\"headerlink\" title=\"4.3 js线程\"></a>4.3 js线程</h3><ul>\n<li>js是单线程执行的(回调函数也是在主线程)</li>\n<li>JavaScript的单线程，与它的用途有关；作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题</li>\n<li>H5提出了实现多线程的方案: Web Workers；只能是主线程更新界面</li>\n</ul>\n<h3 id=\"4-4-定时器问题\"><a href=\"#4-4-定时器问题\" class=\"headerlink\" title=\"4.4 定时器问题\"></a>4.4 定时器问题</h3><ul>\n<li>定时器并不真正完全定时</li>\n<li>如果在主线程执行了一个长时间的操作, 可能导致延时才处理</li>\n</ul>\n<h3 id=\"4-5-事件处理机制\"><a href=\"#4-5-事件处理机制\" class=\"headerlink\" title=\"4. 5 事件处理机制\"></a>4. 5 事件处理机制</h3><ul>\n<li>代码分类<ul>\n<li>初始化执行代码: <strong>包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码</strong></li>\n<li>回调执行代码: 处理回调逻辑</li>\n</ul>\n</li>\n<li>js引擎执行代码的基本流程: <ul>\n<li>初始化代码&#x3D;&#x3D;&#x3D;&gt;回调代码</li>\n</ul>\n</li>\n<li>模型的2个重要组成部分:<ul>\n<li>事件管理模块</li>\n<li>回调队列</li>\n</ul>\n</li>\n<li>模型的运转流程<ul>\n<li>执行初始化代码, 将事件回调函数交给对应模块管理</li>\n<li>当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中</li>\n<li>只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/6a6ec78fa0d74b6490cef4aacb8232c2.png#pic_center\"></p>\n<h3 id=\"4-6-H5-Web-Workers\"><a href=\"#4-6-H5-Web-Workers\" class=\"headerlink\" title=\"4.6 H5 Web Workers\"></a>4.6 H5 Web Workers</h3><p><img src=\"https://img-blog.csdnimg.cn/6b5a0c210a9b4608ad36f8c415c3c5bf.png#pic_center\"></p>\n<ul>\n<li><p>可以让js在分线程执行</p>\n</li>\n<li><p>Worker</p>\n<pre><code class=\"javascript\">var worker = new Worker(&#39;worker.js&#39;);\nworker.onMessage = function(event)&#123;event.data&#125;;// 用来接收另一个线程发送过来的数据的回调\nworker.postMessage(data1);//向另一个线程发送数据\n</code></pre>\n</li>\n<li><p>问题:</p>\n<ul>\n<li>worker内代码不能操作DOM更新UI</li>\n<li>不是每个浏览器都支持这个新特性</li>\n<li>不能跨域加载JS</li>\n</ul>\n</li>\n</ul>\n","feature":true,"text":"JavaScript高级语法包括闭包、原型链、对象高级、线程与执行机制等。掌握这些高级语法可以提升代码的可维护性和性能，实现更复杂的功能和逻辑。在前端开发中，熟练应用JavaScript高级语法能够编写出结构清晰、功能强大的代码，为用户提供更流畅的交互体验。...","permalink":"/post/前端--JavaScript高级","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":4,"path":"api/tags/JavaScript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JavaScript%E9%AB%98%E7%BA%A7\"><span class=\"toc-text\">JavaScript高级</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E6%B7%B1%E5%85%A5\"><span class=\"toc-text\">1、基础总结深入</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E5%88%A4%E6%96%AD\"><span class=\"toc-text\">1.1 数据类型的分类和判断</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-%E6%95%B0%E6%8D%AE-%E5%8F%98%E9%87%8F-%E5%86%85%E5%AD%98%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">1.2 数据,变量, 内存的理解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">1.3 对象的理解和使用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">1.4 函数的理解和使用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7\"><span class=\"toc-text\">2、函数高级</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE\"><span class=\"toc-text\">2.1 原型与原型链</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88\"><span class=\"toc-text\">2.2 执行上下文与执行上下文栈</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE\"><span class=\"toc-text\">2.3 作用域与作用域链</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-%E9%97%AD%E5%8C%85\"><span class=\"toc-text\">2.4 闭包</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-5-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2\"><span class=\"toc-text\">2.5 内存溢出与内存泄露</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7\"><span class=\"toc-text\">3、对象高级</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">3.1 对象的创建模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">3.2 继承模式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4%E3%80%81%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BA%8B%E7%A8%8B%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">4、线程机制与事程机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B\"><span class=\"toc-text\">4.1 线程与进程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%BB%84%E6%88%90\"><span class=\"toc-text\">4.2 浏览器内核模块组成</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-js%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">4.3 js线程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-%E5%AE%9A%E6%97%B6%E5%99%A8%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">4.4 定时器问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-5-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">4. 5 事件处理机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-6-H5-Web-Workers\"><span class=\"toc-text\">4.6 H5 Web Workers</span></a></li></ol></li></ol></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"提高开发效率：ES6技巧大全","uid":"26420f1034bff9b91a54684d743949a2","slug":"前端--一文轻松搞懂ES6-ES11(ES6详解)","date":"2023-01-12T00:36:22.000Z","updated":"2025-07-14T15:12:20.465Z","comments":true,"path":"api/articles/前端--一文轻松搞懂ES6-ES11(ES6详解).json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/693b39076a084dd39ab56802ff1834b9.jpeg","text":"ES6引入了箭头函数、模板字符串等特性，ES7加入了Array.prototype.includes()方法，ES8推出了async/await语法，ES9引入了Asynchronous Iteration，ES10增加了Array.flat()和Array.flatMap()方法，ES11则新增了可选链操作符和空值合并操作符。掌握这些语法能够提升前端开发效率和代码质量。...","permalink":"/post/前端--一文轻松搞懂ES6-ES11(ES6详解)","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"19 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":4,"path":"api/tags/JavaScript.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true},"next_post":{"title":"JavaScript高级开发必备：Bom和Dom全解析","uid":"e5530224ca8e131eb4d30d06bd108a65","slug":"前端--JavaScript Bom和Dom","date":"2022-12-23T13:17:23.000Z","updated":"2025-07-14T15:12:20.463Z","comments":true,"path":"api/articles/前端--JavaScript Bom和Dom.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/de6c1a55cf774f9fa1e2cff7c25e5fc9.png","text":"JavaScript BOM（浏览器对象模型）和DOM（文档对象模型）是前端开发中的两个重要概念。BOM是用于操作浏览器窗口、浏览器历史记录和浏览器位置等的API，而DOM则是用于操作HTML和XML文档中的元素和属性的API。通过使用BOM和DOM，开发人员可以创建交互性更强的网页，实现动态效果和用户交互功能。...","permalink":"/post/前端--JavaScript Bom和Dom","photos":[],"count_time":{"symbolsCount":"70k","symbolsTime":"1:03"},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":4,"path":"api/tags/JavaScript.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true}}