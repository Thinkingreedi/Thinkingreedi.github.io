{"title":"栈和队列","uid":"32e8754bc216ad5a6afe6dae9987332f","slug":"数据结构（C语言版）-- 栈和队列笔记","date":"2022-02-13T02:39:25.000Z","updated":"2025-07-14T15:12:20.469Z","comments":true,"path":"api/articles/数据结构（C语言版）-- 栈和队列笔记.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/68983f406bb44b89b7de3accaf6351a4.png","content":"<hr>\n<h1 id=\"1、栈和队列的定义和特点\"><a href=\"#1、栈和队列的定义和特点\" class=\"headerlink\" title=\"1、栈和队列的定义和特点\"></a>1、栈和队列的定义和特点</h1><h2 id=\"①-栈的定义和特点\"><a href=\"#①-栈的定义和特点\" class=\"headerlink\" title=\"①.栈的定义和特点\"></a>①.栈的定义和特点</h2><p><strong>栈( stack）</strong>是限定仅在表尾进行插人或删除操作的线性表。因此，对栈来说，表尾端有其特殊含义，称为<strong>栈顶( top )<strong>，相应地，表头端称为</strong>栈底（ bottom )<strong>。不含元素的空表称为</strong>空栈</strong>。&#x3D;&#x3D;<strong>后进先出( Last In First Out，LIFO）</strong>&#x3D;&#x3D;</p>\n<p><img src=\"https://img-blog.csdnimg.cn/425be17ca10c42cbbc7e11cb5d5e826a.png#pic_center\"></p>\n<p>在日常生活中，有很多类似栈的例子。例如，洗干净的盘子总是逐个往上叠放在已经洗好的盘子上面，而用时从上往下逐个取用。栈的操作特点正是上述实际应用的抽象。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/36f868a236494cb59509cb339a51c5c0.png#pic_center\"></p>\n<h2 id=\"②-队列的定义和特点\"><a href=\"#②-队列的定义和特点\" class=\"headerlink\" title=\"②.队列的定义和特点\"></a>②.队列的定义和特点</h2><p>和栈相反，**队列( queue)<strong>是一种 &#x3D;&#x3D;先进先出(First In First Out，FIFO)&#x3D;&#x3D; 的线性表。它只允许在表的一端进行插入，而在另一端删除元素。这和日常生活中的排队是一致的，最早进人队列的元素最早离开。在队列中，允许插入的一端称为</strong>队尾( rear )<strong>，允许删除的一端则称为</strong>队头(front )**。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/fb8368d57f924486b3e7fbc8f3b6aa4f.png#pic_center\"></p>\n<p>队列在程序设计中也经常出现,一个最典型的例子就是操作系统中的作业排队。在允许多道程序运行的计算机系统中，同时有几个作业运行。如果运行的结果都需要通过通道输出，那就要按请求输入的先后次序排队。每当通道传输完毕可以接受新的输出任务时，队头的作业先从队列中退出做输出操作。凡是申请输出的作业都从队尾进入队列。</p>\n<hr>\n<h1 id=\"2、栈的表示和操作的实现\"><a href=\"#2、栈的表示和操作的实现\" class=\"headerlink\" title=\"2、栈的表示和操作的实现\"></a>2、栈的表示和操作的实现</h1><h2 id=\"①-栈的类型定义\"><a href=\"#①-栈的类型定义\" class=\"headerlink\" title=\"①.栈的类型定义\"></a>①.栈的类型定义</h2><p>栈的抽象数据类型定义：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/452a0d181c7f4b26976aa131865f7c60.png#pic_center\"></p>\n<h2 id=\"②-顺序栈的表示和实现\"><a href=\"#②-顺序栈的表示和实现\" class=\"headerlink\" title=\"②.顺序栈的表示和实现\"></a>②.顺序栈的表示和实现</h2><p>顺序栈是指利用顺序存储结构实现的栈，即利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设指针 top指示栈顶元素在顺序栈中的位置。base为栈底指针，stacksize指示栈可使用的最大容量。&#x3D;&#x3D;若base &#x3D; NULL,表示栈结构不存在，base &#x3D; &#x3D; top是栈空标志，top-base &#x3D; &#x3D; stacksize是栈满标志&#x3D;&#x3D;</p>\n<pre><code class=\"c\">//顺序栈的存储结构\n#define MAXSIZE 100\ntypedef struct\n&#123;\n    SElemType *base; //栈底指针\n    SElemType *top;  //栈顶指针\n    int stacksize;   //可使用的最大容量\n&#125; SqStack;\n</code></pre>\n<p>顺序栈中数据元素和栈指针之间的对应关系：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/3d4070d06a574a7cacced8c854ca4d05.png#pic_center\"></p>\n<p><strong>顺序栈的初始化</strong></p>\n<ol>\n<li>为顺序栈动态分配-个最大容量为MAXSIZE的数组空间，使base指向这段空间的基地址，即栈底。</li>\n<li>栈顶指针top初始为base,表示栈为空。</li>\n<li>stacksize置为栈的最大容量MAXSIZE</li>\n</ol>\n<pre><code class=\"c\">Status InitStack(SqStack &amp;S)\n&#123;\n    S.base = new SElemType[MAXSIZE];\n    if (!S.base)\n        exit(OVERFLOW);\n    S.top = S.base;\n    S.stacksize = MAXSIZE;\n    return OK;\n&#125;\n</code></pre>\n<p><strong>顺序栈的入栈</strong></p>\n<ol>\n<li>判断栈是否满,若满则返回ERROR。</li>\n<li>将新元素压入栈顶,栈顶指针加 1。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/5669f3a508484cab8d236be705a5dc66.png#pic_center\"></p>\n<pre><code class=\"c\">Status Push(SqStack &amp;S, SElemType e)\n&#123; // 插入元素e为新的栈顶元素\n    if (S.top - S.base == S.stacksize)\n        return ERROR; //栈满\n    *S.top++ = e;     // 新元素e压入栈顶，然后栈顶指针加1(*S.top=e;S.top++;)\n    return OK;\n&#125;\n</code></pre>\n<p><strong>顺序栈的出栈</strong></p>\n<ol>\n<li>判断栈是否空,若空则返回 ERROR。</li>\n<li>栈顶指针减1，栈顶元素出栈。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/d193f5bfa7ec4a2ba9bc2a76f38edf40.png#pic_center\"></p>\n<pre><code class=\"c\">Status Pop(SqStack &amp;S, SElemType &amp;e)\n&#123; // 删除S的栈顶元素，用e返回其值\n    if (S.top == S.base)\n        return ERROR; //栈空报错\n    e = *--S.top;     //栈顶指针减1，然后获取栈顶元素e(--S.top;e=*S.top;)\n    return OK;\n&#125;\n</code></pre>\n<p><strong>顺序栈的实现</strong></p>\n<p>测试样例：SqStack.txt<br>测试内容：<br>A<br>B<br>C<br>D</p>\n<pre><code class=\"c\">/***顺序栈的实现***/\n\n#include&lt;iostream&gt;\n#include&lt;fstream&gt;\nusing namespace std;\n\n//顺序栈定义\n#define OK 1\n#define ERROR 0\n#define OVERFLOW -2\n#define MAXSIZE  100//顺序栈存储空间的初始分配量\ntypedef int Status;\ntypedef char SElemType;\n\ntypedef struct &#123;\n    SElemType *base;//栈底指针\n    SElemType *top;//栈顶指针\n    int stacksize;//栈可用的最大容量\n&#125; SqStack;\n\n//顺序栈的初始化\nStatus InitStack(SqStack &amp;S) &#123;\n    //构造一个空栈S\n    S.base = new SElemType[MAXSIZE];//为顺序栈动态分配一个最大容量为MAXSIZE的数组空间\n    if (!S.base)\n        exit(OVERFLOW); //存储分配失败\n    S.top = S.base; //top初始为base，空栈\n    S.stacksize = MAXSIZE; //stacksize置为栈的最大容量MAXSIZE\n    return OK;\n&#125;\n//顺序栈的入栈\nStatus Push(SqStack &amp;S, SElemType e) &#123;\n    // 插入元素e为新的栈顶元素\n    if (S.top - S.base == S.stacksize)\n        return ERROR; //栈满\n    *(S.top++) = e; //元素e压入栈顶，栈顶指针加1\n    return OK;\n&#125;\n//顺序栈的出栈\nStatus Pop(SqStack &amp;S, SElemType &amp;e) &#123;\n    //删除S的栈顶元素，用e返回其值\t\n    if (S.base == S.top)\n        return ERROR;//栈空\n    e = *(--S.top); //栈顶指针减1，将栈顶元素赋给e\n    return OK;\n&#125;\n//取顺序栈的栈顶元素\nchar GetTop(SqStack S) &#123;//返回S的栈顶元素，不修改栈顶指针\n    if (S.top != S.base) //栈非空\n        return *(S.top - 1); //返回栈顶元素的值，栈顶指针不变\n&#125;\n\nint main() &#123;\n    SqStack s;\n    int choose, flag = 0;\n    SElemType j, e, t;\n    cout &lt;&lt; &quot;1.初始化\\n&quot;;\n    cout &lt;&lt; &quot;2.入栈\\n&quot;;\n    cout &lt;&lt; &quot;3.读栈顶元素\\n&quot;;\n    cout &lt;&lt; &quot;4.出栈\\n&quot;;\n    cout &lt;&lt; &quot;0.退出\\n\\n&quot;;\n\n    choose = -1;\n    while (choose != 0) &#123;\n        cout &lt;&lt; &quot;请选择:&quot;;\n        cin &gt;&gt; choose;\n        switch (choose) &#123;\n        case 1://顺序栈的初始化\n            if (InitStack(s)) &#123;\n                flag = 1;\n                cout &lt;&lt; &quot;成功对栈进行初始化\\n\\n&quot;;\n            &#125; else\n                cout &lt;&lt; &quot;初始化栈失败\\n\\n&quot;;\n            break;\n        case 2: &#123;//顺序栈的入栈\n            fstream file;\n            file.open(&quot;SqStack.txt&quot;);//\n            if (!file) &#123;\n                cout &lt;&lt; &quot;错误！未找到文件！\\n\\n&quot; &lt;&lt; endl;\n                exit(ERROR);\n            &#125;\n            if (flag) &#123;\n                flag = 1;\n                cout &lt;&lt; &quot;进栈元素依次为：\\n&quot;;\n                while (!file.eof()) &#123;\n                    file &gt;&gt; j;\n                    if (file.fail())\n                        break;\n                    else &#123;\n                        Push(s, j);\n                        cout &lt;&lt; j &lt;&lt; &quot;  &quot;;\n                    &#125;\n                &#125;\n                cout &lt;&lt; endl &lt;&lt; endl;\n            &#125; else\n                cout &lt;&lt; &quot;栈未建立，请重新选择\\n\\n&quot;;\n            file.close();\n        &#125;\n            break;\n        case 3://顺序栈的出栈\n            if(flag != -1 &amp;&amp; flag != 0)\n                cout &lt;&lt; &quot;栈顶元素为：\\n&quot; &lt;&lt; GetTop(s) &lt;&lt; endl &lt;&lt; endl;\n            else\n                cout &lt;&lt; &quot;栈中无元素，请重新选择\\n&quot; &lt;&lt; endl;\n            break;\n        case 4://取顺序栈的栈顶元素\n            cout &lt;&lt; &quot;依次弹出的栈顶元素为:\\n&quot;;\n            while (Pop(s, t))&#123;\n                flag = -1;\n                cout &lt;&lt; t &lt;&lt; &quot;  &quot;;\n            &#125;\n            cout &lt;&lt; endl &lt;&lt; endl;\n            break;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<h2 id=\"②-链栈的表示和实现\"><a href=\"#②-链栈的表示和实现\" class=\"headerlink\" title=\"②.链栈的表示和实现\"></a>②.链栈的表示和实现</h2><p>链栈是指采用链式存储结构实现的栈，通常链栈用单链表来表示，链栈的结点结构与单链表的结构相同。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/30c545a234924e1ba29c9009b5829283.png#pic_center\"></p>\n<pre><code class=\"c\">//链栈的存储结构\ntypedef struct StackNode\n&#123;\n    ElemType data;\n    struct StackNode *next;\n&#125; StackNode, *LinkStack;\n\nLinkStack S;\n</code></pre>\n<p>由于栈的主要操作是在栈顶插人和删除，显然以链表的头部作为栈顶是最方便的，而且没必要像单链表那样为了操作方便附加一个头结点。</p>\n<p><strong>链栈的初始化</strong></p>\n<p>链栈的初始化操作就是构造一个空栈，因为没必要设头结点，所以直接将栈顶指针置空即可。</p>\n<pre><code class=\"c\">Status InitStack(LinkStack &amp;S)\n&#123; // 构造一个空栈 S，栈顶指针置空\n    S = NULL;\n    return OK;\n&#125;\n</code></pre>\n<p><strong>链栈的入栈</strong></p>\n<ol>\n<li>为入栈元素e分配空间，用指针p指向。</li>\n<li>将新结点数据域置为e。</li>\n<li>将新结点插人栈顶。</li>\n<li>修改栈顶指针为p。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/58852657c7a14df09c1f7379cbad6696.png#pic_center\"></p>\n<pre><code class=\"c\">Status Push(LinkStack &amp;S, SElemType e)\n&#123;                      //在栈顶插入元素e\n    p = new StackNode; //生成新结点\n    p-&gt;data = e;       //将新结点数据域置为e\n    p-&gt;next = S;       //将新结点插入栈顶\n    S = p;             //修改栈顶指针为p\n    return OK;\n&#125;\n</code></pre>\n<p><strong>链栈的出栈</strong></p>\n<ol>\n<li>判断栈是否为空，若空则返回ERROR。</li>\n<li>将栈顶元素赋给e。</li>\n<li>临时保存栈顶元素的空间，以备释放。</li>\n<li>修改栈顶指针,指向新的栈顶元素。</li>\n<li>释放原栈顶元素的空间。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/9a9dbcdb7fe54f808128ffe97bdb73dc.png#pic_center\"></p>\n<pre><code class=\"c\">Status Pop(LinkStack &amp;S, SElemType &amp;e)\n&#123; //删除S的栈顶元素，用e返回其值\n    if (S == NULL)\n        return ERROR; //栈空\n    e = S-&gt;data;      //将栈顶元素赋给e\n    p = S;            //用p临时保存栈顶元素空间，以备释放\n    S = S-&gt;next;      //修改栈顶指针\n    delete p;         //释放原栈顶元素的空间\n    return OK;\n&#125;\n</code></pre>\n<p><strong>取链栈的栈顶元素</strong></p>\n<p>与顺序栈—样，当栈非空时，此操作返回当前栈顶元素的值，栈顶指针S保持不变。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/72f3a0f427ea452cafb92a698784d39c.png#pic_center\"></p>\n<pre><code class=\"c\">SElemType GetTop(LinkStack S)\n&#123;\n    if (S != NULL)\n        return S–&gt; data;\n&#125;\n</code></pre>\n<p><strong>链栈的实现</strong></p>\n<p>测试样例：SqStack.txt<br>测试内容：<br>A<br>B<br>C<br>D</p>\n<pre><code class=\"c\">/***链栈的实现***/\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define OK 1\n#define ERROR 0\ntypedef int Status;\ntypedef int SElemType;\n//链栈定义\ntypedef struct StackNode\n&#123;\n    SElemType data;\n    struct StackNode *next;\n&#125; StackNode, *LinkStack;\n//链栈的初始化\nStatus InitStack(LinkStack &amp;S)\n&#123; // 构造一个空栈 S，栈顶指针置空\n    S = NULL;\n    return OK;\n&#125;\n//链栈的入栈\nStatus Push(LinkStack &amp;S, SElemType e)\n&#123; //在栈顶插入元素e\n    LinkStack p;\n    p = new StackNode; //生成新结点\n    p-&gt;data = e;       //将新结点数据域置为e\n    p-&gt;next = S;       //将新结点插入栈顶\n    S = p;             //修改栈顶指针为p\n    return OK;\n&#125;\n//链栈的出栈\nStatus Pop(LinkStack &amp;S, SElemType &amp;e)\n&#123; //删除S的栈顶元素，用e返回其值\n    LinkStack p;\n    if (S == NULL)\n        return ERROR; //栈空\n    e = S-&gt;data;      //将栈顶元素赋给e\n    p = S;            //用p临时保存栈顶元素空间，以备释放\n    S = S-&gt;next;      //修改栈顶指针\n    delete p;         //释放原栈顶元素的空间\n    return OK;\n&#125;\n//取链栈的栈顶元素\nSElemType GetTop(LinkStack S)\n&#123;                       //返回S的栈顶元素，不修改栈顶指针\n    if (S != NULL)      //栈非空\n        return S-&gt;data; //返回栈顶元素的值，栈顶指针不变\n&#125;\nint main()\n&#123;\n    LinkStack s;\n    int select, flag = 0, i,j,n, t;\n    cout &lt;&lt; &quot;1.初始化链栈\\n&quot;;\n    cout &lt;&lt; &quot;2.链栈的入栈\\n&quot;;\n    cout &lt;&lt; &quot;3.读栈顶元素\\n&quot;;\n    cout &lt;&lt; &quot;4.链栈的出栈\\n&quot;;\n    cout &lt;&lt; &quot;0.退出\\n\\n&quot;;\n\n    while (1)\n    &#123;\n        cout &lt;&lt; &quot;请选择:&quot;;\n        cin &gt;&gt; select;\n        switch (select)\n        &#123;\n        case 1: //链栈的初始化\n            if (InitStack(s))\n            &#123;\n                flag = 1;\n                cout &lt;&lt; &quot;成功对栈进行初始化\\n\\n&quot;;\n            &#125;\n            else\n                cout &lt;&lt; &quot;初始化栈失败\\n\\n&quot;;\n            break;\n        case 2:\n         //链栈的入栈\n            cout &lt;&lt; &quot;请输入元素个数：&quot;;\n            cin &gt;&gt; n;\n            cout &lt;&lt; &quot;请输入&quot; &lt;&lt; n &lt;&lt; &quot;个元素：&quot;;\n            for (j = 1; j &lt;= n; ++j)\n            &#123;\n                cin &gt;&gt; i;\n                if (Push(s, i))\n                &#123;\n                    flag = 1;\n                &#125;\n            &#125;\n            if (flag = 1)\n            &#123;\n                cout &lt;&lt; &quot;入栈操作成功！\\n\\n&quot;;\n            &#125;\n            break;\n        case 3: //取链栈的栈顶元素\n            if (flag != -1 &amp;&amp; flag != 0)\n                cout &lt;&lt; &quot;栈顶元素为：\\n&quot;\n                     &lt;&lt; GetTop(s) &lt;&lt; endl\n                     &lt;&lt; endl;\n            else\n                cout &lt;&lt; &quot;栈中无元素，请重新选择\\n&quot;\n                     &lt;&lt; endl;\n            break;\n        case 4: //链栈的出栈\n            if (flag)\n            &#123;\n                cout &lt;&lt; &quot;依次弹出的栈顶元素为:\\n&quot;;\n                while (Pop(s, t))\n                    cout &lt;&lt; t &lt;&lt; &quot;  &quot;;\n                cout &lt;&lt; endl\n                     &lt;&lt; endl;\n            &#125;\n            else\n                cout &lt;&lt; &quot;栈未建立，请重新选择\\n\\n&quot;;\n            break;\n        case 0:\n            return 0;\n        default:\n            cout &lt;&lt; &quot;请重新输入！\\n\\n&quot;;\n            break;\n        &#125;\n        &#125;\n        return 0;\n    &#125;\n</code></pre>\n<h2 id=\"④-栈与递归\"><a href=\"#④-栈与递归\" class=\"headerlink\" title=\"④.栈与递归\"></a>④.栈与递归</h2><p><strong>递归的定义</strong></p>\n<p>若一个对象部分地包含它自己，或用它自己给自己定义，则称这个对象是递归的;<br>若一个过程直接或间接地调用自己，则称这个过程是递归的。</p>\n<p><strong>递归实例</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/b9be94fbe77b42b6abdefe7fa393ceaa.png#pic_center\"><br><strong>过程的嵌套定义</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/165518d22a084e42a92617e5f0e83497.png\"><br><strong>分治法</strong></p>\n<pre><code class=\"c\">long Fact(long n)\n&#123;\n    if (n == 1)\n        return 1; //基本项\n    else\n        temp = n * Fact(n - 1); //归纳项\n    return temp;\n&#125;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/fbdd486479e64327906280907af5addf.png#pic_center\"></p>\n<h2 id=\"⑤-思考\"><a href=\"#⑤-思考\" class=\"headerlink\" title=\"⑤.思考\"></a>⑤.思考</h2><p>问：根据栈的特性，如果进栈序列为A,B,C,D,E，能否得到D,C,E,A,B和A,C,E,D,B的出栈序列，如果不能得到请说明原因，如果可以得到请写出入栈、出栈的过程。</p>\n<p>答：出栈序列D,C,E,A,B不可能，因为D先出栈，表明这时A、B已经入栈，A为栈底，出栈时A肯定在B之后。出栈序列A,C,E,D,B可能，入栈、出栈的过程:PUSH(S,A);POP(S);PUSH(S,B);PUSH(S,C);POP(S);PUSH(S,D);PUSH(S,E);POP(S);POP(S); POP(S)。</p>\n<hr>\n<h1 id=\"3、队列的表示和操作的实现\"><a href=\"#3、队列的表示和操作的实现\" class=\"headerlink\" title=\"3、队列的表示和操作的实现\"></a>3、队列的表示和操作的实现</h1><h2 id=\"①-队列的类型定义\"><a href=\"#①-队列的类型定义\" class=\"headerlink\" title=\"①.队列的类型定义\"></a>①.队列的类型定义</h2><p>队列的抽象数据类型定义：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/6a1a56f3143c4097a99ca61f1fba15f2.png\"></p>\n<h2 id=\"②-队列的顺序表示和实现\"><a href=\"#②-队列的顺序表示和实现\" class=\"headerlink\" title=\"②.队列的顺序表示和实现\"></a>②.队列的顺序表示和实现</h2><p>和顺序栈相类似，在队列的顺序存储结构中，除了用一组地址连续的存储单元依次存放从队列头到队列尾的元素之外,尚需附设两个整型变量 front和rear分别指示队列头元素及队列尾元素的位置（后面分别称为头指针和尾指针)。队列的顺序存储结构表示如下:</p>\n<pre><code class=\"c\">#define MAXQSIZE 100 //最大队列长度\nTypedef struct\n&#123;\n    QElemType *base; //存储空间的基地址\n    int front;       //头指针\n    int rear;        //尾指针\n&#125; SqQueue;\n</code></pre>\n<p>顺序分配的队列中头、尾指针和元素之间的关系：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/600b8adebd4d4a2daff3713fad639c8a.png#pic_center\"></p>\n<p>假设当前队列分配的最大空间为6，则当队列处于上图（d）所示的状态时不可再继续插入新的队尾元素，否则会出现溢出现象，即因数组越界而导致程序的非法操作错误。事实上，此时队列的实际可用空间并未占满，所以这种现象称为&#x3D;&#x3D;“假溢出”&#x3D;&#x3D;。这是由“队尾入队，队头出队”这种受限制的操作造成的。解决这种“假溢出”问题一个较巧妙的办法是将顺序队列变为一个环状的空间，如下图所示，称之为循环队列。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/4826c2ff9cb442d1906f64938a1c3db5.png#pic_center\"><br>头、尾指针以及队列元素之间的关系不变，只是在循环队列中，头、尾指针“依环状增1”的操作可用“模”运算来实现。通过取模,头指针和尾指针就可以在顺序表空间内以头尾衔接的方式“循环”移动。循环队列中队空和队满的条件是：</p>\n<p>队空的条件:Q.front &#x3D; &#x3D; Q.rear<br>队满的条件:(Qrear + 1)%MAXQSIZE &#x3D; &#x3D; Q.front</p>\n<p><strong>循环队列的初始化</strong></p>\n<p>为队列分配一个最大容量为MAXSIZE的数组空间，base指向数组空间的首地址。头指针和尾指针置为零，表示队列为空。</p>\n<pre><code class=\"c\">Status InitQueue(SqQueue &amp;Q)\n&#123;\n    Q.base = new QElemType[MAXQSIZE];\n    if (!Q.base)\n        exit(OVERFLOW);\n    Q.front = Q.rear = 0;\n    return OK;\n&#125;\n</code></pre>\n<p><strong>求循环队列的长度</strong></p>\n<p>对于非循环队列，尾指针和头指针的差值便是队列长度，而对于循环队列,差值可能为负数所以需要将差值加上MAXQSIZE，然后与MAXQSIZE求余。</p>\n<pre><code class=\"c\">int QueueLength(SqQueue Q)\n&#123;\n    return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE\n&#125;\n</code></pre>\n<p><strong>循环队列的入队</strong></p>\n<ol>\n<li>判断队列是否满，若满则返回ERROR。</li>\n<li>将新元素插入队尾。</li>\n<li>队尾指针加1。</li>\n</ol>\n<pre><code class=\"c\">Status EnQueue(SqQueue &amp;Q，QElemType e)\n&#123;\n    if ((Q.rear + 1) % MAXQSIZE == Q.front)\n        return ERROR; //队满\n    Q.base[Q.rear] = e;\n    Q.rear = (Q.rear + 1) % MAXQSIZE;\n    return OK;\n&#125;\n</code></pre>\n<p><strong>循环队列的出队</strong></p>\n<ol>\n<li>判断队列是否为空，若空则返回ERROR。</li>\n<li>保存队头元素。</li>\n<li>队头指针加1。</li>\n</ol>\n<pre><code class=\"c\">Status DeQueue(LinkQueue &amp;Q，QElemType &amp;e)\n&#123;\n    if (Q.front == Q.rear)\n        return ERROR; //队空\n    e = Q.base[Q.front];\n    Q.front = (Q.front + 1) % MAXQSIZE;\n    return OK;\n&#125;\n</code></pre>\n<p><strong>取循环队列的队头元素</strong></p>\n<p>当队列非空时，此操作返回当前队头元素的值，队头指针保持不变。</p>\n<pre><code class=\"c\">SElemType GetHead(SqQueue Q)\n&#123;\n    if (Q.front != Q.rear)     //队列非空\n        return Q.base[Q.front] //返回队头元素的值，队头指针不变\n&#125;\n</code></pre>\n<p><strong>循环队列的实现：</strong></p>\n<p>测试样例：QNode.txt<br>测试内容：<br>A<br>B<br>C<br>D</p>\n<pre><code class=\"c\">/***循环队列基本操作***/\n\n#include&lt;iostream&gt;\n#include&lt;fstream&gt;\nusing namespace std;\n\n#define MAXQSIZE 100\n#define OK 1\n#define ERROR 0\n#define OVERFLOW -2\ntypedef char QElemType;\ntypedef char SElemType;\ntypedef int Status;\n\ntypedef struct &#123;\n    QElemType *base;//初始化时动态分配存储空间\n    int front;//头指针\n    int rear;//尾指针\n&#125; SqQueue;\n\n//循环队列的初始化\nStatus InitQueue(SqQueue &amp;Q) &#123;//构造一个空队列Q\n    Q.base = new QElemType[MAXQSIZE]; //为队列分配一个最大容量为MAXSIZE的数组空间\n    if (!Q.base)\n        exit(OVERFLOW); //存储分配失败\n    Q.front = Q.rear = 0; //头指针和尾指针置为零，队列为空\n    return OK;\n&#125;\n\n//求循环队列的长度\nint QueueLength(SqQueue Q) &#123;//返回Q的元素个数，即队列的长度\n    return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;\n&#125;\n\n//循环队列的入队\nStatus EnQueue(SqQueue &amp;Q, QElemType e) &#123;//插入元素e为Q的新的队尾元素\n    if ((Q.rear + 1) % MAXQSIZE == Q.front) //尾指针在循环意义上加1后等于头指针，表明队满\n        return ERROR;\n    Q.base[Q.rear] = e; //新元素插入队尾\n    Q.rear = (Q.rear + 1) % MAXQSIZE; //队尾指针加1\n    return OK;\n&#125;\n\n//循环队列的出队\nStatus DeQueue(SqQueue &amp;Q, QElemType &amp;e) &#123;//删除Q的队头元素，用e返回其值\n    if (Q.front == Q.rear)\n        return ERROR; //队空\n    e = Q.base[Q.front]; //保存队头元素\n    Q.front = (Q.front + 1) % MAXQSIZE; //队头指针加1\n    return OK;\n&#125;\n\n//取循环队列的队头元素\nSElemType GetHead(SqQueue Q) &#123;//返回Q的队头元素，不修改队头指针\n    if (Q.front != Q.rear) //队列非空\n        return Q.base[Q.front]; //返回队头元素的值，队头指针不变\n&#125;\n\nint main() &#123;\n    int choose, flag = 0;\n    SqQueue Q;\n    QElemType e, j;\n    cout &lt;&lt; &quot;1.初始化\\n&quot;;\n    cout &lt;&lt; &quot;2.入队\\n&quot;;\n    cout &lt;&lt; &quot;3.读队头元素\\n&quot;;\n    cout &lt;&lt; &quot;4.出队\\n&quot;;\n    cout &lt;&lt; &quot;0.退出\\n\\n&quot;;\n\n    choose = -1;\n    while (choose != 0) &#123;\n        cout &lt;&lt; &quot;请选择:&quot;;\n        cin &gt;&gt; choose;\n        switch (choose) &#123;\n        case 1://链队的初始化\n            if (InitQueue(Q)) &#123;\n                flag = 1;\n                cout &lt;&lt; &quot;成功对队列进行初始化\\n\\n&quot;;\n            &#125; else\n                cout &lt;&lt; &quot;初始化队列失败\\n\\n&quot;;\n            break;\n        case 2: &#123;//链队的入队\n            fstream file;\n            file.open(&quot;QNode.txt&quot;);\n            if (!file) &#123;\n                cout &lt;&lt; &quot;错误！未找到文件！\\n\\n&quot; &lt;&lt; endl;\n                exit(ERROR);\n            &#125;\n            if (flag) &#123;\n                flag = 1;\n                cout &lt;&lt; &quot;入队的元素依次为：\\n&quot;;\n                while (!file.eof()) &#123;\n                    file &gt;&gt; j;\n                    if (file.fail())\n                        break;\n                    else &#123;\n                        EnQueue(Q, j);\n                        cout &lt;&lt; j &lt;&lt; &quot;  &quot;;\n                    &#125;\n                &#125;\n                cout &lt;&lt; endl &lt;&lt; endl;\n            &#125; else\n                cout &lt;&lt; &quot;队列未建立，请重新选择\\n\\n&quot;;\n            file.close();\n        &#125;\n            break;\n        case 3://取链队的队头元素\n            if (flag != -1 &amp;&amp; flag != 0)\n                cout &lt;&lt; &quot;队头元素为：\\n&quot; &lt;&lt; GetHead(Q) &lt;&lt; endl &lt;&lt; endl;\n            else\n                cout &lt;&lt; &quot;队列中无元素，请重新选择\\n&quot; &lt;&lt; endl;\n            break;\n        case 4://链队的出队\n            cout &lt;&lt; &quot;依次弹出的队头元素为:\\n&quot;;\n            while (DeQueue(Q, e)) &#123;\n                flag = -1;\n                cout &lt;&lt; e &lt;&lt; &quot;  &quot;;\n            &#125;\n            cout &lt;&lt; endl &lt;&lt; endl;\n            break;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<h2 id=\"③-队列的链式表示和实现\"><a href=\"#③-队列的链式表示和实现\" class=\"headerlink\" title=\"③.队列的链式表示和实现\"></a>③.队列的链式表示和实现</h2><p>链队是指采用链式存储结构实现的队列。通常链队用单链表来表示，一个链队显然需要两个分别指示队头和队尾的指针(分别称为头指针和尾指针)才能唯一确定。这里和线性表的单链表一样，为了操作方便起见，给链队添加一个头结点，并令头指针始终指向头结点。<br><img src=\"https://img-blog.csdnimg.cn/401c8ebbf86743efae5ebab7fc851053.png#pic_center\"></p>\n<pre><code class=\"c\">typedef struct Qnode\n&#123;\n    QElemType data;\n    struct Qnode *next;\n&#125; Qnode, *QueuePtr;\ntypedef struct\n&#123;\n    QueuePtr front; //队头指针\n    QueuePtr rear;  //队尾指针\n&#125; LinkQueue;\n</code></pre>\n<p><strong>链队的初始化</strong></p>\n<ol>\n<li>生成新结点作为头结点，队头和队尾指针指向此结点。</li>\n<li>头结点的指针域置空。</li>\n</ol>\n<pre><code class=\"c\">Status InitQueue(LinkQueue &amp;Q)\n&#123;\n    Q.front = Q.rear = new QNode;\n    Q.front-&gt;next = NULL;\n    return OK;\n&#125;\n</code></pre>\n<p><strong>链队的入队</strong></p>\n<ol>\n<li>为入队元素分配结点空间，用指针p指向。</li>\n<li>将新结点数据域置为e。</li>\n<li>将新结点插入到队尾。</li>\n<li>修改队尾指针为p。</li>\n</ol>\n<pre><code class=\"c\">Status EnQueue(LinkQueue &amp;Q, QElemType e)\n&#123;\n    p = new QNode;\n    if (!p)\n        exit(OVERFLOW);\n    p-&gt;data = e;\n    p-&gt;next = NULL;\n    Q.rear-&gt;next = p;\n    Q.rear = p;\n    return OK;\n&#125;\n</code></pre>\n<p><strong>链队的出队</strong></p>\n<ol>\n<li>判断队列是否为空，若空则返回ERROR。</li>\n<li>临时保存队头元素的空间，以备释放。</li>\n<li>修改队头指针，指向下一个结点。</li>\n<li>判断出队元素是否为最后一个元素，若是，则将队尾指针重新赋值，指向头结点。</li>\n<li>释放原队头元素的空间。</li>\n</ol>\n<pre><code class=\"c\">Status DeQueue(LinkQueue &amp;Q，QElemType &amp;e)\n&#123;\n    if (Q.front == Q.rear)\n        return ERROR;        //若队列空，则返回ERROR\n    p = Q.front-&gt;next;       // p指向队头元素\n    e = p-&gt;data;             // e保存队头元素的值\n    Q.front-&gt;next = p-&gt;next; //修改头指针\n    if (Q.rear == p)\n        Q.rear = Q.front; //如果最后一个元素被删，则\n                          //队尾指针指向头结点\n    delete p;             //释放原队头元素的空间\n    return OK;\n&#125;\n</code></pre>\n<p><strong>取链队的队头元素</strong></p>\n<p>与循环队列一样，当队列非空时，此操作返回当前队头元素的值，队头指针保持不变。</p>\n<pre><code class=\"c\">SElemType GetHead(LinkQueue Q)\n&#123;\n    if (Q.front != Q.rear)\n        return Q.front-&gt;next-&gt;data; //返回队头元素的值，队头指针不变\n&#125;\n</code></pre>\n<p><strong>链队的实现：</strong></p>\n<p>测试样例：QNode.txt<br>测试内容：<br>A<br>B<br>C<br>D</p>\n<pre><code class=\"c\">/***链队的基本操作***/\n\n#include&lt;iostream&gt;\n#include&lt;fstream&gt;\nusing namespace std;\n\n#define OK 1\n#define ERROR 0\n#define OVERFLOW -2\ntypedef char QElemType;\ntypedef int Status;\ntypedef char SElemType;\n\n//- - - - - 队列的链式存储结构- - - - - \ntypedef struct QNode &#123;\n    QElemType data;\n    struct QNode *next;\n&#125; QNode, *QueuePtr;\ntypedef struct &#123;\n    QueuePtr front; //队头指针\n    QueuePtr rear; //队尾指针\n&#125; LinkQueue;\n\n//链队的初始化\nStatus InitQueue(LinkQueue &amp;Q) &#123;//构造一个空队列Q\n    Q.front = Q.rear = new QNode; //生成新结点作为头结点，队头和队尾指针指向此结点\n    Q.front-&gt;next = NULL; //头结点的指针域置空\n    return OK;\n&#125;\n\n//链队的入队\nStatus EnQueue(LinkQueue &amp;Q, QElemType e) &#123;//插入元素e为Q的新的队尾元素\n    QueuePtr p;\n    p = new QNode; //为入队元素分配结点空间，用指针p指向\n    p-&gt;data = e; //将新结点数据域置为e\n    p-&gt;next = NULL;\n    Q.rear-&gt;next = p; //将新结点插入到队尾\n    Q.rear = p; //修改队尾指针\n    return OK;\n&#125;\n\n//链队的出队\nStatus DeQueue(LinkQueue &amp;Q, QElemType &amp;e) &#123;//删除Q的队头元素，用e返回其值 \n    QueuePtr p;\n    if (Q.front == Q.rear)\n        return ERROR; //若队列空，则返回ERROR\n    p = Q.front-&gt;next; //p指向队头元素\n    e = p-&gt;data; //e保存队头元素的值\n    Q.front-&gt;next = p-&gt;next; //修改头指针\n    if (Q.rear == p)\n        Q.rear = Q.front; //最后一个元素被删，队尾指针指向头结点\n    delete p; //释放原队头元素的空间\n    return OK;\n&#125;\n\n//取链队的队头元素\nSElemType GetHead(LinkQueue Q) &#123;//返回Q的队头元素，不修改队头指针\n    if (Q.front != Q.rear) //队列非空\n        return Q.front-&gt;next-&gt;data; //返回队头元素的值，队头指针不变\n&#125;\n\nint main() &#123;\n    int choose, flag = 0;\n    LinkQueue Q;\n    QElemType e, j;\n    cout &lt;&lt; &quot;1.初始化\\n&quot;;\n    cout &lt;&lt; &quot;2.入队\\n&quot;;\n    cout &lt;&lt; &quot;3.读队头元素\\n&quot;;\n    cout &lt;&lt; &quot;4.出队\\n&quot;;\n    cout &lt;&lt; &quot;0.退出\\n\\n&quot;;\n\n    choose = -1;\n    while (choose != 0) &#123;\n        cout &lt;&lt; &quot;请选择:&quot;;\n        cin &gt;&gt; choose;\n        switch (choose) &#123;\n        case 1://链队的初始化\n            if (InitQueue(Q)) &#123;\n                flag = 1;\n                cout &lt;&lt; &quot;成功对队列进行初始化\\n\\n&quot;;\n            &#125; else\n                cout &lt;&lt; &quot;初始化队列失败\\n\\n&quot;;\n            break;\n        case 2: &#123;//链队的入队\n            fstream file;\n            file.open(&quot;QNode.txt&quot;);\n            if (!file) &#123;\n                cout &lt;&lt; &quot;错误！未找到文件！\\n\\n&quot; &lt;&lt; endl;\n                exit(ERROR);\n            &#125;\n            if (flag) &#123;\n                flag = 1;\n                cout &lt;&lt; &quot;入队的元素依次为：\\n&quot;;\n                while (!file.eof()) &#123;\n                    file &gt;&gt; j;\n                    if (file.fail())\n                        break;\n                    else &#123;\n                        EnQueue(Q, j);\n                        cout &lt;&lt; j &lt;&lt; &quot;  &quot;;\n                    &#125;\n                &#125;\n                cout &lt;&lt; endl &lt;&lt; endl;\n            &#125; else\n                cout &lt;&lt; &quot;队列未建立，请重新选择\\n\\n&quot;;\n            file.close();\n        &#125;\n            break;\n        case 3://取链队的队头元素\n            if (flag != -1 &amp;&amp; flag != 0)\n                cout &lt;&lt; &quot;队头元素为：\\n&quot; &lt;&lt; GetHead(Q) &lt;&lt; endl &lt;&lt; endl;\n            else\n                cout &lt;&lt; &quot;队列中无元素，请重新选择\\n&quot; &lt;&lt; endl;\n            break;\n        case 4://链队的出队\n            cout &lt;&lt; &quot;依次弹出的队头元素为:\\n&quot;;\n            while (DeQueue(Q, e)) &#123;\n                flag = -1;\n                cout &lt;&lt; e &lt;&lt; &quot;  &quot;;\n            &#125;\n            cout &lt;&lt; endl &lt;&lt; endl;\n            break;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<hr>\n<h1 id=\"4、栈和队列总结\"><a href=\"#4、栈和队列总结\" class=\"headerlink\" title=\"4、栈和队列总结\"></a>4、栈和队列总结</h1><p><img src=\"https://img-blog.csdnimg.cn/e827aced3ec94811b9223dd38ef8b4d6.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/1c31bbfa697c40fa8884caf47e25350b.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/fdfdef451f0541dd8682a16a33d4a5b5.png#pic_center\"></p>\n<hr>\n<h1 id=\"5、例题与应用\"><a href=\"#5、例题与应用\" class=\"headerlink\" title=\"5、例题与应用\"></a>5、例题与应用</h1><p><img src=\"https://img-blog.csdnimg.cn/7774498e7df246398c63bbc0a1089213.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/7d62ae6cf53a45089bd0ff5281f0f7c6.png#pic_center\"></p>\n<ol>\n<li>编程实现栈的如下功能：<br>（1）根据输入的栈中元素个数n和各元素值建立一个顺序栈，并输出栈中各元素值。<br>（2）将数据元素e入栈，并输出入栈后的顺序栈中各元素值。<br>（3）将顺序栈中的栈顶元素出栈，并输出出栈元素的值和出栈后顺序栈中各元素值。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/8cbfebb988fa4703ac0d29f2fc2591c7.png#pic_center\"><br><img src=\"https://img-blog.csdnimg.cn/b418384d10d04a248bf2b2a17c4e5152.png#pic_center\"></p>\n<pre><code class=\"c\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define OK 1\n#define ERROR 0\n#define MAXSIZE 100\ntypedef int Status;\ntypedef int SElemType;\n//顺序栈定义\ntypedef struct\n&#123;\n    SElemType *base;\n    SElemType *top;\n    int stacksize;\n&#125; SqStack;\n//顺序栈的初始化\nStatus InitStack(SqStack &amp;S)\n&#123;\n    S.base = new SElemType[MAXSIZE];\n    if (!S.base)\n        exit(OVERFLOW);\n    S.top = S.base;        //top初始为base，空栈\n    S.stacksize = MAXSIZE; //stacksize置为栈的最大容量MAXSIZE\n    return OK;\n&#125;\n//顺序栈的遍历\nStatus StackTraverse(SqStack S)\n&#123;\n    cout &lt;&lt; &quot;顺序栈中元素如下：\\n&quot;;\n    if (S.top == S.base)\n    &#123;\n        return false;\n    &#125;\n    while (S.top != S.base)\n    &#123;\n        cout &lt;&lt; *S.base++ &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n    return OK;\n&#125;\n//顺序栈的入栈\nStatus Push(SqStack &amp;S, SElemType e)\n&#123;\n    if (S.top - S.base == S.stacksize)\n        return ERROR;\n    *(S.top++) = e; //元素e压入栈顶，栈顶指针加1\n    return OK;\n&#125;\n//顺序栈的出栈\nStatus Pop(SqStack &amp;S, SElemType &amp;e)\n&#123;\n    if (S.base == S.top)\n        return ERROR;\n    e = *(--S.top); //栈顶指针减1，将栈顶元素赋给e\n    return OK;\n&#125;\nint main()\n&#123;\n    SqStack s;\n    int select, flag = 0, i, j, n, e, t;\n\n    cout &lt;&lt; &quot;1.初始化顺序栈\\n&quot;;\n    cout &lt;&lt; &quot;2.顺序栈的入栈\\n&quot;;\n    cout &lt;&lt; &quot;3.取出栈顶元素\\n&quot;;\n    cout &lt;&lt; &quot;4.顺序栈的出栈\\n&quot;;\n    cout &lt;&lt; &quot;0.退出\\n\\n&quot;;\n\n    while (1)\n    &#123;\n        cout &lt;&lt; &quot;\\n请选择:&quot;;\n        cin &gt;&gt; select;\n        switch (select)\n        &#123;\n        case 1:\n            if (InitStack(s))\n            &#123;\n                flag = 1;\n                cout &lt;&lt; &quot;初始化栈成功\\n\\n&quot;;\n            &#125;\n            else\n            &#123;\n                cout &lt;&lt; &quot;初始化栈失败\\n\\n&quot;;\n            &#125;\n            StackTraverse(s);\n            break;\n        case 2:\n            cout &lt;&lt; &quot;请输入元素个数：&quot;;\n            cin &gt;&gt; n;\n            cout &lt;&lt; &quot;请输入&quot; &lt;&lt; n &lt;&lt; &quot;个元素：&quot;;\n            for (j = 1; j &lt;= n; ++j)\n            &#123;\n                cin &gt;&gt; i;\n                if (Push(s, i))\n                &#123;\n                    flag = 1;\n                &#125;\n            &#125;\n            if (flag = 1)\n            &#123;\n                cout &lt;&lt; &quot;入栈操作成功！\\n\\n&quot;;\n            &#125;\n            StackTraverse(s);\n            break;\n        case 3:\n            cout &lt;&lt; &quot;取出的栈顶元素为：\\n&quot;;\n            if (Pop(s, t))\n            &#123;\n                cout &lt;&lt; t &lt;&lt; endl;\n            &#125;\n            StackTraverse(s);\n            break;\n        case 4:\n            cout &lt;&lt; &quot;依次弹出的栈顶元素为:\\n&quot;;\n            while (Pop(s, t))\n            &#123;\n                flag = -1;\n                cout &lt;&lt; t &lt;&lt; &quot;  &quot;;\n            &#125;\n            cout &lt;&lt; endl\n                 &lt;&lt; endl;\n            StackTraverse(s);\n            break;\n        case 0:\n            return 0;\n        default:\n            cout &lt;&lt; &quot;请重新输入！\\n\\n&quot;;\n            break;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<ol start=\"2\">\n<li>编程实现队列的如下功能：<br>（1）根据输入的队列长度n和各元素值建立一个循环顺序表表示的队列（循环队列），并输出队列中各元素值。<br>（2）将数据元素e入队，并输出入队后的队列中各元素值。<br>（3）将循环队列的队首元素出队，并输出出队元素的值和出队后队列中各元素值</li>\n</ol>\n<pre><code class=\"c\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define OK 1\n#define ERROR 0\n#define MAXQSIZE 100\ntypedef int QElemType;\ntypedef int SElemType;\ntypedef int Status;\n//顺序队列定义\ntypedef struct\n&#123;\n    QElemType *base;\n    int front;\n    int rear;\n&#125; SqQueue;\n//循环队列的初始化\nStatus InitQueue(SqQueue &amp;Q)\n&#123;\n    Q.base = new QElemType[MAXQSIZE];\n    if (!Q.base)\n        exit(OVERFLOW);\n    Q.front = Q.rear = 0; //头指针和尾指针置为零，队列为空\n    return OK;\n&#125;\n//顺序队列遍历队列\nStatus TarverseQueue(SqQueue Q)\n&#123;\n    int cur = Q.front;\n    cout &lt;&lt; &quot;顺序队列中元素如下：\\n&quot;;\n    while (cur != Q.rear)\n    &#123;\n        cout &lt;&lt; Q.base[cur] &lt;&lt; &quot; &quot;;\n        cur = (cur + 1) % MAXQSIZE; // 当前指针向后推移\n    &#125;\n    cout &lt;&lt; endl;\n    return OK;\n&#125;\n//求循环队列的长度\nint QueueLength(SqQueue Q)\n&#123;\n    return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;\n&#125;\n//循环队列的入队\nStatus EnQueue(SqQueue &amp;Q, QElemType e)\n&#123;\n    if ((Q.rear + 1) % MAXQSIZE == Q.front)\n        return ERROR;\n    Q.base[Q.rear] = e;               //新元素插入队尾\n    Q.rear = (Q.rear + 1) % MAXQSIZE; //队尾指针加1\n    return OK;\n&#125;\n//循环队列的出队\nStatus DeQueue(SqQueue &amp;Q, QElemType &amp;e)\n&#123;\n    if (Q.front == Q.rear)\n        return ERROR;\n    e = Q.base[Q.front];                //保存队头元素\n    Q.front = (Q.front + 1) % MAXQSIZE; //队头指针加1\n    return OK;\n&#125;\nint main()\n&#123;\n    SqQueue Q;\n    int select, flag = 0, i, n, j, e;\n    cout &lt;&lt; &quot;1.初始化顺序队列\\n&quot;;\n    cout &lt;&lt; &quot;2.顺序队列的入队\\n&quot;;\n    cout &lt;&lt; &quot;3.取出队头的元素\\n&quot;;\n    cout &lt;&lt; &quot;4.顺序队列的出队\\n&quot;;\n    cout &lt;&lt; &quot;0.退出\\n\\n&quot;;\n\n    while (1)\n    &#123;\n        cout &lt;&lt; &quot;\\n请选择:&quot;;\n        cin &gt;&gt; select;\n        switch (select)\n        &#123;\n        case 1: //链队的初始化\n            if (InitQueue(Q))\n            &#123;\n                flag = 1;\n                cout &lt;&lt; &quot;初始化对列成功\\n\\n&quot;;\n            &#125;\n            else\n                cout &lt;&lt; &quot;初始化队列失败\\n\\n&quot;;\n            TarverseQueue(Q);\n            break;\n        case 2:\n            cout &lt;&lt; &quot;请输入元素个数：&quot;;\n            cin &gt;&gt; n;\n            cout &lt;&lt; &quot;请输入&quot; &lt;&lt; n &lt;&lt; &quot;个元素：&quot;;\n            for (j = 1; j &lt;= n; j++)\n            &#123;\n                cin &gt;&gt; i;\n                if (EnQueue(Q, i))\n                &#123;\n                    flag = 1;\n                &#125;\n            &#125;\n            if (flag = 1)\n            &#123;\n                cout &lt;&lt; &quot;入队操作成功！\\n\\n&quot;;\n            &#125;\n            TarverseQueue(Q);\n            break;\n        case 3: //取出链队的队头元素\n            cout &lt;&lt; &quot;取出的队头元素为：\\n&quot;;\n            if (DeQueue(Q, e))\n            &#123;\n                cout &lt;&lt; e &lt;&lt; endl;\n            &#125;\n            TarverseQueue(Q);\n            break;\n        case 4: //链队的出队\n            cout &lt;&lt; &quot;依次弹出的队头元素为:\\n&quot;;\n            while (DeQueue(Q, e))\n            &#123;\n                flag = -1;\n                cout &lt;&lt; e &lt;&lt; &quot;  &quot;;\n            &#125;\n            cout &lt;&lt; endl\n                 &lt;&lt; endl;\n            TarverseQueue(Q);\n            break;\n        case 0:\n            return 0;\n        default:\n            cout &lt;&lt; &quot;请重新输入！\\n\\n&quot;;\n            break;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n","feature":true,"text":"栈( stack）是限定仅在表尾进行插人或删除操作的线性表。因此，对栈来说，表尾端有其特殊含义，称为栈顶( top )，相应地，表头端称为栈底（ bottom )。不含元素的空表称为空栈。...","permalink":"/post/数据结构（C语言版）-- 栈和队列笔记","photos":[],"count_time":{"symbolsCount":"28k","symbolsTime":"25 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"字节跳动青训营","slug":"字节跳动青训营","count":21,"path":"api/tags/字节跳动青训营.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">1、栈和队列的定义和特点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">①.栈的定义和特点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">②.队列的定义和特点</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2%E3%80%81%E6%A0%88%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">2、栈的表示和操作的实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E6%A0%88%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">①.栈的类型定义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">②.顺序栈的表示和实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E9%93%BE%E6%A0%88%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">②.链栈的表示和实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A3-%E6%A0%88%E4%B8%8E%E9%80%92%E5%BD%92\"><span class=\"toc-text\">④.栈与递归</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A4-%E6%80%9D%E8%80%83\"><span class=\"toc-text\">⑤.思考</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3%E3%80%81%E9%98%9F%E5%88%97%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">3、队列的表示和操作的实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E9%98%9F%E5%88%97%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">①.队列的类型定义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">②.队列的顺序表示和实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%91%A2-%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">③.队列的链式表示和实现</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">4、栈和队列总结</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5%E3%80%81%E4%BE%8B%E9%A2%98%E4%B8%8E%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">5、例题与应用</span></a></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"串、数组和广义表","uid":"1d7c86a35a2f9ff3da1b325afe7a5b86","slug":"数据结构（C语言版）-- 串、数组和广义表笔记","date":"2022-02-16T04:53:52.000Z","updated":"2025-07-14T15:12:20.468Z","comments":true,"path":"api/articles/数据结构（C语言版）-- 串、数组和广义表笔记.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/e0c03943274e4aef94cf846304d75a73.png","text":"串(String)----零个或多个字符组成的有限序列，是一种特殊的线性表，其数据元素为一个字符，即内容受限的线性表。数组是由类型相同的数据元素构成的有序集合，每个元素称为数组元素。广义表：n ( ≥0)个表元素组成的有限序列。...","permalink":"/post/数据结构（C语言版）-- 串、数组和广义表笔记","photos":[],"count_time":{"symbolsCount":"9.7k","symbolsTime":"9 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"字节跳动青训营","slug":"字节跳动青训营","count":21,"path":"api/tags/字节跳动青训营.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true},"next_post":{"title":"线性表","uid":"b96df039eaa03d2a5634c2cc83e5cad0","slug":"数据结构（C语言版）-- 线性表笔记","date":"2022-02-10T01:41:07.000Z","updated":"2025-07-14T15:12:20.469Z","comments":true,"path":"api/articles/数据结构（C语言版）-- 线性表笔记.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/cc67f280b3744197a9dfe94df485796b.png","text":"线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素，这种表示也称作线性表的顺序存储结构或顺序映像。线性表链式存储结构的特点：用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。...","permalink":"/post/数据结构（C语言版）-- 线性表笔记","photos":[],"count_time":{"symbolsCount":"26k","symbolsTime":"24 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"字节跳动青训营","slug":"字节跳动青训营","count":21,"path":"api/tags/字节跳动青训营.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true}}