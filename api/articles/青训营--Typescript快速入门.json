{"title":"Typescript快速入门","uid":"fc3331da72f382869606f6a944c6cf7d","slug":"青训营--Typescript快速入门","date":"2022-02-05T10:40:59.000Z","updated":"2025-07-14T15:12:20.471Z","comments":true,"path":"api/articles/青训营--Typescript快速入门.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/3112c385d3c845d4b0305beebbc3ffdf.jpeg","content":"<h1 id=\"第一章-快速入门\"><a href=\"#第一章-快速入门\" class=\"headerlink\" title=\"第一章 快速入门\"></a>第一章 快速入门</h1><h2 id=\"0、TypeScript简介\"><a href=\"#0、TypeScript简介\" class=\"headerlink\" title=\"0、TypeScript简介\"></a>0、TypeScript简介</h2><ol>\n<li><strong>TypeScript是JavaScript的超集。</strong></li>\n<li>它对JS进行了扩展，向JS中引入了类型的概念，并添加了许多新的特性。</li>\n<li><strong>TS代码需要通过编译器编译为JS</strong>，然后再交由JS解析器执行。</li>\n<li><strong>TS完全兼容JS</strong>，换言之，任何的JS代码都可以直接当成JS使用。</li>\n<li>相较于JS而言，TS拥有了静态类型，更加严格的语法，更强大的功能；TS可以在代码执行前就完成代码的检查，减小了运行时异常的出现的几率；TS代码可以编译为任意版本的JS代码，可有效解决不同JS运行环境的兼容问题；同样的功能，TS的代码量要大于JS，但由于TS的代码结构更加清晰，变量类型更加明确，在后期代码的维护中TS却远远胜于JS。</li>\n</ol>\n<h2 id=\"1、TypeScript-开发环境搭建\"><a href=\"#1、TypeScript-开发环境搭建\" class=\"headerlink\" title=\"1、TypeScript 开发环境搭建\"></a>1、TypeScript 开发环境搭建</h2><ol>\n<li><p>下载Node.js</p>\n<ul>\n<li>64位：<a href=\"https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi\">https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi</a></li>\n<li>32位：<a href=\"https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi\">https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi</a></li>\n</ul>\n</li>\n<li><p>安装Node.js</p>\n</li>\n<li><p>使用npm全局安装typescript</p>\n<ul>\n<li>进入命令行</li>\n<li>输入：npm i -g typescript</li>\n</ul>\n</li>\n<li><p>创建一个ts文件</p>\n</li>\n<li><p>使用tsc对ts文件进行编译</p>\n<ul>\n<li><p>进入命令行</p>\n</li>\n<li><p>进入ts文件所在目录</p>\n</li>\n<li><p>执行命令：tsc xxx.ts</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2、基本类型\"><a href=\"#2、基本类型\" class=\"headerlink\" title=\"2、基本类型\"></a>2、基本类型</h2><ul>\n<li><p>类型声明</p>\n<ul>\n<li><p>类型声明是TS非常重要的一个特点</p>\n</li>\n<li><p>通过类型声明可以指定TS中变量（参数、形参）的类型</p>\n</li>\n<li><p>指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错</p>\n</li>\n<li><p>简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值</p>\n</li>\n<li><p>语法：</p>\n<pre><code class=\"typescript\">  let 变量: 类型;\n  let a: number;\n  \n  let 变量: 类型 = 值;\n  let a: number = 10;\n  \n  function fn(参数: 类型, 参数: 类型): 类型&#123;\n      ...\n  &#125;\n   function sum(a: number, b: number): number &#123;\n      return a + b;\n  &#125;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p><strong>自动类型判断</strong></p>\n<ul>\n<li>TS拥有自动的类型判断机制</li>\n<li>当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型</li>\n<li>所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明</li>\n</ul>\n</li>\n<li><p>类型：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">类型</th>\n<th align=\"center\">例子</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">number</td>\n<td align=\"center\">1, -33, 2.5</td>\n<td align=\"center\">任意数字</td>\n</tr>\n<tr>\n<td align=\"center\">string</td>\n<td align=\"center\">‘hi’, “hi”, <code>hi</code></td>\n<td align=\"center\">任意字符串</td>\n</tr>\n<tr>\n<td align=\"center\">boolean</td>\n<td align=\"center\">true、false</td>\n<td align=\"center\">布尔值true或false</td>\n</tr>\n<tr>\n<td align=\"center\">字面量</td>\n<td align=\"center\">其本身</td>\n<td align=\"center\">限制变量的值就是该字面量的值</td>\n</tr>\n<tr>\n<td align=\"center\">any</td>\n<td align=\"center\">*</td>\n<td align=\"center\">任意类型</td>\n</tr>\n<tr>\n<td align=\"center\">unknown</td>\n<td align=\"center\">*</td>\n<td align=\"center\">类型安全的any</td>\n</tr>\n<tr>\n<td align=\"center\">void</td>\n<td align=\"center\">空值（undefined）</td>\n<td align=\"center\">没有值（或undefined）</td>\n</tr>\n<tr>\n<td align=\"center\">never</td>\n<td align=\"center\">没有值</td>\n<td align=\"center\">不能是任何值</td>\n</tr>\n<tr>\n<td align=\"center\">object</td>\n<td align=\"center\">{name:’孙悟空’}</td>\n<td align=\"center\">任意的JS对象</td>\n</tr>\n<tr>\n<td align=\"center\">array</td>\n<td align=\"center\">[1,2,3]</td>\n<td align=\"center\">任意JS数组</td>\n</tr>\n<tr>\n<td align=\"center\">tuple</td>\n<td align=\"center\">[4,5]</td>\n<td align=\"center\">元素，TS新增类型，固定长度数组</td>\n</tr>\n<tr>\n<td align=\"center\">enum</td>\n<td align=\"center\">enum{A, B}</td>\n<td align=\"center\">枚举，TS中新增类型</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>number</p>\n</li>\n</ul>\n<pre><code class=\"typescript\">    let decimal: number = 6;\n    let hex: number = 0xf00d;\n    let binary: number = 0b1010;\n    let octal: number = 0o744;\n    let big: bigint = 100n;\n</code></pre>\n<ul>\n<li><p>boolean</p>\n<pre><code class=\"typescript\">let isDone: boolean = false;\n</code></pre>\n</li>\n<li><p>string</p>\n<pre><code class=\"typescript\">let color: string = &quot;blue&quot;;\ncolor = &#39;red&#39;;\n\nlet fullName: string = `Bob Bobbington`;\nlet age: number = 37;\nlet sentence: string = `Hello, my name is $&#123;fullName&#125;.\n\nI&#39;ll be $&#123;age + 1&#125; years old next month.`;\n</code></pre>\n</li>\n<li><p>字面量</p>\n<ul>\n<li><p>也可以使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围(<strong>类似于常量，限定值或范围</strong>)</p>\n<pre><code class=\"typescript\">let color: &#39;red&#39; | &#39;blue&#39; | &#39;black&#39;;\nlet num: 1 | 2 | 3 | 4 | 5;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>any</p>\n<ul>\n<li>相当于对该变量关闭了TS的类型检测</li>\n</ul>\n<pre><code class=\"typescript\">let d: any = 4;\nd = &#39;hello&#39;;\nd = true;\n//隐式\nlet e;\n</code></pre>\n</li>\n<li><p>unknown</p>\n<ul>\n<li>unknown类型的变量，不能直接赋值给其他变量</li>\n</ul>\n<pre><code class=\"typescript\">let notSure: unknown = 4;\nnotSure = &#39;hello&#39;;\n\n//类型检查\nlet s:string;\nif(typeof e === &quot;string&quot;)&#123;\n    s = e;\n&#125;\n\n//类型断言\n/*\n语法：\n变量 as 类型\n&lt;类型&gt;变量\n*/\ns = e as string;\n//s = &lt;string&gt;e;\n</code></pre>\n</li>\n<li><p>void</p>\n<pre><code class=\"typescript\">let unusable: void = undefined;\n\n//没写void，没写return，默认为void\nfunction fn(): void &#123;\n&#125;\n</code></pre>\n</li>\n<li><p>never</p>\n<ul>\n<li>表示永远不会返回结果</li>\n</ul>\n<pre><code class=\"typescript\">function error(message: string): never &#123;\n  throw new Error(message);\n&#125;\n</code></pre>\n</li>\n<li><p>object（没啥用）</p>\n<pre><code class=\"typescript\">let obj: object = &#123;&#125;;\n\n// &#123;&#125; 用来指定对象中可以包含哪些属性\n// 语法：&#123;属性名:属性值,属性名:属性值&#125;\n// 在属性名后边加上?，表示属性是可选的\nlet b: &#123; name: string, age?: number &#125;;\nb = &#123; name: &#39;孙悟空&#39;, age: 18 &#125;;\n\n//定义对象结构\n// [propName: string]: any 表示任意类型的属性\nlet c: &#123; name: string, [propName: string]: any &#125;;\nc = &#123; name: &#39;猪八戒&#39;, age: 18, gender: &#39;男&#39; &#125;;\n\n//定义函数结构\n/*\n  设置函数结构的类型声明：\n  语法：(形参:类型, 形参:类型 ...) =&gt; 返回值\n*/\nlet d: (a: number, b: number) =&gt; number;\n// d = function (n1: string, n2: string): number&#123;\n//     return 10;\n// &#125;\n</code></pre>\n</li>\n<li><p>array</p>\n<pre><code class=\"typescript\">//类型[]\nlet list: number[] = [1, 2, 3];\n\n//Array&lt;类型&gt;\nlet list: Array&lt;number&gt; = [1, 2, 3];\n</code></pre>\n</li>\n<li><p>tuple</p>\n<pre><code class=\"typescript\">let x: [string, number];\nx = [&quot;hello&quot;, 10]; \n</code></pre>\n</li>\n<li><p>enum</p>\n<pre><code class=\"typescript\">enum Color &#123;\n  Red,\n  Green,\n  Blue,\n&#125;\nlet c: Color = Color.Green;\n\nenum Color &#123;\n  Red = 1,\n  Green,\n  Blue,\n&#125;\nlet c: Color = Color.Green;\n\nenum Color &#123;\n  Red = 1,\n  Green = 2,\n  Blue = 4,\n&#125;\nlet c: Color = Color.Green;\n\n// &amp;表示同时\nlet j: &#123; name: string &#125; &amp; &#123; age: number &#125;;\n// j = &#123;name: &#39;孙悟空&#39;, age: 18&#125;;\n\n// 类型的别名\ntype myType = 1 | 2 | 3 | 4 | 5;\nlet k: myType;\nlet l: myType;\nlet m: myType;\n\nk = 2;\n</code></pre>\n</li>\n<li><p>类型断言</p>\n<ul>\n<li><p>有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：</p>\n<ul>\n<li><p>第一种</p>\n<pre><code class=\"typescript\">let someValue: unknown = &quot;this is a string&quot;;\nlet strLength: number = (someValue as string).length;\n</code></pre>\n</li>\n<li><p>第二种</p>\n<pre><code class=\"typescript\">let someValue: unknown = &quot;this is a string&quot;;\nlet strLength: number = (&lt;string&gt;someValue).length;\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3、编译选项\"><a href=\"#3、编译选项\" class=\"headerlink\" title=\"3、编译选项\"></a>3、编译选项</h2><ul>\n<li><p>自动编译文件</p>\n<ul>\n<li><p>编译文件时，使用 <code>-w </code> 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。</p>\n</li>\n<li><p>示例：</p>\n<pre><code class=\"powershell\">tsc xxx.ts -w\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>自动编译整个项目</p>\n<ul>\n<li><p>如果直接使用<code>tsc</code>指令，则可以自动将当前项目下的所有ts文件编译为js文件。</p>\n</li>\n<li><p>但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json(<code>tsc --init</code>)</p>\n</li>\n<li><p>tsconfig.json是一个JSON文件，添加配置文件后，只需只需<code> tsc</code> 命令即可完成对整个项目的编译<code>tsc -w</code>自动监视所有文件</p>\n</li>\n<li><p>配置选项：</p>\n<ul>\n<li><p><strong>include</strong></p>\n<ul>\n<li><p>定义希望被编译文件所在的目录</p>\n</li>\n<li><p>默认值：[“**&#x2F;*“]    (** 表示任意目录 *表示任意文件)</p>\n</li>\n<li><p>示例：</p>\n<pre><code class=\"json\">&quot;include&quot;:[&quot;src/**/*&quot;, &quot;tests/**/*&quot;]\n</code></pre>\n<ul>\n<li>上述示例中，所有src目录和tests目录下的文件都会被编译</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>exclude</strong></p>\n<ul>\n<li><p>定义需要排除在外的目录</p>\n</li>\n<li><p>默认值：[“node_modules”, “bower_components”, “jspm_packages”]</p>\n</li>\n<li><p>示例：</p>\n<pre><code class=\"json\">&quot;exclude&quot;: [&quot;./src/hello/**/*&quot;]\n</code></pre>\n<ul>\n<li>上述示例中，src下hello目录下的文件都不会被编译</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>extends</strong></p>\n<ul>\n<li><p>定义被继承的配置文件</p>\n</li>\n<li><p>示例：</p>\n<pre><code class=\"json\">&quot;extends&quot;: &quot;./configs/base&quot;\n</code></pre>\n<ul>\n<li>上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>files</strong></p>\n<ul>\n<li><p>指定被编译文件的列表，只有需要编译的<strong>文件少时才会用到</strong></p>\n</li>\n<li><p>示例：</p>\n<pre><code class=\"json\">&quot;files&quot;: [\n    &quot;core.ts&quot;,\n    &quot;sys.ts&quot;,\n    &quot;types.ts&quot;,\n    &quot;scanner.ts&quot;,\n    &quot;parser.ts&quot;,\n    &quot;utilities.ts&quot;,\n    &quot;binder.ts&quot;,\n    &quot;checker.ts&quot;,\n    &quot;tsc.ts&quot;\n  ]\n</code></pre>\n<ul>\n<li>列表中的文件都会被TS编译器所编译</li>\n</ul>\n</li>\n<li><p><strong>compilerOptions</strong></p>\n<ul>\n<li><p>编译选项是配置文件中非常重要也比较复杂的配置选项</p>\n</li>\n<li><p>在compilerOptions中包含多个子选项，用来完成对编译的配置</p>\n<ul>\n<li><p>项目选项</p>\n<ul>\n<li><p><strong>target</strong></p>\n<ul>\n<li><p>设置ts代码编译的目标版本</p>\n</li>\n<li><p>可选值：</p>\n<ul>\n<li>ES3（默认）、ES5、ES6&#x2F;ES2015、ES7&#x2F;ES2016、ES2017、ES2018、ES2019、ES2020、ESNext(ES最新版本)</li>\n</ul>\n</li>\n<li><p>示例：</p>\n<pre><code class=\"json\">&quot;compilerOptions&quot;: &#123;\n    &quot;target&quot;: &quot;ES6&quot;\n&#125;\n</code></pre>\n<ul>\n<li>如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>lib</strong></p>\n<ul>\n<li><p>指定代码运行时所包含的库（宿主环境）</p>\n</li>\n<li><p>可选值：</p>\n<ul>\n<li>ES5、ES6&#x2F;ES2015、ES7&#x2F;ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ……</li>\n</ul>\n</li>\n<li><p>示例：</p>\n<pre><code class=\"json\">&quot;compilerOptions&quot;: &#123;\n    &quot;target&quot;: &quot;ES6&quot;,\n    &quot;lib&quot;: [&quot;ES6&quot;, &quot;DOM&quot;],\n    &quot;outDir&quot;: &quot;dist&quot;,\n    &quot;outFile&quot;: &quot;dist/aa.js&quot;\n&#125;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p><strong>module</strong></p>\n<ul>\n<li><p>设置编译后代码使用的模块化系统</p>\n</li>\n<li><p>可选值：</p>\n<ul>\n<li>CommonJS、UMD、AMD、System、ES2020、ESNext、None</li>\n</ul>\n</li>\n<li><p>示例：</p>\n<pre><code class=\"typescript\">&quot;compilerOptions&quot;: &#123;\n    &quot;module&quot;: &quot;CommonJS&quot;\n&#125;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p><strong>outDir</strong></p>\n<ul>\n<li><p>编译后文件的所在目录</p>\n</li>\n<li><p>默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置</p>\n</li>\n<li><p>示例：</p>\n<pre><code class=\"json\">&quot;compilerOptions&quot;: &#123;\n    &quot;outDir&quot;: &quot;dist&quot;\n&#125;\n</code></pre>\n<ul>\n<li>设置后编译后的js文件将会生成到dist目录</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>outFile</strong></p>\n<ul>\n<li><p>将所有的文件编译为一个js文件</p>\n</li>\n<li><p>默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中</p>\n</li>\n<li><p>示例：</p>\n<pre><code class=\"json\">&quot;compilerOptions&quot;: &#123;\n    &quot;outFile&quot;: &quot;dist/app.js&quot;\n&#125;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p><strong>rootDir</strong></p>\n<ul>\n<li><p>指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录</p>\n</li>\n<li><p>示例：</p>\n<pre><code class=\"json\">&quot;compilerOptions&quot;: &#123;\n    &quot;rootDir&quot;: &quot;./src&quot;\n&#125;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p><strong>allowJs</strong></p>\n<ul>\n<li>是否对js文件编译</li>\n</ul>\n</li>\n<li><p><strong>checkJs</strong></p>\n<ul>\n<li><p>是否对js文件进行检查</p>\n</li>\n<li><p>示例：</p>\n<pre><code class=\"json\">&quot;compilerOptions&quot;: &#123;\n    &quot;allowJs&quot;: true,\n    &quot;checkJs&quot;: true\n&#125;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p><strong>removeComments</strong></p>\n<ul>\n<li>是否删除注释</li>\n<li>默认值：false</li>\n</ul>\n</li>\n<li><p><strong>noEmit</strong></p>\n<ul>\n<li>不对代码进行编译</li>\n<li>默认值：false</li>\n</ul>\n</li>\n<li><p><strong>sourceMap</strong></p>\n<ul>\n<li>是否生成sourceMap</li>\n<li>默认值：false</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>严格检查</strong></p>\n<ul>\n<li><strong>strict</strong><ul>\n<li>启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查</li>\n</ul>\n</li>\n<li><strong>alwaysStrict</strong><ul>\n<li>总是以严格模式对代码进行编译</li>\n</ul>\n</li>\n<li><strong>noImplicitAny</strong><ul>\n<li>禁止隐式的any类型</li>\n</ul>\n</li>\n<li><strong>noImplicitThis</strong><ul>\n<li>禁止类型不明确的this</li>\n</ul>\n</li>\n<li><strong>strictBindCallApply</strong><ul>\n<li>严格检查bind、call和apply的参数列表</li>\n</ul>\n</li>\n<li><strong>strictFunctionTypes</strong><ul>\n<li>严格检查函数的类型</li>\n</ul>\n</li>\n<li><strong>strictNullChecks</strong><ul>\n<li>严格的空值检查</li>\n</ul>\n</li>\n<li><strong>strictPropertyInitialization</strong><ul>\n<li>严格检查属性是否初始化</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>额外检查</strong></p>\n<ul>\n<li><strong>noFallthroughCasesInSwitch</strong><ul>\n<li>检查switch语句包含正确的break</li>\n</ul>\n</li>\n<li><strong>noImplicitReturns</strong><ul>\n<li>检查函数没有隐式的返回值</li>\n</ul>\n</li>\n<li><strong>noUnusedLocals</strong><ul>\n<li>检查未使用的局部变量</li>\n</ul>\n</li>\n<li><strong>noUnusedParameters</strong><ul>\n<li>检查未使用的参数</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>高级</strong></p>\n<ul>\n<li><strong>allowUnreachableCode</strong><ul>\n<li>检查不可达代码</li>\n<li>可选值：<ul>\n<li>true，忽略不可达代码</li>\n<li>false，不可达代码将引起错误</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>noEmitOnError</strong><ul>\n<li>有错误的情况下不进行编译</li>\n<li>默认值：false</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4、webpack\"><a href=\"#4、webpack\" class=\"headerlink\" title=\"4、webpack\"></a>4、webpack</h2><ul>\n<li><p>通常情况下，实际开发中我们都需要使用构建工具对代码进行打包，TS同样也可以结合构建工具一起使用，下边以webpack为例介绍一下如何结合构建工具使用TS。</p>\n</li>\n<li><p>步骤：</p>\n<ol>\n<li><p>初始化项目</p>\n<ul>\n<li>进入项目根目录，执行命令 <code>npm init -y</code><ul>\n<li>主要作用：创建package.json文件</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>下载构建工具</p>\n<ul>\n<li><code>npm i -D webpack webpack-cli webpack-dev-server typescript ts-loader clean-webpack-plugin</code><ul>\n<li>共安装了7个包<ul>\n<li>webpack<ul>\n<li>构建工具webpack</li>\n</ul>\n</li>\n<li>webpack-cli<ul>\n<li>webpack的命令行工具</li>\n</ul>\n</li>\n<li>webpack-dev-server<ul>\n<li>webpack的开发服务器</li>\n</ul>\n</li>\n<li>typescript<ul>\n<li>ts编译器</li>\n</ul>\n</li>\n<li>ts-loader<ul>\n<li>ts加载器，用于在webpack中编译ts文件</li>\n</ul>\n</li>\n<li>html-webpack-plugin<ul>\n<li>webpack中html插件，用来自动创建html文件</li>\n</ul>\n</li>\n<li>clean-webpack-plugin<ul>\n<li>webpack中的清除插件，每次构建都会先清除目录</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>根目录下创建webpack的配置文件webpack.config.js</p>\n<pre><code class=\"javascript\">const path = require(&quot;path&quot;);\nconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);\nconst &#123; CleanWebpackPlugin &#125; = require(&quot;clean-webpack-plugin&quot;);\n\nmodule.exports = &#123;\n    optimization:&#123;\n        minimize: false // 关闭代码压缩，可选\n    &#125;,\n\n    entry: &quot;./src/index.ts&quot;,\n    \n    devtool: &quot;inline-source-map&quot;,\n    \n    devServer: &#123;\n        contentBase: &#39;./dist&#39;\n    &#125;,\n\n    output: &#123;\n        path: path.resolve(__dirname, &quot;dist&quot;),\n        filename: &quot;bundle.js&quot;,\n        environment: &#123;\n            arrowFunction: false // 关闭webpack的箭头函数，可选\n        &#125;\n    &#125;,\n\n    resolve: &#123;\n        extensions: [&quot;.ts&quot;, &quot;.js&quot;]\n    &#125;,\n    \n    module: &#123;\n        rules: [\n            &#123;\n                test: /\\.ts$/,\n                use: &#123;\n                   loader: &quot;ts-loader&quot;     \n                &#125;,\n                exclude: /node_modules/\n            &#125;\n        ]\n    &#125;,\n\n    plugins: [\n        new CleanWebpackPlugin(),\n        new HtmlWebpackPlugin(&#123;\n            title:&#39;TS测试&#39;\n        &#125;),\n    ]\n\n&#125;\n</code></pre>\n</li>\n<li><p>根目录下创建tsconfig.json，配置可以根据自己需要</p>\n<pre><code class=\"json\">&#123;\n    &quot;compilerOptions&quot;: &#123;\n        &quot;target&quot;: &quot;ES2015&quot;,\n        &quot;module&quot;: &quot;ES2015&quot;,\n        &quot;strict&quot;: true\n    &#125;\n&#125;\n</code></pre>\n</li>\n<li><p>修改package.json添加如下配置</p>\n<pre><code class=\"json\">&#123;\n  ...略...\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,\n    &quot;build&quot;: &quot;webpack&quot;,\n    &quot;start&quot;: &quot;webpack serve --open chrome.exe&quot;\n  &#125;,\n  ...略...\n&#125;\n</code></pre>\n</li>\n<li><p>在src下创建ts文件，并在并命令行执行<code>npm run build</code>对代码进行编译，或者执行<code>npm start</code>来启动开发服务器</p>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"5、Babel\"><a href=\"#5、Babel\" class=\"headerlink\" title=\"5、Babel\"></a>5、Babel</h2><ul>\n<li><p>经过一系列的配置，使得TS和webpack已经结合到了一起，除了webpack，开发中还经常需要结合babel来对代码进行转换以使其可以兼容到更多的浏览器，在上述步骤的基础上，通过以下步骤再将babel引入到项目中。</p>\n<ol>\n<li><p>安装依赖包：</p>\n<ul>\n<li><code>npm i -D @babel/core @babel/preset-env babel-loader core-js</code></li>\n<li>共安装了4个包，分别是：<ul>\n<li>@babel&#x2F;core<ul>\n<li>babel的核心工具</li>\n</ul>\n</li>\n<li>@babel&#x2F;preset-env<ul>\n<li>babel的预定义环境</li>\n</ul>\n</li>\n<li>@babel-loader<ul>\n<li>babel在webpack中的加载器</li>\n</ul>\n</li>\n<li>core-js<ul>\n<li>core-js用来使老版本的浏览器支持新版ES语法</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>修改webpack.config.js配置文件</p>\n<pre><code class=\"javascript\">...略...\nmodule: &#123;\n    rules: [\n        &#123;\n            test: /\\.ts$/,\n            use: [\n                &#123;\n                    loader: &quot;babel-loader&quot;,\n                    options:&#123;\n                        presets: [\n                            [\n                                &quot;@babel/preset-env&quot;,\n                                &#123;\n                                    &quot;targets&quot;:&#123;\n                                        &quot;chrome&quot;: &quot;58&quot;,\n                                        &quot;ie&quot;: &quot;11&quot;\n                                    &#125;,\n                                    &quot;corejs&quot;:&quot;3&quot;,\n                                    &quot;useBuiltIns&quot;: &quot;usage&quot;\n                                &#125;\n                            ]\n                        ]\n                    &#125;\n                &#125;,\n                &#123;\n                    loader: &quot;ts-loader&quot;,\n\n                &#125;\n            ],\n            exclude: /node_modules/\n        &#125;\n    ]\n&#125;\n...略...\n</code></pre>\n<ul>\n<li>如此一来，使用ts编译后的文件将会再次被babel处理，使得代码可以在大部分浏览器中直接使用，可以在配置选项的targets中指定要兼容的浏览器版本。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"第二章：面向对象\"><a href=\"#第二章：面向对象\" class=\"headerlink\" title=\"第二章：面向对象\"></a>第二章：面向对象</h1><h2 id=\"0、面向对象简介\"><a href=\"#0、面向对象简介\" class=\"headerlink\" title=\"0、面向对象简介\"></a>0、面向对象简介</h2><p>面向对象是程序中一个非常重要的思想，它被很多同学理解成了一个比较难，比较深奥的问题，其实不然。面向对象很简单，简而言之就是程序之中所有的操作都需要通过对象来完成。</p>\n<ul>\n<li>举例来说：<ul>\n<li>操作浏览器要使用window对象</li>\n<li>操作网页要使用document对象</li>\n<li>操作控制台要使用console对象</li>\n</ul>\n</li>\n</ul>\n<p>一切操作都要通过对象，也就是所谓的面向对象，那么对象到底是什么呢？这就要先说到程序是什么，计算机程序的本质就是对现实事物的抽象，抽象的反义词是具体，比如：照片是对一个具体的人的抽象，汽车模型是对具体汽车的抽象等等。程序也是对事物的抽象，在程序中我们可以表示一个人、一条狗、一把枪、一颗子弹等等所有的事物。一个事物到了程序中就变成了一个对象。</p>\n<p>在程序中所有的对象都被分成了两个部分数据和功能，以人为例，人的姓名、性别、年龄、身高、体重等属于数据，人可以说话、走路、吃饭、睡觉这些属于人的功能。数据在对象中被成为属性，而功能就被称为方法。所以简而言之，在程序中一切皆是对象。</p>\n<h2 id=\"1、类（class）\"><a href=\"#1、类（class）\" class=\"headerlink\" title=\"1、类（class）\"></a>1、类（class）</h2><p>要想面向对象，操作对象，首先便要拥有对象，那么下一个问题就是如何创建对象。要创建对象，必须要先定义类，所谓的类可以理解为对象的模型，程序中可以根据类创建指定类型的对象，举例来说：可以通过Person类来创建人的对象，通过Dog类创建狗的对象，通过Car类来创建汽车的对象，不同的类可以用来创建不同的对象。</p>\n<ul>\n<li><p>定义类：</p>\n<pre><code class=\"typescript\">class 类名 &#123;\n    属性名: 类型;\n    \n    constructor(参数: 类型)&#123;\n        this.属性名 = 参数;\n    &#125;\n    \n    方法名()&#123;\n        ....\n    &#125;\n\n&#125;\n</code></pre>\n</li>\n<li><p>示例：</p>\n<pre><code class=\"typescript\">class Person&#123;\n    name: string;\n    age: number;\n\n    constructor(name: string, age: number)&#123;\n        this.name = name;\n        this.age = age;\n    &#125;\n\n    sayHello()&#123;\n        console.log(`大家好，我是$&#123;this.name&#125;`);\n    &#125;\n&#125;\n</code></pre>\n</li>\n<li><p>使用类：</p>\n<pre><code class=\"typescript\">const p = new Person(&#39;孙悟空&#39;, 18);\np.sayHello();\n</code></pre>\n</li>\n</ul>\n<ul>\n<li>直接定义的属性是实例属性，需要通过对象的实例去访问；使用static开头的属性是静态属性（类属性），可以直接通过类去访问<code>static readonly age: number = 18</code>;；readonly开头的属性表示一个只读的属性无法修改<code>readonly name: string = &#39;孙悟空&#39;;</code></li>\n</ul>\n<h2 id=\"2、面向对象的特点\"><a href=\"#2、面向对象的特点\" class=\"headerlink\" title=\"2、面向对象的特点\"></a>2、面向对象的特点</h2><ul>\n<li><p>封装</p>\n<ul>\n<li><p>对象实质上就是属性和方法的容器，它的主要作用就是存储属性和方法，这就是所谓的封装</p>\n</li>\n<li><p>默认情况下，对象的属性是可以任意的修改的，为了确保数据的安全性，在TS中可以对属性的权限进行设置</p>\n</li>\n<li><p>只读属性（readonly）：</p>\n<ul>\n<li>如果在声明属性时添加一个readonly，则属性便成了只读属性无法修改</li>\n</ul>\n</li>\n<li><p>TS中属性具有三种修饰符：</p>\n<ul>\n<li><strong>public（默认值），可以在类、子类和对象中修改</strong></li>\n<li><strong>protected ，可以在类、子类中修改</strong></li>\n<li><strong>private ，可以在类中修改</strong></li>\n</ul>\n</li>\n<li><p>示例：</p>\n<ul>\n<li><p>public</p>\n<pre><code class=\"typescript\">class Person&#123;\n    public name: string; // 写或什么都不写都是public\n    public age: number;\n\n    constructor(name: string, age: number)&#123;\n        this.name = name; // 可以在类中修改\n        this.age = age;\n    &#125;\n\n    sayHello()&#123;\n        console.log(`大家好，我是$&#123;this.name&#125;`);\n    &#125;\n&#125;\n\nclass Employee extends Person&#123;\n    constructor(name: string, age: number)&#123;\n        super(name, age);\n        this.name = name; //子类中可以修改\n    &#125;\n&#125;\n\nconst p = new Person(&#39;孙悟空&#39;, 18);\np.name = &#39;猪八戒&#39;;// 可以通过对象修改\n</code></pre>\n</li>\n<li><p>protected</p>\n<pre><code class=\"typescript\">class Person&#123;\n    protected name: string;\n    protected age: number;\n\n    constructor(name: string, age: number)&#123;\n        this.name = name; // 可以修改\n        this.age = age;\n    &#125;\n\n    sayHello()&#123;\n        console.log(`大家好，我是$&#123;this.name&#125;`);\n    &#125;\n&#125;\n\nclass Employee extends Person&#123;\n\n    constructor(name: string, age: number)&#123;\n        super(name, age);\n        this.name = name; //子类中可以修改\n    &#125;\n&#125;\n\nconst p = new Person(&#39;孙悟空&#39;, 18);\np.name = &#39;猪八戒&#39;;// 不能修改\n</code></pre>\n</li>\n<li><p>private</p>\n<pre><code class=\"typescript\">class Person&#123;\n    private name: string;\n    private age: number;\n\n    constructor(name: string, age: number)&#123;\n        this.name = name; // 可以修改\n        this.age = age;\n    &#125;\n\n    sayHello()&#123;\n        console.log(`大家好，我是$&#123;this.name&#125;`);\n    &#125;\n&#125;\n\nclass Employee extends Person&#123;\n\n    constructor(name: string, age: number)&#123;\n        super(name, age);\n        this.name = name; //子类中不能修改\n    &#125;\n&#125;\n\nconst p = new Person(&#39;孙悟空&#39;, 18);\np.name = &#39;猪八戒&#39;;// 不能修改\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>属性存取器</p>\n<ul>\n<li><p>对于一些不希望被任意修改的属性，可以将其设置为private</p>\n</li>\n<li><p>直接将其设置为private将导致无法再通过对象修改其中的属性</p>\n</li>\n<li><p>我们可以在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的存取器</p>\n</li>\n<li><p>读取属性的方法叫做setter方法，设置属性的方法叫做getter方法</p>\n</li>\n<li><p>示例：</p>\n<pre><code class=\"typescript\">class Person&#123;\n    private _name: string;\n\n    constructor(name: string)&#123;\n        this._name = name;\n    &#125;\n\n    get name()&#123;\n        return this._name;\n    &#125;\n\n    set name(name: string)&#123;\n        this._name = name;\n    &#125;\n\n&#125;\n\nconst p1 = new Person(&#39;孙悟空&#39;);\nconsole.log(p1.name); // 通过getter读取name属性\np1.name = &#39;猪八戒&#39;; // 通过setter修改name属性\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>静态属性</p>\n<ul>\n<li><p>静态属性（方法），也称为类属性。使用静态属性无需创建实例，通过类即可直接使用</p>\n</li>\n<li><p>静态属性（方法）使用static开头</p>\n</li>\n<li><p>示例：</p>\n<pre><code class=\"typescript\">class Tools&#123;\n    static PI = 3.1415926;\n    \n    static sum(num1: number, num2: number)&#123;\n        return num1 + num2\n    &#125;\n&#125;\n\nconsole.log(Tools.PI);\nconsole.log(Tools.sum(123, 456));\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>this</p>\n<ul>\n<li><strong>在类中，使用this表示当前对象</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>继承</p>\n<ul>\n<li><p>继承时面向对象中的又一个特性</p>\n</li>\n<li><p>通过继承可以将其他类中的属性和方法引入到当前类中</p>\n<ul>\n<li><p>示例：</p>\n<pre><code class=\"typescript\">class Animal&#123;\n    name: string;\n    age: number;\n\n    constructor(name: string, age: number)&#123;\n        this.name = name;\n        this.age = age;\n    &#125;\n&#125;\n\nclass Dog extends Animal&#123;\n\n    bark()&#123;\n        console.log(`$&#123;this.name&#125;在汪汪叫！`);\n    &#125;\n&#125;\n\nconst dog = new Dog(&#39;旺财&#39;, 4);\ndog.bark();\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>通过继承可以在不修改类的情况下完成对类的扩展</p>\n</li>\n<li><p>重写</p>\n<ul>\n<li><p>发生继承时，如果子类中的方法会替换掉父类中的同名方法，这就称为方法的重写</p>\n</li>\n<li><p>示例：</p>\n<pre><code class=\"typescript\">class Animal&#123;\n    name: string;\n    age: number;\n\n    constructor(name: string, age: number)&#123;\n        this.name = name;\n        this.age = age;\n    &#125;\n\n    run()&#123;\n        console.log(`父类中的run方法！`);\n    &#125;\n&#125;\n\nclass Dog extends Animal&#123;\n\n    bark()&#123;\n        console.log(`$&#123;this.name&#125;在汪汪叫！`);\n    &#125;\n\n    run()&#123;\n        console.log(`子类中的run方法，会重写父类中的run方法！`);\n    &#125;\n&#125;\n\nconst dog = new Dog(&#39;旺财&#39;, 4);\ndog.bark();\n</code></pre>\n<ul>\n<li>在子类中可以使用super来完成对父类的引用(构造函数)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>抽象类（abstract class）</p>\n<ul>\n<li><p>抽象类是专门用来被其他类所继承的类，它<strong>只能被其他类所继承不能用来创建实例</strong></p>\n<pre><code class=\"typescript\">abstract class Animal&#123;\n    abstract run(): void;\n    bark()&#123;\n        console.log(&#39;动物在叫~&#39;);\n    &#125;\n&#125;\n\nclass Dog extends Animals&#123;\n    run()&#123;\n        console.log(&#39;狗在跑~&#39;);\n    &#125;\n&#125;\n</code></pre>\n</li>\n<li><p>使用abstract开头的方法叫做抽象方法，抽象方法没有方法体只能定义在抽象类中，<strong>继承抽象类时抽象方法必须要实现</strong></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3、接口（Interface）\"><a href=\"#3、接口（Interface）\" class=\"headerlink\" title=\"3、接口（Interface）\"></a>3、接口（Interface）</h2><p>接口的作用类似于抽象类，不同点在于接口中的所有方法和属性都是没有实值的，换句话说接口中的所有方法都是抽象方法。接口主要负责定义一个类的结构，接口可以去限制一个对象的接口，对象只有包含接口中定义的所有属性和方法时才能匹配接口。同时，可以让一个类去实现接口，实现接口时类中要保护接口中的所有属性。</p>\n<ul>\n<li><p>示例（检查对象类型）：</p>\n<pre><code class=\"typescript\">interface Person&#123;\n    name: string;\n    sayHello():void;\n&#125;\n\nfunction fn(per: Person)&#123;\n    per.sayHello();\n&#125;\n\nfn(&#123;name:&#39;孙悟空&#39;, sayHello() &#123;console.log(`Hello, 我是 $&#123;this.name&#125;`)&#125;&#125;);\n</code></pre>\n</li>\n<li><p>示例（实现）</p>\n<pre><code class=\"typescript\">interface Person&#123;\n    name: string;\n    sayHello():void;\n&#125;\n\nclass Student implements Person&#123;\n    constructor(public name: string) &#123;\n    &#125;\n\n    sayHello() &#123;\n        console.log(&#39;大家好，我是&#39;+this.name);\n    &#125;\n&#125;\n</code></pre>\n</li>\n</ul>\n<h2 id=\"4、泛型（Generic）\"><a href=\"#4、泛型（Generic）\" class=\"headerlink\" title=\"4、泛型（Generic）\"></a>4、泛型（Generic）</h2><p>定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定），此时泛型便能够发挥作用。</p>\n<ul>\n<li><p>举个例子：</p>\n<pre><code class=\"typescript\">function test(arg: any): any&#123;\n    return arg;\n&#125;\n</code></pre>\n<ul>\n<li><p>上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的，由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的，首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型</p>\n</li>\n<li><p>使用泛型：</p>\n<pre><code class=\"typescript\">function test&lt;T&gt;(arg: T): T&#123;\n    return arg;\n&#125;\n</code></pre>\n</li>\n<li><p>这里的<code>&lt;T&gt;</code>就是泛型，T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型。所以泛型其实很好理解，就表示某个类型。</p>\n</li>\n<li><p>那么如何使用上边的函数呢？</p>\n<ul>\n<li><p>方式一（直接使用）：</p>\n<pre><code class=\"typescript\">test(10)\n</code></pre>\n<ul>\n<li>使用时可以直接传递参数使用，类型会由TS自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式</li>\n</ul>\n</li>\n<li><p>方式二（指定类型）：</p>\n<pre><code class=\"typescript\">test&lt;number&gt;(10)\n</code></pre>\n<ul>\n<li>也可以在函数后手动指定泛型</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>可以同时指定多个泛型，泛型间使用逗号隔开：</p>\n<pre><code class=\"typescript\">function test&lt;T, K&gt;(a: T, b: K): K&#123;\n    return b;\n&#125;\n\ntest&lt;number, string&gt;(10, &quot;hello&quot;);\n</code></pre>\n<ul>\n<li>使用泛型时，完全可以将泛型当成是一个普通的类去使用</li>\n</ul>\n</li>\n<li><p>类中同样可以使用泛型：</p>\n<pre><code class=\"typescript\">class MyClass&lt;T&gt;&#123;\n    prop: T;\n\n    constructor(prop: T)&#123;\n        this.prop = prop;\n    &#125;\n&#125;\n</code></pre>\n</li>\n<li><p>除此之外，也可以对泛型的范围进行约束</p>\n<pre><code class=\"typescript\">interface MyInter&#123;\n    length: number;\n&#125;\n\nfunction test&lt;T extends MyInter&gt;(arg: T): number&#123;\n    return arg.length;\n&#125;\n</code></pre>\n<ul>\n<li>使用T extends MyInter表示泛型T必须是MyInter的子类，不一定非要使用接口类和抽象类同样适用。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","feature":false,"text":"TypeScript是一种由Microsoft开发的语言，它是JavaScript的一个超集，增加了静态类型和面向对象编程等特性。本文将引导读者快速入门TypeScript，包括环境搭建、基本语法、类型系统、面向对象编程、模块化等方面的内容。...","permalink":"/post/青训营--Typescript快速入门","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"17 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"字节跳动青训营","slug":"字节跳动青训营","count":21,"path":"api/tags/字节跳动青训营.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8\"><span class=\"toc-text\">第一章 快速入门</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0%E3%80%81TypeScript%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">0、TypeScript简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1%E3%80%81TypeScript-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA\"><span class=\"toc-text\">1、TypeScript 开发环境搭建</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">2、基本类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3%E3%80%81%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9\"><span class=\"toc-text\">3、编译选项</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4%E3%80%81webpack\"><span class=\"toc-text\">4、webpack</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5%E3%80%81Babel\"><span class=\"toc-text\">5、Babel</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">第二章：面向对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">0、面向对象简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1%E3%80%81%E7%B1%BB%EF%BC%88class%EF%BC%89\"><span class=\"toc-text\">1、类（class）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">2、面向对象的特点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%8E%A5%E5%8F%A3%EF%BC%88Interface%EF%BC%89\"><span class=\"toc-text\">3、接口（Interface）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4%E3%80%81%E6%B3%9B%E5%9E%8B%EF%BC%88Generic%EF%BC%89\"><span class=\"toc-text\">4、泛型（Generic）</span></a></li></ol></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"前端设计模式应用","uid":"4fde660230560945997cb0c9305b7a1e","slug":"青训营--前端设计模式应用","date":"2022-02-07T02:42:27.000Z","updated":"2025-07-14T15:12:20.472Z","comments":true,"path":"api/articles/青训营--前端设计模式应用.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/3112c385d3c845d4b0305beebbc3ffdf.jpeg","text":"前端设计模式是在前端开发中常用的一种解决问题的方法论，它可以帮助开发者更好地组织和管理代码。本文将介绍前端设计模式的应用，包括常见的设计模式如单例模式、观察者模式、工厂模式等，并深入探讨它们的原理和适用场景。...","permalink":"/post/青训营--前端设计模式应用","photos":[],"count_time":{"symbolsCount":"9.3k","symbolsTime":"8 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"字节跳动青训营","slug":"字节跳动青训营","count":21,"path":"api/tags/字节跳动青训营.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":false},"next_post":{"title":"Web多媒体入门","uid":"cbeef85e3ef827f236c8157203105c9a","slug":"青训营--Web多媒体入门","date":"2022-02-05T10:40:59.000Z","updated":"2025-07-14T15:12:20.471Z","comments":true,"path":"api/articles/青训营--Web多媒体入门.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/3112c385d3c845d4b0305beebbc3ffdf.jpeg","text":"Web多媒体是Web开发中的重要组成部分，它包括图像、音频和视频等多种形式。本文将介绍常见的Web图像格式（如JPEG、PNG、GIF等）及其特点、优缺点，并深入讨论如何使用CSS和JavaScript来实现Web图像的动态效果。...","permalink":"/post/青训营--Web多媒体入门","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"前端","slug":"前端","count":48,"path":"api/categories/前端.json"}],"tags":[{"name":"字节跳动青训营","slug":"字节跳动青训营","count":21,"path":"api/tags/字节跳动青训营.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":false}}