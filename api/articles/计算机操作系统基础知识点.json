{"title":"计算机操作系统基础知识点","uid":"8de25e8e132b240cdb154bdb91bce02d","slug":"计算机操作系统基础知识点","date":"2022-05-06T12:09:08.000Z","updated":"2025-07-14T15:12:20.470Z","comments":true,"path":"api/articles/计算机操作系统基础知识点.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/6d319164eb214f4395a4111e1944f220.png","content":"<hr>\n<h1 id=\"1、操作系统引论\"><a href=\"#1、操作系统引论\" class=\"headerlink\" title=\"1、操作系统引论\"></a>1、操作系统引论</h1><p><img src=\"https://img-blog.csdnimg.cn/17e92985fd474be8a41c28f13dc5f525.png#pic_center\"></p>\n<p><strong>易错点:</strong></p>\n<ul>\n<li>在一段时间内置允许一个进程访问的资源称为<strong>临界资源</strong>或者独占资源</li>\n<li><strong>并发和共享是操作系统两个最基本的特征</strong>，两者之间互为存在的条件</li>\n<li>文件的 I&#x2F;O 需要在内核态进行，要使用系统调用接口</li>\n<li><strong>shell 属于命令解析器，属于命令接口</strong></li>\n<li><strong>多道程序设计失去了封闭性和顺序性，顺序性是单道程序设计的基本特征</strong></li>\n<li>中断技术使得多道批处理系统和 I&#x2F;O 设备可与 CPU 并行工作</li>\n</ul>\n<p><strong>批处理操作系统、分时操作系统和实时操作系统各有什么特点?</strong></p>\n<p>批处理操作系统的用户脱机使用计算机，作业都是成批处理的，系统内多道程序并发执行，交互能力差。<br>分时操作系统可让多个用户同时使用计算机，人机交互性较强，具有每个用户独立使用计算机的独占性，系统响应及时。<br>实时操作系统能对控制对象做出及时反映，可靠性高，响应及时，但资源利用率低。</p>\n<p><strong>处理器为什么要区分核心态和用户态两种操作方式？在什么情况下进行两种方式的切换？</strong></p>\n<p>区分执行态的主要目的是保护系统程序。用户态到核心态的转换发生在中断产生时，而核心态到用户态的转换则发生在中断返回用户程序时。</p>\n<hr>\n<h1 id=\"2、进程的描述和控制\"><a href=\"#2、进程的描述和控制\" class=\"headerlink\" title=\"2、进程的描述和控制\"></a>2、进程的描述和控制</h1><p><img src=\"https://img-blog.csdnimg.cn/d984b21b01d2426da4e600b63d66518d.png#pic_center\"></p>\n<h2 id=\"生产者-消费者问题\"><a href=\"#生产者-消费者问题\" class=\"headerlink\" title=\"生产者-消费者问题\"></a>生产者-消费者问题</h2><p><img src=\"https://img-blog.csdnimg.cn/b72f4ae5975f4f84b7a514b116ca6aa2.png\"><br>PV 操作题目分析步骤:</p>\n<ol>\n<li><strong>关系分析。</strong> 找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</li>\n<li><strong>整理思路。</strong> 根据各进程的操作流程确定 P、V 操作的大致顺序。</li>\n<li><strong>设置信号量。</strong> 设置需要的信号量，并根据题目条件确定信号量初值。(互斥信号量初值一般为 1，同步信号量的初始值要看对应资源的初始值是多少)</li>\n</ol>\n<p><strong>利用记录型信号量解决生产者-消费者问题</strong></p>\n<div class=\"language-markdown\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">markdown</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1d1d1d\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">item buffer</span><span style=\"color: #89DDFF\">[</span><span style=\"color: #C3E88D\">n</span><span style=\"color: #89DDFF\">]</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">semaphore mutex = 1;//互斥信号量，实现对缓冲区的互斥访问</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">semaphore empty = n;//同步信号量，表示空闲缓冲区的数量</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">semaphore full = 0; //同步信号量，表示产品的数量，也即非空缓冲区的数量</span></span>\n<span class=\"line\"></span></code></pre></div><div class=\"language-markdown\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">markdown</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1d1d1d\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">prodecer ()&#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    while(1)&#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        生产一个产品;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        P(emoty);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        P(mutex);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        把产品放入缓冲区;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        V(mutex);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        V(full);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span></code></pre></div><div class=\"language-markdown\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">markdown</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1d1d1d\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">consumer ()&#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    while(1)&#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        P(full);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        P(mutex);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        从缓冲区取出一个产品;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        V(mutex);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        V(empty);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        使用产品;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span></code></pre></div><ul>\n<li>在生产者-消费者问题中应注意:&#x3D;&#x3D;首先，在每个程序中用于实现互斥的 wait(mutex)和 signal(mutex)必须成对地出现;其次，对资源信号量 empty 和 full 的 wait 和 signal 操作，同样需要成对地出现，但它们分别处于不同的程序中&#x3D;&#x3D;。</li>\n<li>例如，wait(empty)在计算进程中，而 signal(empty)则在打印进程中，计算进程若因执行 wait(empty)而阻塞，则以后将由打印进程将它唤醒;&#x3D;&#x3D;最后，在每个程序中的多个 wait 操作顺序不能颠倒。应先执行对资源信号量的 wait 操作，然后再执行对互斥信号量的 wait 操作，否则可能引起进程死锁。&#x3D;&#x3D;</li>\n</ul>\n<h2 id=\"哲学家进餐问题\"><a href=\"#哲学家进餐问题\" class=\"headerlink\" title=\"哲学家进餐问题\"></a>哲学家进餐问题</h2><p><img src=\"https://img-blog.csdnimg.cn/9d0a3b83f4da49fd98f04f829063a7b7.png\"></p>\n<p>解决方案：</p>\n<ol>\n<li>可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的</li>\n<li>要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子,另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。</li>\n<li>仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子。</li>\n</ol>\n<p><strong>利用记录型信号量解决哲学家进餐问题</strong></p>\n<div class=\"language-markdown\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">markdown</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1d1d1d\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">semaphore chopstick</span><span style=\"color: #89DDFF\">[</span><span style=\"color: #C3E88D\">5</span><span style=\"color: #89DDFF\">]</span><span style=\"color: #BABED8\">=&#123;1,1,1,1,1&#125;;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">semaphore mutex = 1;//互斥地取筷子</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">Pi()&#123;\t\t\t\t//i号哲学家的进程</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    while(1)&#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        p(mutex);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        P(chopstick</span><span style=\"color: #89DDFF\">[</span><span style=\"color: #C3E88D\">i</span><span style=\"color: #89DDFF\">]</span><span style=\"color: #BABED8\">);\t\t//拿左</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        P(chopstick</span><span style=\"color: #89DDFF\">[</span><span style=\"color: #C3E88D\">(i+1)%5</span><span style=\"color: #89DDFF\">]</span><span style=\"color: #BABED8\">;\t//拿右</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        V(mutex);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        吃饭...</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        V(chopstick</span><span style=\"color: #89DDFF\">[</span><span style=\"color: #C3E88D\">i</span><span style=\"color: #89DDFF\">]</span><span style=\"color: #BABED8\">);\t //放左</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        V(chopstick</span><span style=\"color: #89DDFF\">[</span><span style=\"color: #C3E88D\">(i+1)%5</span><span style=\"color: #89DDFF\">]</span><span style=\"color: #BABED8\">;//放右</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        思考...</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span></code></pre></div><ul>\n<li>哲学家进餐问题的关键在于解决进程死锁。</li>\n<li>这些进程之间只存在互斥关系，但是与之前接触到的互斥关系不同的是，每个进程都需要同时持有两个临界资源，因此就有“死锁”问题的隐患。</li>\n<li>如果遇到了一个进程需要同时持有多个临界资源的情况，应该参考哲学家问题的思想，分析题中给出的进程之间是否会发生循环等待，是否会发生死锁。</li>\n<li>可以参考哲学家就餐问题解决死锁的三种思路。</li>\n</ul>\n<h2 id=\"读者-写者问题\"><a href=\"#读者-写者问题\" class=\"headerlink\" title=\"读者-写者问题\"></a>读者-写者问题</h2><p><img src=\"https://img-blog.csdnimg.cn/ea1233715f7b4a5686e1440a2e08d1af.png\"></p>\n<ul>\n<li>读进程与读进程不存在互斥问题。写者进程和任何进程都互斥。设置一个互斥信号量 rw，在写者访问共享文件前后分别执行 P、V 操作。读者进程和写者进程也要互斥，因此读者访问共享文件前后也要对 rw 执行 P、V 操作。</li>\n</ul>\n<div class=\"language-markdown\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">markdown</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1d1d1d\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">Semapore rmutex = 1;//计数器</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">Semapore wmutex = 1;//阀门</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">int readcount = 0;</span></span></code></pre></div><div class=\"language-markdown\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">markdown</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1d1d1d\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">Wruter():</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    while(true)&#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        wait(wmutex);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        写;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        signal(wmutex);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    &#125;;</span></span></code></pre></div><div class=\"language-markdown\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">markdown</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1d1d1d\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">Reader():</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    while(true)&#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    wait(rmutex);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    if(readcount == 0)</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    wait(wmutex);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    readcount++;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    signal(rmutex)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    读;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    wait(rmutex);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    readcount--;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    if(readcount == 0)</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    signal(wmutex);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    signal(rmutex);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;;</span></span></code></pre></div><hr>\n<h1 id=\"3、处理机调度与死锁\"><a href=\"#3、处理机调度与死锁\" class=\"headerlink\" title=\"3、处理机调度与死锁\"></a>3、处理机调度与死锁</h1><p><img src=\"https://img-blog.csdnimg.cn/3420ab469fe244a39daee602196942a6.png#pic_center\"></p>\n<h2 id=\"先来先服务算法-FCFS\"><a href=\"#先来先服务算法-FCFS\" class=\"headerlink\" title=\"先来先服务算法(FCFS)\"></a>先来先服务算法(FCFS)</h2><p><img src=\"https://img-blog.csdnimg.cn/beb590eb9e4c4933ac783acc5c354983.png\"></p>\n<h2 id=\"短进程优先算法-SPF\"><a href=\"#短进程优先算法-SPF\" class=\"headerlink\" title=\"短进程优先算法(SPF)\"></a>短进程优先算法(SPF)</h2><p><img src=\"https://img-blog.csdnimg.cn/fcbeef48f6614febad780093bc17ba92.png\"></p>\n<h2 id=\"高优先权优先算法-HRRN\"><a href=\"#高优先权优先算法-HRRN\" class=\"headerlink\" title=\"高优先权优先算法(HRRN)\"></a>高优先权优先算法(HRRN)</h2><p><img src=\"https://img-blog.csdnimg.cn/1d6c2b6e6862469b96600c6ec29f686c.png\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/c46f81313a2b4ae8b6637c66c1b0cd6c.png\"><br><img src=\"https://img-blog.csdnimg.cn/f765ba94e91d485a834ba033e759ae73.png\"></p>\n<h2 id=\"安全状态与不安全状态\"><a href=\"#安全状态与不安全状态\" class=\"headerlink\" title=\"安全状态与不安全状态\"></a>安全状态与不安全状态</h2><p><img src=\"https://img-blog.csdnimg.cn/98ba4d9dc3d84721a825a7b281f237b0.png\"></p>\n<h2 id=\"银行家算法\"><a href=\"#银行家算法\" class=\"headerlink\" title=\"银行家算法\"></a>银行家算法</h2><p><img src=\"https://img-blog.csdnimg.cn/f5a81710543a40a0be9ff2009d2b3a3f.png\"></p>\n<hr>\n<h1 id=\"4、存储器管理\"><a href=\"#4、存储器管理\" class=\"headerlink\" title=\"4、存储器管理\"></a>4、存储器管理</h1><p><img src=\"https://img-blog.csdnimg.cn/5f54fb8fa817458096767b4d719ed501.png#pic_center\"></p>\n<h2 id=\"存储器的层次结构\"><a href=\"#存储器的层次结构\" class=\"headerlink\" title=\"存储器的层次结构\"></a>存储器的层次结构</h2><p><img src=\"https://img-blog.csdnimg.cn/656f8d7a8eab42bf81eba4fd6c1d1c3d.png\"></p>\n<h2 id=\"首次适应算法\"><a href=\"#首次适应算法\" class=\"headerlink\" title=\"首次适应算法\"></a>首次适应算法</h2><p><img src=\"https://img-blog.csdnimg.cn/6230a911b0b24c2da249030b459dbebd.png\"></p>\n<h2 id=\"循环首次适应算法\"><a href=\"#循环首次适应算法\" class=\"headerlink\" title=\"循环首次适应算法\"></a>循环首次适应算法</h2><p><img src=\"https://img-blog.csdnimg.cn/4768ff2335cb4b94838081db9316faf0.png\"></p>\n<h2 id=\"最佳适应算法\"><a href=\"#最佳适应算法\" class=\"headerlink\" title=\"最佳适应算法\"></a>最佳适应算法</h2><p><img src=\"https://img-blog.csdnimg.cn/d6487802334348048f1780a03d69bbdc.png\"></p>\n<h2 id=\"最坏适应算法\"><a href=\"#最坏适应算法\" class=\"headerlink\" title=\"最坏适应算法\"></a>最坏适应算法</h2><p><img src=\"https://img-blog.csdnimg.cn/408d4785e46b4ee78b26b8e3ac156497.png\"></p>\n<h2 id=\"相关计算\"><a href=\"#相关计算\" class=\"headerlink\" title=\"相关计算\"></a>相关计算</h2><p><img src=\"https://img-blog.csdnimg.cn/0e96793932904fb69125deec391f5fd8.png\"></p>\n<hr>\n<h1 id=\"5、虚拟存储器\"><a href=\"#5、虚拟存储器\" class=\"headerlink\" title=\"5、虚拟存储器\"></a>5、虚拟存储器</h1><p><img src=\"https://img-blog.csdnimg.cn/01fcd0ed18754b729164d9ead5a9197f.png#pic_center\"></p>\n<h2 id=\"最佳置换算法-OPT\"><a href=\"#最佳置换算法-OPT\" class=\"headerlink\" title=\"最佳置换算法(OPT)\"></a>最佳置换算法(OPT)</h2><p><img src=\"https://img-blog.csdnimg.cn/155765181bd0425a8bf1312660d1178f.png\"><br><img src=\"https://img-blog.csdnimg.cn/7a949e2d61e749b193048ff07799d442.png\"></p>\n<h2 id=\"先进先出置换算法\"><a href=\"#先进先出置换算法\" class=\"headerlink\" title=\"先进先出置换算法\"></a>先进先出置换算法</h2><p><img src=\"https://img-blog.csdnimg.cn/3be3f6a902ac4553a9233fba7b7e6adb.png\"></p>\n<h2 id=\"最近最久未使用算法-LRU\"><a href=\"#最近最久未使用算法-LRU\" class=\"headerlink\" title=\"最近最久未使用算法(LRU)\"></a>最近最久未使用算法(LRU)</h2><p><img src=\"https://img-blog.csdnimg.cn/2a1f4b8ab08d44da8f23a65dc8862cf5.png\"></p>\n<hr>\n<h1 id=\"6、输入输出设备\"><a href=\"#6、输入输出设备\" class=\"headerlink\" title=\"6、输入输出设备\"></a>6、输入输出设备</h1><p><img src=\"https://img-blog.csdnimg.cn/a7c682e2e2f94021a1dc7d91f4de63c0.png#pic_center\"></p>\n<h2 id=\"先来先服务算法\"><a href=\"#先来先服务算法\" class=\"headerlink\" title=\"先来先服务算法\"></a>先来先服务算法</h2><p><img src=\"https://img-blog.csdnimg.cn/08609bc7df53455797fb1ea8eba20ba2.png\"></p>\n<h2 id=\"最短寻道时间优先算法\"><a href=\"#最短寻道时间优先算法\" class=\"headerlink\" title=\"最短寻道时间优先算法\"></a>最短寻道时间优先算法</h2><p><img src=\"https://img-blog.csdnimg.cn/80342cf906f14662a0a4d72cdd027fd7.png\"></p>\n<h2 id=\"扫描算法\"><a href=\"#扫描算法\" class=\"headerlink\" title=\"扫描算法\"></a>扫描算法</h2><p><img src=\"https://img-blog.csdnimg.cn/8b056c1553b64c8488fa705448e230ee.png\"></p>\n<h2 id=\"循环扫描算法\"><a href=\"#循环扫描算法\" class=\"headerlink\" title=\"循环扫描算法\"></a>循环扫描算法</h2><p><img src=\"https://img-blog.csdnimg.cn/e2ab02e3c1374b29acf45cf0882de704.png\"></p>\n<hr>\n<h1 id=\"7、文件管理\"><a href=\"#7、文件管理\" class=\"headerlink\" title=\"7、文件管理\"></a>7、文件管理</h1><p><img src=\"https://img-blog.csdnimg.cn/c1a2a0786a5f4a109a19c3b47c42d3ae.png#pic_center\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/d02740162bd749229163adf27632acef.png\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/23a41fd92b41400683d1d45e72855463.png\"><br><img src=\"https://img-blog.csdnimg.cn/317d1c17e620417480c2a0dd883bcd74.png\"></p>\n<hr>\n","feature":true,"text":"计算机操作系统是管理计算机硬件和软件资源的核心软件。它提供了对计算机资源的抽象和控制，包括处理器调度、内存管理、文件系统和设备驱动等功能。操作系统的目标是提供方便、高效、安全和可靠的计算环境。操作系统在计算机科学中扮演着重要角色，是计算机系统的基石。...","permalink":"/post/计算机操作系统基础知识点","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"计算机科学与技术","slug":"计算机科学与技术","count":6,"path":"api/categories/计算机科学与技术.json"}],"tags":[{"name":"操作系统","slug":"操作系统","count":1,"path":"api/tags/操作系统.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA\"><span class=\"toc-text\">1、操作系统引论</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">2、进程的描述和控制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">生产者-消费者问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">哲学家进餐问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">读者-写者问题</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81\"><span class=\"toc-text\">3、处理机调度与死锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E7%AE%97%E6%B3%95-FCFS\"><span class=\"toc-text\">先来先服务算法(FCFS)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%9F%AD%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95-SPF\"><span class=\"toc-text\">短进程优先算法(SPF)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%AB%98%E4%BC%98%E5%85%88%E6%9D%83%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95-HRRN\"><span class=\"toc-text\">高优先权优先算法(HRRN)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81%E4%B8%8E%E4%B8%8D%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">安全状态与不安全状态</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">银行家算法</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">4、存储器管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">存储器的层次结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">首次适应算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BE%AA%E7%8E%AF%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">循环首次适应算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">最佳适应算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%9D%8F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">最坏适应算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%9B%B8%E5%85%B3%E8%AE%A1%E7%AE%97\"><span class=\"toc-text\">相关计算</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5%E3%80%81%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8\"><span class=\"toc-text\">5、虚拟存储器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-OPT\"><span class=\"toc-text\">最佳置换算法(OPT)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">先进先出置换算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95-LRU\"><span class=\"toc-text\">最近最久未使用算法(LRU)</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#6%E3%80%81%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87\"><span class=\"toc-text\">6、输入输出设备</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">先来先服务算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">最短寻道时间优先算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">扫描算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BE%AA%E7%8E%AF%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">循环扫描算法</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#7%E3%80%81%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">7、文件管理</span></a></li></ol>","author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"计算机组成原理基础知识点","uid":"f9f03627b2dbfa46b4d8f839b89a4037","slug":"计算机组成原理基础知识点","date":"2022-05-12T14:21:28.000Z","updated":"2025-07-14T15:12:20.470Z","comments":true,"path":"api/articles/计算机组成原理基础知识点.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/0611f103050f4788884c9cef0c64866c.png","text":"计算机组成原理是研究计算机硬件和软件组成及其相互关系的学科。它包括处理器、存储器、输入输出设备以及计算机内部数据传输和控制等方面的内容。计算机组成原理的核心目标是了解计算机的工作原理，从而设计和优化计算机系统。深入学习计算机组成原理可以帮助理解计算机的底层运作和提高程序设计的效率。...","permalink":"/post/计算机组成原理基础知识点","photos":[],"count_time":{"symbolsCount":"6k","symbolsTime":"5 mins."},"categories":[{"name":"计算机科学与技术","slug":"计算机科学与技术","count":6,"path":"api/categories/计算机科学与技术.json"}],"tags":[{"name":"组成原理","slug":"组成原理","count":1,"path":"api/tags/组成原理.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true},"next_post":{"title":"JAVA图形化基础--GUI编程","uid":"ac07147ebfe9ea11673ae70bed7f524c","slug":"Java图形化基础 -- GUI编程","date":"2022-04-23T03:10:12.000Z","updated":"2025-07-14T15:12:20.458Z","comments":true,"path":"api/articles/Java图形化基础 -- GUI编程.json","keywords":"web前端开发,web前端博客,个人博客,html,css,javascript,vue,react","cover":"https://img-blog.csdnimg.cn/39b97c220e4c47a8a19e408b6dba7804.png","text":"JavaGUI是Java语言提供的一套图形用户界面开发工具，包括AWT和Swing两个主要库。AWT（抽象窗口工具集）是Java最早的GUI库，提供了跨平台的界面组件，但界面风格受系统影响。Swing则是AWT的增强版，提供更丰富的界面组件和更灵活的自定义机制，同时支持跨平台和外观管理器。合理选择AWT或Swing库可根据具体应用场景决定。...","permalink":"/post/Java图形化基础 -- GUI编程","photos":[],"count_time":{"symbolsCount":"30k","symbolsTime":"28 mins."},"categories":[{"name":"后端","slug":"后端","count":22,"path":"api/categories/后端.json"}],"tags":[{"name":"Java","slug":"Java","count":22,"path":"api/tags/Java.json"}],"author":{"name":"会思想的苇草i","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"日拱一卒，功不唐捐 <br/> With each day's arduous effort,<br/>no achievement shall be in vain","socials":{"github":"https://github.com/Thinkingreedi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/ASHIYI66","juejin":"https://juejin.cn/user/4284166567110935","customs":{}}},"feature":true}}